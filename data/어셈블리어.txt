어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.
컴퓨터 구조에 따라 사용하는 기계어가 달라지며, 따라서 기계어에 대응되어 만들어지는 어셈블리어도 각각 다르게 된다.
컴퓨터 CPU마다 지원하는 오퍼레이션의 타입과 개수는 제각각이며, 레지스터의 크기와 개수, 저장된 데이터 형의 표현도 각기 다르다.
모든 범용 컴퓨터는 기본적으로 동일한 기능을 수행하지만, 기능을 어떤 과정을 거쳐 수행할지는 다를 수 있으며, 이런 차이는 어셈블리어에 반영되게 된다.
게다가 단일 명령 집합에 대해 여러 니모닉과 통사론이 대응될 수 있다.
그런 경우에는 제조사가 만든 문서에서 쓰이는 것이 가장 자주 쓰이게 된다.
어셈블러(assembler)는 어셈블리어를 기계어 형태의 오브젝트 코드로 해석해 주는 컴퓨터 언어 번역 프로그램을 말한다.
어셈블러는 기본 컴퓨터 명령어들을, 컴퓨터 프로세서가 기본 연산을 수행하는데 사용할 수 있는 비트 패턴으로 변환시키는 프로그램이다.
몇몇 사람들은 이러한 명령어들을 어셈블러 언어라고 부르며, 어셈블리 언어라고 부르는 사람들도 있다.
니모닉 기호(mnemonics)를 opcode로 변환하고 메모리 위치와 기타 존재물에 따라 식별자를 다시 분석함으로써 목적 코드를 만들어낸다.
거꾸로 기계어를 어셈블리어로 바꾸는 것은 “역(逆)어셈블러”(disassembler)이다.
고급 언어와는 달리 어셈블리어는 간단한 문장에 대해 기계어와 일대일 대응 관계가 있지만, 자주 쓰이는 몇 명령은 둘 이상의 기계어 명령을 묶어 하나의 어셈블리 명령어에 대응시키기도 한다.
이것은 어셈블리 명령 부호를 오피코드로 해석할 뿐만 아니라 메모리의 위치들을 이름으로 표시하는 기능, 매크로를 통한 문장 치환 기능 등을 함께 제공한다.
높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.
MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.
이 어셈블러는 1950년대부터 계속 쓰여 왔으며, 고급 언어를 위한 컴파일러에 견주어 보면 구조가 매우 간단하다.
크로스 어셈블러는 다른 프로세서를 위한 코드를 만든다.
어셈블러가 실행되는 단계를 어셈블리 타임이라고 한다.
어셈블러에는 두 가지 종류가 있는데, 실행 프로그램을 만들기 위해 얼마나 많은 패스가 소스를 거치는지에 따라 다르다.
1패스 어셈블러들을 이용하는 본래 이유는 어셈블리의 속도 때문이다.
2차 패스가 되돌아가기를 요구할 수도 있기 때문이다.
그러나 현대의 컴퓨터는 납득하기 어려운 지연 없이 다중 패스 어셈블리를 수행한다.
다중 패스 어셈블러는 링크 프로세스를 더 빠르게 한다는 장점이 있다.
더 복잡한 고급 어셈블러는 다음과 같은 언어 추상물을 제공한다:
기계어는 실제로 컴퓨터의 CPU가 읽어서 실행할 수 있는 0과 1로 이루어진 명령어의 조합이다.
이러한 각 명령어에 대해 사람이 알아보기 쉬운 니모닉 기호(mnemonic symbol)를 정해 사람이 좀 더 쉽게 컴퓨터의 행동을 제어할 수 있도록 한 것이 어셈블리 언어이다.
10110000 01100001
는 x86 계열 CPU의 기계어 명령이고, 이것을 어셈블리어로 옮겨쓰면 다음과 같다.
명령어 mov는 영어 move를 변형한 니모닉이며, al은 CPU안에 있는 변수를 저장하는 레지스터의 하나이다.
그리고, 061h는 16진수 61 (즉 십진수 97, 이진수 01100001)이다.
이 한 줄의 뜻은 16진수 61을 al레지스터에 넣으라는 뜻이며, 1과 0의 반복인 기계어보다 사람이 혼동없이 이해하기 한결 쉽다.
어셈블리어는 이러한 문장들로 구성된다.
다음은 NASM x86 어셈블리어로 구현한 헬로 월드 프로그램이다.
hello_message db 'Hello, World!',0dh,0ah,'$'
mov dx, offset hello_message
