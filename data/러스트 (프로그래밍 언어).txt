러스트()는 모질라 리서치에서 개발한 범용 프로그래밍 언어이다. "안전하고, 병렬적이며, 실용적인" 언어로 디자인되었으며, 순수 함수형 프로그래밍, 액터 기반 병렬 프로그래밍, 명령형 프로그래밍, 객체 지향 프로그래밍 스타일을 지원한다.
2006년 개발자 그레이든 호아레의 개인 프로젝트로 시작되었으며, 2009년 호아레의 고용주인 모질라가
2010년 처음으로 일반에 공개되었으며, 같은 해 Objective Caml로 작성된 초기 컴파일러에서 Rust로 작성된 컴파일러로 전환되었다. "rustc"는 2011년 처음으로 자기 자신을 컴파일하는데 성공했다.
2012년 1월 첫 번째 알파 버전인 0.1이 발표되었다.
모질라의 정책에 따라, 러스트는 전적으로 오픈 소스로 개발되고 있으며, 커뮤니티로부터 피드백을 받고 있다.
모질라 재단이 러스트의 개발을 후원하고 있다.
러스트의 설계에는 모질라의 렌더링 엔진인 서보와 rustc 컴파일러를 개발하면서 쌓인 경험들이 반영되어 있다.
카고(cargo)는 러스트의 빌드 시스템이다.
러스트는 CPU 병행처리 및 메모리 자원 누수 방지등의 언어 철학 바탕위에 설계된 취지에 맞게 안전성으로 제작된 프로그램은 빌드 과정에서 사전에 불안정한 결과를 방지할 수 있다는 빌드시스템으로까지 이어지는 완전한 안정성을 실현하고 있다
러스트는 인터넷에서 실행되는 서버 및 클라이언트 프로그램을 개발하는데 적합한 언어를 목표로 설계되었다.
이 목표에 따라 러스트는 안전성과 병행 프로그래밍, 그리고 메모리 관리의 직접 제어에 초점을 맞추고 있다.
또한 성능 면에서는 C++와 비슷한 수준을 목표로 하고 있다.
러스트의 문법은 중괄호로 코드 블록을 구분하고, codice_1, codice_2, codice_3 등의 키워드를 사용하는 등 C 및 C++와 유사한 모양을 하고 있다.
그러나 러스트와 C/C++는 의미상으로는 크게 다른 문법을 갖고 있다.
러스트는 메모리 오류를 발생시키지 않도록 설계되었다.
러스트는 널 포인터나 초기화되지 않은 포인터가 존재하지 않도록 강제하고 있다.
모든 변수는 초기값을 가지고 할당되며, 해제된 포인터에 접근하는 코드는 컴파일러가 미리 감지하여 컴파일 오류를 일으킨다.
타입 시스템은 하스켈의 영향을 받아 타입 클래스를 지원한다.
또한, 변수 선언 시 타입을 지정하지 않아도 컴파일러가 타입 추론을 통해 해당 변수의 타입을 지정할 수 있다.
반면 함수의 인자나 반환값에서는 타입 정보를 빼놓을 수 없다.
병행 프로그래밍은 얼랭과 유사한 actor 기반의 모델을 사용하고 있다.
각각의 태스크는 데이터를 직접 공유하지 않고 메시지 전달을 통해서만 데이터를 교환할 수 있다.
메시지를 복사할 때 생기는 성능 저하를 막기 위해, unique box의 경우 데이터 복사 없이 메시지를 전달할 수 있다.
unique box는 하나의 객체만이 소유할 수 있고, 다른 태스크로 전달될 경우 데이터 복사 없이 소유권만 바뀌게 된다.
객체 시스템은 implementation, trait, struct 또는 enum으로 이루어져 있다.
codice_4 또는 codice_5은 객체의 데이터를 정의하는데 사용되며, codice_6 키워드로 정의하는 implementation은 객체의 멤버 함수를 정의하는데 사용된다.
객체의 상속은 codice_7을 통해 이루어지며, C++의 다형 상속 문제를 회피하기 위해 trait은 객체의 멤버를 정의할 수 없도록 만들어져 있다.
아래 코드는 러스트 1.0 기준이며, 러스트의 문법은 향후 변경될 수 있다.
println!("hello, world");
아래는 각각 재귀함수와 반복문을 사용해 작성된 계승 함수이다:
/* 이 함수는 러스트의 암묵적 반환문을 이용해 작성되었다.
러스트의 `if` 문은 선언문이 아닌 표현식이므로, `if` 문에도 반환값이 존재한다.
fn recursive_factorial(n: isize) -&gt; isize {
fn iterative_factorial(n: isize) -&gt; isize {
// `mut` 키워드는 값이 바뀔 수 있는 변수를 가리킨다.
let mut result = 1;
while i &lt;= n {
return result; // 위의 예제와 달리 명시적 반환문을 사용한다
fn foreach_factorial(n: isize) -&gt; isize {
// 1.21 버전부터는 for_each가 가능해졌다.
let mut result = 1;
(1..n+1).for_each(|i| result *= i);
다음은 러스트의 병행 프로그래밍 기능을 보여주는 예제이다.
/* 이 함수는 각각 병렬적으로 실행되는 10개의 스레드를 만든다.
각각의 스레드가 stdout에 접근을 시도함에 따라, 한 행에 여러 문자열이 섞여서
use std::thread;
// 변수 message는 변경이 불가능하므로, 여러 개의 태스크에서 동시에 접근해도 안전하다.
let message = "Hello";
let mut threads = Vec::new();
// `for` 반복문은 `Iterator` trait을 구현하는 어떤 객체에 대해서나 사용할 수 있다.
for num in 0..10 {
// `thread::spawn`을 통해 스레드를 생성한다.
threads.push(thread::spawn(move || {
// println! 은 매크로이며, 컴파일 시간에 변수의 형 검사가 이루어진다.
// C나 C++의 단순한 코드 치환 매크로와 달리, 러스트의 매크로는 Scheme과 유사한 구조적 매크로이다.
println!("{} from task {:?}.", message, num);
// 각 스레드가 끝날 때까지 기다린다.
for thread in threads {
thread.join().unwrap();
러스트 0.4 이전 버전은 정적 타입 검사에 더해 타입 상태 분석 기능을 지원하였다.
타입 상태 분석 기능은 선언문 전후에 codice_8 키워드를 사용하여 해당 선언문이 의도대로 동작하는지 컴파일시에 검사할 수 있었다.
그러나 이 기능은 실질적으로 거의 사용되지 않아 제거되었다.
객체 시스템은 러스트 0.2에서 0.4에 거쳐 많은 변화를 겪었다.
러스트 0.2는 처음으로 클래스를 도입하였고, 0.3에는 소멸자와 인터페이스가 도입되었다.
그러나 0.4에 trait 기능이 도입되면서 인터페이스는 trait와 통합되었고, class는 제거되었다.
러스트 공식홈페이지에서는 '플레이그라운드'(playground) 페이지를 통해서 실시간 빌드 및 실행 테스트 공간을 제공하고있다.
러스트 파운데이션(Rust Foundation)은 참여형 대규모 오픈 소스 생태계를 유지하고 성장시키는 새로운 접근 방식으로 "좋은 소프트웨어는 행복하고 잘 지원되는 사람들에 의해 만들어집니다."라는 모토를 갖고서 러스트(Rust) 프로그래밍 언어와 생태계를 관리하는 독립적인 비영리 조직으로, 프로젝트를 관리하고 개발하는 유지 관리자를 지원하는 데 중점을 두고 있다.
창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.
