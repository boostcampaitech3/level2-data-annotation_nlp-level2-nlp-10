하스켈 또는 해스켈( )은 순수 함수형 프로그래밍 언어이다.
논리학자 해스켈 커리에서 이름을 따왔다.
그러므로 본디 ‘해스켈’로 불러야 하지만, 대한민국에서는 ‘하스켈’이 프로그래밍 언어를 가리키는 말로 널리 쓰여 굳어졌다.
1985년에 개발된 미란다가 하스켈의 전신이라고 할 수 있다.
1987년 오리건주 포틀랜드에서 열린 ‘함수형 프로그래밍 언어와 컴퓨터 구조에 관한 총회’()에서 있었던 회의에서, 난립하고 있는 함수형 언어들을 통합 정리해서 훗날 언어 설계의 기반이 될 수 있는 일반적인 순수 함수형 프로그래밍 언어를 만들자는 데에 참가자들의 뜻이 모였고 위원회가 발족되었다.
하스켈의 첫 버전(‘하스켈 1.0’)은 1990년에 완성되었다.
위원회의 노력은 1997년 말까지 다양한 설계안으로 이어져 마침내 ‘하스켈 98’이라는 성과가 나왔다.
하스켈 98은 교육용이나 확장을 덧붙이는 토대로 쓸 수 있는 안정적이고, 작고, 이식성 좋은 언어 표준을 의도한 결과물로서 표준 라이브러리가 포함되어 있었다.
또한 위원회는 하스켈 98의 확장 기능과 더불어 하스켈 98에 실험적인 기능을 덧붙이거나 합친 변형이 만들어지는 것을 열렬히 환영했다.
하스켈 98 언어 표준은 1999년 1월 〈하스켈 98 보고서〉()라는 이름으로 정식 공개되었다.
그리고 2003년 1월에는 〈하스켈 98 언어와 라이브러리: 개정 보고서〉()라는 이름으로 개정판이 나왔다.
하스켈을 실제 컴퓨터로 쓸 수 있게 구현한 ‘글래스고 하스켈 컴파일러’와 ‘허그스’가 사실상의 표준 역할을 하면서 하스켈은 지금도 끊임없이 발전하고 있다.
2006년초에 하스켈 98 표준의 뒤를 이을 표준에 관한 논의가 시작되었다.
새로운 표준은 비공식적으로 ‘하스켈 프라임’()이라는 이름으로 불렸으며, 2009년 11월 새로운 표준의 첫 번째 판인 하스켈 2010이 발표되었다.
하스켈 2010은 다른 프로그래밍 언어와 호환할 수 있는 인터페이스인 외부 함수 인터페이스를 지원하고, 일부 문법이 변경되었으며, "n"+"k" 패턴이라 불리는 문법 형식이 금지되었다.
하스켈의 특징으로는 패턴 맞춤, 커링, 조건제시법, 가드, 연산자 정의 등을 들 수 있다.
재귀 함수나 대수적 자료형도 지원되고, 느긋한 계산법 또한 하스켈의 특징으로 유명하다.
모나드, 타입 클래스 등은 하스켈만의 독창적인 개념이며 이러한 특징들은 절차적인 프로그래밍 언어에서 매우 힘들었던 함수 정의를 손쉽게 만들어버린다.
수학의 한 특이 분야인 범주론의 개념들, 특히 함수의 개념의 추상화된 형태인 사상과 모나드(monad)를 차용하여 가져온 언어인데, 이를 통해 함수를 대상으로써 다룸에 있어서 명확성을 가질 수 있다.
2002년을 기준으로 하스켈은 느긋한 계산법을 쓰는 함수형 언어 가운데 가장 활발한 연구가 이루어지는 언어로 볼 수 있다.
언어의 변형도 몇 가지 개발되었다.
매사추세츠 공과대학교와 글래스고 대학교가 개발한 버전은 병렬화가 가능하기 때문에 ‘병렬 하스켈’이라고 불린다.
이후 병렬화와 분산 처리를 더욱 강화한 ‘분산 하스켈’과 에덴 프로그래밍 언어가 나왔고, 느긋한 계산법 대신 적극적인 계산법을 쓰는 ‘적극적 하스켈’이 있으며 하스켈에 객체 지향 개념을 도입한 버전으로 ‘하스켈++’, ‘오하스켈’, 몬드리안 프로그래밍 언어 등등이 있다.
하스켈과 비슷한 언어로 그래픽 사용자 인터페이스 개발에 새로운 방법을 도입한 클린이 있다.
이 언어와 하스켈의 가장 큰 차이점은 입출력을 위해 모나드 대신에 유일형을 사용한다는 것이다.
하스켈 사용자의 수는 상대적으로 적은 편이지만, 그 강력함 때문에 몇몇 프로젝트를 쉽게 해주었다.
퍼그스()는 펄 6의 컴파일러와 인터프리터를 구현한 것인데, 개발 기간은 지극히 짧았지만 만들어진 지 몇 달도 채 되지 않아 꽤 쓸 만하다는 평을 받았다.
서브버전과 비슷한 버전 관리 체계인 다크스()가 하스켈로 만들어지기도 했고, 린스파이어는 시스템 도구 개발을 위한 언어로 하스켈을 선택했다.
다음은 계승을 하스켈로 구현하는 몇 가지 방법이다.
패턴 매칭과 꼬리 순환(tail recursion)을 이용한 방법
fac n = n * fac (n-1)
if-then-else와 꼬리 순환을 이용한 방법
fac n = if n &gt; 1 then n * fac (n-1) else 1
고차 함수(high-order function)을 이용한 방법
fac n = foldl1 (*) [n..1]
product 함수를 이용한 방법(product 함수는 위의 foldl1 (*)과 같다)
fac n = product [n..1]
