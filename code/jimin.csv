id,sentence,subject_entity,object_entity,label
0,"예를 들어, HTML은 특수 분야 언어이며, HTML의 영역은 웹페이지와 하이퍼텍스트이다.","{'word': '특수 분야 언어', 'start': 1303, 'end': 1310, 'type': 'COM'}","{'word': 'HTML', 'start': 1297, 'end': 1300, 'type': 'COM'}",com:sub_concept
1,"특수 분야 언어의 다른 예로 설정 파일, 스프레드시트, 그리고 심지어는 전자 메일(""보낸이:"", ""받는이:"" 헤더는 처리문을 통하여 본다.)까지도 들 수 있다.","{'word': '특수 분야 언어', 'start': 1341, 'end': 1348, 'type': 'COM'}","{'word': '설정 파일', 'start': 1357, 'end': 1361, 'type': 'COM'}",com:sub_concept
2,"특수 분야 언어의 다른 예로 설정 파일, 스프레드시트, 그리고 심지어는 전자 메일(""보낸이:"", ""받는이:"" 헤더는 처리문을 통하여 본다.)까지도 들 수 있다.","{'word': '특수 분야 언어', 'start': 1341, 'end': 1348, 'type': 'COM'}","{'word': '스프레드시트', 'start': 1364, 'end': 1369, 'type': 'COM'}",com:sub_concept
3,"특수 분야 언어의 다른 예로 설정 파일, 스프레드시트, 그리고 심지어는 전자 메일(""보낸이:"", ""받는이:"" 헤더는 처리문을 통하여 본다.)까지도 들 수 있다.","{'word': '특수 분야 언어', 'start': 1341, 'end': 1348, 'type': 'COM'}","{'word': '전자 메일', 'start': 1381, 'end': 1385, 'type': 'COM'}",com:sub_concept
4,"따라서 특수 분야 언어들은 보통 범용 언어에 ""내장""된다.","{'word': '범용 언어', 'start': 1491, 'end': 1495, 'type': 'COM'}","{'word': '특수 분야 언어', 'start': 1477, 'end': 1484, 'type': 'COM'}",com:sub_concept
5,"선언형 언어는 다른 언어와 같이 문법을 가지고 있고 언어의 단어들이 어떻게 결합되어야 하는지 설명하고 있으며, 어떻게 프로그램의 출력에 맞게 할 것인지를 언어의 문장으로 설명하는 의미구조가 있다.","{'word': '선언형 언어', 'start': 1092, 'end': 1097, 'type': 'COM'}","{'word': '문법', 'start': 1110, 'end': 1111, 'type': 'POH'}",com:sub_concept
6,"선언형 프로그래밍(宣言型 프로그래밍, )은 두 가지 뜻으로 통용되고 있다.","{'word': '선언형 프로그래밍', 'start': 0, 'end': 8, 'type': 'COM'}","{'word': '宣言型 프로그래밍', 'start': 10, 'end': 18, 'type': 'COM'}",com:alter_names
7,"예를 들어, 웹 페이지는 선언형인데 웹페이지는 제목, 글꼴, 본문, 그림과 같이 ""무엇""이 나타나야하는지를 묘사하는 것이지 ""어떤 방법으로"" 컴퓨터 화면에 페이지를 나타내야 하는지를 묘사하는 것이 아니기 때문이다.","{'word': '웹 페이지', 'start': 124, 'end': 128, 'type': 'COM'}","{'word': '웹페이지', 'start': 137, 'end': 140, 'type': 'COM'}",com:alter_names
8,"또 다른 정의에 따르면, 프로그램이 함수형 프로그래밍 언어, 논리형 프로그래밍 언어, 혹은 제한형 프로그래밍 언어로 쓰인 경우에 ""선언형""이라고 한다.","{'word': '프로그램', 'start': 432, 'end': 435, 'type': 'COM'}","{'word': '제한형 프로그래밍 언어', 'start': 469, 'end': 480, 'type': 'COM'}",com:made_of
9,"이렇게 하면 프로그래머가 특수 분야 언어가 힘을 발휘하는 분야에서 이것을 이용할 수 있고, 특수 분야 언어로 하기 어렵거나 불가능한 문제는 범용 언어를 이용할 수 있다.","{'word': '프로그래머', 'start': 1513, 'end': 1517, 'type': 'PER'}","{'word': '특수 분야 언어', 'start': 1557, 'end': 1564, 'type': 'COM'}",no_relation
10,"간단히 말하여, 명령형 프로그램은 알고리즘을 명시하고 목표는 명시하지 않는 데 반해 선언형 프로그램은 목표를 명시하고 알고리즘을 명시하지 않는 것이다.","{'word': '명령형 프로그램', 'start': 342, 'end': 349, 'type': 'COM'}","{'word': '목표', 'start': 390, 'end': 391, 'type': 'POH'}",no_relation
11,"특히, 제한형 프로그래밍과 논리형 프로그래밍은 필요한 해의 특성을 설명하고(무엇) 그 해를 찾는 데 사용하는 실제 알고리즘은 설명하지 않는다(어떤 방법). 그러나 대부분의 논리형과 제한형 언어들은 알고리즘을 설명할 수 있고, 상세한 부분을 구현할 수 있어서 첫 번째 정의를 따르는 엄밀한 의미의 선언형 프로그래밍 언어는 아니다.","{'word': '프로그래밍', 'start': 591, 'end': 595, 'type': 'COM'}","{'word': '특성', 'start': 616, 'end': 617, 'type': 'POH'}",no_relation
12,"여기서 ""선언형 언어""라는 것은 명령형 언어와 대비되는 이런 프로그래밍 언어들을 통칭하는 것이다.","{'word': '선언형 언어', 'start': 508, 'end': 513, 'type': 'COM'}","{'word': '명령형 언어', 'start': 521, 'end': 526, 'type': 'COM'}",no_relation
13,"특히, 제한형 프로그래밍과 논리형 프로그래밍은 필요한 해의 특성을 설명하고(무엇) 그 해를 찾는 데 사용하는 실제 알고리즘은 설명하지 않는다(어떤 방법). 그러나 대부분의 논리형과 제한형 언어들은 알고리즘을 설명할 수 있고, 상세한 부분을 구현할 수 있어서 첫 번째 정의를 따르는 엄밀한 의미의 선언형 프로그래밍 언어는 아니다.","{'word': '알고리즘', 'start': 693, 'end': 696, 'type': 'COM'}","{'word': '선언형 프로그래밍 언어', 'start': 748, 'end': 759, 'type': 'COM'}",no_relation
14,라이브러리나 프레임워크 내부의 비선언형 부분을 캡슐화하여 이렇게 할 수 있다.,"{'word': '라이브러리', 'start': 811, 'end': 815, 'type': 'COM'}","{'word': '캡슐화', 'start': 837, 'end': 839, 'type': 'COM'}",no_relation
15,"이런 형태의 예가 제이유닛 유닛 테스트 프레임워크에 반영되어 쓰이고 있는데, 이것은 정의만 되어 있으면 프레임워크로 등록하여 유닛을 테스트하는 것을 가능하게 한다.","{'word': '프레임워크', 'start': 913, 'end': 917, 'type': 'COM'}","{'word': '유닛', 'start': 925, 'end': 926, 'type': 'COM'}",no_relation
16,선언형 프로그램에서는 그 언어의 표준 알고리즘으로 처리되는 자료 구조를 작성하거나 선언한다.,"{'word': '선언형 프로그램', 'start': 947, 'end': 954, 'type': 'COM'}","{'word': '자료 구조', 'start': 980, 'end': 984, 'type': 'COM'}",no_relation
17,"예를 들어서 웹페이지를 작성한다고 하면, 페이지가 HTML에서 무엇을 보여주어야 하는지를 선언하고 브라우저의 절차적 알고리즘이 이것을 화면에 표시할 점들로 변환한다.","{'word': '웹페이지', 'start': 1006, 'end': 1009, 'type': 'COM'}","{'word': '절차적 알고리즘', 'start': 1060, 'end': 1067, 'type': 'COM'}",no_relation
18,"선언형 프로그래밍은 특수 분야 언어()의 형태로 자주 사용된다. 여기서 ""분야""이라는 것은 ""언어의 사용 분야""(즉, 그 언어가 표현하는 소재)을 의미한다.","{'word': '선언형 프로그래밍', 'start': 1202, 'end': 1210, 'type': 'COM'}","{'word': '분야', 'start': 1243, 'end': 1244, 'type': 'COM'}",no_relation
19,범용 언어에 내장되지 않는 특수 분야 언어는 같은 프로그램을 작성할 때 내장된 언어보다 더 사용하기 쉬운 경우가 많은데 범용 언어가 지우는 복잡한 개념이 잘 추가되지 않기 때문이다.,"{'word': '범용 언어', 'start': 1601, 'end': 1605, 'type': 'COM'}","{'word': '프로그램', 'start': 1629, 'end': 1632, 'type': 'COM'}",no_relation
20,"이것은 전통적인 포트란과 C, 자바와 같은 명령형 프로그래밍 언어와는 다른 접근방식인데, 명령형 프로그래밍 언어는 프로그래머가 실행될 알고리즘을 명시해주어야 하는 것이다.","{'word': '포트란', 'start': 246, 'end': 248, 'type': 'COM'}","{'word': 'C', 'start': 251, 'end': 251, 'type': 'COM'}",com:similar_tech
21,"이것은 전통적인 포트란과 C, 자바와 같은 명령형 프로그래밍 언어와는 다른 접근방식인데, 명령형 프로그래밍 언어는 프로그래머가 실행될 알고리즘을 명시해주어야 하는 것이다.","{'word': '자바', 'start': 254, 'end': 255, 'type': 'COM'}","{'word': 'C', 'start': 251, 'end': 251, 'type': 'COM'}",com:similar_tech
22,"1978년에 브라이언 커니핸과 데니스 리치가 ""The C Programming Language""라는 책의 초판을 출간했다.","{'word': '브라이언 커니핸과 데니스 리치', 'start': 1280, 'end': 1295, 'type': 'PER'}","{'word': '""The C Programming Language""', 'start': 1298, 'end': 1325, 'type': 'POH'}",per:production
23,C는 1972년 켄 톰슨과 데니스 리치가 벨 연구소에서 일할 당시 새로 개발된 유닉스 운영 체제에서 사용하기 위해 개발한 프로그래밍 언어이다.,"{'word': '켄 톰슨과 데니스 리치', 'start': 9, 'end': 20, 'type': 'PER'}","{'word': 'C', 'start': 0, 'end': 0, 'type': 'COM'}",per:production
24,C는 1972년 켄 톰슨과 데니스 리치가 벨 연구소에서 일할 당시 새로 개발된 유닉스 운영 체제에서 사용하기 위해 개발한 프로그래밍 언어이다.,"{'word': '켄 톰슨', 'start': 9, 'end': 12, 'type': 'PER'}","{'word': '데니스 리치', 'start': 15, 'end': 20, 'type': 'PER'}",per:colleagues
25,"유닉스는 어셈블리가 아닌 언어로 구현된 최초의 운영체제 커널 중의 하나였다.(더 빠른 사례는 PL/I로 쓰인 Multics 시스템, ALGOL로 쓰인 Burroughs B5000을 위한 MCP(Master Control Program)가 있다.) 1977년 경, 리치와 스티븐 C. 존슨이 유닉스 운영체제의 이식성을 향상시키기 위해, C 언어를 추가적으로 변경하였다.","{'word': '리치', 'start': 1162, 'end': 1163, 'type': 'PER'}","{'word': '스티븐 C. 존슨', 'start': 1166, 'end': 1174, 'type': 'PER'}",per:colleagues
26,"1978년에 브라이언 커니핸과 데니스 리치가 ""The C Programming Language""라는 책의 초판을 출간했다.","{'word': '데니스 리치', 'start': 1290, 'end': 1295, 'type': 'PER'}","{'word': '브라이언 커니핸', 'start': 1280, 'end': 1287, 'type': 'PER'}",per:colleagues
27,"켄 톰슨은 BCPL언어를 필요에 맞추어 개조해서 ""B""언어(언어를 개발한 벨 연구소의 B를 따서)라 명명했고, 데니스 리치가 이것을 개선하여 C 언어가 탄생했다.","{'word': '벨 연구소', 'start': 121, 'end': 125, 'type': 'ORG'}","{'word': '""B""언어', 'start': 107, 'end': 111, 'type': 'COM'}",org:production
28,"C 언어의 초기 개발은 1969년부터 1973년까지 4년에 걸쳐 AT&amp;T 벨 연구소에서 이루어 졌으며, 데니스 리치의 말에 따르면, 가장 창의적인 작업이 이루어진 기간은 1972년이었다.","{'word': '벨 연구소', 'start': 587, 'end': 591, 'type': 'ORG'}","{'word': 'C 언어', 'start': 542, 'end': 545, 'type': 'COM'}",org:production
29,"C 언어의 초기 개발은 1969년부터 1973년까지 4년에 걸쳐 AT&amp;T 벨 연구소에서 이루어 졌으며, 데니스 리치의 말에 따르면, 가장 창의적인 작업이 이루어진 기간은 1972년이었다.","{'word': 'AT&amp;T', 'start': 578, 'end': 585, 'type': 'ORG'}","{'word': '벨 연구소', 'start': 587, 'end': 591, 'type': 'ORG'}",org:members
30,C는 1972년 켄 톰슨과 데니스 리치가 벨 연구소에서 일할 당시 새로 개발된 유닉스 운영 체제에서 사용하기 위해 개발한 프로그래밍 언어이다.,"{'word': 'C', 'start': 0, 'end': 0, 'type': 'COM'}","{'word': '1972년', 'start': 3, 'end': 7, 'type': 'DAT'}",com:date_of_prod
31,최종 개발 버전은 2011년도 4월 N1570이었다.,"{'word': 'N1570', 'start': 1953, 'end': 1957, 'type': 'COM'}","{'word': '2011년도 4월', 'start': 1943, 'end': 1951, 'type': 'DAT'}",com:date_of_prod
32,"유닉스는 어셈블리가 아닌 언어로 구현된 최초의 운영체제 커널 중의 하나였다.(더 빠른 사례는 PL/I로 쓰인 Multics 시스템, ALGOL로 쓰인 Burroughs B5000을 위한 MCP(Master Control Program)가 있다.) 1977년 경, 리치와 스티븐 C. 존슨이 유닉스 운영체제의 이식성을 향상시키기 위해, C 언어를 추가적으로 변경하였다.","{'word': '운영체제 커널', 'start': 1041, 'end': 1047, 'type': 'COM'}","{'word': '유닉스', 'start': 1015, 'end': 1017, 'type': 'COM'}",com:sub_concept
33,"C 표준은 1990년대 후반에 더 개정되어, 1999년 ISO/IEC 9899:1999가 출간되었고, 여기서 명시한 규범을 흔히 C99라 부른다.","{'word': 'ISO/IEC 9899:1999', 'start': 1718, 'end': 1734, 'type': 'COM'}","{'word': 'C99', 'start': 1759, 'end': 1761, 'type': 'COM'}",com:alter_names
34,"2011년 ISO/IEC 9899:2011이 출간되었고, 간단하게 C11라고 부른다.","{'word': 'ISO/IEC 9899:2011', 'start': 1859, 'end': 1875, 'type': 'COM'}","{'word': 'C11', 'start': 1890, 'end': 1892, 'type': 'COM'}",com:alter_names
35,C11이 나오기 전까지의 개발 버전을 C1X라고 부른다.,"{'word': '개발 버전', 'start': 1915, 'end': 1919, 'type': 'COM'}","{'word': 'C1X', 'start': 1922, 'end': 1924, 'type': 'COM'}",com:alter_names
36,"2018년 ISO/IEC 9899:2018이 출간되었으며, 간단하게 C17이라고 부른다.","{'word': 'ISO/IEC 9899:2018', 'start': 1969, 'end': 1985, 'type': 'COM'}","{'word': 'C17', 'start': 2001, 'end': 2003, 'type': 'COM'}",com:alter_names
37,이렇게 그룹은 나누는 것을 세그먼트(SEGMENT) 또는 섹션(SECTION)이라는 단어를 사용한다.,"{'word': '세그먼트(SEGMENT)', 'start': 3111, 'end': 3123, 'type': 'COM'}","{'word': '섹션(SECTION)', 'start': 3128, 'end': 3138, 'type': 'COM'}",com:alter_names
38,"유닉스 시스템의 바탕 프로그램은 모두 C로 작성되었고, 수많은 운영 체제의 커널 또한 C로 만들어졌다.","{'word': '유닉스 시스템의 바탕 프로그램', 'start': 171, 'end': 186, 'type': 'COM'}","{'word': 'C', 'start': 192, 'end': 192, 'type': 'COM'}",com:made_of
39,"유닉스 시스템의 바탕 프로그램은 모두 C로 작성되었고, 수많은 운영 체제의 커널 또한 C로 만들어졌다.","{'word': '운영 체제의 커널', 'start': 206, 'end': 214, 'type': 'COM'}","{'word': 'C', 'start': 219, 'end': 219, 'type': 'COM'}",com:made_of
40,이는 오늘날의 널리 쓰이는 거의 모든 운영 체제 커널이 C를 이용해 구현된 이유이기도 하다.,"{'word': '운영 체제 커널', 'start': 280, 'end': 287, 'type': 'COM'}","{'word': 'C', 'start': 290, 'end': 290, 'type': 'COM'}",com:made_of
41,리치와 톰슨에 의해 초기에 PDP-7의 어셈블리 언어로 구현되었던 유닉스 운영체제의 개발과 C 언어의 기원은 밀접하게 연관되어 있다.,"{'word': '유닉스 운영체제', 'start': 771, 'end': 778, 'type': 'COM'}","{'word': '어셈블리 언어', 'start': 756, 'end': 762, 'type': 'COM'}",com:made_of
42,유닉스의 초기 PDP-11 버전은 어셈블리로 개발되었다.,"{'word': 'PDP-11 버전', 'start': 927, 'end': 935, 'type': 'COM'}","{'word': '어셈블리', 'start': 938, 'end': 941, 'type': 'COM'}",com:made_of
43,"켄 톰슨은 BCPL언어를 필요에 맞추어 개조해서 ""B""언어(언어를 개발한 벨 연구소의 B를 따서)라 명명했고, 데니스 리치가 이것을 개선하여 C 언어가 탄생했다.","{'word': 'C 언어', 'start': 159, 'end': 162, 'type': 'COM'}","{'word': '""B""언어', 'start': 107, 'end': 111, 'type': 'COM'}",com:prior_tech
44,"언어의 이름이 'C'인 이유는 그 특징이 'B' 언어에서 유래되었기 때문이며, 켄 톰슨에 의하면, B 언어는 BCPL 언어의 기본만 남긴 버전이다.","{'word': ""'C'"", 'start': 659, 'end': 661, 'type': 'COM'}","{'word': ""'B' 언어"", 'start': 674, 'end': 679, 'type': 'COM'}",com:prior_tech
45,존슨의 Portable C Compiler는 새로운 플랫폼에서의 C의 구현의 기초가 되었다.,"{'word': '존슨', 'start': 1221, 'end': 1222, 'type': 'PER'}","{'word': '새로운 플랫폼', 'start': 1246, 'end': 1252, 'type': 'POH'}",no_relation
46,"커니핸과 리치의 앞 글자만 따서 C 프로그래머들에게는 ""K&amp;R""로 불리는 이 책은, 비공식적이지만 오랫동안 C의 규격과 같은 역할을 했다.","{'word': 'C 프로그래머들', 'start': 1360, 'end': 1367, 'type': 'PER'}","{'word': '""K&amp;R""', 'start': 1372, 'end': 1380, 'type': 'POH'}",no_relation
47,"C 언어의 초기 개발은 1969년부터 1973년까지 4년에 걸쳐 AT&amp;T 벨 연구소에서 이루어 졌으며, 데니스 리치의 말에 따르면, 가장 창의적인 작업이 이루어진 기간은 1972년이었다.","{'word': '데니스 리치', 'start': 604, 'end': 609, 'type': 'PER'}","{'word': '1972년', 'start': 641, 'end': 645, 'type': 'DAT'}",no_relation
48,"만약 malloc 등의 함수를 사용하면, 힙 영역을 사용하겠다는 의미 이기 때문에 힙 영역을 개발자가 선언하여 관리 해야 한다.","{'word': '개발자', 'start': 2429, 'end': 2431, 'type': 'PER'}","{'word': 'malloc', 'start': 2380, 'end': 2385, 'type': 'COM'}",no_relation
49,KGDB를 사용하면 커널 개발자는 일반 응용 프로그램과 마찬가지로 커널을 디버깅할 수 있다.,"{'word': '커널 개발자', 'start': 5735, 'end': 5740, 'type': 'PER'}","{'word': '커널', 'start': 5761, 'end': 5762, 'type': 'COM'}",no_relation
50,"현재는 C 뿐만 아니라 C++, C# 등 다양한 언어를 지원하고 있지만 초기의 마이크로소프트 개발 도구는 C 언어로부터 출발하였다.","{'word': '마이크로소프트', 'start': 4604, 'end': 4610, 'type': 'ORG'}","{'word': 'C#', 'start': 4578, 'end': 4579, 'type': 'COM'}",no_relation
51,"C 언어 표준이 상대적으로 정적으로 남아 있었던 동안, C++는 표준화를 위하여 계속 진화하고 있었다.","{'word': 'C 언어', 'start': 1535, 'end': 1538, 'type': 'COM'}","{'word': '표준화', 'start': 1571, 'end': 1573, 'type': 'POH'}",no_relation
52,"1973년에 codice_1 자료형의 추가로, C 언어는 유닉스의 대부분을 C로 쓸 수 있을 정도로 강력해 졌다.","{'word': '유닉스', 'start': 983, 'end': 985, 'type': 'COM'}","{'word': '1973년', 'start': 951, 'end': 955, 'type': 'DAT'}",no_relation
53,"이처럼 C는 시스템 프로그램 개발에 매우 적합하지만, 응용 프로그램 개발에도 많이 쓰이기도 한다.","{'word': '시스템 프로그램', 'start': 318, 'end': 325, 'type': 'COM'}","{'word': '응용 프로그램', 'start': 341, 'end': 347, 'type': 'COM'}",no_relation
54,"PDP-11의 기능의 일부, 특히 바이트 접근기능을 활용하지 못하는 B 언어의 부족함이 C 언어의 초기 버전의 개발을 이끌었다.","{'word': 'PDP-11', 'start': 847, 'end': 852, 'type': 'COM'}","{'word': 'B 언어', 'start': 885, 'end': 888, 'type': 'COM'}",no_relation
55,"유닉스는 어셈블리가 아닌 언어로 구현된 최초의 운영체제 커널 중의 하나였다.(더 빠른 사례는 PL/I로 쓰인 Multics 시스템, ALGOL로 쓰인 Burroughs B5000을 위한 MCP(Master Control Program)가 있다.) 1977년 경, 리치와 스티븐 C. 존슨이 유닉스 운영체제의 이식성을 향상시키기 위해, C 언어를 추가적으로 변경하였다.","{'word': '유닉스', 'start': 1015, 'end': 1017, 'type': 'COM'}","{'word': '어셈블리', 'start': 1020, 'end': 1023, 'type': 'COM'}",no_relation
56,"유닉스는 어셈블리가 아닌 언어로 구현된 최초의 운영체제 커널 중의 하나였다.(더 빠른 사례는 PL/I로 쓰인 Multics 시스템, ALGOL로 쓰인 Burroughs B5000을 위한 MCP(Master Control Program)가 있다.) 1977년 경, 리치와 스티븐 C. 존슨이 유닉스 운영체제의 이식성을 향상시키기 위해, C 언어를 추가적으로 변경하였다.","{'word': 'PL/I', 'start': 1067, 'end': 1070, 'type': 'COM'}","{'word': 'MCP', 'start': 1119, 'end': 1121, 'type': 'COM'}",no_relation
57,"포트란 77과 같은 언어와 달리, C 소스코드는 free-form 언어로써 형식 코드에 공백을 마음대로 넣을 수 있다.","{'word': '포트란 77', 'start': 2044, 'end': 2049, 'type': 'COM'}","{'word': 'C 소스코드', 'start': 2063, 'end': 2068, 'type': 'COM'}",no_relation
58,"OS에서 응용 프로그램을 실행하거나, CPU의 프로그램을 실행하기 위해 여러가지 영역으로 나누어 메모리를 할당하고 이를 메모리에 올려 실행 한다.","{'word': 'CPU', 'start': 2132, 'end': 2134, 'type': 'COM'}","{'word': 'OS', 'start': 2111, 'end': 2112, 'type': 'COM'}",no_relation
59,C 언어로 개발된 프로그램은 메모리 입장에서 다음과 같은 할당 영역으로 나누어 생각할 수 있다.,"{'word': 'C 언어', 'start': 2193, 'end': 2196, 'type': 'COM'}","{'word': '메모리', 'start': 2209, 'end': 2211, 'type': 'COM'}",no_relation
60,"CPU를 사용하여 개발하여 장치에 넣어 코드를 실행할 때, 힙 영역을 많이 사용하지는 않는다.","{'word': 'CPU', 'start': 2247, 'end': 2249, 'type': 'COM'}","{'word': '힙 영역', 'start': 2280, 'end': 2283, 'type': 'COM'}",no_relation
61,따라서 필요 없다면 메모리 공간을 할당할 필요도 없고 힙관리 프로그램 코드(함수를 개발툴에서 라이브러리 형태로 제공)도 필요하지 않는다.,"{'word': '메모리', 'start': 2311, 'end': 2313, 'type': 'COM'}","{'word': '라이브러리', 'start': 2352, 'end': 2356, 'type': 'COM'}",no_relation
62,C 언어 작성된 코드는 컴파일 과정과 링크 과정을 거치면 실행 파일이 만들어진다.,"{'word': '컴파일', 'start': 2542, 'end': 2544, 'type': 'COM'}","{'word': '파일', 'start': 2564, 'end': 2565, 'type': 'COM'}",no_relation
63,"각 특성별로 나누어 그룹을 지어 메모리에 배치 하는데, 이것을 링커가 한다.","{'word': '링커', 'start': 3088, 'end': 3089, 'type': 'COM'}","{'word': '메모리', 'start': 3071, 'end': 3073, 'type': 'COM'}",no_relation
64,"컴파일마다 각 세그먼트 이름과 구조가 다르지만, 예를 들어 중요한 세그먼트 만 표시 하였다, TEXT와 CONST는 ROM/FLASH에 배치해도 되는 변하지 않는 세그먼트이므로 같은 부류이고, CPU를 설계하고 코드를 직접 쓰는 경우 ROM/FLASH을 이용한다.","{'word': 'TEXT', 'start': 3317, 'end': 3320, 'type': 'COM'}","{'word': 'CPU', 'start': 3373, 'end': 3375, 'type': 'COM'}",no_relation
65,실제 CPU를 다루는 C 언어에서 이런 정보는 중요하다.,"{'word': 'CPU', 'start': 3537, 'end': 3539, 'type': 'COM'}","{'word': 'C 언어', 'start': 3546, 'end': 3549, 'type': 'COM'}",no_relation
66,"C 언어 함수는 표준함수가 있고, 개발 툴에서 제공하는 함수가 있다.","{'word': '표준함수', 'start': 3623, 'end': 3626, 'type': 'COM'}","{'word': '개발 툴', 'start': 3633, 'end': 3636, 'type': 'COM'}",no_relation
67,여러가지 부류가 있고 특성 별로 나누어 lib 파일로 코드를 제공하고 헤더파일로 선언을 알 수 있다.,"{'word': 'lib 파일', 'start': 3675, 'end': 3680, 'type': 'COM'}","{'word': '헤더파일', 'start': 3692, 'end': 3695, 'type': 'COM'}",no_relation
68,유닉스 계열(리눅스)의 시스템에서 주로 사용하는 C/C++ 언어 개발 도구이다.,"{'word': '유닉스 계열', 'start': 3761, 'end': 3766, 'type': 'COM'}","{'word': 'C/C++', 'start': 3788, 'end': 3792, 'type': 'COM'}",no_relation
69,"리눅스의 OS을 제 컴파일하거나, 각종 응용 프로그램 개발에 사용한다. 또한 X-Windows의 개발 도구로도 사용할 수 있다.","{'word': '리눅스', 'start': 3806, 'end': 3808, 'type': 'COM'}","{'word': 'X-Windows', 'start': 3849, 'end': 3857, 'type': 'COM'}",no_relation
70,"전자 장치의 개발 시 임베디드 OS 포팅에서, 리눅스 커널이나 리눅스 커널 기반으로 하는 OS 커널 자체를 개발하는 도구로 사용한다.","{'word': '임베디드', 'start': 3890, 'end': 3893, 'type': 'COM'}","{'word': '리눅스', 'start': 3913, 'end': 3915, 'type': 'COM'}",no_relation
71,리눅스 커널 기반 임베디드에서 실행되는 응용 프로그램 역시 gcc을 많이 사용한다.,"{'word': '리눅스', 'start': 3953, 'end': 3955, 'type': 'COM'}","{'word': 'gcc', 'start': 3986, 'end': 3988, 'type': 'COM'}",no_relation
72,"여러 파일들끼리의 의존성과 각 파일에 필요한 명령을 정의함으로써 프로그램을 컴파일할 수 있으며 최종 프로그램을 만들 수 있는 과정을 서술할 수 있는 표준적인 문법을 가지고 있고, 구조로 기술된 파일(주로 Makefile이라는 파일명)을 [make]가 해석하여 프로그램 빌드를 수행하게 된다.","{'word': 'Makefile', 'start': 4114, 'end': 4121, 'type': 'COM'}","{'word': '최종 프로그램', 'start': 4053, 'end': 4059, 'type': 'COM'}",no_relation
73,이클립스는 다양한 언어와 다양한 OS에서 실행되는 IDE이다.,"{'word': '이클립스', 'start': 4229, 'end': 4232, 'type': 'COM'}","{'word': 'OS', 'start': 4247, 'end': 4248, 'type': 'COM'}",no_relation
74,C/C++언어를 제공하는 IDE으로 리눅스의 경우 기존의 gcc을 사용할 수 있도록 연결 설정만 하면 된다.,"{'word': 'gcc', 'start': 4359, 'end': 4361, 'type': 'COM'}","{'word': 'C/C++언어', 'start': 4327, 'end': 4333, 'type': 'COM'}",no_relation
75,윈도우에서 gcc와 연결하여 C/C++ 언어를 사용하여 프로그램을 개발 할 수 있다.,"{'word': '윈도우', 'start': 4388, 'end': 4390, 'type': 'COM'}","{'word': 'C/C++ 언어', 'start': 4404, 'end': 4411, 'type': 'COM'}",no_relation
76,MinGW는 다양한 언어를 지원하므로 다른 언어로도 이클립스와 연결하여 개발 도구로 사용할 수 있다.,"{'word': 'MinGW', 'start': 4436, 'end': 4440, 'type': 'COM'}","{'word': '이클립스', 'start': 4465, 'end': 4468, 'type': 'COM'}",no_relation
77,"비주얼 스튜디오로는 윈도우 API를 이용한 GUI 프로그램, 명령 줄 인터페이스 환경으로 실행되는 Windows Console Application, 윈도우 서비스, 동적 링크 라이브러리 등의 형태로 소프트웨어를 개발할 수 있고, 최근 버전에서는 모바일 응용 소프트웨어 개발도 지원한다.","{'word': 'GUI 프로그램', 'start': 4658, 'end': 4665, 'type': 'COM'}","{'word': '버전', 'start': 4766, 'end': 4767, 'type': 'COM'}",no_relation
78,비주얼 스튜디오에서 사용 가능한 소프트웨어 개발 키트와 라이브러리는 다음과 같다.,"{'word': '비주얼 스튜디오', 'start': 4795, 'end': 4802, 'type': 'COM'}","{'word': '라이브러리', 'start': 4826, 'end': 4830, 'type': 'COM'}",no_relation
79,윈도우 운영체제의 API를 사용할 수 있게 해주는 툴킷이다.,"{'word': '윈도우', 'start': 4884, 'end': 4886, 'type': 'COM'}","{'word': 'API', 'start': 4894, 'end': 4896, 'type': 'COM'}",no_relation
80,응용프로그램에서 사용 가능한 윈도우 운영체제의 기능은 Windows SDK를 통해 제공된다.,"{'word': '윈도우', 'start': 4934, 'end': 4936, 'type': 'COM'}","{'word': '응용프로그램', 'start': 4918, 'end': 4923, 'type': 'COM'}",no_relation
81,윈도우에서 주로 게임 등을 개발할 때 사용하는 툴킷이다.,"{'word': '윈도우', 'start': 5087, 'end': 5089, 'type': 'COM'}","{'word': '게임', 'start': 5096, 'end': 5097, 'type': 'COM'}",no_relation
82,보통 소프트웨어 개발에서 디버깅의 가장 일반적인 방법은 두가지이다.,"{'word': '소프트웨어', 'start': 5151, 'end': 5155, 'type': 'COM'}","{'word': '디버깅', 'start': 5162, 'end': 5164, 'type': 'COM'}",no_relation
83,GCC 옵션을 디버깅이 되도록 설정하면 디버깅 테이블을 만든다. gdb 실행 중에 이것을 사용한다.,"{'word': '디버깅', 'start': 5245, 'end': 5247, 'type': 'COM'}","{'word': 'gdb', 'start': 5273, 'end': 5275, 'type': 'COM'}",no_relation
84,"GDB을 실행하여 응용 프로그램을 실행하면서 break, 변수, 함수 등의 디버깅을 할 수 있다.","{'word': 'GDB', 'start': 5293, 'end': 5295, 'type': 'COM'}","{'word': '디버깅', 'start': 5335, 'end': 5337, 'type': 'COM'}",no_relation
85,GCC에서 gdb는 서버 구조를 사용할 수 있다.,"{'word': 'GCC', 'start': 5348, 'end': 5350, 'type': 'COM'}","{'word': '서버 구조', 'start': 5359, 'end': 5363, 'type': 'COM'}",no_relation
86,gdb-server을 설치하면 네트워크를 통해 디버깅 환경을 구성할 수 있다.,"{'word': 'gdb-server', 'start': 5376, 'end': 5385, 'type': 'COM'}","{'word': '디버깅', 'start': 5402, 'end': 5404, 'type': 'COM'}",no_relation
87,"예를 들어 임베디드 개발 시 리눅스 커널을 포팅하고, 해당 리눅스 시스템에 gdb-server를 설치하면 다른 환경에서 이를 통해 응용 프로그램을 디버깅 할 수 있다.","{'word': '임베디드', 'start': 5426, 'end': 5429, 'type': 'COM'}","{'word': '응용 프로그램', 'start': 5493, 'end': 5499, 'type': 'COM'}",no_relation
88,임베디드의 많은 경우 자신의 시스템에서는 디버깅이 만만치 않다.,"{'word': '시스템', 'start': 5530, 'end': 5532, 'type': 'COM'}","{'word': '임베디드', 'start': 5514, 'end': 5517, 'type': 'COM'}",no_relation
89,따라서 원격으로 gdb의 실행 결과를 전송 할 수 있고 이 정보를 바탕으로 이클립스와 같은 IDE와 연동할 수 있다.,"{'word': 'gdb', 'start': 5559, 'end': 5561, 'type': 'COM'}","{'word': '이클립스', 'start': 5592, 'end': 5595, 'type': 'COM'}",no_relation
90,원격 디버깅 모드는 리눅스 커널에 사용되는 소스 수준의 디버거인 KGDB에서도 사용된다.,"{'word': '리눅스 커널', 'start': 5685, 'end': 5690, 'type': 'COM'}","{'word': 'KGDB', 'start': 5710, 'end': 5713, 'type': 'COM'}",no_relation
91,이클립스 디버깅은 GDB와 연동해서 구성할 수 있다.,"{'word': '이클립스', 'start': 5821, 'end': 5824, 'type': 'COM'}","{'word': 'GDB', 'start': 5831, 'end': 5833, 'type': 'COM'}",no_relation
92,"자바스크립트는 본래 넷스케이프 커뮤니케이션즈 코퍼레이션의 브렌던 아이크(Brendan Eich)가 처음에는 모카(Mocha)라는 이름으로, 나중에는 라이브스크립트(LiveScript)라는 이름으로 개발하였으며, 최종적으로 자바스크립트가 되었다.","{'word': '브렌던 아이크', 'start': 179, 'end': 185, 'type': 'PER'}","{'word': '자바스크립트', 'start': 147, 'end': 152, 'type': 'COM'}",per:production
93,경쟁적인 제안에 대항하여 자바스크립트 개념을 방어하기 위해 이 기업은 프로토타입이 필요했다. 아이크는 1995년 5월 10일 안에 이를 작성했다.,"{'word': '아이크', 'start': 1601, 'end': 1603, 'type': 'PER'}","{'word': '프로토타입', 'start': 1588, 'end': 1592, 'type': 'COM'}",per:production
94,"기업의 설립자 Marc Andreessen은 HTML에 코드를 웹 페이지 마크업으로 직접 작성하면서 웹 디자이너들과 파트타입 프로그래머들이 이미지, 플러그인 등의 요소를 쉽게 조합할 수 있는 글루 언어(glue language)가 필요했다고 믿었다.","{'word': 'Marc Andreessen', 'start': 1092, 'end': 1106, 'type': 'PER'}","{'word': '설립자', 'start': 1088, 'end': 1090, 'type': 'POH'}",per:title
95,"자바스크립트가 썬 마이크로시스템즈의 자바와 구문이 유사한 점도 있지만, 이는 사실 두 언어 모두 C 언어의 기본 구문에 바탕을 뒀기 때문이고, 자바와 자바스크립트는 직접적인 연관성은 약하다.","{'word': '썬 마이크로시스템즈', 'start': 292, 'end': 301, 'type': 'ORG'}","{'word': '자바', 'start': 304, 'end': 305, 'type': 'COM'}",org:production
96,"1993년, 일리노이 대학교 어배너-섐페인의 NCSA는 최초의 대중적인 그래픽 웹 브라우저인 NCSA 모자이크를 출시하였다.","{'word': 'NCSA', 'start': 603, 'end': 606, 'type': 'ORG'}","{'word': 'NCSA 모자이크', 'start': 630, 'end': 638, 'type': 'COM'}",org:production
97,"1994년, 모자이크 커뮤니케이션스라는 이름의 회사가 캘래포니아주 마운틴 뷰에 설립되었으며 모자이크 넷스케이프를 만들기 위해 오리지널 NCSA 모자이크 개발자들을 고용하였다.","{'word': '모자이크 커뮤니케이션스', 'start': 655, 'end': 666, 'type': 'ORG'}","{'word': '모자이크 넷스케이프', 'start': 699, 'end': 708, 'type': 'COM'}",org:production
98,이름의 최종 선정에 혼란이 야기되었는데 이 언어가 자바 프로그래밍 언어에서 파생되었다는 인상을 심었으며 이러한 선택이 마케팅적인 특징을 보였고 이는 넷스케이프가 당시 인기있는 웹 프로그래밍 언어로서 자바스크립트를 내밀기 위한 것이었다.,"{'word': '넷스케이프', 'start': 1883, 'end': 1887, 'type': 'ORG'}","{'word': '자바스크립트', 'start': 1911, 'end': 1916, 'type': 'COM'}",org:production
99,웹 페이지 향상 언어로서 자바스크립트의 성공에 자극받은 마이크로소프트는 J스크립트로 알려진 호환 언어를 개발하게 되었다.,"{'word': '마이크로소프트', 'start': 2292, 'end': 2298, 'type': 'ORG'}","{'word': 'J스크립트', 'start': 2301, 'end': 2305, 'type': 'COM'}",org:production
100,이 웹 브라우저의 첫 버전인 모자이크 넷스케이프 0.9는 1994년 말에 출시되었다.,"{'word': '모자이크 넷스케이프 0.9', 'start': 862, 'end': 875, 'type': 'COM'}","{'word': '1994년 말', 'start': 878, 'end': 884, 'type': 'DAT'}",com:date_of_prod
101,경쟁적인 제안에 대항하여 자바스크립트 개념을 방어하기 위해 이 기업은 프로토타입이 필요했다. 아이크는 1995년 5월 10일 안에 이를 작성했다.,"{'word': '프로토타입', 'start': 1588, 'end': 1592, 'type': 'COM'}","{'word': '1995년 5월 10일', 'start': 1606, 'end': 1617, 'type': 'DAT'}",com:date_of_prod
102,원래 모카(Mocha)라는 이름으로 개발되었으나 이 언어는 공식적으로 라이브스크립트(LiveScript)로 불렸으며 이 당시 1995년 9월 넷스케이프 내비게이터 2.0의 베타 릴리스가 이루어졌으나 나중에 이름이 자바스크립트로 바뀌었는데 이는 12월 넷스케이프 내비게이터 2.0 베타 3에 채용되었다.,"{'word': '넷스케이프 내비게이터 2.0의 베타', 'start': 1710, 'end': 1728, 'type': 'COM'}","{'word': '1995년 9월', 'start': 1701, 'end': 1708, 'type': 'DAT'}",com:date_of_prod
103,"자바스크립트는 1995년 12월 출시된 넷스케이프 2.0B3에서부터 공개, 채택되었다.","{'word': '넷스케이프 2.0B3', 'start': 2068, 'end': 2078, 'type': 'COM'}","{'word': '1995년 12월', 'start': 2054, 'end': 2062, 'type': 'DAT'}",com:date_of_prod
104,J스크립트는 1996년 8월에 출시된 인터넷 익스플로러 브라우저 3.0부터 지원 되기 시작했다.,"{'word': '인터넷 익스플로러 브라우저 3.0', 'start': 2350, 'end': 2367, 'type': 'COM'}","{'word': '1996년 8월', 'start': 2336, 'end': 2343, 'type': 'DAT'}",com:date_of_prod
105,또한 Node.js와 같은 런타임 환경과 같이 서버 프로그래밍에도 사용되고 있다.,"{'word': '서버 프로그래밍', 'start': 127, 'end': 134, 'type': 'COM'}","{'word': 'Node.js', 'start': 104, 'end': 110, 'type': 'COM'}",com:sub_concept
106,"한편 자바스크립트에서 사용되는 기초적인 문법의 개념으로는 속성과 메소드를 갖는 객체(오브젝트) 개념이 있으며, 변수 선언, 함수 정의, 연산자 그리고 제어문등을 이 프로그래밍 언어의 주요 개념으로 언급할수 있을뿐만아니라 이 언어가 속한 객체 지향 프로그래밍언어(OOP)의 공통적인 주요 개념이기도 한다.","{'word': '객체', 'start': 4348, 'end': 4349, 'type': 'COM'}","{'word': '메소드', 'start': 4340, 'end': 4342, 'type': 'COM'}",com:sub_concept
107,"한편 자바스크립트에서 사용되는 기초적인 문법의 개념으로는 속성과 메소드를 갖는 객체(오브젝트) 개념이 있으며, 변수 선언, 함수 정의, 연산자 그리고 제어문등을 이 프로그래밍 언어의 주요 개념으로 언급할수 있을뿐만아니라 이 언어가 속한 객체 지향 프로그래밍언어(OOP)의 공통적인 주요 개념이기도 한다.","{'word': '객체', 'start': 4348, 'end': 4349, 'type': 'COM'}","{'word': '속성', 'start': 4336, 'end': 4337, 'type': 'COM'}",com:sub_concept
108,"한편 자바스크립트에서 사용되는 기초적인 문법의 개념으로는 속성과 메소드를 갖는 객체(오브젝트) 개념이 있으며, 변수 선언, 함수 정의, 연산자 그리고 제어문등을 이 프로그래밍 언어의 주요 개념으로 언급할수 있을뿐만아니라 이 언어가 속한 객체 지향 프로그래밍언어(OOP)의 공통적인 주요 개념이기도 한다.","{'word': '객체 지향 프로그래밍언어(OOP)', 'start': 4436, 'end': 4453, 'type': 'COM'}","{'word': '자바스크립트', 'start': 4307, 'end': 4312, 'type': 'COM'}",com:sub_concept
109,"자바스크립트는 본래 넷스케이프 커뮤니케이션즈 코퍼레이션의 브렌던 아이크(Brendan Eich)가 처음에는 모카(Mocha)라는 이름으로, 나중에는 라이브스크립트(LiveScript)라는 이름으로 개발하였으며, 최종적으로 자바스크립트가 되었다.","{'word': '자바스크립트', 'start': 271, 'end': 276, 'type': 'COM'}","{'word': '모카(Mocha)', 'start': 207, 'end': 215, 'type': 'COM'}",com:alter_names
110,"자바스크립트는 본래 넷스케이프 커뮤니케이션즈 코퍼레이션의 브렌던 아이크(Brendan Eich)가 처음에는 모카(Mocha)라는 이름으로, 나중에는 라이브스크립트(LiveScript)라는 이름으로 개발하였으며, 최종적으로 자바스크립트가 되었다.","{'word': '자바스크립트', 'start': 271, 'end': 276, 'type': 'COM'}","{'word': '라이브스크립트(LiveScript)', 'start': 230, 'end': 248, 'type': 'COM'}",com:alter_names
111,자바스크립트는 ECMA스크립트(ECMAScript)의 표준 사양을 가장 잘 구현한 언어로 인정받고 있으며 ECMAScript 5 (ES5) 까지는 대부분의 브라우저에서 기본적으로 지원되었으나 ECMAScript 6 이후부터는 브라우저 호환성을 위해 트랜스파일러로 컴파일된다.,"{'word': 'ECMA스크립트', 'start': 432, 'end': 439, 'type': 'COM'}","{'word': 'ECMAScript', 'start': 441, 'end': 450, 'type': 'COM'}",com:alter_names
112,"이 웹 브라우저의 첫 버전인 모자이크 넷스케이프 0.9는 1994년 말에 출시되었다. 4개월 후 브라우저 시장의 3/4를 잠식하면서 1990년대에 주된 웹 브라우저가 되었다. NCSA의 상표 소유권 문제를 회피하고자 이 브라우저는 같은 해에 ""넷스케이프 내비게이터""로 이름을 바꾸었으며 이 기업은 ""넷스케이프 커뮤니케이션스""라는 이름을 취하였다.","{'word': '모자이크 넷스케이프 0.9', 'start': 862, 'end': 875, 'type': 'COM'}","{'word': '넷스케이프 내비게이터', 'start': 982, 'end': 992, 'type': 'COM'}",com:alter_names
113,라이브스크립트의 이름이 자바스크립트로 변경된 것은 대략 넷스케이프가 자사의 넷스케이프 내비게이터 웹 브라우저에 자바 기술에 대한 지원을 포함하기 시작할 즈음이다.,"{'word': '라이브스크립트', 'start': 1955, 'end': 1961, 'type': 'COM'}","{'word': '자바스크립트', 'start': 1968, 'end': 1973, 'type': 'COM'}",com:alter_names
114,"""자바스크립트""(JavaScript)는 이제 오라클의 상표이다.","{'word': '자바스크립트', 'start': 2593, 'end': 2598, 'type': 'COM'}","{'word': 'JavaScript', 'start': 2601, 'end': 2610, 'type': 'COM'}",com:alter_names
115,"자바스크립트가 썬 마이크로시스템즈의 자바와 구문이 유사한 점도 있지만, 이는 사실 두 언어 모두 C 언어의 기본 구문에 바탕을 뒀기 때문이고, 자바와 자바스크립트는 직접적인 연관성은 약하다.","{'word': '자바스크립트', 'start': 284, 'end': 289, 'type': 'COM'}","{'word': 'C 언어', 'start': 338, 'end': 341, 'type': 'COM'}",com:prior_tech
116,"자바스크립트가 썬 마이크로시스템즈의 자바와 구문이 유사한 점도 있지만, 이는 사실 두 언어 모두 C 언어의 기본 구문에 바탕을 뒀기 때문이고, 자바와 자바스크립트는 직접적인 연관성은 약하다.","{'word': '자바', 'start': 304, 'end': 305, 'type': 'COM'}","{'word': 'C 언어', 'start': 338, 'end': 341, 'type': 'COM'}",com:prior_tech
117,자바스크립트는 ECMA스크립트(ECMAScript)의 표준 사양을 가장 잘 구현한 언어로 인정받고 있으며 ECMAScript 5 (ES5) 까지는 대부분의 브라우저에서 기본적으로 지원되었으나 ECMAScript 6 이후부터는 브라우저 호환성을 위해 트랜스파일러로 컴파일된다.,"{'word': 'ECMAScript 6', 'start': 531, 'end': 542, 'type': 'COM'}","{'word': 'ECMAScript 5', 'start': 483, 'end': 494, 'type': 'COM'}",com:prior_tech
118,이것은 자바와 자바스크립트 간에는 구문이 유사하다는 점(양쪽 모두 C에 바탕을 두었기 때문에) 외에는 실제 관련성이 없었기 때문이다.,"{'word': '자바', 'start': 2126, 'end': 2127, 'type': 'COM'}","{'word': 'C', 'start': 2159, 'end': 2159, 'type': 'COM'}",com:prior_tech
119,이것은 자바와 자바스크립트 간에는 구문이 유사하다는 점(양쪽 모두 C에 바탕을 두었기 때문에) 외에는 실제 관련성이 없었기 때문이다.,"{'word': '자바스크립트', 'start': 2130, 'end': 2135, 'type': 'COM'}","{'word': 'C', 'start': 2159, 'end': 2159, 'type': 'COM'}",com:prior_tech
120,"자바스크립트와 함께 자주 쓰이는 용어인 DOM은 사실 ECMA스크립트 표준의 일부가 아니며, 그것은 자체로 하나의 표준이고 XML에 기반을 둔다.","{'word': 'DOM', 'start': 2532, 'end': 2534, 'type': 'COM'}","{'word': 'XML', 'start': 2579, 'end': 2581, 'type': 'COM'}",com:prior_tech
121,"1995년, 넷스케이프 커뮤니케이션스는 스킴 프로그래밍 언어를 넷스케이프 내비게이터에 임베디드하기 위해 브렌던 아이크를 영입하였다.","{'word': '브렌던 아이크', 'start': 1282, 'end': 1288, 'type': 'PER'}","{'word': '넷스케이프 커뮤니케이션스', 'start': 1231, 'end': 1243, 'type': 'ORG'}",no_relation
122,"기업의 설립자 Marc Andreessen은 HTML에 코드를 웹 페이지 마크업으로 직접 작성하면서 웹 디자이너들과 파트타입 프로그래머들이 이미지, 플러그인 등의 요소를 쉽게 조합할 수 있는 글루 언어(glue language)가 필요했다고 믿었다.","{'word': '웹 디자이너', 'start': 1140, 'end': 1145, 'type': 'PER'}","{'word': '플러그인', 'start': 1167, 'end': 1170, 'type': 'COM'}",no_relation
123,"그러나 NCSA 모자이크와 코드는 의도적으로 공유하지 않았다. 이 기업의 브라우저의 내부 코드명은 모질라였으며 이는 ""Mosaic and Godzilla""에서 비롯된 용어이다..","{'word': 'NCSA 모자이크', 'start': 750, 'end': 758, 'type': 'ORG'}","{'word': '""Mosaic and Godzilla""', 'start': 811, 'end': 831, 'type': 'POH'}",no_relation
124,시작 전에 넷스케이프 커뮤니케이션스는 넷스케이프 내비게이터 썬의 더 정적인 프로그래밍 언어인 자바를 포함시키기 위해 썬 마이크로시스템즈와 협업했으며 이는 사용자에게 웹 기술 및 플랫폼을 채택시키려는 마이크로소프트와 경쟁하기 위해서였다.,"{'word': '넷스케이프 커뮤니케이션스', 'start': 1304, 'end': 1316, 'type': 'ORG'}","{'word': '마이크로소프트', 'start': 1409, 'end': 1415, 'type': 'ORG'}",no_relation
125,"넷스케이프 커뮤니케이션스가 발명, 구현한 기술 및 모질라 재단과 같은 독립 기관의 라이선스 하에 사용된다.","{'word': '넷스케이프 커뮤니케이션스', 'start': 2628, 'end': 2640, 'type': 'ORG'}","{'word': '모질라', 'start': 2656, 'end': 2658, 'type': 'ORG'}",no_relation
126,"넷스케이프 커뮤니케이션스는 이때 자신들이 만들기 바랐던 스크립트 언어가 자바를 구현할 것이고 비슷한 문법을 채용하는 것이 좋겠다고 생각했으며 펄, 파이썬, Tcl, 스킴 등 기타 언어를 채택하는 것을 배제하였다.","{'word': '넷스케이프 커뮤니케이션스', 'start': 1430, 'end': 1442, 'type': 'ORG'}","{'word': '파이썬', 'start': 1512, 'end': 1514, 'type': 'COM'}",no_relation
127,"IE 브라우저에서의 자바스크립트 사용은 실제로는 J스크립트의 사용을 의미하는 것이었다. 이에 대한 표준화 요구는 ECMA스크립트에 대한 ECMA-262 표준의 기반이 되었으며, 1996년 11월 이후 세 번째 판까지 출판됐다.","{'word': '자바스크립트', 'start': 2394, 'end': 2399, 'type': 'COM'}","{'word': 'ECMA-262', 'start': 2459, 'end': 2466, 'type': 'POH'}",no_relation
128,"여기서처럼 HTML과 자바스크립트 간에는 광범위한 호환성을 보장하는 동전의 양면성 같은 구조를 엿볼 수 있는데, 이것이 가능한 것은 DOM 때문이라고 말할 수 있다.","{'word': 'HTML', 'start': 4112, 'end': 4115, 'type': 'COM'}","{'word': '호환성', 'start': 4134, 'end': 4136, 'type': 'POH'}",no_relation
129,한편 자바스크립트는 HTML과의 연동관계에서 HTML의 로딩시점 또는 초기화와 관련된 즉시 실행 함수(Immediately invoked function expression)를 제공한다.,"{'word': '자바스크립트', 'start': 4202, 'end': 4207, 'type': 'COM'}","{'word': '로딩시점', 'start': 4230, 'end': 4233, 'type': 'POH'}",no_relation
130,4개월 후 브라우저 시장의 3/4를 잠식하면서 1990년대에 주된 웹 브라우저가 되었다.,"{'word': '브라우저', 'start': 900, 'end': 903, 'type': 'COM'}","{'word': '1990년대', 'start': 920, 'end': 925, 'type': 'DAT'}",no_relation
131,자바스크립트()는 객체 기반의 스크립트 프로그래밍 언어이다.,"{'word': '자바스크립트', 'start': 0, 'end': 5, 'type': 'COM'}","{'word': '프로그래밍', 'start': 22, 'end': 26, 'type': 'COM'}",no_relation
132,"이 언어는 웹 브라우저 내에서 주로 사용하며, 다른 응용 프로그램의 내장 객체에도 접근할 수 있는 기능을 가지고 있다.","{'word': '응용 프로그램', 'start': 63, 'end': 69, 'type': 'COM'}","{'word': '웹 브라우저', 'start': 40, 'end': 45, 'type': 'COM'}",no_relation
133,&lt;p&gt;브라우저가 자바스크립트 기능을 지원하지 않거나 자바스크립트 기능이 꺼져 있습니다.,"{'word': '브라우저', 'start': 3007, 'end': 3010, 'type': 'COM'}","{'word': '자바스크립트', 'start': 3033, 'end': 3038, 'type': 'COM'}",no_relation
134,이름과 구문 외에는 자바보다 셀프나 스킴과 유사성이 많다.,"{'word': '셀프', 'start': 407, 'end': 408, 'type': 'COM'}","{'word': '스킴', 'start': 411, 'end': 412, 'type': 'COM'}",com:similar_tech
135,논리학자 해스켈 커리에서 이름을 따왔다.,"{'word': '해스켈 커리', 'start': 39, 'end': 44, 'type': 'PER'}","{'word': '논리학자', 'start': 34, 'end': 37, 'type': 'POH'}",per:title
136,위원회의 노력은 1997년 말까지 다양한 설계안으로 이어져 마침내 ‘하스켈 98’이라는 성과가 나왔다.,"{'word': '위원회', 'start': 363, 'end': 365, 'type': 'ORG'}","{'word': '‘하스켈 98’', 'start': 400, 'end': 407, 'type': 'COM'}",org:production
137,매사추세츠 공과대학교와 글래스고 대학교가 개발한 버전은 병렬화가 가능하기 때문에 ‘병렬 하스켈’이라고 불린다.,"{'word': '매사추세츠 공과대학교와 글래스고 대학교', 'start': 1404, 'end': 1424, 'type': 'ORG'}","{'word': '‘병렬 하스켈’', 'start': 1449, 'end': 1456, 'type': 'COM'}",org:production
138,1985년에 개발된 미란다가 하스켈의 전신이라고 할 수 있다.,"{'word': '미란다', 'start': 137, 'end': 139, 'type': 'COM'}","{'word': '1985년', 'start': 126, 'end': 130, 'type': 'DAT'}",com:date_of_prod
139,하스켈의 첫 버전(‘하스켈 1.0’)은 1990년에 완성되었다.,"{'word': '하스켈의 첫 버전', 'start': 327, 'end': 335, 'type': 'COM'}","{'word': '1990년', 'start': 349, 'end': 353, 'type': 'DAT'}",com:date_of_prod
140,하스켈 98 언어 표준은 1999년 1월 〈하스켈 98 보고서〉()라는 이름으로 정식 공개되었다.,"{'word': '하스켈 98 언어 표준', 'start': 586, 'end': 597, 'type': 'COM'}","{'word': '1999년 1월', 'start': 600, 'end': 607, 'type': 'DAT'}",com:date_of_prod
141,그리고 2003년 1월에는 〈하스켈 98 언어와 라이브러리: 개정 보고서〉()라는 이름으로 개정판이 나왔다.,"{'word': '〈하스켈 98 언어와 라이브러리: 개정 보고서〉', 'start': 656, 'end': 681, 'type': 'COM'}","{'word': '2003년 1월', 'start': 645, 'end': 652, 'type': 'DAT'}",com:date_of_prod
142,"새로운 표준은 비공식적으로 ‘하스켈 프라임’()이라는 이름으로 불렸으며, 2009년 11월 새로운 표준의 첫 번째 판인 하스켈 2010이 발표되었다.","{'word': '하스켈 2010', 'start': 899, 'end': 906, 'type': 'COM'}","{'word': '2009년 11월', 'start': 873, 'end': 881, 'type': 'DAT'}",com:date_of_prod
143,"하스켈 98은 교육용이나 확장을 덧붙이는 토대로 쓸 수 있는 안정적이고, 작고, 이식성 좋은 언어 표준을 의도한 결과물로서 표준 라이브러리가 포함되어 있었다.","{'word': '하스켈 98', 'start': 421, 'end': 426, 'type': 'COM'}","{'word': '표준 라이브러리', 'start': 490, 'end': 497, 'type': 'COM'}",com:sub_concept
144,"수학의 한 특이 분야인 범주론의 개념들, 특히 함수의 개념의 추상화된 형태인 사상과 모나드(monad)를 차용하여 가져온 언어인데, 이를 통해 함수를 대상으로써 다룸에 있어서 명확성을 가질 수 있다.","{'word': '수학', 'start': 1203, 'end': 1204, 'type': 'COM'}","{'word': '범주론', 'start': 1216, 'end': 1218, 'type': 'COM'}",com:sub_concept
145,하스켈 또는 해스켈( )은 순수 함수형 프로그래밍 언어이다.,"{'word': '하스켈', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': '해스켈', 'start': 7, 'end': 9, 'type': 'COM'}",com:alter_names
146,"서브버전과 비슷한 버전 관리 체계인 다크스()가 하스켈로 만들어지기도 했고, 린스파이어는 시스템 도구 개발을 위한 언어로 하스켈을 선택했다.","{'word': '다크스', 'start': 1884, 'end': 1886, 'type': 'COM'}","{'word': '하스켈', 'start': 1891, 'end': 1893, 'type': 'COM'}",com:made_of
147,1985년에 개발된 미란다가 하스켈의 전신이라고 할 수 있다.,"{'word': '하스켈', 'start': 142, 'end': 144, 'type': 'COM'}","{'word': '미란다', 'start': 137, 'end': 139, 'type': 'COM'}",com:prior_tech
148,또한 위원회는 하스켈 98의 확장 기능과 더불어 하스켈 98에 실험적인 기능을 덧붙이거나 합친 변형이 만들어지는 것을 열렬히 환영했다.,"{'word': '위원회', 'start': 513, 'end': 515, 'type': 'ORG'}","{'word': '변형', 'start': 563, 'end': 564, 'type': 'POH'}",no_relation
149,"그러므로 본디 ‘해스켈’로 불러야 하지만, 대한민국에서는 ‘하스켈’이 프로그래밍 언어를 가리키는 말로 널리 쓰여 굳어졌다.","{'word': '‘해스켈’', 'start': 65, 'end': 69, 'type': 'COM'}","{'word': '대한민국', 'start': 81, 'end': 84, 'type': 'POH'}",no_relation
150,"하스켈 2010은 다른 프로그래밍 언어와 호환할 수 있는 인터페이스인 외부 함수 인터페이스를 지원하고, 일부 문법이 변경되었으며, ""n""+""k"" 패턴이라 불리는 문법 형식이 금지되었다.","{'word': '인터페이스', 'start': 961, 'end': 965, 'type': 'COM'}","{'word': '패턴', 'start': 997, 'end': 998, 'type': 'POH'}",no_relation
151,이 언어와 하스켈의 가장 큰 차이점은 입출력을 위해 모나드 대신에 유일형을 사용한다는 것이다.,"{'word': '하스켈', 'start': 1675, 'end': 1677, 'type': 'COM'}","{'word': '유일형', 'start': 1706, 'end': 1708, 'type': 'POH'}",no_relation
152,"하스켈 사용자의 수는 상대적으로 적은 편이지만, 그 강력함 때문에 몇몇 프로젝트를 쉽게 해주었다.","{'word': '하스켈', 'start': 1722, 'end': 1724, 'type': 'COM'}","{'word': '프로젝트', 'start': 1762, 'end': 1765, 'type': 'POH'}",no_relation
153,"1987년 오리건주 포틀랜드에서 열린 ‘함수형 프로그래밍 언어와 컴퓨터 구조에 관한 총회’()에서 있었던 회의에서, 난립하고 있는 함수형 언어들을 통합 정리해서 훗날 언어 설계의 기반이 될 수 있는 일반적인 순수 함수형 프로그래밍 언어를 만들자는 데에 참가자들의 뜻이 모였고 위원회가 발족되었다.","{'word': '함수형 언어', 'start': 234, 'end': 239, 'type': 'COM'}","{'word': '1987년', 'start': 161, 'end': 165, 'type': 'DAT'}",no_relation
154,2002년을 기준으로 하스켈은 느긋한 계산법을 쓰는 함수형 언어 가운데 가장 활발한 연구가 이루어지는 언어로 볼 수 있다.,"{'word': '하스켈', 'start': 1327, 'end': 1329, 'type': 'COM'}","{'word': '2002년', 'start': 1315, 'end': 1319, 'type': 'DAT'}",no_relation
155,"퍼그스()는 펄 6의 컴파일러와 인터프리터를 구현한 것인데, 개발 기간은 지극히 짧았지만 만들어진 지 몇 달도 채 되지 않아 꽤 쓸 만하다는 평을 받았다.","{'word': '퍼그스', 'start': 1777, 'end': 1779, 'type': 'COM'}","{'word': '몇 달', 'start': 1834, 'end': 1836, 'type': 'DAT'}",no_relation
156,하스켈을 실제 컴퓨터로 쓸 수 있게 구현한 ‘글래스고 하스켈 컴파일러’와 ‘허그스’가 사실상의 표준 역할을 하면서 하스켈은 지금도 끊임없이 발전하고 있다.,"{'word': '컴파일러', 'start': 736, 'end': 739, 'type': 'COM'}","{'word': '하스켈', 'start': 766, 'end': 768, 'type': 'COM'}",no_relation
157,"하스켈의 특징으로는 패턴 맞춤, 커링, 조건제시법, 가드, 연산자 정의 등을 들 수 있다.","{'word': '커링', 'start': 1038, 'end': 1039, 'type': 'COM'}","{'word': '가드', 'start': 1049, 'end': 1050, 'type': 'COM'}",no_relation
158,"이후 병렬화와 분산 처리를 더욱 강화한 ‘분산 하스켈’과 에덴 프로그래밍 언어가 나왔고, 느긋한 계산법 대신 적극적인 계산법을 쓰는 ‘적극적 하스켈’이 있으며 하스켈에 객체 지향 개념을 도입한 버전으로 ‘하스켈++’, ‘오하스켈’, 몬드리안 프로그래밍 언어 등등이 있다.","{'word': '‘분산 하스켈’', 'start': 1488, 'end': 1495, 'type': 'COM'}","{'word': '‘적극적 하스켈’', 'start': 1540, 'end': 1548, 'type': 'COM'}",no_relation
159,하스켈과 비슷한 언어로 그래픽 사용자 인터페이스 개발에 새로운 방법을 도입한 클린이 있다.,"{'word': '하스켈', 'start': 1618, 'end': 1620, 'type': 'COM'}","{'word': '클린', 'start': 1661, 'end': 1662, 'type': 'COM'}",com:similar_tech
160,"서브버전과 비슷한 버전 관리 체계인 다크스()가 하스켈로 만들어지기도 했고, 린스파이어는 시스템 도구 개발을 위한 언어로 하스켈을 선택했다.","{'word': '서브버전', 'start': 1864, 'end': 1867, 'type': 'COM'}","{'word': '다크스', 'start': 1884, 'end': 1886, 'type': 'COM'}",com:similar_tech
161,"C#( 또는 C 샵)는 마이크로소프트에서 개발한 객체 지향 프로그래밍 언어로, 닷넷 프레임워크의 한 부분으로 만들어졌으며 나중에 ECMA (ECMA-334)와 ISO (ISO/IEC/23270)의 표준으로 자리잡았다.","{'word': '마이크로소프트', 'start': 13, 'end': 19, 'type': 'ORG'}","{'word': 'C#', 'start': 0, 'end': 1, 'type': 'COM'}",org:production
162,"1999년 1월, 아네르스 하일스베르가 이끄는 팀이 새로운 언어인 Cool(C-like Object Oriented Language)을 개발했다.","{'word': '아네르스 하일스베르가 이끄는 팀', 'start': 1333, 'end': 1349, 'type': 'ORG'}","{'word': 'Cool', 'start': 1360, 'end': 1363, 'type': 'COM'}",org:production
163,"1999년 1월, 아네르스 하일스베르가 이끄는 팀이 새로운 언어인 Cool(C-like Object Oriented Language)을 개발했다.","{'word': 'Cool', 'start': 1360, 'end': 1363, 'type': 'COM'}","{'word': '1999년 1월', 'start': 1323, 'end': 1330, 'type': 'DAT'}",com:date_of_prod
164,2000년 7월 PDC에서 닷넷 프로젝트가 발표될 때 즈음 Cool의 이름은 C#으로 정해졌고 클래스 라이브러리와 ASP.NET 런타임은 C#으로 옮겨갔다.,"{'word': '닷넷 프로젝트', 'start': 1479, 'end': 1485, 'type': 'COM'}","{'word': '2000년 7월', 'start': 1464, 'end': 1471, 'type': 'DAT'}",com:date_of_prod
165,"즉, 모든 인스턴스나 메서드는 반드시 특정 클래스의 멤버로 소속되어야 한다.","{'word': '클래스', 'start': 3205, 'end': 3207, 'type': 'COM'}","{'word': '인스턴스', 'start': 3187, 'end': 3190, 'type': 'COM'}",com:sub_concept
166,"즉, 모든 인스턴스나 메서드는 반드시 특정 클래스의 멤버로 소속되어야 한다.","{'word': '클래스', 'start': 3205, 'end': 3207, 'type': 'COM'}","{'word': '메서드', 'start': 3193, 'end': 3195, 'type': 'COM'}",com:sub_concept
167,확장 메서드는 정적 클래스의 멤버로 있어야 하며 이 때에도 대상 클래스의 private 멤버에는 접근 할 수 없다.,"{'word': '정적 클래스', 'start': 3268, 'end': 3273, 'type': 'COM'}","{'word': '확장 메서드', 'start': 3260, 'end': 3265, 'type': 'COM'}",com:sub_concept
168,"C#( 또는 C 샵)는 마이크로소프트에서 개발한 객체 지향 프로그래밍 언어로, 닷넷 프레임워크의 한 부분으로 만들어졌으며 나중에 ECMA (ECMA-334)와 ISO (ISO/IEC/23270)의 표준으로 자리잡았다.","{'word': 'C#', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': 'C 샵', 'start': 7, 'end': 9, 'type': 'COM'}",com:alter_names
169,2000년 7월 PDC에서 닷넷 프로젝트가 발표될 때 즈음 Cool의 이름은 C#으로 정해졌고 클래스 라이브러리와 ASP.NET 런타임은 C#으로 옮겨갔다.,"{'word': 'Cool', 'start': 1497, 'end': 1500, 'type': 'COM'}","{'word': 'C#', 'start': 1507, 'end': 1508, 'type': 'COM'}",com:alter_names
170,C#은 ISO 소위원회 JTC 1/SC 22에 ISO/IEC 23270:2003으로 제출되었으나 철회 후 ISO/IEC 23270:2006으로 등록되었다.,"{'word': 'C#', 'start': 1552, 'end': 1553, 'type': 'COM'}","{'word': 'ISO/IEC 23270:2006', 'start': 1611, 'end': 1628, 'type': 'COM'}",com:alter_names
171,C++ 언어와 비교할 때 C#은 다음과 같은 점에서 단순화되거나 확장되었다.,"{'word': 'C#', 'start': 1990, 'end': 1991, 'type': 'COM'}","{'word': 'C++', 'start': 1976, 'end': 1978, 'type': 'COM'}",com:prior_tech
172,마이크로소프트는 언어의 최종 이름을 Cool로 유지할지도 고려해봤지만 상표 문제로 인해 이뤄지지 않았다.,"{'word': '마이크로소프트', 'start': 1405, 'end': 1411, 'type': 'ORG'}","{'word': '상표', 'start': 1444, 'end': 1445, 'type': 'POH'}",no_relation
173,"그러나 광고나 패키지 포장 등 가능한 경우, 마이크로소프트에서는 의도한 대로 올림표를 사용한다.","{'word': '마이크로소프트', 'start': 1907, 'end': 1913, 'type': 'ORG'}","{'word': '올림표', 'start': 1925, 'end': 1927, 'type': 'POH'}",no_relation
174,"마찬가지로 올림표는 네 개의 ""+"" 기호와 비슷하므로 C++를 한번 더 증가시켰다는 뜻도 지닌다.","{'word': 'C++', 'start': 1759, 'end': 1761, 'type': 'COM'}","{'word': '올림표', 'start': 1735, 'end': 1737, 'type': 'POH'}",no_relation
175,"또한 C/C++에는 없던 #region, #endregion 지시자가 새로 추가되었다.","{'word': 'C/C++', 'start': 2981, 'end': 2985, 'type': 'COM'}","{'word': '지시자', 'start': 3012, 'end': 3014, 'type': 'POH'}",no_relation
176,이것은 Java 와 다르고 C 와 C++ 처럼 (string[] args) 가 붙지 않으며 보통 빈칸이다.,"{'word': 'Java', 'start': 395, 'end': 398, 'type': 'COM'}","{'word': 'C++', 'start': 410, 'end': 412, 'type': 'COM'}",no_relation
177,"C#은 닷넷 프로그램이 동작하는 닷넷 플랫폼을 가장 직접적으로 반영하고, 또한 닷넷 플랫폼에 강하게 의존하는 프로그래밍 언어이다.","{'word': 'C#', 'start': 859, 'end': 860, 'type': 'COM'}","{'word': '플랫폼', 'start': 906, 'end': 908, 'type': 'COM'}",no_relation
178,C#은 그 문법적인 특성이 자바와 상당히 유사하며 C#을 통하여 다룰 수 있는 닷넷 플랫폼의 기술들조차도 자바를 염두에 둔 것이 많아서 자바와 가장 많이 비교되고 있다. 하지만 C#은 자바와 달리 불안전 코드(unsafe code)와 같은 기술을 통하여 플랫폼 간 상호 운용성에 상당히 많은 노력을 기울이고 있다.,"{'word': '닷넷 플랫폼', 'start': 976, 'end': 981, 'type': 'COM'}","{'word': '자바', 'start': 947, 'end': 948, 'type': 'COM'}",no_relation
179,C#은 그 문법적인 특성이 자바와 상당히 유사하며 C#을 통하여 다룰 수 있는 닷넷 플랫폼의 기술들조차도 자바를 염두에 둔 것이 많아서 자바와 가장 많이 비교되고 있다. 하지만 C#은 자바와 달리 불안전 코드(unsafe code)와 같은 기술을 통하여 플랫폼 간 상호 운용성에 상당히 많은 노력을 기울이고 있다.,"{'word': '자바', 'start': 1035, 'end': 1036, 'type': 'COM'}","{'word': '불안전 코드', 'start': 1042, 'end': 1047, 'type': 'COM'}",no_relation
180,"C#의 기본 자료형은 닷넷의 객체 모델을 따르고 있고, 런타임 차원에서 쓰레기 수집(garbage collection)이 되며 또한 클래스, 인터페이스, 위임, 예외와 같이 객체 지향 언어로서 가져야 할 모든 요소들이 포함되어 있다.","{'word': '닷넷', 'start': 1120, 'end': 1121, 'type': 'COM'}","{'word': '클래스', 'start': 1182, 'end': 1184, 'type': 'COM'}",no_relation
181,닷넷 프레임워크를 개발하던 시절 클래스 라이브러리는 SMC(Simple Managed C)라 불리는 관리 코드(managed code)를 사용했었다.,"{'word': '프레임워크', 'start': 1242, 'end': 1246, 'type': 'COM'}","{'word': '라이브러리', 'start': 1261, 'end': 1265, 'type': 'COM'}",no_relation
182,C++에서 포인터는 특정한 형식의 인스턴스 또는 주소값을 가리키기 위한 목적으로 할당되는 주소값을 기억하기 위한 변수로 취급되지만,"{'word': '포인터', 'start': 2072, 'end': 2074, 'type': 'COM'}","{'word': '인스턴스', 'start': 2085, 'end': 2088, 'type': 'COM'}",no_relation
183,그래서 C++의 포인터와 같은 쓰임새를 C#으로 이식할 수 없는 경우가 상당히 많다.,"{'word': 'C++', 'start': 2192, 'end': 2194, 'type': 'COM'}","{'word': 'C#', 'start': 2210, 'end': 2211, 'type': 'COM'}",no_relation
184,C#에서 리플렉션으로 확장하여 사용하는 것이 가능하다. 리플렉션은 자바 언어의 리플렉션과 같은 개념이다.,"{'word': 'C#', 'start': 2792, 'end': 2793, 'type': 'COM'}","{'word': '자바', 'start': 2829, 'end': 2830, 'type': 'COM'}",no_relation
185,C/C++에서 매크로 상수나 매크로 함수 등을 위해 사용되던 #define이 C#에서는 매우 제한적인 용도로 사용된다.,"{'word': 'C#', 'start': 2954, 'end': 2955, 'type': 'COM'}","{'word': '매크로 함수', 'start': 2927, 'end': 2932, 'type': 'COM'}",no_relation
186,C++와 자바의 문법과 비슷한 문법을 가지고 있다.,"{'word': 'C++', 'start': 122, 'end': 124, 'type': 'COM'}","{'word': '자바', 'start': 127, 'end': 128, 'type': 'COM'}",com:similar_tech
187,"C#의 기본 문법은 C, C++, 자바 등 C 스타일 언어와 유사하다.","{'word': 'C#', 'start': 1936, 'end': 1937, 'type': 'COM'}","{'word': 'C 스타일 언어', 'start': 1960, 'end': 1967, 'type': 'COM'}",com:similar_tech
188,애플리케이션 프레임워크(application Framework)는 소프트웨어 개발자가 응용 소프트웨어의 표준 구조를 구현하기 위해 사용하는 소프트웨어 프레임워크로 구성된다.,"{'word': '애플리케이션 프레임워크', 'start': 0, 'end': 11, 'type': 'COM'}","{'word': '소프트웨어 프레임워크', 'start': 78, 'end': 88, 'type': 'COM'}",com:made_of
189,애플리케이션 프레임워크(application Framework)는 소프트웨어 개발자가 응용 소프트웨어의 표준 구조를 구현하기 위해 사용하는 소프트웨어 프레임워크로 구성된다.,"{'word': '소프트웨어 개발자', 'start': 37, 'end': 45, 'type': 'PER'}","{'word': '프레임워크', 'start': 84, 'end': 88, 'type': 'COM'}",no_relation
190,재사용할 수 있는 수많은 코드를 프레임워크로 통합함으로써 개발자가 새로운 애플리케이션을 위한 표준 코드를 다시 작성하지 않아도 같이 사용된다.,"{'word': '개발자', 'start': 209, 'end': 211, 'type': 'PER'}","{'word': '프레임워크', 'start': 195, 'end': 199, 'type': 'COM'}",no_relation
191,그 까닭은 GUI 응용 프로그램의 기본 구조의 표준화를 촉진하는 경향이 있기 때문이다.,"{'word': 'GUI', 'start': 309, 'end': 311, 'type': 'COM'}","{'word': '표준화', 'start': 329, 'end': 331, 'type': 'POH'}",no_relation
192,"즉, 프로그래밍에서 특정 운영 체제를 위한 응용 프로그램 표준 구조를 구현하는 클래스와 라이브러리 모임이다. 간단하게 프레임워크라고도 부른다.","{'word': '프로그래밍', 'start': 100, 'end': 104, 'type': 'COM'}","{'word': '프레임워크', 'start': 163, 'end': 167, 'type': 'COM'}",no_relation
193,응용 프로그램의 기본 코드 구조가 명백하므로 표준 프레임워크를 사용하면 자동으로 GUI 툴을 만드게 된다. 프레임워크의 구현은 객체 지향 프로그래밍 기법이 사용되고 있는 응용 프로그램 고유의 클래스가 프레임워크의 기존 클래스를 상속할 수 있다.,"{'word': 'GUI', 'start': 397, 'end': 399, 'type': 'COM'}","{'word': '클래스', 'start': 474, 'end': 476, 'type': 'COM'}",no_relation
194,"절차적 프로그래밍(節次的 프로그래밍, )은 절차지향 프로그래밍 혹은 절차지향적 프로그래밍이라고도 불리는 프로그래밍 패러다임의 일종으로서, 때때로 명령형 프로그래밍과 동의어로 쓰이기도 하지만, 프로시저 호출의 개념을 바탕으로 하고 있는 프로그래밍 패러다임을 의미하기도 한다.","{'word': '프로그래밍 패러다임', 'start': 58, 'end': 67, 'type': 'COM'}","{'word': '절차적 프로그래밍', 'start': 0, 'end': 8, 'type': 'COM'}",com:sub_concept
195,알골과 같은 언어가 절차적 프로그래밍 언어의 표준적인 예이다.,"{'word': '절차적 프로그래밍 언어', 'start': 1562, 'end': 1573, 'type': 'COM'}","{'word': '알골', 'start': 1551, 'end': 1552, 'type': 'COM'}",com:sub_concept
196,"알골과 같은 언어가 절차적 프로그래밍 언어의 표준적인 예이다. 그 밖에 포트란, PL/I, 모듈라-2, 에이다, 베이직, C 등이 있다.","{'word': '절차적 프로그래밍 언어', 'start': 1562, 'end': 1573, 'type': 'COM'}","{'word': '포트란', 'start': 1591, 'end': 1593, 'type': 'COM'}",com:sub_concept
197,"알골과 같은 언어가 절차적 프로그래밍 언어의 표준적인 예이다. 그 밖에 포트란, PL/I, 모듈라-2, 에이다, 베이직, C 등이 있다.","{'word': '절차적 프로그래밍 언어', 'start': 1562, 'end': 1573, 'type': 'COM'}","{'word': '에이다', 'start': 1609, 'end': 1611, 'type': 'COM'}",com:sub_concept
198,"절차적 프로그래밍(節次的 프로그래밍, )은 절차지향 프로그래밍 혹은 절차지향적 프로그래밍이라고도 불리는 프로그래밍 패러다임의 일종으로서, 때때로 명령형 프로그래밍과 동의어로 쓰이기도 하지만, 프로시저 호출의 개념을 바탕으로 하고 있는 프로그래밍 패러다임을 의미하기도 한다.","{'word': '절차적 프로그래밍', 'start': 0, 'end': 8, 'type': 'COM'}","{'word': '節次的 프로그래밍', 'start': 10, 'end': 18, 'type': 'COM'}",com:alter_names
199,"프로시저는 루틴, 하위프로그램, 서브루틴, 메서드, 함수(수학적 함수와는 다르고 함수형 프로그래밍에 있는 함수와는 비슷한 의미이다.)라고도 하는데, 간단히 말하여 수행되어야 할 연속적인 계산 과정을 포함하고 있다.","{'word': '프로시저', 'start': 153, 'end': 156, 'type': 'COM'}","{'word': '루틴', 'start': 159, 'end': 160, 'type': 'COM'}",com:alter_names
200,"프로시저는 루틴, 하위프로그램, 서브루틴, 메서드, 함수(수학적 함수와는 다르고 함수형 프로그래밍에 있는 함수와는 비슷한 의미이다.)라고도 하는데, 간단히 말하여 수행되어야 할 연속적인 계산 과정을 포함하고 있다.","{'word': '프로시저', 'start': 153, 'end': 156, 'type': 'COM'}","{'word': '하위프로그램', 'start': 163, 'end': 168, 'type': 'COM'}",com:alter_names
201,"프로시저는 루틴, 하위프로그램, 서브루틴, 메서드, 함수(수학적 함수와는 다르고 함수형 프로그래밍에 있는 함수와는 비슷한 의미이다.)라고도 하는데, 간단히 말하여 수행되어야 할 연속적인 계산 과정을 포함하고 있다.","{'word': '프로시저', 'start': 153, 'end': 156, 'type': 'COM'}","{'word': '함수', 'start': 182, 'end': 183, 'type': 'COM'}",com:alter_names
202,"더 간단하고, 독립적이고, 다시 사용할 수 있기 때문에 프로시저는 프로그램 라이브러리를 포함하여 서로 다른 사람들이나 단체에서 작성한 코드의 조각들을 담을 수 있는 훌륭한 그릇이다.","{'word': '단체', 'start': 1002, 'end': 1003, 'type': 'ORG'}","{'word': '그릇', 'start': 1032, 'end': 1033, 'type': 'POH'}",no_relation
203,크고 복잡한 프로그램을 작성할 때 모듈성은 꼭 필요하다.,"{'word': '프로그램', 'start': 437, 'end': 440, 'type': 'COM'}","{'word': '모듈성', 'start': 449, 'end': 451, 'type': 'POH'}",no_relation
204,모듈성은 프로시저에 어떤 형태의 입력과 출력이 이루어지는지 명확한 규칙을 정하여 구현할 수 있다.,"{'word': '모듈성', 'start': 462, 'end': 464, 'type': 'COM'}","{'word': '출력', 'start': 484, 'end': 485, 'type': 'POH'}",no_relation
205,유효범위(스코프)는 프로시저가 모듈성을 잘 지킬 수 있게 해 준다.,"{'word': '프로시저', 'start': 590, 'end': 593, 'type': 'COM'}","{'word': '유효범위', 'start': 579, 'end': 582, 'type': 'POH'}",no_relation
206,"모듈성이 덜한 프로시저는 빨리 만든 간단한 프로그램에서 사용되기도 하는데 실행환경에서 많은 변수들과 소통하는 경향이 있고, 다른 프로시저가 변수값을 수정할 수 있을지도 모르게 된다.","{'word': '프로시저', 'start': 791, 'end': 794, 'type': 'COM'}","{'word': '변수값', 'start': 861, 'end': 863, 'type': 'POH'}",no_relation
207,여러 변수가 프로그램의 다양한 부분들 사이에서 관계가 있다면 이것은 모듈성을 약하게 한다.,"{'word': '프로그램', 'start': 892, 'end': 895, 'type': 'COM'}","{'word': '모듈성', 'start': 923, 'end': 925, 'type': 'POH'}",no_relation
208,"현재까지 남아있는 대부분의 절차적 프로그래밍 언어는 명령형 프로그래밍 언어이기도 한데, 이것은 실행 환경의 상태(state)로 명시적인 참조를 하기 때문이다.","{'word': '절차적 프로그래밍 언어', 'start': 1053, 'end': 1064, 'type': 'COM'}","{'word': '참조', 'start': 1114, 'end': 1115, 'type': 'POH'}",no_relation
209,"이것은 ""변수""(프로세서 레지스터에 대응될 수도 있다)로부터 시작해서 로고 프로그래밍 언어의 ""거북이"" 위치 같은 것(화면상의 커서부터 시작해서 방바닥 주변에 있는 장치들까지도)까지 어떤 것이든 될 수 있다.","{'word': '프로세서', 'start': 1136, 'end': 1139, 'type': 'COM'}","{'word': '거북이', 'start': 1180, 'end': 1182, 'type': 'POH'}",no_relation
210,"프로시저와 프로시저의 입력과 출력을 다루는 대신에 객체지향 프로그램들은 ""객체""를 다룬다.","{'word': '프로시저', 'start': 1369, 'end': 1372, 'type': 'COM'}","{'word': '""객체""', 'start': 1403, 'end': 1406, 'type': 'POH'}",no_relation
211,연산은 객체에게 내부 프로시저 중에 하나(혹은 상속받은 것)를 수행하라고 요청하는 것으로 이루어지며 이런 방법으로 하여 내부 상태를 다룬다.,"{'word': '프로시저', 'start': 1426, 'end': 1429, 'type': 'COM'}","{'word': '내부 상태', 'start': 1481, 'end': 1485, 'type': 'POH'}",no_relation
212,절차적 프로그래밍 언어들은 절차적 프로그래밍 접근 방식을 따름으로써 프로그래머의 작업을 수월하게 한다.,"{'word': '프로그래밍', 'start': 1497, 'end': 1501, 'type': 'COM'}","{'word': '프로그래머', 'start': 1531, 'end': 1535, 'type': 'PER'}",no_relation
213,"프로그램의 아무 위치에서나 프로시저를 호출할 수 있는데, 다른 프로시저에서도 호출 가능하고 심지어는 자기 자신에서도 호출 가능하다.","{'word': '프로그램', 'start': 273, 'end': 276, 'type': 'COM'}","{'word': '프로시저', 'start': 288, 'end': 291, 'type': 'COM'}",no_relation
214,절차적 프로그래밍은 복잡도가 지나치지 않고 유지보수하기 쉽기 때문에 단순한 순차적 프로그래밍이나 비구조적 프로그래밍보다 여러 상황에서 장점이 많다.,"{'word': '절차적 프로그래밍', 'start': 347, 'end': 355, 'type': 'COM'}","{'word': '순차적 프로그래밍', 'start': 389, 'end': 397, 'type': 'COM'}",no_relation
215,좀 더 최근에 나온 객체지향 프로그래밍을 통하면 좀 더 세련된 형태의 모듈화를 할 수 있다.,"{'word': '객체지향 프로그래밍', 'start': 1322, 'end': 1331, 'type': 'COM'}","{'word': '모듈화', 'start': 1350, 'end': 1352, 'type': 'COM'}",no_relation
216,객체 지향 언어의 시초는 1960년 노위지안 컴퓨팅 센터의 조한 달과 크리스틴이 발표한 시뮬라67이다.,"{'word': '조한 달과 크리스틴', 'start': 390, 'end': 399, 'type': 'PER'}","{'word': '시뮬라67', 'start': 406, 'end': 410, 'type': 'COM'}",per:production
217,1990년대 중반 이후로 각광받고 있는 객체 지향 언어는 자바로 가전 제품에 사용될 소프트웨어의 개발 목적으로 썬 마이크로시스템즈의 제임스 고슬링에 의하여 고안된 언어이다.,"{'word': '제임스 고슬링', 'start': 2292, 'end': 2298, 'type': 'PER'}","{'word': '자바', 'start': 2250, 'end': 2251, 'type': 'COM'}",per:production
218,"1993년 고슬링은 월드 와이드 웹에 자바 언어를 적용할 것을 결정하면서 핫자바라는 웹 브라우저를 개발하였고, 이는 1995년 이후 넷스케이프사 쪽에서 지원을 받게 되었다.","{'word': '고슬링', 'start': 2321, 'end': 2323, 'type': 'PER'}","{'word': '핫자바', 'start': 2356, 'end': 2358, 'type': 'COM'}",per:production
219,브래드 콕스가 개발한 오브젝티브-C는 C++와 마찬가지로 C와 객체 지향 언어를 혼합한 언어이다.,"{'word': '브래드 콕스', 'start': 2511, 'end': 2516, 'type': 'PER'}","{'word': '오브젝티브-C', 'start': 2523, 'end': 2529, 'type': 'COM'}",per:production
220,객체 지향 언어의 시초는 1960년 노위지안 컴퓨팅 센터의 조한 달과 크리스틴이 발표한 시뮬라67이다.,"{'word': '조한 달', 'start': 390, 'end': 393, 'type': 'PER'}","{'word': '크리스틴', 'start': 396, 'end': 399, 'type': 'PER'}",per:colleagues
221,객체 지향 언어로서의 실질적 원조는 제록스 기업의 팰러앨토 연구소에서 앨런 케이의 책임 하에 만들어진 스몰토크이다.,"{'word': '팰러앨토 연구소', 'start': 672, 'end': 679, 'type': 'ORG'}","{'word': '스몰토크', 'start': 701, 'end': 704, 'type': 'COM'}",org:production
222,에이다는 1980년대 초 객체 지향 프로그래밍 언어로 미 국방성에서 개발한 것이다.,"{'word': '미 국방성', 'start': 1202, 'end': 1206, 'type': 'ORG'}","{'word': '에이다', 'start': 1172, 'end': 1174, 'type': 'COM'}",org:production
223,미 국방성은 에이다 개발 전까지 코볼과 포트란을 이용하여 시스템을 개발하였는데 프로젝트 규모가 점점 커져 가면서 그것의 유지와 보수 비용의 문제가 따랐다.,"{'word': '미 국방성', 'start': 1219, 'end': 1223, 'type': 'ORG'}","{'word': '에이다', 'start': 1226, 'end': 1228, 'type': 'COM'}",org:production
224,"미 국방성은 새로운 언어에 대한 정의를 공모하였으며, 여러 업체들이 제시한 언어들을 기준으로 에이다를 정의하였다.","{'word': '미 국방성', 'start': 1371, 'end': 1375, 'type': 'ORG'}","{'word': '에이다', 'start': 1423, 'end': 1425, 'type': 'COM'}",org:production
225,객체 지향 언어로서의 실질적 원조는 제록스 기업의 팰러앨토 연구소에서 앨런 케이의 책임 하에 만들어진 스몰토크이다.,"{'word': '제록스 기업', 'start': 664, 'end': 669, 'type': 'ORG'}","{'word': '팰러앨토 연구소', 'start': 672, 'end': 679, 'type': 'ORG'}",org:members
226,그 중 AT&amp;T의 벨 연구소에서 비야네 스트롭스트룹등에 의해 개발된 C++는 가장 많은 사용자를 확보하고 있는 객체지향 언어다.,"{'word': 'AT&amp;T', 'start': 1931, 'end': 1938, 'type': 'ORG'}","{'word': '벨 연구소', 'start': 1941, 'end': 1945, 'type': 'ORG'}",org:members
227,객체 지향 언어의 시초는 1960년 노위지안 컴퓨팅 센터의 조한 달과 크리스틴이 발표한 시뮬라67이다.,"{'word': '시뮬라67', 'start': 406, 'end': 410, 'type': 'COM'}","{'word': '1960년', 'start': 371, 'end': 375, 'type': 'DAT'}",com:date_of_prod
228,1970년대 말 스몰토크가 만들어질 당시 제록스에서는 3가지 가정을 하고 이 가정에 초점을 맞추어 스몰토크의 문법과 의미를 정의하였다.,"{'word': '스몰토크', 'start': 808, 'end': 811, 'type': 'COM'}","{'word': '1970년대 말', 'start': 799, 'end': 806, 'type': 'DAT'}",com:date_of_prod
229,에이다는 1980년대 초 객체 지향 프로그래밍 언어로 미 국방성에서 개발한 것이다.,"{'word': '에이다', 'start': 1172, 'end': 1174, 'type': 'COM'}","{'word': '1980년대 초', 'start': 1177, 'end': 1184, 'type': 'DAT'}",com:date_of_prod
230,"1993년 고슬링은 월드 와이드 웹에 자바 언어를 적용할 것을 결정하면서 핫자바라는 웹 브라우저를 개발하였고, 이는 1995년 이후 넷스케이프사 쪽에서 지원을 받게 되었다.","{'word': '핫자바라는 웹 브라우저', 'start': 2356, 'end': 2367, 'type': 'COM'}","{'word': '1993년', 'start': 2315, 'end': 2319, 'type': 'DAT'}",com:date_of_prod
231,객체 지향 프로그래밍()은 컴퓨터 프로그래밍의 패러다임 중 하나이다.,"{'word': '컴퓨터 프로그래밍', 'start': 15, 'end': 23, 'type': 'COM'}","{'word': '객체 지향 프로그래밍', 'start': 0, 'end': 10, 'type': 'COM'}",com:sub_concept
232,"시뮬라67이 채택하고 있는 가장 중요한 개념은 클래스의 도입으로서 이 아이디어는 스몰토크, C++ 등에도 사용되었다. 하지만 시뮬라 67의 발표 이후 10여년 간 객체 지향 언어는 전혀 주목을 받지 못하였다.","{'word': '시뮬라67', 'start': 415, 'end': 419, 'type': 'COM'}","{'word': '클래스', 'start': 441, 'end': 443, 'type': 'COM'}",com:sub_concept
233,"초기의 C++는 C에 클래스 개념만 도입된 것에 지나지 않았으나, 중복, 상속, 가상 함수, 추상 클래스, 예외 처리와 같은 다양한 기능이 추가되면서 점차 향상되고 있다.","{'word': 'C++', 'start': 2040, 'end': 2042, 'type': 'COM'}","{'word': '중복', 'start': 2073, 'end': 2074, 'type': 'COM'}",com:sub_concept
234,"초기의 C++는 C에 클래스 개념만 도입된 것에 지나지 않았으나, 중복, 상속, 가상 함수, 추상 클래스, 예외 처리와 같은 다양한 기능이 추가되면서 점차 향상되고 있다.","{'word': 'C++', 'start': 2040, 'end': 2042, 'type': 'COM'}","{'word': '추상 클래스', 'start': 2088, 'end': 2093, 'type': 'COM'}",com:sub_concept
235,"초기의 C++는 C에 클래스 개념만 도입된 것에 지나지 않았으나, 중복, 상속, 가상 함수, 추상 클래스, 예외 처리와 같은 다양한 기능이 추가되면서 점차 향상되고 있다.","{'word': 'C++', 'start': 2040, 'end': 2042, 'type': 'COM'}","{'word': '예외 처리', 'start': 2096, 'end': 2100, 'type': 'COM'}",com:sub_concept
236,"객체 지향 프로그래밍의 특징은 기본적으로 자료 추상화, 상속, 다형 개념, 동적 바인딩 등이 있으며 추가적으로 다중 상속 등의 특징이 존재한다.","{'word': '객체 지향 프로그래밍', 'start': 2606, 'end': 2616, 'type': 'COM'}","{'word': '자료 추상화', 'start': 2629, 'end': 2634, 'type': 'COM'}",com:sub_concept
237,"객체 지향 프로그래밍의 특징은 기본적으로 자료 추상화, 상속, 다형 개념, 동적 바인딩 등이 있으며 추가적으로 다중 상속 등의 특징이 존재한다.","{'word': '객체 지향 프로그래밍', 'start': 2606, 'end': 2616, 'type': 'COM'}","{'word': '상속', 'start': 2637, 'end': 2638, 'type': 'COM'}",com:sub_concept
238,"객체 지향 프로그래밍의 특징은 기본적으로 자료 추상화, 상속, 다형 개념, 동적 바인딩 등이 있으며 추가적으로 다중 상속 등의 특징이 존재한다.","{'word': '객체 지향 프로그래밍', 'start': 2606, 'end': 2616, 'type': 'COM'}","{'word': '동적 바인딩', 'start': 2648, 'end': 2653, 'type': 'COM'}",com:sub_concept
239,"객체 지향 프로그래밍의 특징은 기본적으로 자료 추상화, 상속, 다형 개념, 동적 바인딩 등이 있으며 추가적으로 다중 상속 등의 특징이 존재한다.","{'word': '객체 지향 프로그래밍', 'start': 2606, 'end': 2616, 'type': 'COM'}","{'word': '다중 상속', 'start': 2668, 'end': 2672, 'type': 'COM'}",com:sub_concept
240,"객체 지향 프로그래밍에서 일반적으로 추상 자료형을 클래스, 추상 자료형의 인스턴스를 객체, 추상 자료형에서 정의된 연산을 메소드(함수), 메소드의 호출을 생성자라고 한다.","{'word': '추상 자료형', 'start': 2979, 'end': 2984, 'type': 'COM'}","{'word': '클래스', 'start': 2987, 'end': 2989, 'type': 'COM'}",com:alter_names
241,"객체 지향 프로그래밍에서 일반적으로 추상 자료형을 클래스, 추상 자료형의 인스턴스를 객체, 추상 자료형에서 정의된 연산을 메소드(함수), 메소드의 호출을 생성자라고 한다.","{'word': '추상 자료형의 인스턴스', 'start': 2992, 'end': 3003, 'type': 'COM'}","{'word': '객체', 'start': 3006, 'end': 3007, 'type': 'COM'}",com:alter_names
242,"객체 지향 프로그래밍에서 일반적으로 추상 자료형을 클래스, 추상 자료형의 인스턴스를 객체, 추상 자료형에서 정의된 연산을 메소드(함수), 메소드의 호출을 생성자라고 한다.","{'word': '추상 자료형에서 정의된 연산', 'start': 3010, 'end': 3024, 'type': 'COM'}","{'word': '메소드(함수)', 'start': 3027, 'end': 3033, 'type': 'COM'}",com:alter_names
243,"객체 지향 프로그래밍에서 일반적으로 추상 자료형을 클래스, 추상 자료형의 인스턴스를 객체, 추상 자료형에서 정의된 연산을 메소드(함수), 메소드의 호출을 생성자라고 한다.","{'word': '메소드의 호출', 'start': 3036, 'end': 3042, 'type': 'COM'}","{'word': '생성자', 'start': 3045, 'end': 3047, 'type': 'COM'}",com:alter_names
244,미 국방성은 에이다 개발 전까지 코볼과 포트란을 이용하여 시스템을 개발하였는데 프로젝트 규모가 점점 커져 가면서 그것의 유지와 보수 비용의 문제가 따랐다.,"{'word': '시스템', 'start': 1251, 'end': 1253, 'type': 'COM'}","{'word': '코볼과 포트란', 'start': 1237, 'end': 1243, 'type': 'COM'}",com:made_of
245,그 당시에는 파스칼이 인기가 좋아서 에이다의 문법은 기본적으로 파스칼의 문법을 기반으로 하였다.,"{'word': '에이다의 문법', 'start': 1455, 'end': 1461, 'type': 'COM'}","{'word': '파스칼의 문법', 'start': 1470, 'end': 1476, 'type': 'COM'}",com:prior_tech
246,C++는 C를 기반으로 하기 때문에 많은 프로그래머들의 인기를 받고 있지만 그로 인하여 객체 지향성을 제대로 반영하지 못하고 있다는 비난을 받기도 한다.,"{'word': 'C++', 'start': 2132, 'end': 2134, 'type': 'COM'}","{'word': 'C', 'start': 2137, 'end': 2137, 'type': 'COM'}",com:prior_tech
247,사람이 말로 표현 가능한 모든 것을 객체라 할 수 있다.,"{'word': '사람', 'start': 2769, 'end': 2770, 'type': 'PER'}","{'word': '객체', 'start': 2789, 'end': 2790, 'type': 'POH'}",no_relation
248,현재 많은 컴퓨터 사용자들은 그들의 응용 프로그램을 스스로 개발하지 않는다. 이러한 점 때문에 스몰토크의 순수성과 독창성에 비하여 크게 성공하진 못하였다.,"{'word': '컴퓨터 사용자', 'start': 1091, 'end': 1097, 'type': 'PER'}","{'word': '스몰토크', 'start': 1138, 'end': 1141, 'type': 'COM'}",no_relation
249,"이는 시스템의 신뢰도를 높이기 위한 중요한 기능이며, 미 국방성 프로젝트가 중요시 하는 신뢰도를 증가시키기 위한 필수적인 기능으로 볼 수 있다. 하지만 에이다는 큰 단점을 가지고 있었는데, 상속의 개념을 언어에 반영하지 않았다.","{'word': '미 국방성', 'start': 1546, 'end': 1550, 'type': 'ORG'}","{'word': '신뢰도', 'start': 1565, 'end': 1567, 'type': 'POH'}",no_relation
250,"1970년대 컴퓨터 산업을 주도한 IBM, AT&amp;T, 미 국방성 등에서 관심을 두지 않았기 때문에 시뮬라 67은 실용적인 언어로 발전하지는 못하였다. 하지만 이의 학문적 가치는 인정받고 있다.","{'word': 'IBM', 'start': 551, 'end': 553, 'type': 'ORG'}","{'word': '시뮬라 67', 'start': 591, 'end': 596, 'type': 'COM'}",no_relation
251,"각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.","{'word': '데이터', 'start': 145, 'end': 147, 'type': 'COM'}","{'word': '메시지', 'start': 134, 'end': 136, 'type': 'POH'}",no_relation
252,"또한 프로그래밍을 더 배우기 쉽게 하고 소프트웨어 개발과 보수를 간편하게 하며, 보다 직관적인 코드 분석을 가능하게 하는 장점이 있다.","{'word': '프로그래밍', 'start': 225, 'end': 229, 'type': 'COM'}","{'word': '보수', 'start': 254, 'end': 255, 'type': 'POH'}",no_relation
253,그러나 지나친 프로그램의 객체화 경향은 실제 세계의 모습을 그대로 반영하지 못한다는 비판을 받기도 한다.,"{'word': '프로그램', 'start': 306, 'end': 309, 'type': 'COM'}","{'word': '실제 세계', 'start': 320, 'end': 324, 'type': 'POH'}",no_relation
254,"이는 시스템의 신뢰도를 높이기 위한 중요한 기능이며, 미 국방성 프로젝트가 중요시 하는 신뢰도를 증가시키기 위한 필수적인 기능으로 볼 수 있다. 하지만 에이다는 큰 단점을 가지고 있었는데, 상속의 개념을 언어에 반영하지 않았다.","{'word': '에이다', 'start': 1601, 'end': 1603, 'type': 'COM'}","{'word': '상속', 'start': 1622, 'end': 1623, 'type': 'POH'}",no_relation
255,또한 에이다는 대부분의 객체 지향 언어가 대부분 동적 바인딩 방식을 채택하고 있는 반면에 정적 바인딩방식을 사용하고 있었다.,"{'word': '객체 지향 언어', 'start': 1657, 'end': 1664, 'type': 'COM'}","{'word': '정적 바인딩방식', 'start': 1694, 'end': 1701, 'type': 'POH'}",no_relation
256,특히 언어의 단순성 입장에서 객체 지향 패러다임에 충실하게 언어가 고안되었기 때문에 C++보다 오용의 소지가 다소 적다.,"{'word': 'C++', 'start': 2490, 'end': 2492, 'type': 'COM'}","{'word': '단순성', 'start': 2450, 'end': 2452, 'type': 'POH'}",no_relation
257,추상 자료형은 자료형의 자료 표현과 자료형의 연산을 캡슐화한 것으로 접근 제어를 통해서 자료형의 정보를 은닉할 수 있다.,"{'word': '추상 자료형', 'start': 2891, 'end': 2896, 'type': 'COM'}","{'word': '정보', 'start': 2945, 'end': 2946, 'type': 'POH'}",no_relation
258,상속은 새로운 클래스가 기존의 클래스의 자료와 연산을 이용할 수 있게 하는 기능이다.,"{'word': '클래스', 'start': 3063, 'end': 3065, 'type': 'COM'}","{'word': '연산', 'start': 3081, 'end': 3082, 'type': 'POH'}",no_relation
259,상속을 통해서 기존의 클래스를 상속받은 하위 클래스를 이용해 프로그램의 요구에 맞추어 클래스를 수정할 수 있고 클래스 간의 종속 관계를 형성함으로써 객체를 조직화할 수 있다.,"{'word': '프로그램', 'start': 3239, 'end': 3242, 'type': 'COM'}","{'word': '상속', 'start': 3205, 'end': 3206, 'type': 'POH'}",no_relation
260,클래스들의 기능이 동시에 필요할 때 용이하나 클래스의 상속 관계에 혼란을 줄 수 있고(예: 다이아몬드 상속) 프로그래밍 언어에 따라 사용 가능 유무가 다르므로 주의해서 사용해야 한다.,"{'word': '프로그래밍 언어', 'start': 3409, 'end': 3416, 'type': 'COM'}","{'word': '다이아몬드', 'start': 3399, 'end': 3403, 'type': 'POH'}",no_relation
261,동적 바인딩은 프로그램의 한 개체나 기호를 실행 과정에 여러 속성이나 연산에 바인딩함으로써 다형 개념을 실현한다.,"{'word': '동적 바인딩', 'start': 3719, 'end': 3724, 'type': 'COM'}","{'word': '기호', 'start': 3739, 'end': 3740, 'type': 'POH'}",no_relation
262,"소프트웨어 공학의 관점에서 볼 때 S/W의 질을 향상하기 위해 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 지향해야 하는데, OOP의 경우 하나의 문제 해결을 위한 데이터를 클래스에 모아 놓은 데이터형을 사용함으로써 응집력을 강화하고, 클래스간에 독립적인 디자인을 함으로써 결합력을 약하게 한다.","{'word': '소프트웨어', 'start': 3783, 'end': 3787, 'type': 'COM'}","{'word': '약한 결합력', 'start': 3843, 'end': 3848, 'type': 'POH'}",no_relation
263,"소프트웨어 공학의 관점에서 볼 때 S/W의 질을 향상하기 위해 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 지향해야 하는데, OOP의 경우 하나의 문제 해결을 위한 데이터를 클래스에 모아 놓은 데이터형을 사용함으로써 응집력을 강화하고, 클래스간에 독립적인 디자인을 함으로써 결합력을 약하게 한다.","{'word': 'OOP', 'start': 3876, 'end': 3878, 'type': 'COM'}","{'word': '응집력', 'start': 3927, 'end': 3929, 'type': 'POH'}",no_relation
264,마지막으로 모든 사람이 각자의 응용 프로그램을 쉽게 개발할 수 있어야 한다는 것이었다. 첫 번째와 두 번째 가정은 현실에서 거의 사실화 되었으나 마지막 가정은 제록스의 실수였다.,"{'word': '응용 프로그램', 'start': 1002, 'end': 1008, 'type': 'COM'}","{'word': '제록스', 'start': 1074, 'end': 1076, 'type': 'ORG'}",no_relation
265,"시뮬라67이 채택하고 있는 가장 중요한 개념은 클래스의 도입으로서 이 아이디어는 스몰토크, C++ 등에도 사용되었다. 하지만 시뮬라 67의 발표 이후 10여년 간 객체 지향 언어는 전혀 주목을 받지 못하였다.","{'word': '시뮬라 67', 'start': 485, 'end': 490, 'type': 'COM'}","{'word': '10여년', 'start': 499, 'end': 502, 'type': 'DAT'}",no_relation
266,객체 지향 언어는 프로그래밍 언어가 많은 지원을 받기 시작하고 발전하기 시작한 1990년 대 초반에 많은 발전이 있었다.,"{'word': '프로그래밍 언어', 'start': 1724, 'end': 1731, 'type': 'COM'}","{'word': '1990년', 'start': 1758, 'end': 1762, 'type': 'DAT'}",no_relation
267,"객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 ""객체""들의 모임으로 파악하고자 하는 것이다.","{'word': '명령어', 'start': 62, 'end': 64, 'type': 'COM'}","{'word': '객체', 'start': 101, 'end': 102, 'type': 'COM'}",no_relation
268,"첫 번째는 전 세계의 모든 사람이 컴퓨터를 사용할 것이라는 가정이었고, 두 번째는 모든 사용자가 그래픽이 지원되는 모니터와 마우스를 기본 설비로 사용하며 윈도 환경에서 작업할 것이라는 가정이었다.","{'word': '컴퓨터', 'start': 894, 'end': 896, 'type': 'COM'}","{'word': '그래픽', 'start': 929, 'end': 931, 'type': 'COM'}",no_relation
269,"C++, 델파이, FoxPro와 같은 프로그램들은 객체 지향 언어에 가장 큰 영향을 미쳤던 GUI의 발전에 따라 점점 향상되었다.","{'word': 'C++', 'start': 1854, 'end': 1856, 'type': 'COM'}","{'word': 'GUI', 'start': 1905, 'end': 1907, 'type': 'COM'}",no_relation
270,"객체 지향 프로그래밍은 자료 추상화를 기초로 하여 상속, 다형 개념, 동적 바인딩이 시스템의 복잡성을 제어하기 위해 서로 맞물려 기능하는 것이다.","{'word': '시스템', 'start': 2734, 'end': 2736, 'type': 'COM'}","{'word': '자료 추상화', 'start': 2700, 'end': 2705, 'type': 'COM'}",no_relation
271,자료 추상화는 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단히 만드는 것이다.,"{'word': '프로그램', 'start': 2838, 'end': 2841, 'type': 'COM'}","{'word': '자료 추상화', 'start': 2801, 'end': 2806, 'type': 'COM'}",no_relation
272,"상속을 받는 새로운 클래스를 부클래스, 파생 클래스, 하위 클래스, 자식 클래스라고 하며 새로운 클래스가 상속하는 기존의 클래스를 기반 클래스, 상위 클래스, 부모 클래스라고 한다.","{'word': '기반 클래스', 'start': 3176, 'end': 3181, 'type': 'COM'}","{'word': '부클래스', 'start': 3119, 'end': 3122, 'type': 'COM'}",no_relation
273,다형성 개념이란 어떤 한 요소에 여러 개념을 넣어 놓는 것으로 일반적으로 오버라이딩(같은 이름의 메소드가 여러 클래스에서 다른 기능을 하는 것)이나 오버로딩(같은 이름의 메소드가 인자의 개수나 자료형에 따라서 다른 기능을 하는 것)을 의미한다.,"{'word': '오버라이딩', 'start': 3492, 'end': 3496, 'type': 'COM'}","{'word': '메소드', 'start': 3505, 'end': 3507, 'type': 'COM'}",no_relation
274,동적 바인딩은 실행 시간 중에 일어나거나 실행 과정에서 변경될 수 있는 바인딩으로 컴파일 시간에 완료되어 변화하지 않는 정적 바인딩과 대비되는 개념이다.,"{'word': '컴파일', 'start': 3679, 'end': 3681, 'type': 'COM'}","{'word': '동적 바인딩', 'start': 3633, 'end': 3638, 'type': 'COM'}",no_relation
275,오브젝티브-C는 C++보다는 스몰토크에 좀 더 가깝게 정의된 언어이다.,"{'word': '오브젝티브-C', 'start': 2566, 'end': 2572, 'type': 'COM'}","{'word': '스몰토크', 'start': 2582, 'end': 2585, 'type': 'COM'}",com:similar_tech
276,"컴퓨터 언어()라는 용어는 컴퓨터와의 커뮤니케이션에 쓰이는 다양한 종류의 언어들을 일컫는 말로서, 흔히 사용되는 프로그래밍 언어라는 용어의 뜻을 확장한 용어이다.","{'word': '컴퓨터 언어', 'start': 0, 'end': 5, 'type': 'COM'}","{'word': '프로그래밍 언어', 'start': 63, 'end': 70, 'type': 'COM'}",com:sub_concept
277,프로그래밍 언어는 컴퓨터 언어의 부분집합이다.,"{'word': '컴퓨터 언어', 'start': 101, 'end': 106, 'type': 'COM'}","{'word': '프로그래밍 언어', 'start': 91, 'end': 98, 'type': 'COM'}",com:sub_concept
278,오늘날 대부분의 소프트웨어는 고급 언어로 작성된다.,"{'word': '소프트웨어', 'start': 337, 'end': 341, 'type': 'COM'}","{'word': '고급 언어', 'start': 344, 'end': 348, 'type': 'COM'}",com:made_of
279,사람이 읽을 수 있는 언어는 사람이 직접 사용하여 컴퓨터와 커뮤니케이트하게 해주는 용도로 쓰일 수 있다.,"{'word': '사람', 'start': 479, 'end': 480, 'type': 'PER'}","{'word': '컴퓨터', 'start': 507, 'end': 509, 'type': 'COM'}",no_relation
280,고급(high level) 언어와 저급(low level)언어로 나뉠 수 있다.,"{'word': '고급(high level) 언어', 'start': 152, 'end': 168, 'type': 'COM'}","{'word': '저급(low level)언어', 'start': 171, 'end': 185, 'type': 'COM'}",no_relation
281,"고급 언어는 저급 언어보다 사용하기 쉽고, 더 추상적이며, 더 이식 가능성이 높게 디자인된다.","{'word': '저급 언어', 'start': 204, 'end': 208, 'type': 'COM'}","{'word': '고급 언어', 'start': 197, 'end': 201, 'type': 'COM'}",no_relation
282,"어떤 언어의 경우에는, 문법적으로 올바른 프로그램들은 저급 언어로 컴파일(compile)되어 컴퓨터 상에서 실행(execute)되게 된다.","{'word': '컴파일', 'start': 287, 'end': 289, 'type': 'COM'}","{'word': '프로그램', 'start': 273, 'end': 276, 'type': 'COM'}",no_relation
283,그 후 오브젝트 코드로 컴파일되고 난 뒤 기계어로 변환된다.,"{'word': '기계어', 'start': 380, 'end': 382, 'type': 'COM'}","{'word': '오브젝트 코드', 'start': 361, 'end': 367, 'type': 'COM'}",no_relation
284,사람이 읽을 수 있는(human-readable) 언어와 사람이 읽을 수 없는 언어로 분류할 수 있다.,"{'word': '사람이 읽을 수 없는 언어', 'start': 453, 'end': 466, 'type': 'COM'}","{'word': '사람이 읽을 수 있는(human-readable) 언어', 'start': 421, 'end': 450, 'type': 'COM'}",no_relation
285,최초로 공개된 JIT 컴파일러는 일반적으로 1960년 존 매카시의 리스프에 공이 주어진다.,"{'word': '최초로 공개된 JIT 컴파일러', 'start': 1308, 'end': 1323, 'type': 'COM'}","{'word': '1960년', 'start': 1332, 'end': 1336, 'type': 'DAT'}",com:date_of_prod
286,일반적인 인터프러터 언어(예시: cpython)는 바이트코드나 소스코드를 최적화 과정이 없이 번역하기 때문에 성능이 낮다.,"{'word': '인터프러터 언어', 'start': 768, 'end': 775, 'type': 'COM'}","{'word': 'cpython', 'start': 781, 'end': 787, 'type': 'COM'}",com:sub_concept
287,"반면 정적으로 컴파일하는 언어(예시: c 언어)는 실행 전에 무조건 컴파일을 해야하기 때문에 다양한 플랫폼에 맞게 컴파일을 하려면 시간이 오래 걸린다. ""동적 컴파일 환경""은 실행 과정에서 컴파일을 할 수 있기 위해 만들어졌다.","{'word': '정적으로 컴파일하는 언어', 'start': 835, 'end': 847, 'type': 'COM'}","{'word': 'c 언어', 'start': 853, 'end': 856, 'type': 'COM'}",com:sub_concept
288,JIT 컴파일() 또는 동적 번역()은 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법이다.,"{'word': 'JIT 컴파일', 'start': 0, 'end': 6, 'type': 'COM'}","{'word': '동적 번역', 'start': 13, 'end': 17, 'type': 'COM'}",com:alter_names
289,"전통적인 입장에서 컴퓨터 프로그램을 만드는 방법은 두 가지가 있는데, 인터프리트 방식과 정적 컴파일 방식으로 나눌 수 있다.","{'word': '인터프리트 방식', 'start': 99, 'end': 106, 'type': 'COM'}","{'word': '정적 컴파일 방식', 'start': 109, 'end': 117, 'type': 'COM'}",no_relation
290,"이 중 인터프리트 방식은 실행 중 프로그래밍 언어를 읽어가면서 해당 기능에 대응하는 기계어 코드를 실행하며, 반면 정적 컴파일은 실행하기 전에 프로그램 코드를 기계어로 번역한다.","{'word': '인터프리트 방식', 'start': 134, 'end': 141, 'type': 'COM'}","{'word': '기계어 코드', 'start': 177, 'end': 182, 'type': 'COM'}",no_relation
291,"이 중 인터프리트 방식은 실행 중 프로그래밍 언어를 읽어가면서 해당 기능에 대응하는 기계어 코드를 실행하며, 반면 정적 컴파일은 실행하기 전에 프로그램 코드를 기계어로 번역한다.","{'word': '인터프리트 방식', 'start': 134, 'end': 141, 'type': 'COM'}","{'word': '정적 컴파일', 'start': 194, 'end': 199, 'type': 'COM'}",no_relation
292,"JIT 컴파일러는 두 가지의 방식을 혼합한 방식으로 생각할 수 있는데, 실행 시점에서 인터프리트 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지한다.","{'word': '코드', 'start': 305, 'end': 306, 'type': 'COM'}","{'word': '기계어 코드', 'start': 335, 'end': 340, 'type': 'COM'}",no_relation
293,"최근의 자바 가상 머신과 .NET, V8(node.js)에서는 JIT 컴파일을 지원한다.","{'word': '자바 가상 머신', 'start': 361, 'end': 368, 'type': 'COM'}","{'word': 'V8', 'start': 377, 'end': 378, 'type': 'COM'}",no_relation
294,"즉, 자바 컴파일러가 자바 프로그램 코드를 바이트코드로 변환한 다음, 실제 바이트코드를 실행하는 시점에서 자바 가상 머신이 바이트코드를 JIT 컴파일을 통해 기계어로 변환한다.","{'word': '바이트코드', 'start': 431, 'end': 435, 'type': 'COM'}","{'word': '기계어', 'start': 495, 'end': 497, 'type': 'COM'}",no_relation
295,바이트코드 컴파일러는 소스 코드를 중간언어인 바이트코드로 변환한다.,"{'word': '컴파일러', 'start': 512, 'end': 515, 'type': 'COM'}","{'word': '바이트코드', 'start': 531, 'end': 535, 'type': 'COM'}",no_relation
296,바이트코드는 기계어는 아니지만 가상 머신에 의해 기계어로 손쉽게 변환할 수 있는 코드이다.,"{'word': '바이트코드', 'start': 544, 'end': 548, 'type': 'COM'}","{'word': '기계어', 'start': 551, 'end': 553, 'type': 'COM'}",no_relation
297,JIT 컴파일러는 바이트코드를 읽어 빠른 속도로 기계어를 생성할 수 있다.,"{'word': 'JIT 컴파일러', 'start': 595, 'end': 602, 'type': 'COM'}","{'word': '기계어', 'start': 622, 'end': 624, 'type': 'COM'}",no_relation
298,"이런 기계어 변환은 코드가 실행되는 과정에 실시간으로 일어나며(그래서 Just-In-Time이다), 전체 코드의 필요한 부분만 변환한다.","{'word': '기계어', 'start': 640, 'end': 642, 'type': 'COM'}","{'word': '코드', 'start': 696, 'end': 697, 'type': 'COM'}",no_relation
299,기계어로 변환된 코드는 캐시에 저장되기 때문에 재사용시 컴파일을 다시 할 필요가 없다.,"{'word': '캐시', 'start': 727, 'end': 728, 'type': 'COM'}","{'word': '컴파일', 'start': 745, 'end': 747, 'type': 'COM'}",no_relation
300,JIT는 정적 컴파일러 만큼 빠르면서 인터프러터 언어의 빠른 응답속도를 추구하기 위해 사용한다.,"{'word': 'JIT', 'start': 960, 'end': 962, 'type': 'COM'}","{'word': '인터프러터 언어', 'start': 981, 'end': 988, 'type': 'COM'}",no_relation
301,바이트코드 컴파일러가 시간이 많이 소요되는 최적화를 미리 해주기 때문에 바이트코드에서 기계어 번역은 훨씬 빠르게 진행될 수 있다.,"{'word': '바이트코드', 'start': 1014, 'end': 1018, 'type': 'COM'}","{'word': '최적화', 'start': 1038, 'end': 1040, 'type': 'COM'}",no_relation
302,"플랫폼 별로 가상 머신을 개발하는 과정은 컴파일러를 만드는 것보다 간단한데, 그 이유는","{'word': '플랫폼', 'start': 1136, 'end': 1138, 'type': 'COM'}","{'word': '컴파일러', 'start': 1159, 'end': 1162, 'type': 'COM'}",no_relation
303,"JIT 코드는 일반적인 인터프러터 언어에 비해 훨씬 좋은 성능을 낸다. 심지어 경우에 따라 정적 컴파일러 언어보다 좋은 성능을 내곤 하는데, 이는 실행 과정에 컴파일을 할 수 있기 때문에 가지는 장점이라고 할 수 있다:","{'word': 'JIT 코드', 'start': 1185, 'end': 1190, 'type': 'COM'}","{'word': '정적 컴파일러 언어', 'start': 1236, 'end': 1245, 'type': 'COM'}",no_relation
304,"컴파일 언어(compiled language)는 구현체들이 일반적으로 컴파일러(소스 코드로부터 기계어를 생성해내는 변환기)이면서 인터프리터(런타임 전 변환 과정을 거치지 않는, 소스 코드의 단계별 실행기)가 아닌 프로그래밍 언어이다.","{'word': '컴파일러', 'start': 39, 'end': 42, 'type': 'COM'}","{'word': '인터프리터', 'start': 72, 'end': 76, 'type': 'COM'}",no_relation
