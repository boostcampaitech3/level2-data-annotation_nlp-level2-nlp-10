id,sentence,subject_entity,object_entity,label
0,프로그래밍 패러다임(programming paradigm)은 프로그래밍의 패러다임 형태이다. 소프트웨어 공학을 할 때의 패러다임 형태인 방법론과 비교된다.,"{'word': '소프트웨어 공학', 'start': 52, 'end': 59, 'type': 'COM'}","{'word': '프로그래밍 패러다임', 'start': 0, 'end': 9, 'type': 'COM'}",com:sub_concept
1,소프트웨어 공학을 할 때의 패러다임 형태인 방법론과 비교된다.,"{'word': '소프트웨어 공학', 'start': 52, 'end': 59, 'type': 'COM'}","{'word': '방법론', 'start': 76, 'end': 78, 'type': 'COM'}",com:sub_concept
2,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '언어', 'start': 502, 'end': 503, 'type': 'COM'}","{'word': '오즈', 'start': 477, 'end': 478, 'type': 'COM'}",com:sub_concept
3,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '언어', 'start': 502, 'end': 503, 'type': 'COM'}","{'word': '자바', 'start': 493, 'end': 494, 'type': 'COM'}",com:sub_concept
4,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '언어', 'start': 502, 'end': 503, 'type': 'COM'}","{'word': '커먼 리스프', 'start': 464, 'end': 469, 'type': 'COM'}",com:sub_concept
5,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '언어', 'start': 502, 'end': 503, 'type': 'COM'}","{'word': '파이썬', 'start': 472, 'end': 474, 'type': 'COM'}",com:sub_concept
6,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '표준 API', 'start': 659, 'end': 664, 'type': 'COM'}","{'word': 'Stream', 'start': 648, 'end': 653, 'type': 'COM'}",com:sub_concept
7,"자바에서 람다식은 함수형 인터페이스를 구현하는 익명클래스의 인스턴스를 생성하며, 좀 더 간단한 표현을 위해 컴파일러의 타입 추론이 동원된다."" )","{'word': '자바', 'start': 736, 'end': 737, 'type': 'COM'}","{'word': '람다식', 'start': 741, 'end': 743, 'type': 'COM'}",com:sub_concept
8,"자바에서 람다식은 함수형 인터페이스를 구현하는 익명클래스의 인스턴스를 생성하며, 좀 더 간단한 표현을 위해 컴파일러의 타입 추론이 동원된다."" )","{'word': '익명클래스', 'start': 762, 'end': 766, 'type': 'COM'}","{'word': '인스턴스', 'start': 769, 'end': 772, 'type': 'COM'}",com:sub_concept
9,"자바에서 람다식은 함수형 인터페이스를 구현하는 익명클래스의 인스턴스를 생성하며, 좀 더 간단한 표현을 위해 컴파일러의 타입 추론이 동원된다."" )","{'word': '컴파일러', 'start': 796, 'end': 799, 'type': 'COM'}","{'word': '타입 추론', 'start': 802, 'end': 806, 'type': 'COM'}",com:sub_concept
10,"어떤 언어들은 하나의 특정한 패러다임을 지원하기도 하는데, 스몰토크와 jdk 1.8 이전의 자바가 객체지향 프로그래밍을 지원하는 반면에, 하스켈과 스킴은 함수형 프로그래밍을 지원한다.","{'word': '객체지향 프로그래밍', 'start': 389, 'end': 398, 'type': 'COM'}","{'word': '자바', 'start': 385, 'end': 386, 'type': 'COM'}",com:made_of
11,"어떤 언어들은 하나의 특정한 패러다임을 지원하기도 하는데, 스몰토크와 jdk 1.8 이전의 자바가 객체지향 프로그래밍을 지원하는 반면에, 하스켈과 스킴은 함수형 프로그래밍을 지원한다.","{'word': '객체지향 프로그래밍', 'start': 389, 'end': 398, 'type': 'COM'}","{'word': '스몰토크', 'start': 367, 'end': 370, 'type': 'COM'}",com:made_of
12,"어떤 언어들은 하나의 특정한 패러다임을 지원하기도 하는데, 스몰토크와 jdk 1.8 이전의 자바가 객체지향 프로그래밍을 지원하는 반면에, 하스켈과 스킴은 함수형 프로그래밍을 지원한다.","{'word': '함수형 프로그래밍', 'start': 420, 'end': 428, 'type': 'COM'}","{'word': '스킴', 'start': 416, 'end': 417, 'type': 'COM'}",com:made_of
13,"어떤 언어들은 하나의 특정한 패러다임을 지원하기도 하는데, 스몰토크와 jdk 1.8 이전의 자바가 객체지향 프로그래밍을 지원하는 반면에, 하스켈과 스킴은 함수형 프로그래밍을 지원한다.","{'word': '함수형 프로그래밍', 'start': 420, 'end': 428, 'type': 'COM'}","{'word': '하스켈', 'start': 411, 'end': 413, 'type': 'COM'}",com:made_of
14,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '함수형 프로그래밍 패러다임', 'start': 576, 'end': 589, 'type': 'COM'}","{'word': '람다식', 'start': 600, 'end': 602, 'type': 'COM'}",com:made_of
15,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '함수형 프로그래밍 패러다임', 'start': 576, 'end': 589, 'type': 'COM'}","{'word': '생성자 레퍼런스', 'start': 605, 'end': 612, 'type': 'COM'}",com:made_of
16,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '함수형 프로그래밍 패러다임', 'start': 576, 'end': 589, 'type': 'COM'}","{'word': '메서드 레퍼런스', 'start': 615, 'end': 622, 'type': 'COM'}",com:made_of
17,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '선언형 프로그래밍', 'start': 630, 'end': 638, 'type': 'COM'}","{'word': '표준 API', 'start': 659, 'end': 664, 'type': 'COM'}",com:made_of
18,"예를 들어서 C++는 절차적 프로그래밍, 객체기반 프로그래밍, 객체지향 프로그래밍, 제네릭 프로그래밍의 요소들을 지원하도록 설계되었다.","{'word': '절차적 프로그래밍', 'start': 1211, 'end': 1219, 'type': 'COM'}","{'word': 'C++', 'start': 1206, 'end': 1208, 'type': 'COM'}",com:made_of
19,"예를 들어서 C++는 절차적 프로그래밍, 객체기반 프로그래밍, 객체지향 프로그래밍, 제네릭 프로그래밍의 요소들을 지원하도록 설계되었다.","{'word': '객체기반 프로그래밍', 'start': 1222, 'end': 1231, 'type': 'COM'}","{'word': 'C++', 'start': 1206, 'end': 1208, 'type': 'COM'}",com:made_of
20,"예를 들어서 C++는 절차적 프로그래밍, 객체기반 프로그래밍, 객체지향 프로그래밍, 제네릭 프로그래밍의 요소들을 지원하도록 설계되었다.","{'word': '객체지향 프로그래밍', 'start': 1234, 'end': 1243, 'type': 'COM'}","{'word': 'C++', 'start': 1206, 'end': 1208, 'type': 'COM'}",com:made_of
21,"예를 들어서 C++는 절차적 프로그래밍, 객체기반 프로그래밍, 객체지향 프로그래밍, 제네릭 프로그래밍의 요소들을 지원하도록 설계되었다.","{'word': '제네릭 프로그래밍', 'start': 1246, 'end': 1254, 'type': 'COM'}","{'word': 'C++', 'start': 1206, 'end': 1208, 'type': 'COM'}",com:made_of
22,"C++에서는 순수하게 절차적 프로그램을 작성할 수 있고, 순수하게 객체지향 프로그램을 작성할 수 있으며, 두 가지 패러다임 모두의 요소를 포함한 프로그램을 작성할 수도 있다.","{'word': '절차적 프로그램', 'start': 1287, 'end': 1294, 'type': 'COM'}","{'word': 'C++', 'start': 1275, 'end': 1277, 'type': 'COM'}",com:made_of
23,"C++에서는 순수하게 절차적 프로그램을 작성할 수 있고, 순수하게 객체지향 프로그램을 작성할 수 있으며, 두 가지 패러다임 모두의 요소를 포함한 프로그램을 작성할 수도 있다.","{'word': '객체지향 프로그램', 'start': 1312, 'end': 1320, 'type': 'COM'}","{'word': 'C++', 'start': 1275, 'end': 1277, 'type': 'COM'}",com:made_of
24,"예를 들어, 안드로이드 앱 개발자는 기본적으로 자바와 안드로이드를 알지만, 때로 웹 앱 개발이 유리한 경우에는 HTML, CSS, Javascript의 사용이 필요할 수 있고, 안드로이드 공식 개발 언어가 Kotlin으로 바뀌었으므로 그 또한 필요할 수 있다.","{'word': '웹 앱 개발', 'start': 2185, 'end': 2190, 'type': 'COM'}","{'word': 'HTML', 'start': 2202, 'end': 2205, 'type': 'COM'}",com:made_of
25,"예를 들어, 안드로이드 앱 개발자는 기본적으로 자바와 안드로이드를 알지만, 때로 웹 앱 개발이 유리한 경우에는 HTML, CSS, Javascript의 사용이 필요할 수 있고, 안드로이드 공식 개발 언어가 Kotlin으로 바뀌었으므로 그 또한 필요할 수 있다.","{'word': '웹 앱 개발', 'start': 2185, 'end': 2190, 'type': 'COM'}","{'word': 'CSS', 'start': 2208, 'end': 2210, 'type': 'COM'}",com:made_of
26,"예를 들어, 안드로이드 앱 개발자는 기본적으로 자바와 안드로이드를 알지만, 때로 웹 앱 개발이 유리한 경우에는 HTML, CSS, Javascript의 사용이 필요할 수 있고, 안드로이드 공식 개발 언어가 Kotlin으로 바뀌었으므로 그 또한 필요할 수 있다.","{'word': '웹 앱 개발', 'start': 2185, 'end': 2190, 'type': 'COM'}","{'word': 'Javascript', 'start': 2213, 'end': 2222, 'type': 'COM'}",com:made_of
27,"예를 들어, 안드로이드 앱 개발자는 기본적으로 자바와 안드로이드를 알지만, 때로 웹 앱 개발이 유리한 경우에는 HTML, CSS, Javascript의 사용이 필요할 수 있고, 안드로이드 공식 개발 언어가 Kotlin으로 바뀌었으므로 그 또한 필요할 수 있다.","{'word': '웹 앱 개발', 'start': 2185, 'end': 2190, 'type': 'COM'}","{'word': 'Kotlin', 'start': 2255, 'end': 2260, 'type': 'COM'}",com:made_of
28,"데이터베이스 사용에선 RDBMS를 주로 사용하던 이전과 달리 NoSQL의 대두로 여러 패러다임의 이해가 요구될 수 있다. ( ""NoSQL 은 RDB의 관계지향 패러다임과 같이 하나의 패러다임이 적용된 것이 아니고, 여러 다양한 철학이 적용되어 있다.","{'word': '데이터베이스', 'start': 2648, 'end': 2653, 'type': 'COM'}","{'word': 'RDBMS', 'start': 2660, 'end': 2664, 'type': 'COM'}",com:made_of
29,"데이터베이스 사용에선 RDBMS를 주로 사용하던 이전과 달리 NoSQL의 대두로 여러 패러다임의 이해가 요구될 수 있다. ( ""NoSQL 은 RDB의 관계지향 패러다임과 같이 하나의 패러다임이 적용된 것이 아니고, 여러 다양한 철학이 적용되어 있다.","{'word': '데이터베이스', 'start': 2648, 'end': 2653, 'type': 'COM'}","{'word': 'NoSQL', 'start': 2682, 'end': 2686, 'type': 'COM'}",com:made_of
30,프로그래밍 패러다임(programming paradigm)은 프로그래밍의 패러다임 형태이다. 소프트웨어 공학을 할 때의 패러다임 형태인 방법론과 비교된다.,"{'word': '프로그래밍 패러다임', 'start': 0, 'end': 9, 'type': 'COM'}","{'word': '방법론', 'start': 76, 'end': 78, 'type': 'COM'}",no_relation
31,"예를 들어 객체지향 프로그래밍은 프로그래머들이 프로그램을 상호작용하는 객체들의 집합으로 볼 수 있게 하는 반면에, 함수형 프로그래밍은 상태값을 지니지 않는 함수값들의 연속으로 생각할 수 있게 해준다.","{'word': '객체지향 프로그래밍', 'start': 146, 'end': 155, 'type': 'COM'}","{'word': '함수형 프로그래밍', 'start': 204, 'end': 212, 'type': 'COM'}",no_relation
32,"예를 들어, 순수 함수형 프로그래밍은 부작용의 사용을 허용하지 않는다. 구조적 프로그래밍은 GOTO문의 사용을 제한한다.","{'word': '순수 함수형 프로그래밍', 'start': 882, 'end': 893, 'type': 'COM'}","{'word': '구조적 프로그래밍', 'start': 915, 'end': 923, 'type': 'COM'}",no_relation
33,"자바나 PHP와 같이 기존부터 있던 언어들에는 본래 없던 패러다임이 추가되고, Swift나 Go, Kotlin과 같이 비교적 새로 만들어지는 언어들은 처음부터 여러 패러다임의 지원을 고려하여 설계된다.","{'word': '자바', 'start': 1407, 'end': 1408, 'type': 'COM'}","{'word': 'PHP', 'start': 1411, 'end': 1413, 'type': 'COM'}",com:similar_tech
34,"자바나 PHP와 같이 기존부터 있던 언어들에는 본래 없던 패러다임이 추가되고, Swift나 Go, Kotlin과 같이 비교적 새로 만들어지는 언어들은 처음부터 여러 패러다임의 지원을 고려하여 설계된다.","{'word': 'Swift', 'start': 1451, 'end': 1455, 'type': 'COM'}","{'word': 'Go', 'start': 1458, 'end': 1459, 'type': 'COM'}",com:similar_tech
35,"자바나 PHP와 같이 기존부터 있던 언어들에는 본래 없던 패러다임이 추가되고, Swift나 Go, Kotlin과 같이 비교적 새로 만들어지는 언어들은 처음부터 여러 패러다임의 지원을 고려하여 설계된다.","{'word': 'Swift', 'start': 1451, 'end': 1455, 'type': 'COM'}","{'word': 'Kotlin', 'start': 1462, 'end': 1467, 'type': 'COM'}",com:similar_tech
36,"예를 들어, 안드로이드 앱 개발자는 기본적으로 자바와 안드로이드를 알지만, 때로 웹 앱 개발이 유리한 경우에는 HTML, CSS, Javascript의 사용이 필요할 수 있고, 안드로이드 공식 개발 언어가 Kotlin으로 바뀌었으므로 그 또한 필요할 수 있다.","{'word': '자바', 'start': 2166, 'end': 2167, 'type': 'COM'}","{'word': '안드로이드', 'start': 2170, 'end': 2174, 'type': 'COM'}",com:similar_tech
37,다른 예로는 자바 기반 프로젝트의 특정 맥락에서 자바 대신 자바 가상머신 지원 언어를 사용하는 것을 생각해 볼 수 있다.,"{'word': '자바', 'start': 2528, 'end': 2529, 'type': 'COM'}","{'word': '자바 가상머신 지원 언어', 'start': 2534, 'end': 2546, 'type': 'COM'}",com:similar_tech
38,"데이터베이스 사용에선 RDBMS를 주로 사용하던 이전과 달리 NoSQL의 대두로 여러 패러다임의 이해가 요구될 수 있다. ( ""NoSQL 은 RDB의 관계지향 패러다임과 같이 하나의 패러다임이 적용된 것이 아니고, 여러 다양한 철학이 적용되어 있다.","{'word': 'RDBMS', 'start': 2660, 'end': 2664, 'type': 'COM'}","{'word': 'NoSQL', 'start': 2682, 'end': 2686, 'type': 'COM'}",com:similar_tech
39,자바()는 썬 마이크로시스템즈의 제임스 고슬링()과 다른 연구원들이 개발한 객체 지향적 프로그래밍 언어이다.,"{'word': '제임스 고슬링', 'start': 18, 'end': 24, 'type': 'PER'}","{'word': '자바', 'start': 0, 'end': 1, 'type': 'COM'}",per:production
40,자바 언어는 1991년 6월 셋톱 프로젝트를 위해 제임스 고슬링(James Gosling)이 만들었다.,"{'word': '제임스 고슬링', 'start': 648, 'end': 654, 'type': 'PER'}","{'word': '자바 언어', 'start': 620, 'end': 624, 'type': 'COM'}",per:production
41,자바()는 썬 마이크로시스템즈의 제임스 고슬링()과 다른 연구원들이 개발한 객체 지향적 프로그래밍 언어이다.,"{'word': '썬 마이크로시스템즈', 'start': 6, 'end': 15, 'type': 'ORG'}","{'word': '자바', 'start': 0, 'end': 1, 'type': 'COM'}",org:production
42,썬 마이크로시스템즈는 자바의 대부분을 무료로 배포하였으나 오픈이 아닌 사유 소프트웨어였다.,"{'word': '썬 마이크로시스템즈', 'start': 1464, 'end': 1473, 'type': 'ORG'}","{'word': '자바', 'start': 1476, 'end': 1477, 'type': 'COM'}",org:production
43,2006년 11월 13일 썬 마이크로시스템즈는 대부분은 자바를 GPL 라이선스로 소스를 오픈하였으며 2007년 5월 8일 이 과정을 마쳤다.,"{'word': '썬 마이크로시스템즈', 'start': 1699, 'end': 1708, 'type': 'ORG'}","{'word': '자바', 'start': 1716, 'end': 1717, 'type': 'COM'}",org:production
44,"현재 오라클 공식 홈페이지에서 JDK 16, Java.net에서 JDK 9가 배포 중이며, 다운로드 페이지 오른쪽에 있는 약관 동의에 체크하고 그 아래 링크를 이용해 다운로드 받을 수 있다.","{'word': '오라클', 'start': 4748, 'end': 4750, 'type': 'ORG'}","{'word': 'JDK 9', 'start': 4781, 'end': 4785, 'type': 'COM'}",org:production
45,2009년 4월 20일 제작사인 썬 마이크로시스템즈가 오라클과 인수 합병됨에 따라 자바에 대한 권리 및 유지보수 또한 오라클로 넘어가게 되었다.,"{'word': '오라클', 'start': 1839, 'end': 1841, 'type': 'ORG'}","{'word': '썬 마이크로시스템즈', 'start': 1827, 'end': 1836, 'type': 'ORG'}",org:members
46,자바 언어는 1991년 6월 셋톱 프로젝트를 위해 제임스 고슬링(James Gosling)이 만들었다.,"{'word': '자바 언어', 'start': 620, 'end': 624, 'type': 'COM'}","{'word': '1991년 6월', 'start': 627, 'end': 634, 'type': 'DAT'}",com:date_of_prod
47,첫 공개 자바 버전은 1995년의 자바 1.0이었다.,"{'word': '자바 1.0', 'start': 843, 'end': 848, 'type': 'COM'}","{'word': '1995년', 'start': 836, 'end': 840, 'type': 'DAT'}",com:date_of_prod
48,2006년 11월 13일 썬 마이크로시스템즈는 대부분은 자바를 GPL 라이선스로 소스를 오픈하였으며 2007년 5월 8일 이 과정을 마쳤다.,"{'word': '자바', 'start': 1716, 'end': 1717, 'type': 'COM'}","{'word': '2006년 11월 13일', 'start': 1685, 'end': 1697, 'type': 'DAT'}",com:date_of_prod
49,"자바()는 썬 마이크로시스템즈의 제임스 고슬링()과 다른 연구원들이 개발한 객체 지향적 프로그래밍 언어이다. 1991년 그린 프로젝트()라는 이름으로 시작해 1995년에 발표했다. 처음에는 가전제품 내에 탑재해 동작하는 프로그램을 위해 개발했지만 현재 웹 애플리케이션 개발에 가장 많이 사용하는 언어 가운데 하나이고, 모바일 기기용 소프트웨어 개발에도 널리 사용하고 있다.","{'word': '웹 애플리케이션', 'start': 141, 'end': 148, 'type': 'COM'}","{'word': '자바', 'start': 0, 'end': 1, 'type': 'COM'}",com:made_of
50,"자바()는 썬 마이크로시스템즈의 제임스 고슬링()과 다른 연구원들이 개발한 객체 지향적 프로그래밍 언어이다. 1991년 그린 프로젝트()라는 이름으로 시작해 1995년에 발표했다. 처음에는 가전제품 내에 탑재해 동작하는 프로그램을 위해 개발했지만 현재 웹 애플리케이션 개발에 가장 많이 사용하는 언어 가운데 하나이고, 모바일 기기용 소프트웨어 개발에도 널리 사용하고 있다.","{'word': '모바일 기기용 소프트웨어', 'start': 178, 'end': 190, 'type': 'COM'}","{'word': '자바', 'start': 0, 'end': 1, 'type': 'COM'}",com:made_of
51,"첫 공개 자바 버전은 1995년의 자바 1.0이었다. 한 번 쓰고 어느 곳에도 실행 ""Write Once, Run Anywhere""하는 것을 약속하였고 인기 플랫폼에 무료 런타임을 제공하였다. 이 플랫폼은 꽤 안정성을 지녔고 보안 시스템은 여러 설정을 통해 네트워크 및 파일 접근을 통제할 수 있었다. 대부분의 브라우저들은 곧 자바 애플릿(Java Applet)을 웹 페이지 안에서 실행할 수 있었고 자바의 인기는 급상승했다. 자바 2(JDK 1.2 ~ 1.4)의 출현으로 여러 다양한 플랫폼에서 사용할 수 있는 설정(Configuration)들을 만들었다.","{'word': '자바 2', 'start': 1063, 'end': 1066, 'type': 'COM'}","{'word': '자바 1.0', 'start': 843, 'end': 848, 'type': 'COM'}",com:prior_tech
52,초기 1.0/1.1 버전에서 JDK/JRE의 명칭을 사용하다가 Java 1.2가 발표되면서 J2SDK/J2RE라고 개명하여 사용했으나 기존의 명칭으로 사용하는 사람들이 많아 현재는 다시 JDK/JRE의 명칭으로 돌아왔다.,"{'word': 'Java 1.2', 'start': 3833, 'end': 3840, 'type': 'COM'}","{'word': '1.0/1.1', 'start': 3801, 'end': 3807, 'type': 'COM'}",com:prior_tech
53,또한 J2SE(Java2 Standard Edition)라는 명칭 또한 Java SE(Java Standard Edition)로 변경되었다.,"{'word': 'Java SE', 'start': 3962, 'end': 3968, 'type': 'COM'}","{'word': 'J2SE', 'start': 3925, 'end': 3928, 'type': 'COM'}",com:prior_tech
54,자바의 개발자들은 유닉스 기반의 배경을 가지고 있었기 때문에 문법적인 특성은 파스칼이 아닌 C++의 조상인 C 언어와 비슷하다.,"{'word': '자바', 'start': 226, 'end': 227, 'type': 'COM'}","{'word': 'C 언어', 'start': 286, 'end': 289, 'type': 'COM'}",com:similar_tech
55,자바의 버전은 보통 Java SE 또는 JDK/JRE의 버전으로 말한다.,"{'word': 'Java SE', 'start': 3686, 'end': 3692, 'type': 'COM'}","{'word': 'JDK/JRE', 'start': 3697, 'end': 3703, 'type': 'COM'}",com:similar_tech
56,"스칼라()는 객체 지향 프로그래밍 언어와 함수형 프로그래밍의 요소가 결합된 다중패러다임 프로그래밍 언어이다. ""스칼라""라는 이름은 ""Scalable Language (확장 가능한 언어)""에서 유래된 것이다. 기존의 Java 언어가 너무 복잡하다는 단점을 극복하기 위해 2004년 Martin Odersky가 처음 개발하여 배포했다.","{'word': 'Martin Odersky', 'start': 156, 'end': 169, 'type': 'PER'}","{'word': '스칼라', 'start': 0, 'end': 2, 'type': 'COM'}",per:production
57,"스칼라()는 객체 지향 프로그래밍 언어와 함수형 프로그래밍의 요소가 결합된 다중패러다임 프로그래밍 언어이다. ""스칼라""라는 이름은 ""Scalable Language (확장 가능한 언어)""에서 유래된 것이다. 기존의 Java 언어가 너무 복잡하다는 단점을 극복하기 위해 2004년 Martin Odersky가 처음 개발하여 배포했다.","{'word': '스칼라', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': '2004년', 'start': 150, 'end': 154, 'type': 'DAT'}",com:date_of_prod
58,"스칼라()는 객체 지향 프로그래밍 언어와 함수형 프로그래밍의 요소가 결합된 다중패러다임 프로그래밍 언어이다. ""스칼라""라는 이름은 ""Scalable Language (확장 가능한 언어)""에서 유래된 것이다.","{'word': '다중패러다임 프로그래밍 언어', 'start': 42, 'end': 56, 'type': 'COM'}","{'word': '스칼라', 'start': 0, 'end': 2, 'type': 'COM'}",com:sub_concept
59,스칼라는 다른 언어로 표현할 수 있는 패턴을 매우 간결하게 표현할 수 있는 범용 프로그래밍 언어이다.,"{'word': '범용 프로그래밍 언어', 'start': 372, 'end': 382, 'type': 'COM'}","{'word': '스칼라', 'start': 330, 'end': 332, 'type': 'COM'}",com:sub_concept
60,"자바에서의 자료형은 기본 자료형(int, short, long, float, double, byte, char, boolean)과 참조 자료형(기본 자료형의 조합으로 생성한 클래스)으로 나뉜다.","{'word': '참조 자료형', 'start': 1374, 'end': 1379, 'type': 'COM'}","{'word': '기본 자료형', 'start': 1312, 'end': 1317, 'type': 'COM'}",com:similar_tech
61,이에 반해 스칼라에서는 스몰토크나 루비와 같이 모든 자료형을 객체로 취급하고 있다.,"{'word': '스칼라', 'start': 1483, 'end': 1485, 'type': 'COM'}","{'word': '스몰토크', 'start': 1490, 'end': 1493, 'type': 'COM'}",com:similar_tech
62,이에 반해 스칼라에서는 스몰토크나 루비와 같이 모든 자료형을 객체로 취급하고 있다.,"{'word': '스칼라', 'start': 1483, 'end': 1485, 'type': 'COM'}","{'word': '루비', 'start': 1496, 'end': 1497, 'type': 'COM'}",com:similar_tech
63,초기 컴퓨팅 선구자 모리스 윌크스는 1940년대 말에 자신의 프로그램에 남겨놓은 실수를 찾는데 자신의 남은 인생을 보내겠다는 의미로 그가 깨달은 바를 기술하였다.,"{'word': '모리스 윌크스', 'start': 1161, 'end': 1167, 'type': 'PER'}","{'word': '컴퓨팅 선구자', 'start': 1153, 'end': 1159, 'type': 'POH'}",per:title
64,"예를 들어, 악의적인 사용자는 자주 발생하는 버그인 버퍼 오버플로를 사용해서 원래는 허락되지 않은 일을 할 수 있다.","{'word': '버그', 'start': 320, 'end': 321, 'type': 'COM'}","{'word': '버퍼 오버플로', 'start': 324, 'end': 330, 'type': 'COM'}",com:sub_concept
65,버그를 찾아서 고치는 과정은 디버깅()은 컴퓨터 프로그래밍의 주된 부분이다.,"{'word': '컴퓨터 프로그래밍', 'start': 1130, 'end': 1138, 'type': 'COM'}","{'word': '디버깅', 'start': 1123, 'end': 1125, 'type': 'COM'}",com:sub_concept
66,"소프트웨어 버그() 또는 줄여서 버그()는 소프트웨어가 예상하지 못한 잘못된 결과를 내거나, 오류가 발생하거나, 착오나 오작동이 발생하는 등의 문제를 뜻한다.","{'word': '소프트웨어 버그', 'start': 0, 'end': 7, 'type': 'COM'}","{'word': '소프트웨어', 'start': 24, 'end': 28, 'type': 'COM'}",no_relation
67,최초에는 버그가 하드웨어의 기계적인 오동작을 설명하기 위해 사용된 것으로 보인다.,"{'word': '버그', 'start': 724, 'end': 725, 'type': 'COM'}","{'word': '하드웨어의 기계적인 오동작', 'start': 728, 'end': 741, 'type': 'COM'}",com:similar_tech
68,테스트와 디버깅을 구별하는 것은 1979년 글렌포드 J 마이어스(Glenford J. Myers)가 처음 사용한 것이다.,"{'word': '글렌포드 J 마이어스', 'start': 450, 'end': 460, 'type': 'PER'}","{'word': '테스트와 디버깅을 구별', 'start': 426, 'end': 437, 'type': 'COM'}",per:production
69,테스트와 디버깅을 구별하는 것은 1979년 글렌포드 J 마이어스(Glenford J. Myers)가 처음 사용한 것이다.,"{'word': '테스트와 디버깅을 구별', 'start': 426, 'end': 437, 'type': 'COM'}","{'word': '1979년', 'start': 444, 'end': 448, 'type': 'DAT'}",com:date_of_prod
70,소프트웨어 테스트()는 주요 이해관계자들에게 시험 대상 제품 또는 서비스의 품질에 관한 정보를 제공하는 조사 과정이다.,"{'word': '조사 과정', 'start': 58, 'end': 62, 'type': 'COM'}","{'word': '소프트웨어 테스트', 'start': 0, 'end': 8, 'type': 'COM'}",com:sub_concept
71,시험 기술에는 프로그램이나 응용 프로그램을 실행하여 소프트웨어 버그를 찾는 절차를 포함되나 이에 국한되지는 않는다.,"{'word': '시험 기술', 'start': 146, 'end': 150, 'type': 'COM'}","{'word': '소프트웨어 버그', 'start': 175, 'end': 182, 'type': 'COM'}",com:sub_concept
72,시험 기술에는 프로그램이나 응용 프로그램을 실행하여 소프트웨어 버그를 찾는 절차를 포함되나 이에 국한되지는 않는다. 소프트웨어 결함이 어떻게 일어나는가.,"{'word': '소프트웨어 결함', 'start': 211, 'end': 218, 'type': 'COM'}","{'word': '소프트웨어 버그', 'start': 175, 'end': 182, 'type': 'COM'}",com:alter_names
73,소프트웨어 테스트는 또한 소프트웨어에 대한 객관적이고 독립적인 시각을 제공하여 사업주체가 소프트웨어 구현의 위험성을 올바로 이해하도록 한다.,"{'word': '소프트웨어 테스트', 'start': 67, 'end': 75, 'type': 'COM'}","{'word': '소프트웨어', 'start': 81, 'end': 85, 'type': 'COM'}",no_relation
74,"소프트웨어 테스트의 문제는 단순 제품 이상의 것을 테스트할 때 전반적인 입력, 사전 대비가 가능하지 않다는 것이다.","{'word': '테스트', 'start': 320, 'end': 322, 'type': 'COM'}","{'word': '입력', 'start': 332, 'end': 333, 'type': 'COM'}",no_relation
75,이는 소프트웨어 제품 안의 결함 수가 매우 많으며 드물게 일어나는 결함의 경우 테스트 동안 찾아내기 힘들다는 것을 뜻한다.,"{'word': '소프트웨어 제품', 'start': 360, 'end': 367, 'type': 'COM'}","{'word': '테스트', 'start': 401, 'end': 403, 'type': 'COM'}",no_relation
76,소프트웨어 테스트는 또한 소프트웨어에 대한 객관적이고 독립적인 시각을 제공하여 사업주체가 소프트웨어 구현의 위험성을 올바로 이해하도록 한다.,"{'word': '사업주체', 'start': 111, 'end': 114, 'type': 'ORG'}","{'word': '소프트웨어 구현', 'start': 117, 'end': 124, 'type': 'COM'}",no_relation
77,ISTQB는 소프트웨어 결함이 다음의 과정을 통해 일어난다고 언급한다:,"{'word': 'ISTQB', 'start': 232, 'end': 236, 'type': 'ORG'}","{'word': '소프트웨어 결함', 'start': 239, 'end': 246, 'type': 'COM'}",no_relation
78,알론조 처치가 1930년대에 개발한 람다 대수는 함수에 대한 이론적 기반을 세웠다.,"{'word': '알론조 처치', 'start': 1182, 'end': 1187, 'type': 'PER'}","{'word': '람다 대수', 'start': 1202, 'end': 1206, 'type': 'COM'}",per:production
79,"존 매카시가 만든 리스프는 훨씬 향상된 함수형 프로그래밍 언어였고, 이것은 현대적 함수형 프로그래밍의 여러 특징을 가지고 있었다.","{'word': '존 매카시', 'start': 1316, 'end': 1320, 'type': 'PER'}","{'word': '리스프', 'start': 1326, 'end': 1328, 'type': 'COM'}",per:production
80,"1970년대에 로빈 밀너는 ML을 개발하였고, 데이비드 터너는 미란다를 개발하였다.","{'word': '로빈 밀너', 'start': 1428, 'end': 1432, 'type': 'PER'}","{'word': 'ML', 'start': 1435, 'end': 1436, 'type': 'COM'}",per:production
81,"1970년대에 로빈 밀너는 ML을 개발하였고, 데이비드 터너는 미란다를 개발하였다.","{'word': '데이비드 터너', 'start': 1446, 'end': 1452, 'type': 'PER'}","{'word': '미란다', 'start': 1455, 'end': 1457, 'type': 'COM'}",per:production
82,"함수형 프로그래밍은 1930년대에 계산가능성, 결정문제, 함수정의, 함수응용과 재귀를 연구하기 위해 개발된 형식체계인 람다 대수에 근간을 두고 있다.","{'word': '람다 대수', 'start': 263, 'end': 267, 'type': 'COM'}","{'word': '1930년대', 'start': 208, 'end': 213, 'type': 'DAT'}",com:date_of_prod
83,알론조 처치가 1930년대에 개발한 람다 대수는 함수에 대한 이론적 기반을 세웠다.,"{'word': '람다 대수', 'start': 1202, 'end': 1206, 'type': 'COM'}","{'word': '1930년대', 'start': 1190, 'end': 1195, 'type': 'DAT'}",com:date_of_prod
84,"1970년대에 로빈 밀너는 ML을 개발하였고, 데이비드 터너는 미란다를 개발하였다.","{'word': 'ML', 'start': 1435, 'end': 1436, 'type': 'COM'}","{'word': '1970년대', 'start': 1420, 'end': 1425, 'type': 'DAT'}",com:date_of_prod
85,1980년대에는 그동안의 함수형 프로그래밍에 대한 연구를 바탕으로 순수 함수형 언어인 하스켈이 만들어졌다.,"{'word': '하스켈', 'start': 1561, 'end': 1563, 'type': 'COM'}","{'word': '1980년대', 'start': 1513, 'end': 1518, 'type': 'DAT'}",com:date_of_prod
86,"함수형 프로그래밍(函數型 프로그래밍, )은 자료 처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임의 하나이다.","{'word': '프로그래밍 패러다임', 'start': 66, 'end': 75, 'type': 'COM'}","{'word': '함수형 프로그래밍(函數型 프로그래밍, )', 'start': 0, 'end': 21, 'type': 'COM'}",com:sub_concept
87,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': '스킴', 'start': 706, 'end': 707, 'type': 'COM'}",com:sub_concept
88,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': 'ISLISP', 'start': 710, 'end': 715, 'type': 'COM'}",com:sub_concept
89,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': '클로져', 'start': 718, 'end': 720, 'type': 'COM'}",com:sub_concept
90,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': 'Racket', 'start': 723, 'end': 728, 'type': 'COM'}",com:sub_concept
91,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': '얼랭', 'start': 731, 'end': 732, 'type': 'COM'}",com:sub_concept
92,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': 'OCaml', 'start': 735, 'end': 739, 'type': 'COM'}",com:sub_concept
93,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': '하스켈,', 'start': 742, 'end': 745, 'type': 'COM'}",com:sub_concept
94,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': '스칼라', 'start': 747, 'end': 749, 'type': 'COM'}",com:sub_concept
95,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': 'F#', 'start': 752, 'end': 753, 'type': 'COM'}",com:sub_concept
96,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': '커먼 리스프', 'start': 698, 'end': 703, 'type': 'COM'}",com:sub_concept
97,많이 쓰이는 특정 분야 선언 언어인 SQL과 lex/Yacc는 특히 가변값을 회피하는데 있어 함수형 언어의 요소들을 사용한다.,"{'word': '특정 분야 선언 언어', 'start': 968, 'end': 978, 'type': 'COM'}","{'word': 'SQL', 'start': 981, 'end': 983, 'type': 'COM'}",com:sub_concept
98,많이 쓰이는 특정 분야 선언 언어인 SQL과 lex/Yacc는 특히 가변값을 회피하는데 있어 함수형 언어의 요소들을 사용한다.,"{'word': '특정 분야 선언 언어', 'start': 968, 'end': 978, 'type': 'COM'}","{'word': 'lex/Yacc', 'start': 986, 'end': 993, 'type': 'COM'}",com:sub_concept
99,"예를 들어, 명령형인 펄 프로그래밍 언어는 함수형 프로그래밍 개념을 적용하는 법을 설명하는 책에서 주제로 다루기도 했다.","{'word': '명령형', 'start': 1087, 'end': 1089, 'type': 'COM'}","{'word': '펄 프로그래밍 언어', 'start': 1092, 'end': 1101, 'type': 'COM'}",com:sub_concept
100,처음으로 만들어진 함수형 프로그래밍 언어는 IPL이었다.,"{'word': '함수형 프로그래밍 언어', 'start': 1294, 'end': 1305, 'type': 'COM'}","{'word': 'IPL', 'start': 1308, 'end': 1310, 'type': 'COM'}",com:sub_concept
101,"존 매카시가 만든 리스프는 훨씬 향상된 함수형 프로그래밍 언어였고, 이것은 현대적 함수형 프로그래밍의 여러 특징을 가지고 있었다.","{'word': '함수형 프로그래밍 언어', 'start': 1338, 'end': 1349, 'type': 'COM'}","{'word': '리스프', 'start': 1326, 'end': 1328, 'type': 'COM'}",com:sub_concept
102,"ML의 여러 ""방언""이 개발되었고, 현재 가장 많이 쓰이는 방언은 OCaml이다.","{'word': '방언', 'start': 1500, 'end': 1501, 'type': 'COM'}","{'word': 'OCaml', 'start': 1504, 'end': 1508, 'type': 'COM'}",com:sub_concept
103,1980년대에는 그동안의 함수형 프로그래밍에 대한 연구를 바탕으로 순수 함수형 언어인 하스켈이 만들어졌다.,"{'word': '순수 함수형 언어', 'start': 1550, 'end': 1558, 'type': 'COM'}","{'word': '하스켈', 'start': 1561, 'end': 1563, 'type': 'COM'}",com:sub_concept
104,"C의 printf 함수는 ""x""가 정상적으로 출력되었느냐 여부에 따라 0이나 1 값을 반환한다.","{'word': 'C', 'start': 2109, 'end': 2109, 'type': 'COM'}","{'word': 'printf 함수', 'start': 2112, 'end': 2120, 'type': 'COM'}",com:sub_concept
105,"수학적 함수와 명령형 프로그래밍에서 사용되는 함수는 차이가 있는데, 명령형의 함수는 프로그램의 상태의 값을 바꿀 수 있는 부작용이 생길 수 있다. 이 때문에 명령형 함수는 참조 투명성이 없고, 같은 코드라도 실행되는 프로그램의 상태에 따라 다른 결과값을 낼 수 있다. 반대로 함수형 코드에서는 함수의 출력값은 그 함수에 입력된 인수에만 의존하므로 인수 x에 같은 값을 넣고 함수 f를 호출하면 항상 f(x)라는 결과가 나온다.","{'word': '수학적 함수', 'start': 324, 'end': 329, 'type': 'COM'}","{'word': '함수형 코드', 'start': 478, 'end': 483, 'type': 'COM'}",com:alter_names
106,"순수한 함수(pure function)란, 부작용(side-effect)이 없는 함수, 즉, 함수의 실행이 외부에 영향을 끼치지 않는 함수를 뜻한다.","{'word': '순수한 함수(pure function)', 'start': 1573, 'end': 1593, 'type': 'COM'}","{'word': '부작용(side-effect)이 없는 함수', 'start': 1597, 'end': 1619, 'type': 'COM'}",com:alter_names
107,"순수한 함수(pure function)란, 부작용(side-effect)이 없는 함수, 즉, 함수의 실행이 외부에 영향을 끼치지 않는 함수를 뜻한다.","{'word': '순수한 함수(pure function)', 'start': 1573, 'end': 1593, 'type': 'COM'}","{'word': '함수의 실행이 외부에 영향을 끼치지 않는 함수', 'start': 1625, 'end': 1649, 'type': 'COM'}",com:alter_names
108,"함수 random은 호출할 때마다 결과가 달라질 수 있는, 즉 부작용을 발생시키는 함수다.","{'word': '함수 random', 'start': 1942, 'end': 1950, 'type': 'COM'}","{'word': '부작용을 발생시키는 함수', 'start': 1977, 'end': 1989, 'type': 'COM'}",com:alter_names
109,"익명 함수(anonymous function)란, 이름이 없는 함수를 뜻한다.","{'word': '익명 함수(anonymous function)', 'start': 2244, 'end': 2268, 'type': 'COM'}","{'word': '이름이 없는 함수', 'start': 2272, 'end': 2280, 'type': 'COM'}",com:alter_names
110,"고계 함수(higher-order function)란, 함수를 다루는 함수를 뜻한다.","{'word': '고계 함수(higher-order function)', 'start': 2535, 'end': 2562, 'type': 'COM'}","{'word': '함수를 다루는 함수', 'start': 2566, 'end': 2575, 'type': 'COM'}",com:alter_names
111,"함수형 프로그래밍은 1930년대에 계산가능성, 결정문제, 함수정의, 함수응용과 재귀를 연구하기 위해 개발된 형식체계인 람다 대수에 근간을 두고 있다.","{'word': '함수형 프로그래밍', 'start': 197, 'end': 205, 'type': 'COM'}","{'word': '람다 대수', 'start': 263, 'end': 267, 'type': 'COM'}",com:made_of
112,"함수형 언어는 R (통계), 매스매티카 (기호와 수론 수학), J, K 와 Kx 시스템 기반 (재정 시스템)에서 나온 Q, XQuery/XSLT (XML), Opal 같은 특정 분야 프로그래밍 언어(Domain Specific Language)에서도 사용되고 있다.","{'word': 'R (통계)', 'start': 820, 'end': 825, 'type': 'COM'}","{'word': '함수형 언어', 'start': 812, 'end': 817, 'type': 'COM'}",com:made_of
113,"함수형 언어는 R (통계), 매스매티카 (기호와 수론 수학), J, K 와 Kx 시스템 기반 (재정 시스템)에서 나온 Q, XQuery/XSLT (XML), Opal 같은 특정 분야 프로그래밍 언어(Domain Specific Language)에서도 사용되고 있다.","{'word': '매스매티카 (기호와 수론 수학)', 'start': 828, 'end': 844, 'type': 'COM'}","{'word': '함수형 언어', 'start': 812, 'end': 817, 'type': 'COM'}",com:made_of
114,"함수형 언어는 R (통계), 매스매티카 (기호와 수론 수학), J, K 와 Kx 시스템 기반 (재정 시스템)에서 나온 Q, XQuery/XSLT (XML), Opal 같은 특정 분야 프로그래밍 언어(Domain Specific Language)에서도 사용되고 있다.","{'word': 'Q', 'start': 878, 'end': 878, 'type': 'COM'}","{'word': '함수형 언어', 'start': 812, 'end': 817, 'type': 'COM'}",com:made_of
115,"함수형 언어는 R (통계), 매스매티카 (기호와 수론 수학), J, K 와 Kx 시스템 기반 (재정 시스템)에서 나온 Q, XQuery/XSLT (XML), Opal 같은 특정 분야 프로그래밍 언어(Domain Specific Language)에서도 사용되고 있다.","{'word': 'XQuery/XSLT (XML)', 'start': 881, 'end': 897, 'type': 'COM'}","{'word': '함수형 언어', 'start': 812, 'end': 817, 'type': 'COM'}",com:made_of
116,"함수형 언어는 R (통계), 매스매티카 (기호와 수론 수학), J, K 와 Kx 시스템 기반 (재정 시스템)에서 나온 Q, XQuery/XSLT (XML), Opal 같은 특정 분야 프로그래밍 언어(Domain Specific Language)에서도 사용되고 있다.","{'word': 'Opal', 'start': 900, 'end': 903, 'type': 'COM'}","{'word': '함수형 언어', 'start': 812, 'end': 817, 'type': 'COM'}",com:made_of
117,많이 쓰이는 특정 분야 선언 언어인 SQL과 lex/Yacc는 특히 가변값을 회피하는데 있어 함수형 언어의 요소들을 사용한다.,"{'word': 'SQL', 'start': 981, 'end': 983, 'type': 'COM'}","{'word': '함수형 언어', 'start': 1013, 'end': 1018, 'type': 'COM'}",com:made_of
118,많이 쓰이는 특정 분야 선언 언어인 SQL과 lex/Yacc는 특히 가변값을 회피하는데 있어 함수형 언어의 요소들을 사용한다.,"{'word': 'lex/Yacc', 'start': 986, 'end': 993, 'type': 'COM'}","{'word': '함수형 언어', 'start': 1013, 'end': 1018, 'type': 'COM'}",com:made_of
119,"알론조 처치가 1930년대에 개발한 람다 대수는 함수에 대한 이론적 기반을 세웠다. 이것은 프로그래밍 언어가 아니라 수학적 추상화였지만, 이것은 함수형 프로그래밍의 근간을 이루었다.","{'word': '함수형 프로그래밍', 'start': 1263, 'end': 1271, 'type': 'COM'}","{'word': '람다 대수', 'start': 1202, 'end': 1206, 'type': 'COM'}",com:made_of
120,다음은 하스켈로 작성한 제곱 함수이다.,"{'word': '제곱 함수', 'start': 2424, 'end': 2428, 'type': 'COM'}","{'word': '하스켈', 'start': 2415, 'end': 2417, 'type': 'COM'}",com:made_of
121,위 함수를 람다 표현으로 나타내면 formula_1가 된다.,"{'word': 'formula_1', 'start': 2498, 'end': 2506, 'type': 'COM'}","{'word': '람다 표현', 'start': 2485, 'end': 2489, 'type': 'COM'}",com:made_of
122,리스프를 발전시키고 간단하게 만든 언어로 스킴도 있다.,"{'word': '스킴', 'start': 1412, 'end': 1413, 'type': 'COM'}","{'word': '리스프', 'start': 1389, 'end': 1391, 'type': 'COM'}",com:prior_tech
123,"명령형 프로그래밍에서는 상태를 바꾸는 것을 강조하는 것과는 달리, 함수형 프로그래밍은 함수의 응용을 강조한다.","{'word': '함수형 프로그래밍', 'start': 121, 'end': 129, 'type': 'COM'}","{'word': '명령형 프로그래밍', 'start': 84, 'end': 92, 'type': 'COM'}",no_relation
124,"수학적 함수와 명령형 프로그래밍에서 사용되는 함수는 차이가 있는데, 명령형의 함수는 프로그램의 상태의 값을 바꿀 수 있는 부작용이 생길 수 있다.","{'word': '수학적 함수', 'start': 324, 'end': 329, 'type': 'COM'}","{'word': '명령형 프로그래밍에서 사용되는 함수', 'start': 332, 'end': 350, 'type': 'COM'}",no_relation
125,"수학적 함수와 명령형 프로그래밍에서 사용되는 함수는 차이가 있는데, 명령형의 함수는 프로그램의 상태의 값을 바꿀 수 있는 부작용이 생길 수 있다. 이 때문에 명령형 함수는 참조 투명성이 없고, 같은 코드라도 실행되는 프로그램의 상태에 따라 다른 결과값을 낼 수 있다.","{'word': '수학적 함수', 'start': 324, 'end': 329, 'type': 'COM'}","{'word': '명령형 함수', 'start': 412, 'end': 417, 'type': 'COM'}",no_relation
126,"이 때문에 명령형 함수는 참조 투명성이 없고, 같은 코드라도 실행되는 프로그램의 상태에 따라 다른 결과값을 낼 수 있다. 반대로 함수형 코드에서는 함수의 출력값은 그 함수에 입력된 인수에만 의존하므로 인수 x에 같은 값을 넣고 함수 f를 호출하면 항상 f(x)라는 결과가 나온다.","{'word': '함수형 코드', 'start': 478, 'end': 483, 'type': 'COM'}","{'word': '명령형 함수', 'start': 412, 'end': 417, 'type': 'COM'}",no_relation
127,"명령형 언어에서는 반복문을 이용하여 리스트를 훑어 가며 각 원소를 제곱하겠지만, 함수형 언어에서는 리스트를 다루는 고계 함수로 이를 처리할 수 있다.","{'word': '명령형 언어', 'start': 2807, 'end': 2812, 'type': 'COM'}","{'word': '함수형 언어', 'start': 2852, 'end': 2857, 'type': 'COM'}",no_relation
128,"함수형 프로그래밍(函數型 프로그래밍, )은 자료 처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임의 하나이다. 명령형 프로그래밍에서는 상태를 바꾸는 것을 강조하는 것과는 달리, 함수형 프로그래밍은 함수의 응용을 강조한다. 프로그래밍이 문이 아닌 식이나 선언으로 수행되는 선언형 프로그래밍 패러다임을 따르고 있다.","{'word': '함수형 프로그래밍(函數型 프로그래밍, )', 'start': 0, 'end': 21, 'type': 'COM'}","{'word': '선언형 프로그래밍 패러다임', 'start': 173, 'end': 186, 'type': 'COM'}",com:similar_tech
129,식(蝕)을 뜻하는 이클립스란 이름은 자바를 개발한 회사의 SUN(재단)이란 이름을 염두에 두었다는 말도 있어 2003년도에 썬 마이크로시스템즈는 이클립스 재단에 참여하지 않았던 이유 중의 하나였지만 2005년도에 열린 EclipseCon의 키노트에서 Lee Nackman은 그 목적은 원래 마이크로소프트와 비주얼 스튜디오 생태 시스템을 겨냥한 것이었다고 말했다.,"{'word': 'SUN', 'start': 209, 'end': 211, 'type': 'ORG'}","{'word': '자바', 'start': 197, 'end': 198, 'type': 'COM'}",org:production
130,"2003년 IBM의 래셔널 디비전의 CTO 리 낵먼(Lee Nackman)에 따르면 당시 적어도 2001년부터 쓰인 식(蝕)을 의미하는 ""이클립스""(eclipse)라는 이름은 썬 마이크로시스템즈의 말장난은 아니었으며 명명 당시 제품의 주요 경쟁 제품인 마이크로소프트 비주얼 스튜디오에 대항하여 해당 제품이 가려지게 될 것을 두고 쓰인 말이다.","{'word': '마이크로소프트', 'start': 879, 'end': 885, 'type': 'ORG'}","{'word': '비주얼 스튜디오', 'start': 887, 'end': 894, 'type': 'COM'}",org:production
131,"이클립스()는 자바를 비롯한 다양한 언어를 지원하는 프로그래밍 통합 개발 환경을 목적으로 시작하였으나 현재는 OSGi를 도입하여, 범용 응용 소프트웨어 플랫폼으로 진화하였다.","{'word': '범용 응용 소프트웨어 플랫폼', 'start': 73, 'end': 87, 'type': 'COM'}","{'word': '이클립스', 'start': 0, 'end': 3, 'type': 'COM'}",com:sub_concept
132,"C/C++ 개발자용, 자바 개발자용, 웹 개발자용 등 다양한 배포판이 존재한다.","{'word': '배포판', 'start': 505, 'end': 507, 'type': 'COM'}","{'word': 'C/C++ 개발자용', 'start': 471, 'end': 480, 'type': 'COM'}",com:sub_concept
133,"C/C++ 개발자용, 자바 개발자용, 웹 개발자용 등 다양한 배포판이 존재한다.","{'word': '배포판', 'start': 505, 'end': 507, 'type': 'COM'}","{'word': '자바 개발자용', 'start': 483, 'end': 489, 'type': 'COM'}",com:sub_concept
134,"C/C++ 개발자용, 자바 개발자용, 웹 개발자용 등 다양한 배포판이 존재한다.","{'word': '배포판', 'start': 505, 'end': 507, 'type': 'COM'}","{'word': '웹 개발자용', 'start': 492, 'end': 497, 'type': 'COM'}",com:sub_concept
135,"이클립스 퍼블릭 라이선스(Eclipse Public License, EPL)는 이클립스 프로젝트 출시에 사용되는 근본적인 라이선스이다.","{'word': '라이선스', 'start': 636, 'end': 639, 'type': 'COM'}","{'word': '이클립스 퍼블릭 라이선스', 'start': 568, 'end': 580, 'type': 'COM'}",com:sub_concept
136,"이클립스 퍼블릭 라이선스(Eclipse Public License, EPL)는 이클립스 프로젝트 출시에 사용되는 근본적인 라이선스이다. 일부 프로젝트는 듀얼 라이선스를 요구하여 Eclipse Distribution License(EDL)가 사용되기도 하는데 케이스 바이 케이스 기준으로 고려되어야 한다.","{'word': '라이선스', 'start': 636, 'end': 639, 'type': 'COM'}","{'word': 'Eclipse Distribution License', 'start': 667, 'end': 694, 'type': 'COM'}",com:sub_concept
137,이클립스의 GUI 위젯은 자바를 위한 위젯 툴킷인 SWT로 구현되었다.,"{'word': '자바를 위한 위젯 툴킷', 'start': 1274, 'end': 1285, 'type': 'COM'}","{'word': 'SWT', 'start': 1288, 'end': 1290, 'type': 'COM'}",com:sub_concept
138,"또한 이클립스의 사용자 인터페이스는 또 하나의 중간 GUI 계층인 JFace를 사용하여, 이는 SWT 기반의 응용 작성을 좀 더 쉽게 만들어 준다.","{'word': '중간 GUI 계층', 'start': 1373, 'end': 1381, 'type': 'COM'}","{'word': 'JFace', 'start': 1384, 'end': 1388, 'type': 'COM'}",com:sub_concept
139,이 플러그인 메커니즘은 경량화한 소프트웨어 컴포넌트 프레임워크라할 수 있다.,"{'word': '소프트웨어 컴포넌트 프레임워크', 'start': 1541, 'end': 1556, 'type': 'COM'}","{'word': '플러그인 메커니즘', 'start': 1525, 'end': 1533, 'type': 'COM'}",com:sub_concept
140,"플러그인 프레임워크를 활용하면, 자바가 아닌 다른 프로그래밍 언어, 예를 들면, C 언어나 파이썬 언어로 이클립스를 확장하는 것이 가능할 뿐 아니라, 이클립스에서 LaTeX와 같은 조판 언어를 활용하거나, 텔넷과 같은 네트워크 응용을 실행하거나, 데이터베이스 관리를 하는 것도 가능하다.","{'word': '프로그래밍 언어', 'start': 1594, 'end': 1601, 'type': 'COM'}","{'word': 'C 언어', 'start': 1611, 'end': 1614, 'type': 'COM'}",com:sub_concept
141,"플러그인 프레임워크를 활용하면, 자바가 아닌 다른 프로그래밍 언어, 예를 들면, C 언어나 파이썬 언어로 이클립스를 확장하는 것이 가능할 뿐 아니라, 이클립스에서 LaTeX와 같은 조판 언어를 활용하거나, 텔넷과 같은 네트워크 응용을 실행하거나, 데이터베이스 관리를 하는 것도 가능하다.","{'word': '프로그래밍 언어', 'start': 1594, 'end': 1601, 'type': 'COM'}","{'word': '파이썬', 'start': 1617, 'end': 1619, 'type': 'COM'}",com:sub_concept
142,"플러그인 프레임워크를 활용하면, 자바가 아닌 다른 프로그래밍 언어, 예를 들면, C 언어나 파이썬 언어로 이클립스를 확장하는 것이 가능할 뿐 아니라, 이클립스에서 LaTeX와 같은 조판 언어를 활용하거나, 텔넷과 같은 네트워크 응용을 실행하거나, 데이터베이스 관리를 하는 것도 가능하다.","{'word': '조판 언어', 'start': 1667, 'end': 1671, 'type': 'COM'}","{'word': 'LaTeX', 'start': 1657, 'end': 1661, 'type': 'COM'}",com:sub_concept
143,"플러그인 프레임워크를 활용하면, 자바가 아닌 다른 프로그래밍 언어, 예를 들면, C 언어나 파이썬 언어로 이클립스를 확장하는 것이 가능할 뿐 아니라, 이클립스에서 LaTeX와 같은 조판 언어를 활용하거나, 텔넷과 같은 네트워크 응용을 실행하거나, 데이터베이스 관리를 하는 것도 가능하다.","{'word': '네트워크 응용', 'start': 1688, 'end': 1694, 'type': 'COM'}","{'word': '텔넷', 'start': 1681, 'end': 1682, 'type': 'COM'}",com:sub_concept
144,"이클립스 SDK에는 이클립스 자바 개발 툴(Java Development Tools)이 포함되어 있는데, 이는 자바 컴파일러를 내장하고 있고, 자바 소스 파일 전체 모델을 제공한다.","{'word': '이클립스 SDK', 'start': 1819, 'end': 1826, 'type': 'COM'}","{'word': '이클립스 자바 개발 툴(Java Development Tools)', 'start': 1830, 'end': 1865, 'type': 'COM'}",com:sub_concept
145,"이클립스 SDK에는 이클립스 자바 개발 툴(Java Development Tools)이 포함되어 있는데, 이는 자바 컴파일러를 내장하고 있고, 자바 소스 파일 전체 모델을 제공한다.","{'word': '이클립스 자바 개발 툴(Java Development Tools)', 'start': 1830, 'end': 1865, 'type': 'COM'}","{'word': '자바 컴파일러', 'start': 1881, 'end': 1887, 'type': 'COM'}",com:sub_concept
146,"이클립스()는 자바를 비롯한 다양한 언어를 지원하는 프로그래밍 통합 개발 환경을 목적으로 시작하였으나 현재는 OSGi를 도입하여, 범용 응용 소프트웨어 플랫폼으로 진화하였다.","{'word': '이클립스', 'start': 0, 'end': 3, 'type': 'COM'}","{'word': 'OSGi', 'start': 61, 'end': 64, 'type': 'COM'}",com:made_of
147,"이클립스()는 자바를 비롯한 다양한 언어를 지원하는 프로그래밍 통합 개발 환경을 목적으로 시작하였으나 현재는 OSGi를 도입하여, 범용 응용 소프트웨어 플랫폼으로 진화하였다. 자바로 작성되어 있으며, 자유 소프트웨어이지만 막강한 기능을 자랑한다. 2004년과 2005년 졸트 어워드(Jolt Award)를 수상했다.","{'word': '이클립스', 'start': 0, 'end': 3, 'type': 'COM'}","{'word': '자바', 'start': 98, 'end': 99, 'type': 'COM'}",com:made_of
148,이클립스의 GUI 위젯은 자바를 위한 위젯 툴킷인 SWT로 구현되었다.,"{'word': '이클립스의 GUI 위젯', 'start': 1260, 'end': 1271, 'type': 'COM'}","{'word': 'SWT', 'start': 1288, 'end': 1290, 'type': 'COM'}",com:made_of
149,"이클립스는 RCP를 포함한 상위의 모든 기능을 제공하기 위해, 플러그인을 사용한다.","{'word': '이클립스', 'start': 1430, 'end': 1433, 'type': 'COM'}","{'word': '플러그인', 'start': 1465, 'end': 1468, 'type': 'COM'}",com:made_of
150,"1954년 IBM의 존 배커스가 개발한 포트란은 기계어의 이런 장애물을 없애고, 복잡한 프로그램을 작성할 수 있는 최초의 주요한 언어였다.","{'word': '존 배커스', 'start': 1269, 'end': 1273, 'type': 'PER'}","{'word': '포트란', 'start': 1280, 'end': 1282, 'type': 'COM'}",per:production
151,"1970년대에는 니클라우스 버트가 파스칼을 개발하고, 데니스 리치가 벨 연구소에서 일하던 시절 C를 개발하였다.","{'word': '니클라우스 버트', 'start': 1606, 'end': 1613, 'type': 'PER'}","{'word': '파스칼', 'start': 1616, 'end': 1618, 'type': 'COM'}",per:production
152,"1970년대에는 니클라우스 버트가 파스칼을 개발하고, 데니스 리치가 벨 연구소에서 일하던 시절 C를 개발하였다.","{'word': '데니스 리치', 'start': 1627, 'end': 1632, 'type': 'PER'}","{'word': 'C', 'start': 1650, 'end': 1650, 'type': 'COM'}",per:production
153,"버트는 계속해서 모듈라-2, 모듈라-3와 오베론을 개발하였다.","{'word': '버트', 'start': 1660, 'end': 1661, 'type': 'PER'}","{'word': '모듈라-2', 'start': 1669, 'end': 1673, 'type': 'COM'}",per:production
154,"버트는 계속해서 모듈라-2, 모듈라-3와 오베론을 개발하였다.","{'word': '버트', 'start': 1660, 'end': 1661, 'type': 'PER'}","{'word': '모듈라-3', 'start': 1676, 'end': 1680, 'type': 'COM'}",per:production
155,"버트는 계속해서 모듈라-2, 모듈라-3와 오베론을 개발하였다.","{'word': '버트', 'start': 1660, 'end': 1661, 'type': 'PER'}","{'word': '오베론', 'start': 1683, 'end': 1685, 'type': 'COM'}",per:production
156,"미국 국방부의 필요에 따라, 쟌 이시비아와 허니웰에 있는 팀이 에이다를 설계하였다.","{'word': '쟌 이시비아와 허니웰', 'start': 1711, 'end': 1721, 'type': 'PER'}","{'word': '에이다', 'start': 1730, 'end': 1732, 'type': 'COM'}",per:production
157,"스몰토크-80은 앨런 케이가 1969년에 처음 생각했는데, 1980년에 제록스 팔로 알토 연구센터에서 출시되었다.","{'word': '앨런 케이', 'start': 1932, 'end': 1936, 'type': 'PER'}","{'word': '스몰토크-80', 'start': 1923, 'end': 1929, 'type': 'COM'}",per:production
158,시뮬라(세계 최초의 객체 지향 프로그래밍 언어로 알려졌다.) 등의 다른 객체지향 언어를 참고하여 비야네 스트롭스트룹이 C를 바탕으로 하여 C++를 설계했다.,"{'word': '비야네 스트롭스트룹', 'start': 2041, 'end': 2050, 'type': 'PER'}","{'word': 'C++', 'start': 2064, 'end': 2066, 'type': 'COM'}",per:production
159,1980년대 후반과 1990년대에는 래리 월이 1987년 객체지향 언어의 개념을 수용한 탁월한 명령형 언어인 펄(Perl)을 출시하였다.,"{'word': '래리 월', 'start': 2116, 'end': 2119, 'type': 'PER'}","{'word': '펄(Perl)', 'start': 2157, 'end': 2163, 'type': 'COM'}",per:production
160,"귀도 반 로섬이 1990년에 파이썬을 출시하였고, 래스무스 러도르프가 1994년에 PHP를 출시하였으며, 역시 1994년 썬마이크로시스템즈에서 자바가 나왔다.","{'word': '귀도 반 로섬', 'start': 2173, 'end': 2179, 'type': 'PER'}","{'word': '파이썬', 'start': 2189, 'end': 2191, 'type': 'COM'}",per:production
161,"귀도 반 로섬이 1990년에 파이썬을 출시하였고, 래스무스 러도르프가 1994년에 PHP를 출시하였으며, 역시 1994년 썬마이크로시스템즈에서 자바가 나왔다.","{'word': '래스무스 러도르프', 'start': 2201, 'end': 2209, 'type': 'PER'}","{'word': 'PHP', 'start': 2219, 'end': 2221, 'type': 'COM'}",per:production
162,"1954년 IBM의 존 배커스가 개발한 포트란은 기계어의 이런 장애물을 없애고, 복잡한 프로그램을 작성할 수 있는 최초의 주요한 언어였다.","{'word': 'IBM', 'start': 1264, 'end': 1266, 'type': 'ORG'}","{'word': '포트란', 'start': 1280, 'end': 1282, 'type': 'COM'}",org:production
163,"스몰토크-80은 앨런 케이가 1969년에 처음 생각했는데, 1980년에 제록스 팔로 알토 연구센터에서 출시되었다.","{'word': '제록스 팔로 알토 연구센터', 'start': 1963, 'end': 1976, 'type': 'ORG'}","{'word': '스몰토크-80', 'start': 1923, 'end': 1929, 'type': 'COM'}",org:production
164,"귀도 반 로섬이 1990년에 파이썬을 출시하였고, 래스무스 러도르프가 1994년에 PHP를 출시하였으며, 역시 1994년 썬마이크로시스템즈에서 자바가 나왔다.","{'word': '썬마이크로시스템즈', 'start': 2241, 'end': 2249, 'type': 'ORG'}","{'word': '자바', 'start': 2253, 'end': 2254, 'type': 'COM'}",org:production
165,"1954년 IBM의 존 배커스가 개발한 포트란은 기계어의 이런 장애물을 없애고, 복잡한 프로그램을 작성할 수 있는 최초의 주요한 언어였다.","{'word': '포트란', 'start': 1280, 'end': 1282, 'type': 'COM'}","{'word': '1954년', 'start': 1258, 'end': 1262, 'type': 'DAT'}",com:date_of_prod
166,"1950년대 후반과 1960년대에는 수학적 알고리즘을 더 쉽게 표현하기 위하여 알골이 개발되었는데, 몇몇 컴퓨터 운영 체제의 언어로 쓰이기도 했다.","{'word': '알골', 'start': 1507, 'end': 1508, 'type': 'COM'}","{'word': '1950년대 후반과 1960년대', 'start': 1463, 'end': 1479, 'type': 'DAT'}",com:date_of_prod
167,코볼(1960년)과 베이직(1964년)은 프로그래밍 구문을 더 영어와 비슷하게 표현하였다.,"{'word': '코볼', 'start': 1546, 'end': 1547, 'type': 'COM'}","{'word': '1960년', 'start': 1549, 'end': 1553, 'type': 'DAT'}",com:date_of_prod
168,코볼(1960년)과 베이직(1964년)은 프로그래밍 구문을 더 영어와 비슷하게 표현하였다.,"{'word': '베이직', 'start': 1557, 'end': 1559, 'type': 'COM'}","{'word': '1964년', 'start': 1561, 'end': 1565, 'type': 'DAT'}",com:date_of_prod
169,"1970년대에는 니클라우스 버트가 파스칼을 개발하고, 데니스 리치가 벨 연구소에서 일하던 시절 C를 개발하였다.","{'word': '파스칼', 'start': 1616, 'end': 1618, 'type': 'COM'}","{'word': '1970년대', 'start': 1597, 'end': 1602, 'type': 'DAT'}",com:date_of_prod
170,"스몰토크-80은 앨런 케이가 1969년에 처음 생각했는데, 1980년에 제록스 팔로 알토 연구센터에서 출시되었다.","{'word': '스몰토크-80', 'start': 1923, 'end': 1929, 'type': 'COM'}","{'word': '1980년', 'start': 1956, 'end': 1960, 'type': 'DAT'}",com:date_of_prod
171,C++는 1985년 처음 구현되었다.,"{'word': 'C++', 'start': 2075, 'end': 2077, 'type': 'COM'}","{'word': '1985년', 'start': 2080, 'end': 2084, 'type': 'DAT'}",com:date_of_prod
172,1980년대 후반과 1990년대에는 래리 월이 1987년 객체지향 언어의 개념을 수용한 탁월한 명령형 언어인 펄(Perl)을 출시하였다.,"{'word': '펄(Perl)', 'start': 2157, 'end': 2163, 'type': 'COM'}","{'word': '1980년대 후반과 1990년대', 'start': 2096, 'end': 2112, 'type': 'DAT'}",com:date_of_prod
173,"귀도 반 로섬이 1990년에 파이썬을 출시하였고, 래스무스 러도르프가 1994년에 PHP를 출시하였으며, 역시 1994년 썬마이크로시스템즈에서 자바가 나왔다.","{'word': '파이썬', 'start': 2189, 'end': 2191, 'type': 'COM'}","{'word': '1990년', 'start': 2182, 'end': 2186, 'type': 'DAT'}",com:date_of_prod
174,"귀도 반 로섬이 1990년에 파이썬을 출시하였고, 래스무스 러도르프가 1994년에 PHP를 출시하였으며, 역시 1994년 썬마이크로시스템즈에서 자바가 나왔다.","{'word': 'PHP', 'start': 2219, 'end': 2221, 'type': 'COM'}","{'word': '1994년', 'start': 2212, 'end': 2216, 'type': 'DAT'}",com:date_of_prod
175,"귀도 반 로섬이 1990년에 파이썬을 출시하였고, 래스무스 러도르프가 1994년에 PHP를 출시하였으며, 역시 1994년 썬마이크로시스템즈에서 자바가 나왔다.","{'word': '자바', 'start': 2253, 'end': 2254, 'type': 'COM'}","{'word': '1994년', 'start': 2235, 'end': 2239, 'type': 'DAT'}",com:date_of_prod
176,"컴퓨터 과학에서 명령형 프로그래밍(命令型 프로그래밍, )은 선언형 프로그래밍과 반대되는 개념으로, 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 프로그래밍 패러다임의 일종이다.","{'word': '컴퓨터 과학', 'start': 0, 'end': 5, 'type': 'COM'}","{'word': '명령형 프로그래밍', 'start': 9, 'end': 17, 'type': 'COM'}",com:sub_concept
177,"컴퓨터 과학에서 명령형 프로그래밍(命令型 프로그래밍, )은 선언형 프로그래밍과 반대되는 개념으로, 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 프로그래밍 패러다임의 일종이다.","{'word': '컴퓨터 과학', 'start': 0, 'end': 5, 'type': 'COM'}","{'word': '선언형 프로그래밍', 'start': 33, 'end': 41, 'type': 'COM'}",com:sub_concept
178,"컴퓨터 과학에서 명령형 프로그래밍(命令型 프로그래밍, )은 선언형 프로그래밍과 반대되는 개념으로, 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 프로그래밍 패러다임의 일종이다.","{'word': '프로그래밍 패러다임', 'start': 94, 'end': 103, 'type': 'COM'}","{'word': '명령형 프로그래밍', 'start': 9, 'end': 17, 'type': 'COM'}",com:sub_concept
179,"하스켈 같은 함수형 프로그래밍 언어는 구문들을 순서대로 써 놓은 것이 아니며, 명령형 프로그래밍 언어와는 다르게 전역적인 상태가 없다.","{'word': '함수형 프로그래밍 언어', 'start': 257, 'end': 268, 'type': 'COM'}","{'word': '하스켈', 'start': 250, 'end': 252, 'type': 'COM'}",com:sub_concept
180,"프롤로그와 같은 논리 프로그래밍 언어는 ""어떻게"" 계산을 할지보다는 ""무엇""이 계산될 것인지를 정의한다는 생각으로 작성된다.","{'word': '논리 프로그래밍 언어', 'start': 335, 'end': 345, 'type': 'COM'}","{'word': '프롤로그', 'start': 326, 'end': 329, 'type': 'COM'}",com:sub_concept
181,"여러 언어에서 제공하는 GOTO문, 서브프로그램, 프로시저, 호출문들이 비조건 분기문이다.","{'word': '비조건 분기문', 'start': 1156, 'end': 1162, 'type': 'COM'}","{'word': '호출문', 'start': 1150, 'end': 1152, 'type': 'COM'}",com:sub_concept
182,"여러 언어에서 제공하는 GOTO문, 서브프로그램, 프로시저, 호출문들이 비조건 분기문이다.","{'word': '비조건 분기문', 'start': 1156, 'end': 1162, 'type': 'COM'}","{'word': '프로시저', 'start': 1144, 'end': 1147, 'type': 'COM'}",com:sub_concept
183,"여러 언어에서 제공하는 GOTO문, 서브프로그램, 프로시저, 호출문들이 비조건 분기문이다.","{'word': '비조건 분기문', 'start': 1156, 'end': 1162, 'type': 'COM'}","{'word': '서브프로그램', 'start': 1136, 'end': 1141, 'type': 'COM'}",com:sub_concept
184,"여러 언어에서 제공하는 GOTO문, 서브프로그램, 프로시저, 호출문들이 비조건 분기문이다.","{'word': '비조건 분기문', 'start': 1156, 'end': 1162, 'type': 'COM'}","{'word': 'GOTO문', 'start': 1129, 'end': 1133, 'type': 'COM'}",com:sub_concept
185,최초의 명령형 언어는 원시 컴퓨터의 기계어였다.,"{'word': '명령형 언어', 'start': 1171, 'end': 1176, 'type': 'COM'}","{'word': '기계어', 'start': 1187, 'end': 1189, 'type': 'COM'}",com:sub_concept
186,"포트란은 컴파일 언어였는데, 변수의 이름을 붙일 수 있고, 복잡한 수식을 계산할 수 있었으며, 서브프로그램과 명령형 언어의 많은 특징을 가지고 있다.","{'word': '컴파일 언어', 'start': 1341, 'end': 1346, 'type': 'COM'}","{'word': '포트란', 'start': 1336, 'end': 1338, 'type': 'COM'}",com:sub_concept
187,명령형 프로그래밍의 전형적인 예는 포트란과 알골이다.,"{'word': '명령형 프로그래밍', 'start': 2262, 'end': 2270, 'type': 'COM'}","{'word': '포트란', 'start': 2281, 'end': 2283, 'type': 'COM'}",com:sub_concept
188,명령형 프로그래밍의 전형적인 예는 포트란과 알골이다.,"{'word': '명령형 프로그래밍', 'start': 2262, 'end': 2270, 'type': 'COM'}","{'word': '알골', 'start': 2286, 'end': 2287, 'type': 'COM'}",com:sub_concept
189,"명령형 프로그래밍의 전형적인 예는 포트란과 알골이다. 파스칼, C, 에이다는 또 다른 예이다.","{'word': '명령형 프로그래밍', 'start': 2262, 'end': 2270, 'type': 'COM'}","{'word': '파스칼', 'start': 2292, 'end': 2294, 'type': 'COM'}",com:sub_concept
190,"명령형 프로그래밍의 전형적인 예는 포트란과 알골이다. 파스칼, C, 에이다는 또 다른 예이다.","{'word': '명령형 프로그래밍', 'start': 2262, 'end': 2270, 'type': 'COM'}","{'word': 'C', 'start': 2297, 'end': 2297, 'type': 'COM'}",com:sub_concept
191,"명령형 프로그래밍의 전형적인 예는 포트란과 알골이다. 파스칼, C, 에이다는 또 다른 예이다.","{'word': '명령형 프로그래밍', 'start': 2262, 'end': 2270, 'type': 'COM'}","{'word': '에이다', 'start': 2300, 'end': 2302, 'type': 'COM'}",com:sub_concept
192,거의 대부분의 컴퓨터 하드웨어는 명령형으로 구현된다.,"{'word': '컴퓨터 하드웨어', 'start': 404, 'end': 411, 'type': 'COM'}","{'word': '명령형', 'start': 414, 'end': 416, 'type': 'COM'}",com:made_of
193,"거의 모든 컴퓨터 하드웨어들이 컴퓨터의 고유 언어인 기계어를 실행하도록 설계되어 있는데, 이것이 명령형으로 씌어 있다.","{'word': '컴퓨터 하드웨어', 'start': 432, 'end': 439, 'type': 'COM'}","{'word': '명령형', 'start': 480, 'end': 482, 'type': 'COM'}",com:made_of
194,"컴퓨터 과학에서 명령형 프로그래밍(命令型 프로그래밍, )은 선언형 프로그래밍과 반대되는 개념으로, 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 프로그래밍 패러다임의 일종이다.","{'word': '명령형 프로그래밍', 'start': 9, 'end': 17, 'type': 'COM'}","{'word': '선언형 프로그래밍', 'start': 33, 'end': 41, 'type': 'COM'}",no_relation
195,명령형 프로그래밍 언어는 함수형 프로그래밍이나 논리형 프로그래밍 언어와 같은 다른 형태의 언어와 다르다.,"{'word': '명령형 프로그래밍 언어', 'start': 191, 'end': 202, 'type': 'COM'}","{'word': '논리형 프로그래밍 언어', 'start': 217, 'end': 228, 'type': 'COM'}",no_relation
196,"하스켈 같은 함수형 프로그래밍 언어는 구문들을 순서대로 써 놓은 것이 아니며, 명령형 프로그래밍 언어와는 다르게 전역적인 상태가 없다.","{'word': '함수형 프로그래밍 언어', 'start': 257, 'end': 268, 'type': 'COM'}","{'word': '명령형 프로그래밍 언어', 'start': 294, 'end': 305, 'type': 'COM'}",no_relation
197,시뮬라(세계 최초의 객체 지향 프로그래밍 언어로 알려졌다.) 등의 다른 객체지향 언어를 참고하여 비야네 스트롭스트룹이 C를 바탕으로 하여 C++를 설계했다.,"{'word': 'C++', 'start': 2064, 'end': 2066, 'type': 'COM'}","{'word': 'C', 'start': 2053, 'end': 2053, 'type': 'COM'}",com:similar_tech
198,"컴퓨터 프로그래밍에서, 소프트웨어 프레임워크(software framework)는 복잡한 문제를 해결하거나 서술하는 데 사용되는 기본 개념 구조이다.","{'word': '컴퓨터 프로그래밍', 'start': 0, 'end': 8, 'type': 'COM'}","{'word': '소프트웨어 프레임워크', 'start': 13, 'end': 23, 'type': 'COM'}",com:sub_concept
199,리스프는 1958년 스티브 러셀이 IBM 704 컴퓨터에 최초로 구현하였다.,"{'word': '스티브 러셀', 'start': 959, 'end': 964, 'type': 'PER'}","{'word': '리스프', 'start': 948, 'end': 950, 'type': 'COM'}",per:production
200,리스프는 1958년 스티브 러셀이 IBM 704 컴퓨터에 최초로 구현하였다.,"{'word': '리스프', 'start': 948, 'end': 950, 'type': 'COM'}","{'word': '1958년', 'start': 953, 'end': 957, 'type': 'DAT'}",com:date_of_prod
201,"인터프리터(, )는 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경을 말한다.","{'word': '컴퓨터 프로그램', 'start': 36, 'end': 43, 'type': 'COM'}","{'word': '인터프리터', 'start': 0, 'end': 4, 'type': 'COM'}",com:sub_concept
202,"인터프리터(, )는 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경을 말한다.","{'word': '환경', 'start': 48, 'end': 49, 'type': 'COM'}","{'word': '인터프리터', 'start': 0, 'end': 4, 'type': 'COM'}",com:sub_concept
203,인터프리터는 다음의 과정 가운데 적어도 한 가지 기능을 가진 프로그램이다.,"{'word': '프로그램', 'start': 120, 'end': 123, 'type': 'COM'}","{'word': '인터프리터', 'start': 86, 'end': 90, 'type': 'COM'}",com:sub_concept
204,인터프리터는 고급 언어로 작성된 원시코드 명령어들을 한번에 한 줄씩 읽어들여서 실행하는 프로그램이다.,"{'word': '프로그램', 'start': 177, 'end': 180, 'type': 'COM'}","{'word': '인터프리터', 'start': 128, 'end': 132, 'type': 'COM'}",com:sub_concept
205,인터프리터와 컴파일러는 둘 다 대부분의 고급언어에 적용이 가능하지만 BASIC 이나 LISP과 같은 일부 언어들은 개발 당시에는 특별히 인터프리터에 의해서만 실행되도록 설계되었다.,"{'word': '언어', 'start': 779, 'end': 780, 'type': 'COM'}","{'word': 'BASIC', 'start': 758, 'end': 762, 'type': 'COM'}",com:sub_concept
206,인터프리터와 컴파일러는 둘 다 대부분의 고급언어에 적용이 가능하지만 BASIC 이나 LISP과 같은 일부 언어들은 개발 당시에는 특별히 인터프리터에 의해서만 실행되도록 설계되었다.,"{'word': '언어', 'start': 779, 'end': 780, 'type': 'COM'}","{'word': 'LISP', 'start': 767, 'end': 770, 'type': 'COM'}",com:sub_concept
207,그 외에도 포스트스크립트와 같은 페이지 기술 언어 들도 인터프리터를 사용한다.,"{'word': '페이지 기술 언어', 'start': 839, 'end': 847, 'type': 'COM'}","{'word': '포스트스크립트', 'start': 827, 'end': 833, 'type': 'COM'}",com:sub_concept
208,최초의 인터프리트 방식의 고급 언어는 리스프였다.,"{'word': '고급 언어', 'start': 934, 'end': 938, 'type': 'COM'}","{'word': '리스프', 'start': 941, 'end': 943, 'type': 'COM'}",com:sub_concept
209,리스프는 1958년 스티브 러셀이 IBM 704 컴퓨터에 최초로 구현하였다.,"{'word': 'IBM 704', 'start': 967, 'end': 973, 'type': 'COM'}","{'word': '컴퓨터', 'start': 975, 'end': 977, 'type': 'COM'}",com:alter_names
210,인터프리터는 고급 언어로 작성된 원시코드 명령어들을 한번에 한 줄씩 읽어들여서 실행하는 프로그램이다.,"{'word': '원시코드 명령어', 'start': 146, 'end': 153, 'type': 'COM'}","{'word': '고급 언어', 'start': 135, 'end': 139, 'type': 'COM'}",com:made_of
211,고급언어로 작성된 프로그램들을 실행하는 데에는 두 가지 방법이 있다.,"{'word': '프로그램', 'start': 195, 'end': 198, 'type': 'COM'}","{'word': '고급언어', 'start': 185, 'end': 188, 'type': 'COM'}",com:made_of
212,리스프는 1958년 스티브 러셀이 IBM 704 컴퓨터에 최초로 구현하였다.,"{'word': 'IBM 704', 'start': 967, 'end': 973, 'type': 'COM'}","{'word': '리스프', 'start': 948, 'end': 950, 'type': 'COM'}",com:made_of
213,"인터프리터(, )는 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경을 말한다. 원시 코드를 기계어로 번역하는 컴파일러와 대비된다.","{'word': '인터프리터', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': '컴파일러', 'start': 74, 'end': 77, 'type': 'COM'}",no_relation
214,"가장 일반적인 방법은 프로그램을 컴파일 하는 것이고, 다른 하나는 프로그램을 인터프리터에 통과시키는 방법이다.","{'word': '인터프리터', 'start': 267, 'end': 271, 'type': 'COM'}","{'word': '컴파일', 'start': 242, 'end': 244, 'type': 'COM'}",no_relation
215,"인터프리터는 고급 명령어들을 중간 형태로 번역한 다음, 그것을 실행한다.","{'word': '인터프리터', 'start': 286, 'end': 290, 'type': 'COM'}","{'word': '명령어', 'start': 296, 'end': 298, 'type': 'COM'}",no_relation
216,"이와는 대조적으로, 컴파일러는 고급 명령어들을 직접 기계어로 번역한다.","{'word': '컴파일러', 'start': 338, 'end': 341, 'type': 'COM'}","{'word': '명령어', 'start': 347, 'end': 349, 'type': 'COM'}",no_relation
217,인터프리터와 컴파일러는 둘 다 대부분의 고급언어에 적용이 가능하지만 BASIC 이나 LISP과 같은 일부 언어들은 개발 당시에는 특별히 인터프리터에 의해서만 실행되도록 설계되었다.,"{'word': '컴파일러', 'start': 727, 'end': 730, 'type': 'COM'}","{'word': '인터프리터', 'start': 720, 'end': 724, 'type': 'COM'}",no_relation
