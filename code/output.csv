id,sentence,subject_entity,object_entity,label
0,프로그래밍 패러다임(programming paradigm)은 프로그래밍의 패러다임 형태이다. 소프트웨어 공학을 할 때의 패러다임 형태인 방법론과 비교된다.,"{'word': '소프트웨어 공학', 'start': 52, 'end': 59, 'type': 'COM'}","{'word': '프로그래밍 패러다임', 'start': 0, 'end': 9, 'type': 'COM'}",com:sub_concept
1,소프트웨어 공학을 할 때의 패러다임 형태인 방법론과 비교된다.,"{'word': '소프트웨어 공학', 'start': 52, 'end': 59, 'type': 'COM'}","{'word': '방법론', 'start': 76, 'end': 78, 'type': 'COM'}",com:sub_concept
2,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '언어', 'start': 502, 'end': 503, 'type': 'COM'}","{'word': '오즈', 'start': 477, 'end': 478, 'type': 'COM'}",com:sub_concept
3,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '언어', 'start': 502, 'end': 503, 'type': 'COM'}","{'word': '자바', 'start': 493, 'end': 494, 'type': 'COM'}",com:sub_concept
4,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '언어', 'start': 502, 'end': 503, 'type': 'COM'}","{'word': '커먼 리스프', 'start': 464, 'end': 469, 'type': 'COM'}",com:sub_concept
5,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '언어', 'start': 502, 'end': 503, 'type': 'COM'}","{'word': '파이썬', 'start': 472, 'end': 474, 'type': 'COM'}",com:sub_concept
6,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '표준 API', 'start': 659, 'end': 664, 'type': 'COM'}","{'word': 'Stream', 'start': 648, 'end': 653, 'type': 'COM'}",com:sub_concept
7,"자바에서 람다식은 함수형 인터페이스를 구현하는 익명클래스의 인스턴스를 생성하며, 좀 더 간단한 표현을 위해 컴파일러의 타입 추론이 동원된다."" )","{'word': '자바', 'start': 736, 'end': 737, 'type': 'COM'}","{'word': '람다식', 'start': 741, 'end': 743, 'type': 'COM'}",com:sub_concept
8,"자바에서 람다식은 함수형 인터페이스를 구현하는 익명클래스의 인스턴스를 생성하며, 좀 더 간단한 표현을 위해 컴파일러의 타입 추론이 동원된다."" )","{'word': '익명클래스', 'start': 762, 'end': 766, 'type': 'COM'}","{'word': '인스턴스', 'start': 769, 'end': 772, 'type': 'COM'}",com:sub_concept
9,"자바에서 람다식은 함수형 인터페이스를 구현하는 익명클래스의 인스턴스를 생성하며, 좀 더 간단한 표현을 위해 컴파일러의 타입 추론이 동원된다."" )","{'word': '컴파일러', 'start': 796, 'end': 799, 'type': 'COM'}","{'word': '타입 추론', 'start': 802, 'end': 806, 'type': 'COM'}",com:sub_concept
10,"어떤 언어들은 하나의 특정한 패러다임을 지원하기도 하는데, 스몰토크와 jdk 1.8 이전의 자바가 객체지향 프로그래밍을 지원하는 반면에, 하스켈과 스킴은 함수형 프로그래밍을 지원한다.","{'word': '객체지향 프로그래밍', 'start': 389, 'end': 398, 'type': 'COM'}","{'word': '자바', 'start': 385, 'end': 386, 'type': 'COM'}",com:made_of
11,"어떤 언어들은 하나의 특정한 패러다임을 지원하기도 하는데, 스몰토크와 jdk 1.8 이전의 자바가 객체지향 프로그래밍을 지원하는 반면에, 하스켈과 스킴은 함수형 프로그래밍을 지원한다.","{'word': '객체지향 프로그래밍', 'start': 389, 'end': 398, 'type': 'COM'}","{'word': '스몰토크', 'start': 367, 'end': 370, 'type': 'COM'}",com:made_of
12,"어떤 언어들은 하나의 특정한 패러다임을 지원하기도 하는데, 스몰토크와 jdk 1.8 이전의 자바가 객체지향 프로그래밍을 지원하는 반면에, 하스켈과 스킴은 함수형 프로그래밍을 지원한다.","{'word': '함수형 프로그래밍', 'start': 420, 'end': 428, 'type': 'COM'}","{'word': '스킴', 'start': 416, 'end': 417, 'type': 'COM'}",com:made_of
13,"어떤 언어들은 하나의 특정한 패러다임을 지원하기도 하는데, 스몰토크와 jdk 1.8 이전의 자바가 객체지향 프로그래밍을 지원하는 반면에, 하스켈과 스킴은 함수형 프로그래밍을 지원한다.","{'word': '함수형 프로그래밍', 'start': 420, 'end': 428, 'type': 'COM'}","{'word': '하스켈', 'start': 411, 'end': 413, 'type': 'COM'}",com:made_of
14,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '함수형 프로그래밍 패러다임', 'start': 576, 'end': 589, 'type': 'COM'}","{'word': '람다식', 'start': 600, 'end': 602, 'type': 'COM'}",com:made_of
15,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '함수형 프로그래밍 패러다임', 'start': 576, 'end': 589, 'type': 'COM'}","{'word': '생성자 레퍼런스', 'start': 605, 'end': 612, 'type': 'COM'}",com:made_of
16,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '함수형 프로그래밍 패러다임', 'start': 576, 'end': 589, 'type': 'COM'}","{'word': '메서드 레퍼런스', 'start': 615, 'end': 622, 'type': 'COM'}",com:made_of
17,"여러 가지 패러다임을 지원하는 언어들도 있는데, 커먼 리스프, 파이썬, 오즈, jdk 1.8 이상의 자바 등이 이런 언어들이다. (""몇년 전까지 자바는 명령형 프로그래밍, 객체지향 프로그래밍 패러다임을 따르기로 유명했다. 하지만 jdk 1.8 부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입했고 선언형 프로그래밍의 장려를 위해 Stream과 같은 표준 API 등도 추가했다.","{'word': '선언형 프로그래밍', 'start': 630, 'end': 638, 'type': 'COM'}","{'word': '표준 API', 'start': 659, 'end': 664, 'type': 'COM'}",com:made_of
18,"예를 들어서 C++는 절차적 프로그래밍, 객체기반 프로그래밍, 객체지향 프로그래밍, 제네릭 프로그래밍의 요소들을 지원하도록 설계되었다.","{'word': '절차적 프로그래밍', 'start': 1211, 'end': 1219, 'type': 'COM'}","{'word': 'C++', 'start': 1206, 'end': 1208, 'type': 'COM'}",com:made_of
19,"예를 들어서 C++는 절차적 프로그래밍, 객체기반 프로그래밍, 객체지향 프로그래밍, 제네릭 프로그래밍의 요소들을 지원하도록 설계되었다.","{'word': '객체기반 프로그래밍', 'start': 1222, 'end': 1231, 'type': 'COM'}","{'word': 'C++', 'start': 1206, 'end': 1208, 'type': 'COM'}",com:made_of
20,"예를 들어서 C++는 절차적 프로그래밍, 객체기반 프로그래밍, 객체지향 프로그래밍, 제네릭 프로그래밍의 요소들을 지원하도록 설계되었다.","{'word': '객체지향 프로그래밍', 'start': 1234, 'end': 1243, 'type': 'COM'}","{'word': 'C++', 'start': 1206, 'end': 1208, 'type': 'COM'}",com:made_of
21,"예를 들어서 C++는 절차적 프로그래밍, 객체기반 프로그래밍, 객체지향 프로그래밍, 제네릭 프로그래밍의 요소들을 지원하도록 설계되었다.","{'word': '제네릭 프로그래밍', 'start': 1246, 'end': 1254, 'type': 'COM'}","{'word': 'C++', 'start': 1206, 'end': 1208, 'type': 'COM'}",com:made_of
22,"C++에서는 순수하게 절차적 프로그램을 작성할 수 있고, 순수하게 객체지향 프로그램을 작성할 수 있으며, 두 가지 패러다임 모두의 요소를 포함한 프로그램을 작성할 수도 있다.","{'word': '절차적 프로그램', 'start': 1287, 'end': 1294, 'type': 'COM'}","{'word': 'C++', 'start': 1275, 'end': 1277, 'type': 'COM'}",com:made_of
23,"C++에서는 순수하게 절차적 프로그램을 작성할 수 있고, 순수하게 객체지향 프로그램을 작성할 수 있으며, 두 가지 패러다임 모두의 요소를 포함한 프로그램을 작성할 수도 있다.","{'word': '객체지향 프로그램', 'start': 1312, 'end': 1320, 'type': 'COM'}","{'word': 'C++', 'start': 1275, 'end': 1277, 'type': 'COM'}",com:made_of
24,"예를 들어, 안드로이드 앱 개발자는 기본적으로 자바와 안드로이드를 알지만, 때로 웹 앱 개발이 유리한 경우에는 HTML, CSS, Javascript의 사용이 필요할 수 있고, 안드로이드 공식 개발 언어가 Kotlin으로 바뀌었으므로 그 또한 필요할 수 있다.","{'word': '웹 앱 개발', 'start': 2185, 'end': 2190, 'type': 'COM'}","{'word': 'HTML', 'start': 2202, 'end': 2205, 'type': 'COM'}",com:made_of
25,"예를 들어, 안드로이드 앱 개발자는 기본적으로 자바와 안드로이드를 알지만, 때로 웹 앱 개발이 유리한 경우에는 HTML, CSS, Javascript의 사용이 필요할 수 있고, 안드로이드 공식 개발 언어가 Kotlin으로 바뀌었으므로 그 또한 필요할 수 있다.","{'word': '웹 앱 개발', 'start': 2185, 'end': 2190, 'type': 'COM'}","{'word': 'CSS', 'start': 2208, 'end': 2210, 'type': 'COM'}",com:made_of
26,"예를 들어, 안드로이드 앱 개발자는 기본적으로 자바와 안드로이드를 알지만, 때로 웹 앱 개발이 유리한 경우에는 HTML, CSS, Javascript의 사용이 필요할 수 있고, 안드로이드 공식 개발 언어가 Kotlin으로 바뀌었으므로 그 또한 필요할 수 있다.","{'word': '웹 앱 개발', 'start': 2185, 'end': 2190, 'type': 'COM'}","{'word': 'Javascript', 'start': 2213, 'end': 2222, 'type': 'COM'}",com:made_of
27,"예를 들어, 안드로이드 앱 개발자는 기본적으로 자바와 안드로이드를 알지만, 때로 웹 앱 개발이 유리한 경우에는 HTML, CSS, Javascript의 사용이 필요할 수 있고, 안드로이드 공식 개발 언어가 Kotlin으로 바뀌었으므로 그 또한 필요할 수 있다.","{'word': '웹 앱 개발', 'start': 2185, 'end': 2190, 'type': 'COM'}","{'word': 'Kotlin', 'start': 2255, 'end': 2260, 'type': 'COM'}",com:made_of
28,"데이터베이스 사용에선 RDBMS를 주로 사용하던 이전과 달리 NoSQL의 대두로 여러 패러다임의 이해가 요구될 수 있다. ( ""NoSQL 은 RDB의 관계지향 패러다임과 같이 하나의 패러다임이 적용된 것이 아니고, 여러 다양한 철학이 적용되어 있다.","{'word': '데이터베이스', 'start': 2648, 'end': 2653, 'type': 'COM'}","{'word': 'RDBMS', 'start': 2660, 'end': 2664, 'type': 'COM'}",com:made_of
29,"데이터베이스 사용에선 RDBMS를 주로 사용하던 이전과 달리 NoSQL의 대두로 여러 패러다임의 이해가 요구될 수 있다. ( ""NoSQL 은 RDB의 관계지향 패러다임과 같이 하나의 패러다임이 적용된 것이 아니고, 여러 다양한 철학이 적용되어 있다.","{'word': '데이터베이스', 'start': 2648, 'end': 2653, 'type': 'COM'}","{'word': 'NoSQL', 'start': 2682, 'end': 2686, 'type': 'COM'}",com:made_of
30,프로그래밍 패러다임(programming paradigm)은 프로그래밍의 패러다임 형태이다. 소프트웨어 공학을 할 때의 패러다임 형태인 방법론과 비교된다.,"{'word': '프로그래밍 패러다임', 'start': 0, 'end': 9, 'type': 'COM'}","{'word': '방법론', 'start': 76, 'end': 78, 'type': 'COM'}",no_relation
31,"예를 들어 객체지향 프로그래밍은 프로그래머들이 프로그램을 상호작용하는 객체들의 집합으로 볼 수 있게 하는 반면에, 함수형 프로그래밍은 상태값을 지니지 않는 함수값들의 연속으로 생각할 수 있게 해준다.","{'word': '객체지향 프로그래밍', 'start': 146, 'end': 155, 'type': 'COM'}","{'word': '함수형 프로그래밍', 'start': 204, 'end': 212, 'type': 'COM'}",no_relation
32,"예를 들어, 순수 함수형 프로그래밍은 부작용의 사용을 허용하지 않는다. 구조적 프로그래밍은 GOTO문의 사용을 제한한다.","{'word': '순수 함수형 프로그래밍', 'start': 882, 'end': 893, 'type': 'COM'}","{'word': '구조적 프로그래밍', 'start': 915, 'end': 923, 'type': 'COM'}",no_relation
33,"자바나 PHP와 같이 기존부터 있던 언어들에는 본래 없던 패러다임이 추가되고, Swift나 Go, Kotlin과 같이 비교적 새로 만들어지는 언어들은 처음부터 여러 패러다임의 지원을 고려하여 설계된다.","{'word': '자바', 'start': 1407, 'end': 1408, 'type': 'COM'}","{'word': 'PHP', 'start': 1411, 'end': 1413, 'type': 'COM'}",com:similar_tech
34,"자바나 PHP와 같이 기존부터 있던 언어들에는 본래 없던 패러다임이 추가되고, Swift나 Go, Kotlin과 같이 비교적 새로 만들어지는 언어들은 처음부터 여러 패러다임의 지원을 고려하여 설계된다.","{'word': 'Swift', 'start': 1451, 'end': 1455, 'type': 'COM'}","{'word': 'Go', 'start': 1458, 'end': 1459, 'type': 'COM'}",com:similar_tech
35,"자바나 PHP와 같이 기존부터 있던 언어들에는 본래 없던 패러다임이 추가되고, Swift나 Go, Kotlin과 같이 비교적 새로 만들어지는 언어들은 처음부터 여러 패러다임의 지원을 고려하여 설계된다.","{'word': 'Swift', 'start': 1451, 'end': 1455, 'type': 'COM'}","{'word': 'Kotlin', 'start': 1462, 'end': 1467, 'type': 'COM'}",com:similar_tech
36,"예를 들어, 안드로이드 앱 개발자는 기본적으로 자바와 안드로이드를 알지만, 때로 웹 앱 개발이 유리한 경우에는 HTML, CSS, Javascript의 사용이 필요할 수 있고, 안드로이드 공식 개발 언어가 Kotlin으로 바뀌었으므로 그 또한 필요할 수 있다.","{'word': '자바', 'start': 2166, 'end': 2167, 'type': 'COM'}","{'word': '안드로이드', 'start': 2170, 'end': 2174, 'type': 'COM'}",com:similar_tech
37,다른 예로는 자바 기반 프로젝트의 특정 맥락에서 자바 대신 자바 가상머신 지원 언어를 사용하는 것을 생각해 볼 수 있다.,"{'word': '자바', 'start': 2528, 'end': 2529, 'type': 'COM'}","{'word': '자바 가상머신 지원 언어', 'start': 2534, 'end': 2546, 'type': 'COM'}",com:similar_tech
38,"데이터베이스 사용에선 RDBMS를 주로 사용하던 이전과 달리 NoSQL의 대두로 여러 패러다임의 이해가 요구될 수 있다. ( ""NoSQL 은 RDB의 관계지향 패러다임과 같이 하나의 패러다임이 적용된 것이 아니고, 여러 다양한 철학이 적용되어 있다.","{'word': 'RDBMS', 'start': 2660, 'end': 2664, 'type': 'COM'}","{'word': 'NoSQL', 'start': 2682, 'end': 2686, 'type': 'COM'}",com:similar_tech
39,자바()는 썬 마이크로시스템즈의 제임스 고슬링()과 다른 연구원들이 개발한 객체 지향적 프로그래밍 언어이다.,"{'word': '제임스 고슬링', 'start': 18, 'end': 24, 'type': 'PER'}","{'word': '자바', 'start': 0, 'end': 1, 'type': 'COM'}",per:production
40,자바 언어는 1991년 6월 셋톱 프로젝트를 위해 제임스 고슬링(James Gosling)이 만들었다.,"{'word': '제임스 고슬링', 'start': 648, 'end': 654, 'type': 'PER'}","{'word': '자바 언어', 'start': 620, 'end': 624, 'type': 'COM'}",per:production
41,자바()는 썬 마이크로시스템즈의 제임스 고슬링()과 다른 연구원들이 개발한 객체 지향적 프로그래밍 언어이다.,"{'word': '썬 마이크로시스템즈', 'start': 6, 'end': 15, 'type': 'ORG'}","{'word': '자바', 'start': 0, 'end': 1, 'type': 'COM'}",org:production
42,썬 마이크로시스템즈는 자바의 대부분을 무료로 배포하였으나 오픈이 아닌 사유 소프트웨어였다.,"{'word': '썬 마이크로시스템즈', 'start': 1464, 'end': 1473, 'type': 'ORG'}","{'word': '자바', 'start': 1476, 'end': 1477, 'type': 'COM'}",org:production
43,2006년 11월 13일 썬 마이크로시스템즈는 대부분은 자바를 GPL 라이선스로 소스를 오픈하였으며 2007년 5월 8일 이 과정을 마쳤다.,"{'word': '썬 마이크로시스템즈', 'start': 1699, 'end': 1708, 'type': 'ORG'}","{'word': '자바', 'start': 1716, 'end': 1717, 'type': 'COM'}",org:production
44,"현재 오라클 공식 홈페이지에서 JDK 16, Java.net에서 JDK 9가 배포 중이며, 다운로드 페이지 오른쪽에 있는 약관 동의에 체크하고 그 아래 링크를 이용해 다운로드 받을 수 있다.","{'word': '오라클', 'start': 4748, 'end': 4750, 'type': 'ORG'}","{'word': 'JDK 9', 'start': 4781, 'end': 4785, 'type': 'COM'}",org:production
45,2009년 4월 20일 제작사인 썬 마이크로시스템즈가 오라클과 인수 합병됨에 따라 자바에 대한 권리 및 유지보수 또한 오라클로 넘어가게 되었다.,"{'word': '오라클', 'start': 1839, 'end': 1841, 'type': 'ORG'}","{'word': '썬 마이크로시스템즈', 'start': 1827, 'end': 1836, 'type': 'ORG'}",org:members
46,자바 언어는 1991년 6월 셋톱 프로젝트를 위해 제임스 고슬링(James Gosling)이 만들었다.,"{'word': '자바 언어', 'start': 620, 'end': 624, 'type': 'COM'}","{'word': '1991년 6월', 'start': 627, 'end': 634, 'type': 'DAT'}",com:date_of_prod
47,첫 공개 자바 버전은 1995년의 자바 1.0이었다.,"{'word': '자바 1.0', 'start': 843, 'end': 848, 'type': 'COM'}","{'word': '1995년', 'start': 836, 'end': 840, 'type': 'DAT'}",com:date_of_prod
48,2006년 11월 13일 썬 마이크로시스템즈는 대부분은 자바를 GPL 라이선스로 소스를 오픈하였으며 2007년 5월 8일 이 과정을 마쳤다.,"{'word': '자바', 'start': 1716, 'end': 1717, 'type': 'COM'}","{'word': '2006년 11월 13일', 'start': 1685, 'end': 1697, 'type': 'DAT'}",com:date_of_prod
49,"자바()는 썬 마이크로시스템즈의 제임스 고슬링()과 다른 연구원들이 개발한 객체 지향적 프로그래밍 언어이다. 1991년 그린 프로젝트()라는 이름으로 시작해 1995년에 발표했다. 처음에는 가전제품 내에 탑재해 동작하는 프로그램을 위해 개발했지만 현재 웹 애플리케이션 개발에 가장 많이 사용하는 언어 가운데 하나이고, 모바일 기기용 소프트웨어 개발에도 널리 사용하고 있다.","{'word': '웹 애플리케이션', 'start': 141, 'end': 148, 'type': 'COM'}","{'word': '자바', 'start': 0, 'end': 1, 'type': 'COM'}",com:made_of
50,"자바()는 썬 마이크로시스템즈의 제임스 고슬링()과 다른 연구원들이 개발한 객체 지향적 프로그래밍 언어이다. 1991년 그린 프로젝트()라는 이름으로 시작해 1995년에 발표했다. 처음에는 가전제품 내에 탑재해 동작하는 프로그램을 위해 개발했지만 현재 웹 애플리케이션 개발에 가장 많이 사용하는 언어 가운데 하나이고, 모바일 기기용 소프트웨어 개발에도 널리 사용하고 있다.","{'word': '모바일 기기용 소프트웨어', 'start': 178, 'end': 190, 'type': 'COM'}","{'word': '자바', 'start': 0, 'end': 1, 'type': 'COM'}",com:made_of
51,"첫 공개 자바 버전은 1995년의 자바 1.0이었다. 한 번 쓰고 어느 곳에도 실행 ""Write Once, Run Anywhere""하는 것을 약속하였고 인기 플랫폼에 무료 런타임을 제공하였다. 이 플랫폼은 꽤 안정성을 지녔고 보안 시스템은 여러 설정을 통해 네트워크 및 파일 접근을 통제할 수 있었다. 대부분의 브라우저들은 곧 자바 애플릿(Java Applet)을 웹 페이지 안에서 실행할 수 있었고 자바의 인기는 급상승했다. 자바 2(JDK 1.2 ~ 1.4)의 출현으로 여러 다양한 플랫폼에서 사용할 수 있는 설정(Configuration)들을 만들었다.","{'word': '자바 2', 'start': 1063, 'end': 1066, 'type': 'COM'}","{'word': '자바 1.0', 'start': 843, 'end': 848, 'type': 'COM'}",com:prior_tech
52,초기 1.0/1.1 버전에서 JDK/JRE의 명칭을 사용하다가 Java 1.2가 발표되면서 J2SDK/J2RE라고 개명하여 사용했으나 기존의 명칭으로 사용하는 사람들이 많아 현재는 다시 JDK/JRE의 명칭으로 돌아왔다.,"{'word': 'Java 1.2', 'start': 3833, 'end': 3840, 'type': 'COM'}","{'word': '1.0/1.1', 'start': 3801, 'end': 3807, 'type': 'COM'}",com:prior_tech
53,또한 J2SE(Java2 Standard Edition)라는 명칭 또한 Java SE(Java Standard Edition)로 변경되었다.,"{'word': 'Java SE', 'start': 3962, 'end': 3968, 'type': 'COM'}","{'word': 'J2SE', 'start': 3925, 'end': 3928, 'type': 'COM'}",com:prior_tech
54,자바의 개발자들은 유닉스 기반의 배경을 가지고 있었기 때문에 문법적인 특성은 파스칼이 아닌 C++의 조상인 C 언어와 비슷하다.,"{'word': '자바', 'start': 226, 'end': 227, 'type': 'COM'}","{'word': 'C 언어', 'start': 286, 'end': 289, 'type': 'COM'}",com:similar_tech
55,자바의 버전은 보통 Java SE 또는 JDK/JRE의 버전으로 말한다.,"{'word': 'Java SE', 'start': 3686, 'end': 3692, 'type': 'COM'}","{'word': 'JDK/JRE', 'start': 3697, 'end': 3703, 'type': 'COM'}",com:similar_tech
56,"스칼라()는 객체 지향 프로그래밍 언어와 함수형 프로그래밍의 요소가 결합된 다중패러다임 프로그래밍 언어이다. ""스칼라""라는 이름은 ""Scalable Language (확장 가능한 언어)""에서 유래된 것이다. 기존의 Java 언어가 너무 복잡하다는 단점을 극복하기 위해 2004년 Martin Odersky가 처음 개발하여 배포했다.","{'word': 'Martin Odersky', 'start': 156, 'end': 169, 'type': 'PER'}","{'word': '스칼라', 'start': 0, 'end': 2, 'type': 'COM'}",per:production
57,"스칼라()는 객체 지향 프로그래밍 언어와 함수형 프로그래밍의 요소가 결합된 다중패러다임 프로그래밍 언어이다. ""스칼라""라는 이름은 ""Scalable Language (확장 가능한 언어)""에서 유래된 것이다. 기존의 Java 언어가 너무 복잡하다는 단점을 극복하기 위해 2004년 Martin Odersky가 처음 개발하여 배포했다.","{'word': '스칼라', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': '2004년', 'start': 150, 'end': 154, 'type': 'DAT'}",com:date_of_prod
58,"스칼라()는 객체 지향 프로그래밍 언어와 함수형 프로그래밍의 요소가 결합된 다중패러다임 프로그래밍 언어이다. ""스칼라""라는 이름은 ""Scalable Language (확장 가능한 언어)""에서 유래된 것이다.","{'word': '다중패러다임 프로그래밍 언어', 'start': 42, 'end': 56, 'type': 'COM'}","{'word': '스칼라', 'start': 0, 'end': 2, 'type': 'COM'}",com:sub_concept
59,스칼라는 다른 언어로 표현할 수 있는 패턴을 매우 간결하게 표현할 수 있는 범용 프로그래밍 언어이다.,"{'word': '범용 프로그래밍 언어', 'start': 372, 'end': 382, 'type': 'COM'}","{'word': '스칼라', 'start': 330, 'end': 332, 'type': 'COM'}",com:sub_concept
60,"자바에서의 자료형은 기본 자료형(int, short, long, float, double, byte, char, boolean)과 참조 자료형(기본 자료형의 조합으로 생성한 클래스)으로 나뉜다.","{'word': '참조 자료형', 'start': 1374, 'end': 1379, 'type': 'COM'}","{'word': '기본 자료형', 'start': 1312, 'end': 1317, 'type': 'COM'}",com:similar_tech
61,이에 반해 스칼라에서는 스몰토크나 루비와 같이 모든 자료형을 객체로 취급하고 있다.,"{'word': '스칼라', 'start': 1483, 'end': 1485, 'type': 'COM'}","{'word': '스몰토크', 'start': 1490, 'end': 1493, 'type': 'COM'}",com:similar_tech
62,이에 반해 스칼라에서는 스몰토크나 루비와 같이 모든 자료형을 객체로 취급하고 있다.,"{'word': '스칼라', 'start': 1483, 'end': 1485, 'type': 'COM'}","{'word': '루비', 'start': 1496, 'end': 1497, 'type': 'COM'}",com:similar_tech
63,초기 컴퓨팅 선구자 모리스 윌크스는 1940년대 말에 자신의 프로그램에 남겨놓은 실수를 찾는데 자신의 남은 인생을 보내겠다는 의미로 그가 깨달은 바를 기술하였다.,"{'word': '모리스 윌크스', 'start': 1161, 'end': 1167, 'type': 'PER'}","{'word': '컴퓨팅 선구자', 'start': 1153, 'end': 1159, 'type': 'POH'}",per:title
64,"예를 들어, 악의적인 사용자는 자주 발생하는 버그인 버퍼 오버플로를 사용해서 원래는 허락되지 않은 일을 할 수 있다.","{'word': '버그', 'start': 320, 'end': 321, 'type': 'COM'}","{'word': '버퍼 오버플로', 'start': 324, 'end': 330, 'type': 'COM'}",com:sub_concept
65,버그를 찾아서 고치는 과정은 디버깅()은 컴퓨터 프로그래밍의 주된 부분이다.,"{'word': '컴퓨터 프로그래밍', 'start': 1130, 'end': 1138, 'type': 'COM'}","{'word': '디버깅', 'start': 1123, 'end': 1125, 'type': 'COM'}",com:sub_concept
66,"소프트웨어 버그() 또는 줄여서 버그()는 소프트웨어가 예상하지 못한 잘못된 결과를 내거나, 오류가 발생하거나, 착오나 오작동이 발생하는 등의 문제를 뜻한다.","{'word': '소프트웨어 버그', 'start': 0, 'end': 7, 'type': 'COM'}","{'word': '소프트웨어', 'start': 24, 'end': 28, 'type': 'COM'}",no_relation
67,최초에는 버그가 하드웨어의 기계적인 오동작을 설명하기 위해 사용된 것으로 보인다.,"{'word': '버그', 'start': 724, 'end': 725, 'type': 'COM'}","{'word': '하드웨어의 기계적인 오동작', 'start': 728, 'end': 741, 'type': 'COM'}",com:similar_tech
68,테스트와 디버깅을 구별하는 것은 1979년 글렌포드 J 마이어스(Glenford J. Myers)가 처음 사용한 것이다.,"{'word': '글렌포드 J 마이어스', 'start': 450, 'end': 460, 'type': 'PER'}","{'word': '테스트와 디버깅을 구별', 'start': 426, 'end': 437, 'type': 'COM'}",per:production
69,테스트와 디버깅을 구별하는 것은 1979년 글렌포드 J 마이어스(Glenford J. Myers)가 처음 사용한 것이다.,"{'word': '테스트와 디버깅을 구별', 'start': 426, 'end': 437, 'type': 'COM'}","{'word': '1979년', 'start': 444, 'end': 448, 'type': 'DAT'}",com:date_of_prod
70,소프트웨어 테스트()는 주요 이해관계자들에게 시험 대상 제품 또는 서비스의 품질에 관한 정보를 제공하는 조사 과정이다.,"{'word': '조사 과정', 'start': 58, 'end': 62, 'type': 'COM'}","{'word': '소프트웨어 테스트', 'start': 0, 'end': 8, 'type': 'COM'}",com:sub_concept
71,시험 기술에는 프로그램이나 응용 프로그램을 실행하여 소프트웨어 버그를 찾는 절차를 포함되나 이에 국한되지는 않는다.,"{'word': '시험 기술', 'start': 146, 'end': 150, 'type': 'COM'}","{'word': '소프트웨어 버그', 'start': 175, 'end': 182, 'type': 'COM'}",com:sub_concept
72,시험 기술에는 프로그램이나 응용 프로그램을 실행하여 소프트웨어 버그를 찾는 절차를 포함되나 이에 국한되지는 않는다. 소프트웨어 결함이 어떻게 일어나는가.,"{'word': '소프트웨어 결함', 'start': 211, 'end': 218, 'type': 'COM'}","{'word': '소프트웨어 버그', 'start': 175, 'end': 182, 'type': 'COM'}",com:alter_names
73,소프트웨어 테스트는 또한 소프트웨어에 대한 객관적이고 독립적인 시각을 제공하여 사업주체가 소프트웨어 구현의 위험성을 올바로 이해하도록 한다.,"{'word': '소프트웨어 테스트', 'start': 67, 'end': 75, 'type': 'COM'}","{'word': '소프트웨어', 'start': 81, 'end': 85, 'type': 'COM'}",no_relation
74,"소프트웨어 테스트의 문제는 단순 제품 이상의 것을 테스트할 때 전반적인 입력, 사전 대비가 가능하지 않다는 것이다.","{'word': '테스트', 'start': 320, 'end': 322, 'type': 'COM'}","{'word': '입력', 'start': 332, 'end': 333, 'type': 'COM'}",no_relation
75,이는 소프트웨어 제품 안의 결함 수가 매우 많으며 드물게 일어나는 결함의 경우 테스트 동안 찾아내기 힘들다는 것을 뜻한다.,"{'word': '소프트웨어 제품', 'start': 360, 'end': 367, 'type': 'COM'}","{'word': '테스트', 'start': 401, 'end': 403, 'type': 'COM'}",no_relation
76,소프트웨어 테스트는 또한 소프트웨어에 대한 객관적이고 독립적인 시각을 제공하여 사업주체가 소프트웨어 구현의 위험성을 올바로 이해하도록 한다.,"{'word': '사업주체', 'start': 111, 'end': 114, 'type': 'ORG'}","{'word': '소프트웨어 구현', 'start': 117, 'end': 124, 'type': 'COM'}",no_relation
77,ISTQB는 소프트웨어 결함이 다음의 과정을 통해 일어난다고 언급한다:,"{'word': 'ISTQB', 'start': 232, 'end': 236, 'type': 'ORG'}","{'word': '소프트웨어 결함', 'start': 239, 'end': 246, 'type': 'COM'}",no_relation
78,알론조 처치가 1930년대에 개발한 람다 대수는 함수에 대한 이론적 기반을 세웠다.,"{'word': '알론조 처치', 'start': 1182, 'end': 1187, 'type': 'PER'}","{'word': '람다 대수', 'start': 1202, 'end': 1206, 'type': 'COM'}",per:production
79,"존 매카시가 만든 리스프는 훨씬 향상된 함수형 프로그래밍 언어였고, 이것은 현대적 함수형 프로그래밍의 여러 특징을 가지고 있었다.","{'word': '존 매카시', 'start': 1316, 'end': 1320, 'type': 'PER'}","{'word': '리스프', 'start': 1326, 'end': 1328, 'type': 'COM'}",per:production
80,"1970년대에 로빈 밀너는 ML을 개발하였고, 데이비드 터너는 미란다를 개발하였다.","{'word': '로빈 밀너', 'start': 1428, 'end': 1432, 'type': 'PER'}","{'word': 'ML', 'start': 1435, 'end': 1436, 'type': 'COM'}",per:production
81,"1970년대에 로빈 밀너는 ML을 개발하였고, 데이비드 터너는 미란다를 개발하였다.","{'word': '데이비드 터너', 'start': 1446, 'end': 1452, 'type': 'PER'}","{'word': '미란다', 'start': 1455, 'end': 1457, 'type': 'COM'}",per:production
82,"함수형 프로그래밍은 1930년대에 계산가능성, 결정문제, 함수정의, 함수응용과 재귀를 연구하기 위해 개발된 형식체계인 람다 대수에 근간을 두고 있다.","{'word': '람다 대수', 'start': 263, 'end': 267, 'type': 'COM'}","{'word': '1930년대', 'start': 208, 'end': 213, 'type': 'DAT'}",com:date_of_prod
83,알론조 처치가 1930년대에 개발한 람다 대수는 함수에 대한 이론적 기반을 세웠다.,"{'word': '람다 대수', 'start': 1202, 'end': 1206, 'type': 'COM'}","{'word': '1930년대', 'start': 1190, 'end': 1195, 'type': 'DAT'}",com:date_of_prod
84,"1970년대에 로빈 밀너는 ML을 개발하였고, 데이비드 터너는 미란다를 개발하였다.","{'word': 'ML', 'start': 1435, 'end': 1436, 'type': 'COM'}","{'word': '1970년대', 'start': 1420, 'end': 1425, 'type': 'DAT'}",com:date_of_prod
85,1980년대에는 그동안의 함수형 프로그래밍에 대한 연구를 바탕으로 순수 함수형 언어인 하스켈이 만들어졌다.,"{'word': '하스켈', 'start': 1561, 'end': 1563, 'type': 'COM'}","{'word': '1980년대', 'start': 1513, 'end': 1518, 'type': 'DAT'}",com:date_of_prod
86,"함수형 프로그래밍(函數型 프로그래밍, )은 자료 처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임의 하나이다.","{'word': '프로그래밍 패러다임', 'start': 66, 'end': 75, 'type': 'COM'}","{'word': '함수형 프로그래밍(函數型 프로그래밍, )', 'start': 0, 'end': 21, 'type': 'COM'}",com:sub_concept
87,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': '스킴', 'start': 706, 'end': 707, 'type': 'COM'}",com:sub_concept
88,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': 'ISLISP', 'start': 710, 'end': 715, 'type': 'COM'}",com:sub_concept
89,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': '클로져', 'start': 718, 'end': 720, 'type': 'COM'}",com:sub_concept
90,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': 'Racket', 'start': 723, 'end': 728, 'type': 'COM'}",com:sub_concept
91,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': '얼랭', 'start': 731, 'end': 732, 'type': 'COM'}",com:sub_concept
92,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': 'OCaml', 'start': 735, 'end': 739, 'type': 'COM'}",com:sub_concept
93,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': '하스켈,', 'start': 742, 'end': 745, 'type': 'COM'}",com:sub_concept
94,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': '스칼라', 'start': 747, 'end': 749, 'type': 'COM'}",com:sub_concept
95,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': 'F#', 'start': 752, 'end': 753, 'type': 'COM'}",com:sub_concept
96,"Hope같은 최초의 순수 함수형 언어는 상업적 소프트웨어 개발보다는 학계에서 많은 관심을 받았다. 하지만 커먼 리스프, 스킴, ISLISP, 클로져, Racket, 얼랭, OCaml, 하스켈, 스칼라, F# 같은 주요 함수형 언어들은 광범위한 기관에서 산업적이고 상업적인 응용 프로그램 개발에 사용되고 있다.","{'word': '함수형 언어', 'start': 761, 'end': 766, 'type': 'COM'}","{'word': '커먼 리스프', 'start': 698, 'end': 703, 'type': 'COM'}",com:sub_concept
97,많이 쓰이는 특정 분야 선언 언어인 SQL과 lex/Yacc는 특히 가변값을 회피하는데 있어 함수형 언어의 요소들을 사용한다.,"{'word': '특정 분야 선언 언어', 'start': 968, 'end': 978, 'type': 'COM'}","{'word': 'SQL', 'start': 981, 'end': 983, 'type': 'COM'}",com:sub_concept
98,많이 쓰이는 특정 분야 선언 언어인 SQL과 lex/Yacc는 특히 가변값을 회피하는데 있어 함수형 언어의 요소들을 사용한다.,"{'word': '특정 분야 선언 언어', 'start': 968, 'end': 978, 'type': 'COM'}","{'word': 'lex/Yacc', 'start': 986, 'end': 993, 'type': 'COM'}",com:sub_concept
99,"예를 들어, 명령형인 펄 프로그래밍 언어는 함수형 프로그래밍 개념을 적용하는 법을 설명하는 책에서 주제로 다루기도 했다.","{'word': '명령형', 'start': 1087, 'end': 1089, 'type': 'COM'}","{'word': '펄 프로그래밍 언어', 'start': 1092, 'end': 1101, 'type': 'COM'}",com:sub_concept
100,처음으로 만들어진 함수형 프로그래밍 언어는 IPL이었다.,"{'word': '함수형 프로그래밍 언어', 'start': 1294, 'end': 1305, 'type': 'COM'}","{'word': 'IPL', 'start': 1308, 'end': 1310, 'type': 'COM'}",com:sub_concept
101,"존 매카시가 만든 리스프는 훨씬 향상된 함수형 프로그래밍 언어였고, 이것은 현대적 함수형 프로그래밍의 여러 특징을 가지고 있었다.","{'word': '함수형 프로그래밍 언어', 'start': 1338, 'end': 1349, 'type': 'COM'}","{'word': '리스프', 'start': 1326, 'end': 1328, 'type': 'COM'}",com:sub_concept
102,"ML의 여러 ""방언""이 개발되었고, 현재 가장 많이 쓰이는 방언은 OCaml이다.","{'word': '방언', 'start': 1500, 'end': 1501, 'type': 'COM'}","{'word': 'OCaml', 'start': 1504, 'end': 1508, 'type': 'COM'}",com:sub_concept
103,1980년대에는 그동안의 함수형 프로그래밍에 대한 연구를 바탕으로 순수 함수형 언어인 하스켈이 만들어졌다.,"{'word': '순수 함수형 언어', 'start': 1550, 'end': 1558, 'type': 'COM'}","{'word': '하스켈', 'start': 1561, 'end': 1563, 'type': 'COM'}",com:sub_concept
104,"C의 printf 함수는 ""x""가 정상적으로 출력되었느냐 여부에 따라 0이나 1 값을 반환한다.","{'word': 'C', 'start': 2109, 'end': 2109, 'type': 'COM'}","{'word': 'printf 함수', 'start': 2112, 'end': 2120, 'type': 'COM'}",com:sub_concept
105,"수학적 함수와 명령형 프로그래밍에서 사용되는 함수는 차이가 있는데, 명령형의 함수는 프로그램의 상태의 값을 바꿀 수 있는 부작용이 생길 수 있다. 이 때문에 명령형 함수는 참조 투명성이 없고, 같은 코드라도 실행되는 프로그램의 상태에 따라 다른 결과값을 낼 수 있다. 반대로 함수형 코드에서는 함수의 출력값은 그 함수에 입력된 인수에만 의존하므로 인수 x에 같은 값을 넣고 함수 f를 호출하면 항상 f(x)라는 결과가 나온다.","{'word': '수학적 함수', 'start': 324, 'end': 329, 'type': 'COM'}","{'word': '함수형 코드', 'start': 478, 'end': 483, 'type': 'COM'}",com:alter_names
106,"순수한 함수(pure function)란, 부작용(side-effect)이 없는 함수, 즉, 함수의 실행이 외부에 영향을 끼치지 않는 함수를 뜻한다.","{'word': '순수한 함수(pure function)', 'start': 1573, 'end': 1593, 'type': 'COM'}","{'word': '부작용(side-effect)이 없는 함수', 'start': 1597, 'end': 1619, 'type': 'COM'}",com:alter_names
107,"순수한 함수(pure function)란, 부작용(side-effect)이 없는 함수, 즉, 함수의 실행이 외부에 영향을 끼치지 않는 함수를 뜻한다.","{'word': '순수한 함수(pure function)', 'start': 1573, 'end': 1593, 'type': 'COM'}","{'word': '함수의 실행이 외부에 영향을 끼치지 않는 함수', 'start': 1625, 'end': 1649, 'type': 'COM'}",com:alter_names
108,"함수 random은 호출할 때마다 결과가 달라질 수 있는, 즉 부작용을 발생시키는 함수다.","{'word': '함수 random', 'start': 1942, 'end': 1950, 'type': 'COM'}","{'word': '부작용을 발생시키는 함수', 'start': 1977, 'end': 1989, 'type': 'COM'}",com:alter_names
109,"익명 함수(anonymous function)란, 이름이 없는 함수를 뜻한다.","{'word': '익명 함수(anonymous function)', 'start': 2244, 'end': 2268, 'type': 'COM'}","{'word': '이름이 없는 함수', 'start': 2272, 'end': 2280, 'type': 'COM'}",com:alter_names
110,"고계 함수(higher-order function)란, 함수를 다루는 함수를 뜻한다.","{'word': '고계 함수(higher-order function)', 'start': 2535, 'end': 2562, 'type': 'COM'}","{'word': '함수를 다루는 함수', 'start': 2566, 'end': 2575, 'type': 'COM'}",com:alter_names
111,"함수형 프로그래밍은 1930년대에 계산가능성, 결정문제, 함수정의, 함수응용과 재귀를 연구하기 위해 개발된 형식체계인 람다 대수에 근간을 두고 있다.","{'word': '함수형 프로그래밍', 'start': 197, 'end': 205, 'type': 'COM'}","{'word': '람다 대수', 'start': 263, 'end': 267, 'type': 'COM'}",com:made_of
112,"함수형 언어는 R (통계), 매스매티카 (기호와 수론 수학), J, K 와 Kx 시스템 기반 (재정 시스템)에서 나온 Q, XQuery/XSLT (XML), Opal 같은 특정 분야 프로그래밍 언어(Domain Specific Language)에서도 사용되고 있다.","{'word': 'R (통계)', 'start': 820, 'end': 825, 'type': 'COM'}","{'word': '함수형 언어', 'start': 812, 'end': 817, 'type': 'COM'}",com:made_of
113,"함수형 언어는 R (통계), 매스매티카 (기호와 수론 수학), J, K 와 Kx 시스템 기반 (재정 시스템)에서 나온 Q, XQuery/XSLT (XML), Opal 같은 특정 분야 프로그래밍 언어(Domain Specific Language)에서도 사용되고 있다.","{'word': '매스매티카 (기호와 수론 수학)', 'start': 828, 'end': 844, 'type': 'COM'}","{'word': '함수형 언어', 'start': 812, 'end': 817, 'type': 'COM'}",com:made_of
114,"함수형 언어는 R (통계), 매스매티카 (기호와 수론 수학), J, K 와 Kx 시스템 기반 (재정 시스템)에서 나온 Q, XQuery/XSLT (XML), Opal 같은 특정 분야 프로그래밍 언어(Domain Specific Language)에서도 사용되고 있다.","{'word': 'Q', 'start': 878, 'end': 878, 'type': 'COM'}","{'word': '함수형 언어', 'start': 812, 'end': 817, 'type': 'COM'}",com:made_of
115,"함수형 언어는 R (통계), 매스매티카 (기호와 수론 수학), J, K 와 Kx 시스템 기반 (재정 시스템)에서 나온 Q, XQuery/XSLT (XML), Opal 같은 특정 분야 프로그래밍 언어(Domain Specific Language)에서도 사용되고 있다.","{'word': 'XQuery/XSLT (XML)', 'start': 881, 'end': 897, 'type': 'COM'}","{'word': '함수형 언어', 'start': 812, 'end': 817, 'type': 'COM'}",com:made_of
116,"함수형 언어는 R (통계), 매스매티카 (기호와 수론 수학), J, K 와 Kx 시스템 기반 (재정 시스템)에서 나온 Q, XQuery/XSLT (XML), Opal 같은 특정 분야 프로그래밍 언어(Domain Specific Language)에서도 사용되고 있다.","{'word': 'Opal', 'start': 900, 'end': 903, 'type': 'COM'}","{'word': '함수형 언어', 'start': 812, 'end': 817, 'type': 'COM'}",com:made_of
117,많이 쓰이는 특정 분야 선언 언어인 SQL과 lex/Yacc는 특히 가변값을 회피하는데 있어 함수형 언어의 요소들을 사용한다.,"{'word': 'SQL', 'start': 981, 'end': 983, 'type': 'COM'}","{'word': '함수형 언어', 'start': 1013, 'end': 1018, 'type': 'COM'}",com:made_of
118,많이 쓰이는 특정 분야 선언 언어인 SQL과 lex/Yacc는 특히 가변값을 회피하는데 있어 함수형 언어의 요소들을 사용한다.,"{'word': 'lex/Yacc', 'start': 986, 'end': 993, 'type': 'COM'}","{'word': '함수형 언어', 'start': 1013, 'end': 1018, 'type': 'COM'}",com:made_of
119,"알론조 처치가 1930년대에 개발한 람다 대수는 함수에 대한 이론적 기반을 세웠다. 이것은 프로그래밍 언어가 아니라 수학적 추상화였지만, 이것은 함수형 프로그래밍의 근간을 이루었다.","{'word': '함수형 프로그래밍', 'start': 1263, 'end': 1271, 'type': 'COM'}","{'word': '람다 대수', 'start': 1202, 'end': 1206, 'type': 'COM'}",com:made_of
120,다음은 하스켈로 작성한 제곱 함수이다.,"{'word': '제곱 함수', 'start': 2424, 'end': 2428, 'type': 'COM'}","{'word': '하스켈', 'start': 2415, 'end': 2417, 'type': 'COM'}",com:made_of
121,위 함수를 람다 표현으로 나타내면 formula_1가 된다.,"{'word': 'formula_1', 'start': 2498, 'end': 2506, 'type': 'COM'}","{'word': '람다 표현', 'start': 2485, 'end': 2489, 'type': 'COM'}",com:made_of
122,리스프를 발전시키고 간단하게 만든 언어로 스킴도 있다.,"{'word': '스킴', 'start': 1412, 'end': 1413, 'type': 'COM'}","{'word': '리스프', 'start': 1389, 'end': 1391, 'type': 'COM'}",com:prior_tech
123,"명령형 프로그래밍에서는 상태를 바꾸는 것을 강조하는 것과는 달리, 함수형 프로그래밍은 함수의 응용을 강조한다.","{'word': '함수형 프로그래밍', 'start': 121, 'end': 129, 'type': 'COM'}","{'word': '명령형 프로그래밍', 'start': 84, 'end': 92, 'type': 'COM'}",no_relation
124,"수학적 함수와 명령형 프로그래밍에서 사용되는 함수는 차이가 있는데, 명령형의 함수는 프로그램의 상태의 값을 바꿀 수 있는 부작용이 생길 수 있다.","{'word': '수학적 함수', 'start': 324, 'end': 329, 'type': 'COM'}","{'word': '명령형 프로그래밍에서 사용되는 함수', 'start': 332, 'end': 350, 'type': 'COM'}",no_relation
125,"수학적 함수와 명령형 프로그래밍에서 사용되는 함수는 차이가 있는데, 명령형의 함수는 프로그램의 상태의 값을 바꿀 수 있는 부작용이 생길 수 있다. 이 때문에 명령형 함수는 참조 투명성이 없고, 같은 코드라도 실행되는 프로그램의 상태에 따라 다른 결과값을 낼 수 있다.","{'word': '수학적 함수', 'start': 324, 'end': 329, 'type': 'COM'}","{'word': '명령형 함수', 'start': 412, 'end': 417, 'type': 'COM'}",no_relation
126,"이 때문에 명령형 함수는 참조 투명성이 없고, 같은 코드라도 실행되는 프로그램의 상태에 따라 다른 결과값을 낼 수 있다. 반대로 함수형 코드에서는 함수의 출력값은 그 함수에 입력된 인수에만 의존하므로 인수 x에 같은 값을 넣고 함수 f를 호출하면 항상 f(x)라는 결과가 나온다.","{'word': '함수형 코드', 'start': 478, 'end': 483, 'type': 'COM'}","{'word': '명령형 함수', 'start': 412, 'end': 417, 'type': 'COM'}",no_relation
127,"명령형 언어에서는 반복문을 이용하여 리스트를 훑어 가며 각 원소를 제곱하겠지만, 함수형 언어에서는 리스트를 다루는 고계 함수로 이를 처리할 수 있다.","{'word': '명령형 언어', 'start': 2807, 'end': 2812, 'type': 'COM'}","{'word': '함수형 언어', 'start': 2852, 'end': 2857, 'type': 'COM'}",no_relation
128,"함수형 프로그래밍(函數型 프로그래밍, )은 자료 처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임의 하나이다. 명령형 프로그래밍에서는 상태를 바꾸는 것을 강조하는 것과는 달리, 함수형 프로그래밍은 함수의 응용을 강조한다. 프로그래밍이 문이 아닌 식이나 선언으로 수행되는 선언형 프로그래밍 패러다임을 따르고 있다.","{'word': '함수형 프로그래밍(函數型 프로그래밍, )', 'start': 0, 'end': 21, 'type': 'COM'}","{'word': '선언형 프로그래밍 패러다임', 'start': 173, 'end': 186, 'type': 'COM'}",com:similar_tech
129,식(蝕)을 뜻하는 이클립스란 이름은 자바를 개발한 회사의 SUN(재단)이란 이름을 염두에 두었다는 말도 있어 2003년도에 썬 마이크로시스템즈는 이클립스 재단에 참여하지 않았던 이유 중의 하나였지만 2005년도에 열린 EclipseCon의 키노트에서 Lee Nackman은 그 목적은 원래 마이크로소프트와 비주얼 스튜디오 생태 시스템을 겨냥한 것이었다고 말했다.,"{'word': 'SUN', 'start': 209, 'end': 211, 'type': 'ORG'}","{'word': '자바', 'start': 197, 'end': 198, 'type': 'COM'}",org:production
130,"2003년 IBM의 래셔널 디비전의 CTO 리 낵먼(Lee Nackman)에 따르면 당시 적어도 2001년부터 쓰인 식(蝕)을 의미하는 ""이클립스""(eclipse)라는 이름은 썬 마이크로시스템즈의 말장난은 아니었으며 명명 당시 제품의 주요 경쟁 제품인 마이크로소프트 비주얼 스튜디오에 대항하여 해당 제품이 가려지게 될 것을 두고 쓰인 말이다.","{'word': '마이크로소프트', 'start': 879, 'end': 885, 'type': 'ORG'}","{'word': '비주얼 스튜디오', 'start': 887, 'end': 894, 'type': 'COM'}",org:production
131,"이클립스()는 자바를 비롯한 다양한 언어를 지원하는 프로그래밍 통합 개발 환경을 목적으로 시작하였으나 현재는 OSGi를 도입하여, 범용 응용 소프트웨어 플랫폼으로 진화하였다.","{'word': '범용 응용 소프트웨어 플랫폼', 'start': 73, 'end': 87, 'type': 'COM'}","{'word': '이클립스', 'start': 0, 'end': 3, 'type': 'COM'}",com:sub_concept
132,"C/C++ 개발자용, 자바 개발자용, 웹 개발자용 등 다양한 배포판이 존재한다.","{'word': '배포판', 'start': 505, 'end': 507, 'type': 'COM'}","{'word': 'C/C++ 개발자용', 'start': 471, 'end': 480, 'type': 'COM'}",com:sub_concept
133,"C/C++ 개발자용, 자바 개발자용, 웹 개발자용 등 다양한 배포판이 존재한다.","{'word': '배포판', 'start': 505, 'end': 507, 'type': 'COM'}","{'word': '자바 개발자용', 'start': 483, 'end': 489, 'type': 'COM'}",com:sub_concept
134,"C/C++ 개발자용, 자바 개발자용, 웹 개발자용 등 다양한 배포판이 존재한다.","{'word': '배포판', 'start': 505, 'end': 507, 'type': 'COM'}","{'word': '웹 개발자용', 'start': 492, 'end': 497, 'type': 'COM'}",com:sub_concept
135,"이클립스 퍼블릭 라이선스(Eclipse Public License, EPL)는 이클립스 프로젝트 출시에 사용되는 근본적인 라이선스이다.","{'word': '라이선스', 'start': 636, 'end': 639, 'type': 'COM'}","{'word': '이클립스 퍼블릭 라이선스', 'start': 568, 'end': 580, 'type': 'COM'}",com:sub_concept
136,"이클립스 퍼블릭 라이선스(Eclipse Public License, EPL)는 이클립스 프로젝트 출시에 사용되는 근본적인 라이선스이다. 일부 프로젝트는 듀얼 라이선스를 요구하여 Eclipse Distribution License(EDL)가 사용되기도 하는데 케이스 바이 케이스 기준으로 고려되어야 한다.","{'word': '라이선스', 'start': 636, 'end': 639, 'type': 'COM'}","{'word': 'Eclipse Distribution License', 'start': 667, 'end': 694, 'type': 'COM'}",com:sub_concept
137,이클립스의 GUI 위젯은 자바를 위한 위젯 툴킷인 SWT로 구현되었다.,"{'word': '자바를 위한 위젯 툴킷', 'start': 1274, 'end': 1285, 'type': 'COM'}","{'word': 'SWT', 'start': 1288, 'end': 1290, 'type': 'COM'}",com:sub_concept
138,"또한 이클립스의 사용자 인터페이스는 또 하나의 중간 GUI 계층인 JFace를 사용하여, 이는 SWT 기반의 응용 작성을 좀 더 쉽게 만들어 준다.","{'word': '중간 GUI 계층', 'start': 1373, 'end': 1381, 'type': 'COM'}","{'word': 'JFace', 'start': 1384, 'end': 1388, 'type': 'COM'}",com:sub_concept
139,이 플러그인 메커니즘은 경량화한 소프트웨어 컴포넌트 프레임워크라할 수 있다.,"{'word': '소프트웨어 컴포넌트 프레임워크', 'start': 1541, 'end': 1556, 'type': 'COM'}","{'word': '플러그인 메커니즘', 'start': 1525, 'end': 1533, 'type': 'COM'}",com:sub_concept
140,"플러그인 프레임워크를 활용하면, 자바가 아닌 다른 프로그래밍 언어, 예를 들면, C 언어나 파이썬 언어로 이클립스를 확장하는 것이 가능할 뿐 아니라, 이클립스에서 LaTeX와 같은 조판 언어를 활용하거나, 텔넷과 같은 네트워크 응용을 실행하거나, 데이터베이스 관리를 하는 것도 가능하다.","{'word': '프로그래밍 언어', 'start': 1594, 'end': 1601, 'type': 'COM'}","{'word': 'C 언어', 'start': 1611, 'end': 1614, 'type': 'COM'}",com:sub_concept
141,"플러그인 프레임워크를 활용하면, 자바가 아닌 다른 프로그래밍 언어, 예를 들면, C 언어나 파이썬 언어로 이클립스를 확장하는 것이 가능할 뿐 아니라, 이클립스에서 LaTeX와 같은 조판 언어를 활용하거나, 텔넷과 같은 네트워크 응용을 실행하거나, 데이터베이스 관리를 하는 것도 가능하다.","{'word': '프로그래밍 언어', 'start': 1594, 'end': 1601, 'type': 'COM'}","{'word': '파이썬', 'start': 1617, 'end': 1619, 'type': 'COM'}",com:sub_concept
142,"플러그인 프레임워크를 활용하면, 자바가 아닌 다른 프로그래밍 언어, 예를 들면, C 언어나 파이썬 언어로 이클립스를 확장하는 것이 가능할 뿐 아니라, 이클립스에서 LaTeX와 같은 조판 언어를 활용하거나, 텔넷과 같은 네트워크 응용을 실행하거나, 데이터베이스 관리를 하는 것도 가능하다.","{'word': '조판 언어', 'start': 1667, 'end': 1671, 'type': 'COM'}","{'word': 'LaTeX', 'start': 1657, 'end': 1661, 'type': 'COM'}",com:sub_concept
143,"플러그인 프레임워크를 활용하면, 자바가 아닌 다른 프로그래밍 언어, 예를 들면, C 언어나 파이썬 언어로 이클립스를 확장하는 것이 가능할 뿐 아니라, 이클립스에서 LaTeX와 같은 조판 언어를 활용하거나, 텔넷과 같은 네트워크 응용을 실행하거나, 데이터베이스 관리를 하는 것도 가능하다.","{'word': '네트워크 응용', 'start': 1688, 'end': 1694, 'type': 'COM'}","{'word': '텔넷', 'start': 1681, 'end': 1682, 'type': 'COM'}",com:sub_concept
144,"이클립스 SDK에는 이클립스 자바 개발 툴(Java Development Tools)이 포함되어 있는데, 이는 자바 컴파일러를 내장하고 있고, 자바 소스 파일 전체 모델을 제공한다.","{'word': '이클립스 SDK', 'start': 1819, 'end': 1826, 'type': 'COM'}","{'word': '이클립스 자바 개발 툴(Java Development Tools)', 'start': 1830, 'end': 1865, 'type': 'COM'}",com:sub_concept
145,"이클립스 SDK에는 이클립스 자바 개발 툴(Java Development Tools)이 포함되어 있는데, 이는 자바 컴파일러를 내장하고 있고, 자바 소스 파일 전체 모델을 제공한다.","{'word': '이클립스 자바 개발 툴(Java Development Tools)', 'start': 1830, 'end': 1865, 'type': 'COM'}","{'word': '자바 컴파일러', 'start': 1881, 'end': 1887, 'type': 'COM'}",com:sub_concept
146,"이클립스()는 자바를 비롯한 다양한 언어를 지원하는 프로그래밍 통합 개발 환경을 목적으로 시작하였으나 현재는 OSGi를 도입하여, 범용 응용 소프트웨어 플랫폼으로 진화하였다.","{'word': '이클립스', 'start': 0, 'end': 3, 'type': 'COM'}","{'word': 'OSGi', 'start': 61, 'end': 64, 'type': 'COM'}",com:made_of
147,"이클립스()는 자바를 비롯한 다양한 언어를 지원하는 프로그래밍 통합 개발 환경을 목적으로 시작하였으나 현재는 OSGi를 도입하여, 범용 응용 소프트웨어 플랫폼으로 진화하였다. 자바로 작성되어 있으며, 자유 소프트웨어이지만 막강한 기능을 자랑한다. 2004년과 2005년 졸트 어워드(Jolt Award)를 수상했다.","{'word': '이클립스', 'start': 0, 'end': 3, 'type': 'COM'}","{'word': '자바', 'start': 98, 'end': 99, 'type': 'COM'}",com:made_of
148,이클립스의 GUI 위젯은 자바를 위한 위젯 툴킷인 SWT로 구현되었다.,"{'word': '이클립스의 GUI 위젯', 'start': 1260, 'end': 1271, 'type': 'COM'}","{'word': 'SWT', 'start': 1288, 'end': 1290, 'type': 'COM'}",com:made_of
149,"이클립스는 RCP를 포함한 상위의 모든 기능을 제공하기 위해, 플러그인을 사용한다.","{'word': '이클립스', 'start': 1430, 'end': 1433, 'type': 'COM'}","{'word': '플러그인', 'start': 1465, 'end': 1468, 'type': 'COM'}",com:made_of
150,"1954년 IBM의 존 배커스가 개발한 포트란은 기계어의 이런 장애물을 없애고, 복잡한 프로그램을 작성할 수 있는 최초의 주요한 언어였다.","{'word': '존 배커스', 'start': 1269, 'end': 1273, 'type': 'PER'}","{'word': '포트란', 'start': 1280, 'end': 1282, 'type': 'COM'}",per:production
151,"1970년대에는 니클라우스 버트가 파스칼을 개발하고, 데니스 리치가 벨 연구소에서 일하던 시절 C를 개발하였다.","{'word': '니클라우스 버트', 'start': 1606, 'end': 1613, 'type': 'PER'}","{'word': '파스칼', 'start': 1616, 'end': 1618, 'type': 'COM'}",per:production
152,"1970년대에는 니클라우스 버트가 파스칼을 개발하고, 데니스 리치가 벨 연구소에서 일하던 시절 C를 개발하였다.","{'word': '데니스 리치', 'start': 1627, 'end': 1632, 'type': 'PER'}","{'word': 'C', 'start': 1650, 'end': 1650, 'type': 'COM'}",per:production
153,"버트는 계속해서 모듈라-2, 모듈라-3와 오베론을 개발하였다.","{'word': '버트', 'start': 1660, 'end': 1661, 'type': 'PER'}","{'word': '모듈라-2', 'start': 1669, 'end': 1673, 'type': 'COM'}",per:production
154,"버트는 계속해서 모듈라-2, 모듈라-3와 오베론을 개발하였다.","{'word': '버트', 'start': 1660, 'end': 1661, 'type': 'PER'}","{'word': '모듈라-3', 'start': 1676, 'end': 1680, 'type': 'COM'}",per:production
155,"버트는 계속해서 모듈라-2, 모듈라-3와 오베론을 개발하였다.","{'word': '버트', 'start': 1660, 'end': 1661, 'type': 'PER'}","{'word': '오베론', 'start': 1683, 'end': 1685, 'type': 'COM'}",per:production
156,"미국 국방부의 필요에 따라, 쟌 이시비아와 허니웰에 있는 팀이 에이다를 설계하였다.","{'word': '쟌 이시비아와 허니웰', 'start': 1711, 'end': 1721, 'type': 'PER'}","{'word': '에이다', 'start': 1730, 'end': 1732, 'type': 'COM'}",per:production
157,"스몰토크-80은 앨런 케이가 1969년에 처음 생각했는데, 1980년에 제록스 팔로 알토 연구센터에서 출시되었다.","{'word': '앨런 케이', 'start': 1932, 'end': 1936, 'type': 'PER'}","{'word': '스몰토크-80', 'start': 1923, 'end': 1929, 'type': 'COM'}",per:production
158,시뮬라(세계 최초의 객체 지향 프로그래밍 언어로 알려졌다.) 등의 다른 객체지향 언어를 참고하여 비야네 스트롭스트룹이 C를 바탕으로 하여 C++를 설계했다.,"{'word': '비야네 스트롭스트룹', 'start': 2041, 'end': 2050, 'type': 'PER'}","{'word': 'C++', 'start': 2064, 'end': 2066, 'type': 'COM'}",per:production
159,1980년대 후반과 1990년대에는 래리 월이 1987년 객체지향 언어의 개념을 수용한 탁월한 명령형 언어인 펄(Perl)을 출시하였다.,"{'word': '래리 월', 'start': 2116, 'end': 2119, 'type': 'PER'}","{'word': '펄(Perl)', 'start': 2157, 'end': 2163, 'type': 'COM'}",per:production
160,"귀도 반 로섬이 1990년에 파이썬을 출시하였고, 래스무스 러도르프가 1994년에 PHP를 출시하였으며, 역시 1994년 썬마이크로시스템즈에서 자바가 나왔다.","{'word': '귀도 반 로섬', 'start': 2173, 'end': 2179, 'type': 'PER'}","{'word': '파이썬', 'start': 2189, 'end': 2191, 'type': 'COM'}",per:production
161,"귀도 반 로섬이 1990년에 파이썬을 출시하였고, 래스무스 러도르프가 1994년에 PHP를 출시하였으며, 역시 1994년 썬마이크로시스템즈에서 자바가 나왔다.","{'word': '래스무스 러도르프', 'start': 2201, 'end': 2209, 'type': 'PER'}","{'word': 'PHP', 'start': 2219, 'end': 2221, 'type': 'COM'}",per:production
162,"1954년 IBM의 존 배커스가 개발한 포트란은 기계어의 이런 장애물을 없애고, 복잡한 프로그램을 작성할 수 있는 최초의 주요한 언어였다.","{'word': 'IBM', 'start': 1264, 'end': 1266, 'type': 'ORG'}","{'word': '포트란', 'start': 1280, 'end': 1282, 'type': 'COM'}",org:production
163,"스몰토크-80은 앨런 케이가 1969년에 처음 생각했는데, 1980년에 제록스 팔로 알토 연구센터에서 출시되었다.","{'word': '제록스 팔로 알토 연구센터', 'start': 1963, 'end': 1976, 'type': 'ORG'}","{'word': '스몰토크-80', 'start': 1923, 'end': 1929, 'type': 'COM'}",org:production
164,"귀도 반 로섬이 1990년에 파이썬을 출시하였고, 래스무스 러도르프가 1994년에 PHP를 출시하였으며, 역시 1994년 썬마이크로시스템즈에서 자바가 나왔다.","{'word': '썬마이크로시스템즈', 'start': 2241, 'end': 2249, 'type': 'ORG'}","{'word': '자바', 'start': 2253, 'end': 2254, 'type': 'COM'}",org:production
165,"1954년 IBM의 존 배커스가 개발한 포트란은 기계어의 이런 장애물을 없애고, 복잡한 프로그램을 작성할 수 있는 최초의 주요한 언어였다.","{'word': '포트란', 'start': 1280, 'end': 1282, 'type': 'COM'}","{'word': '1954년', 'start': 1258, 'end': 1262, 'type': 'DAT'}",com:date_of_prod
166,"1950년대 후반과 1960년대에는 수학적 알고리즘을 더 쉽게 표현하기 위하여 알골이 개발되었는데, 몇몇 컴퓨터 운영 체제의 언어로 쓰이기도 했다.","{'word': '알골', 'start': 1507, 'end': 1508, 'type': 'COM'}","{'word': '1950년대 후반과 1960년대', 'start': 1463, 'end': 1479, 'type': 'DAT'}",com:date_of_prod
167,코볼(1960년)과 베이직(1964년)은 프로그래밍 구문을 더 영어와 비슷하게 표현하였다.,"{'word': '코볼', 'start': 1546, 'end': 1547, 'type': 'COM'}","{'word': '1960년', 'start': 1549, 'end': 1553, 'type': 'DAT'}",com:date_of_prod
168,코볼(1960년)과 베이직(1964년)은 프로그래밍 구문을 더 영어와 비슷하게 표현하였다.,"{'word': '베이직', 'start': 1557, 'end': 1559, 'type': 'COM'}","{'word': '1964년', 'start': 1561, 'end': 1565, 'type': 'DAT'}",com:date_of_prod
169,"1970년대에는 니클라우스 버트가 파스칼을 개발하고, 데니스 리치가 벨 연구소에서 일하던 시절 C를 개발하였다.","{'word': '파스칼', 'start': 1616, 'end': 1618, 'type': 'COM'}","{'word': '1970년대', 'start': 1597, 'end': 1602, 'type': 'DAT'}",com:date_of_prod
170,"스몰토크-80은 앨런 케이가 1969년에 처음 생각했는데, 1980년에 제록스 팔로 알토 연구센터에서 출시되었다.","{'word': '스몰토크-80', 'start': 1923, 'end': 1929, 'type': 'COM'}","{'word': '1980년', 'start': 1956, 'end': 1960, 'type': 'DAT'}",com:date_of_prod
171,C++는 1985년 처음 구현되었다.,"{'word': 'C++', 'start': 2075, 'end': 2077, 'type': 'COM'}","{'word': '1985년', 'start': 2080, 'end': 2084, 'type': 'DAT'}",com:date_of_prod
172,1980년대 후반과 1990년대에는 래리 월이 1987년 객체지향 언어의 개념을 수용한 탁월한 명령형 언어인 펄(Perl)을 출시하였다.,"{'word': '펄(Perl)', 'start': 2157, 'end': 2163, 'type': 'COM'}","{'word': '1980년대 후반과 1990년대', 'start': 2096, 'end': 2112, 'type': 'DAT'}",com:date_of_prod
173,"귀도 반 로섬이 1990년에 파이썬을 출시하였고, 래스무스 러도르프가 1994년에 PHP를 출시하였으며, 역시 1994년 썬마이크로시스템즈에서 자바가 나왔다.","{'word': '파이썬', 'start': 2189, 'end': 2191, 'type': 'COM'}","{'word': '1990년', 'start': 2182, 'end': 2186, 'type': 'DAT'}",com:date_of_prod
174,"귀도 반 로섬이 1990년에 파이썬을 출시하였고, 래스무스 러도르프가 1994년에 PHP를 출시하였으며, 역시 1994년 썬마이크로시스템즈에서 자바가 나왔다.","{'word': 'PHP', 'start': 2219, 'end': 2221, 'type': 'COM'}","{'word': '1994년', 'start': 2212, 'end': 2216, 'type': 'DAT'}",com:date_of_prod
175,"귀도 반 로섬이 1990년에 파이썬을 출시하였고, 래스무스 러도르프가 1994년에 PHP를 출시하였으며, 역시 1994년 썬마이크로시스템즈에서 자바가 나왔다.","{'word': '자바', 'start': 2253, 'end': 2254, 'type': 'COM'}","{'word': '1994년', 'start': 2235, 'end': 2239, 'type': 'DAT'}",com:date_of_prod
176,"컴퓨터 과학에서 명령형 프로그래밍(命令型 프로그래밍, )은 선언형 프로그래밍과 반대되는 개념으로, 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 프로그래밍 패러다임의 일종이다.","{'word': '컴퓨터 과학', 'start': 0, 'end': 5, 'type': 'COM'}","{'word': '명령형 프로그래밍', 'start': 9, 'end': 17, 'type': 'COM'}",com:sub_concept
177,"컴퓨터 과학에서 명령형 프로그래밍(命令型 프로그래밍, )은 선언형 프로그래밍과 반대되는 개념으로, 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 프로그래밍 패러다임의 일종이다.","{'word': '컴퓨터 과학', 'start': 0, 'end': 5, 'type': 'COM'}","{'word': '선언형 프로그래밍', 'start': 33, 'end': 41, 'type': 'COM'}",com:sub_concept
178,"컴퓨터 과학에서 명령형 프로그래밍(命令型 프로그래밍, )은 선언형 프로그래밍과 반대되는 개념으로, 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 프로그래밍 패러다임의 일종이다.","{'word': '프로그래밍 패러다임', 'start': 94, 'end': 103, 'type': 'COM'}","{'word': '명령형 프로그래밍', 'start': 9, 'end': 17, 'type': 'COM'}",com:sub_concept
179,"하스켈 같은 함수형 프로그래밍 언어는 구문들을 순서대로 써 놓은 것이 아니며, 명령형 프로그래밍 언어와는 다르게 전역적인 상태가 없다.","{'word': '함수형 프로그래밍 언어', 'start': 257, 'end': 268, 'type': 'COM'}","{'word': '하스켈', 'start': 250, 'end': 252, 'type': 'COM'}",com:sub_concept
180,"프롤로그와 같은 논리 프로그래밍 언어는 ""어떻게"" 계산을 할지보다는 ""무엇""이 계산될 것인지를 정의한다는 생각으로 작성된다.","{'word': '논리 프로그래밍 언어', 'start': 335, 'end': 345, 'type': 'COM'}","{'word': '프롤로그', 'start': 326, 'end': 329, 'type': 'COM'}",com:sub_concept
181,"여러 언어에서 제공하는 GOTO문, 서브프로그램, 프로시저, 호출문들이 비조건 분기문이다.","{'word': '비조건 분기문', 'start': 1156, 'end': 1162, 'type': 'COM'}","{'word': '호출문', 'start': 1150, 'end': 1152, 'type': 'COM'}",com:sub_concept
182,"여러 언어에서 제공하는 GOTO문, 서브프로그램, 프로시저, 호출문들이 비조건 분기문이다.","{'word': '비조건 분기문', 'start': 1156, 'end': 1162, 'type': 'COM'}","{'word': '프로시저', 'start': 1144, 'end': 1147, 'type': 'COM'}",com:sub_concept
183,"여러 언어에서 제공하는 GOTO문, 서브프로그램, 프로시저, 호출문들이 비조건 분기문이다.","{'word': '비조건 분기문', 'start': 1156, 'end': 1162, 'type': 'COM'}","{'word': '서브프로그램', 'start': 1136, 'end': 1141, 'type': 'COM'}",com:sub_concept
184,"여러 언어에서 제공하는 GOTO문, 서브프로그램, 프로시저, 호출문들이 비조건 분기문이다.","{'word': '비조건 분기문', 'start': 1156, 'end': 1162, 'type': 'COM'}","{'word': 'GOTO문', 'start': 1129, 'end': 1133, 'type': 'COM'}",com:sub_concept
185,최초의 명령형 언어는 원시 컴퓨터의 기계어였다.,"{'word': '명령형 언어', 'start': 1171, 'end': 1176, 'type': 'COM'}","{'word': '기계어', 'start': 1187, 'end': 1189, 'type': 'COM'}",com:sub_concept
186,"포트란은 컴파일 언어였는데, 변수의 이름을 붙일 수 있고, 복잡한 수식을 계산할 수 있었으며, 서브프로그램과 명령형 언어의 많은 특징을 가지고 있다.","{'word': '컴파일 언어', 'start': 1341, 'end': 1346, 'type': 'COM'}","{'word': '포트란', 'start': 1336, 'end': 1338, 'type': 'COM'}",com:sub_concept
187,명령형 프로그래밍의 전형적인 예는 포트란과 알골이다.,"{'word': '명령형 프로그래밍', 'start': 2262, 'end': 2270, 'type': 'COM'}","{'word': '포트란', 'start': 2281, 'end': 2283, 'type': 'COM'}",com:sub_concept
188,명령형 프로그래밍의 전형적인 예는 포트란과 알골이다.,"{'word': '명령형 프로그래밍', 'start': 2262, 'end': 2270, 'type': 'COM'}","{'word': '알골', 'start': 2286, 'end': 2287, 'type': 'COM'}",com:sub_concept
189,"명령형 프로그래밍의 전형적인 예는 포트란과 알골이다. 파스칼, C, 에이다는 또 다른 예이다.","{'word': '명령형 프로그래밍', 'start': 2262, 'end': 2270, 'type': 'COM'}","{'word': '파스칼', 'start': 2292, 'end': 2294, 'type': 'COM'}",com:sub_concept
190,"명령형 프로그래밍의 전형적인 예는 포트란과 알골이다. 파스칼, C, 에이다는 또 다른 예이다.","{'word': '명령형 프로그래밍', 'start': 2262, 'end': 2270, 'type': 'COM'}","{'word': 'C', 'start': 2297, 'end': 2297, 'type': 'COM'}",com:sub_concept
191,"명령형 프로그래밍의 전형적인 예는 포트란과 알골이다. 파스칼, C, 에이다는 또 다른 예이다.","{'word': '명령형 프로그래밍', 'start': 2262, 'end': 2270, 'type': 'COM'}","{'word': '에이다', 'start': 2300, 'end': 2302, 'type': 'COM'}",com:sub_concept
192,거의 대부분의 컴퓨터 하드웨어는 명령형으로 구현된다.,"{'word': '컴퓨터 하드웨어', 'start': 404, 'end': 411, 'type': 'COM'}","{'word': '명령형', 'start': 414, 'end': 416, 'type': 'COM'}",com:made_of
193,"거의 모든 컴퓨터 하드웨어들이 컴퓨터의 고유 언어인 기계어를 실행하도록 설계되어 있는데, 이것이 명령형으로 씌어 있다.","{'word': '컴퓨터 하드웨어', 'start': 432, 'end': 439, 'type': 'COM'}","{'word': '명령형', 'start': 480, 'end': 482, 'type': 'COM'}",com:made_of
194,"컴퓨터 과학에서 명령형 프로그래밍(命令型 프로그래밍, )은 선언형 프로그래밍과 반대되는 개념으로, 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 프로그래밍 패러다임의 일종이다.","{'word': '명령형 프로그래밍', 'start': 9, 'end': 17, 'type': 'COM'}","{'word': '선언형 프로그래밍', 'start': 33, 'end': 41, 'type': 'COM'}",no_relation
195,명령형 프로그래밍 언어는 함수형 프로그래밍이나 논리형 프로그래밍 언어와 같은 다른 형태의 언어와 다르다.,"{'word': '명령형 프로그래밍 언어', 'start': 191, 'end': 202, 'type': 'COM'}","{'word': '논리형 프로그래밍 언어', 'start': 217, 'end': 228, 'type': 'COM'}",no_relation
196,"하스켈 같은 함수형 프로그래밍 언어는 구문들을 순서대로 써 놓은 것이 아니며, 명령형 프로그래밍 언어와는 다르게 전역적인 상태가 없다.","{'word': '함수형 프로그래밍 언어', 'start': 257, 'end': 268, 'type': 'COM'}","{'word': '명령형 프로그래밍 언어', 'start': 294, 'end': 305, 'type': 'COM'}",no_relation
197,시뮬라(세계 최초의 객체 지향 프로그래밍 언어로 알려졌다.) 등의 다른 객체지향 언어를 참고하여 비야네 스트롭스트룹이 C를 바탕으로 하여 C++를 설계했다.,"{'word': 'C++', 'start': 2064, 'end': 2066, 'type': 'COM'}","{'word': 'C', 'start': 2053, 'end': 2053, 'type': 'COM'}",com:similar_tech
198,"컴퓨터 프로그래밍에서, 소프트웨어 프레임워크(software framework)는 복잡한 문제를 해결하거나 서술하는 데 사용되는 기본 개념 구조이다.","{'word': '컴퓨터 프로그래밍', 'start': 0, 'end': 8, 'type': 'COM'}","{'word': '소프트웨어 프레임워크', 'start': 13, 'end': 23, 'type': 'COM'}",com:sub_concept
199,리스프는 1958년 스티브 러셀이 IBM 704 컴퓨터에 최초로 구현하였다.,"{'word': '스티브 러셀', 'start': 959, 'end': 964, 'type': 'PER'}","{'word': '리스프', 'start': 948, 'end': 950, 'type': 'COM'}",per:production
200,리스프는 1958년 스티브 러셀이 IBM 704 컴퓨터에 최초로 구현하였다.,"{'word': '리스프', 'start': 948, 'end': 950, 'type': 'COM'}","{'word': '1958년', 'start': 953, 'end': 957, 'type': 'DAT'}",com:date_of_prod
201,"인터프리터(, )는 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경을 말한다.","{'word': '컴퓨터 프로그램', 'start': 36, 'end': 43, 'type': 'COM'}","{'word': '인터프리터', 'start': 0, 'end': 4, 'type': 'COM'}",com:sub_concept
202,"인터프리터(, )는 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경을 말한다.","{'word': '환경', 'start': 48, 'end': 49, 'type': 'COM'}","{'word': '인터프리터', 'start': 0, 'end': 4, 'type': 'COM'}",com:sub_concept
203,인터프리터는 다음의 과정 가운데 적어도 한 가지 기능을 가진 프로그램이다.,"{'word': '프로그램', 'start': 120, 'end': 123, 'type': 'COM'}","{'word': '인터프리터', 'start': 86, 'end': 90, 'type': 'COM'}",com:sub_concept
204,인터프리터는 고급 언어로 작성된 원시코드 명령어들을 한번에 한 줄씩 읽어들여서 실행하는 프로그램이다.,"{'word': '프로그램', 'start': 177, 'end': 180, 'type': 'COM'}","{'word': '인터프리터', 'start': 128, 'end': 132, 'type': 'COM'}",com:sub_concept
205,인터프리터와 컴파일러는 둘 다 대부분의 고급언어에 적용이 가능하지만 BASIC 이나 LISP과 같은 일부 언어들은 개발 당시에는 특별히 인터프리터에 의해서만 실행되도록 설계되었다.,"{'word': '언어', 'start': 779, 'end': 780, 'type': 'COM'}","{'word': 'BASIC', 'start': 758, 'end': 762, 'type': 'COM'}",com:sub_concept
206,인터프리터와 컴파일러는 둘 다 대부분의 고급언어에 적용이 가능하지만 BASIC 이나 LISP과 같은 일부 언어들은 개발 당시에는 특별히 인터프리터에 의해서만 실행되도록 설계되었다.,"{'word': '언어', 'start': 779, 'end': 780, 'type': 'COM'}","{'word': 'LISP', 'start': 767, 'end': 770, 'type': 'COM'}",com:sub_concept
207,그 외에도 포스트스크립트와 같은 페이지 기술 언어 들도 인터프리터를 사용한다.,"{'word': '페이지 기술 언어', 'start': 839, 'end': 847, 'type': 'COM'}","{'word': '포스트스크립트', 'start': 827, 'end': 833, 'type': 'COM'}",com:sub_concept
208,최초의 인터프리트 방식의 고급 언어는 리스프였다.,"{'word': '고급 언어', 'start': 934, 'end': 938, 'type': 'COM'}","{'word': '리스프', 'start': 941, 'end': 943, 'type': 'COM'}",com:sub_concept
209,리스프는 1958년 스티브 러셀이 IBM 704 컴퓨터에 최초로 구현하였다.,"{'word': 'IBM 704', 'start': 967, 'end': 973, 'type': 'COM'}","{'word': '컴퓨터', 'start': 975, 'end': 977, 'type': 'COM'}",com:alter_names
210,인터프리터는 고급 언어로 작성된 원시코드 명령어들을 한번에 한 줄씩 읽어들여서 실행하는 프로그램이다.,"{'word': '원시코드 명령어', 'start': 146, 'end': 153, 'type': 'COM'}","{'word': '고급 언어', 'start': 135, 'end': 139, 'type': 'COM'}",com:made_of
211,고급언어로 작성된 프로그램들을 실행하는 데에는 두 가지 방법이 있다.,"{'word': '프로그램', 'start': 195, 'end': 198, 'type': 'COM'}","{'word': '고급언어', 'start': 185, 'end': 188, 'type': 'COM'}",com:made_of
212,리스프는 1958년 스티브 러셀이 IBM 704 컴퓨터에 최초로 구현하였다.,"{'word': 'IBM 704', 'start': 967, 'end': 973, 'type': 'COM'}","{'word': '리스프', 'start': 948, 'end': 950, 'type': 'COM'}",com:made_of
213,"인터프리터(, )는 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경을 말한다. 원시 코드를 기계어로 번역하는 컴파일러와 대비된다.","{'word': '인터프리터', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': '컴파일러', 'start': 74, 'end': 77, 'type': 'COM'}",no_relation
214,"가장 일반적인 방법은 프로그램을 컴파일 하는 것이고, 다른 하나는 프로그램을 인터프리터에 통과시키는 방법이다.","{'word': '인터프리터', 'start': 267, 'end': 271, 'type': 'COM'}","{'word': '컴파일', 'start': 242, 'end': 244, 'type': 'COM'}",no_relation
215,"인터프리터는 고급 명령어들을 중간 형태로 번역한 다음, 그것을 실행한다.","{'word': '인터프리터', 'start': 286, 'end': 290, 'type': 'COM'}","{'word': '명령어', 'start': 296, 'end': 298, 'type': 'COM'}",no_relation
216,"이와는 대조적으로, 컴파일러는 고급 명령어들을 직접 기계어로 번역한다.","{'word': '컴파일러', 'start': 338, 'end': 341, 'type': 'COM'}","{'word': '명령어', 'start': 347, 'end': 349, 'type': 'COM'}",no_relation
217,인터프리터와 컴파일러는 둘 다 대부분의 고급언어에 적용이 가능하지만 BASIC 이나 LISP과 같은 일부 언어들은 개발 당시에는 특별히 인터프리터에 의해서만 실행되도록 설계되었다.,"{'word': '컴파일러', 'start': 727, 'end': 730, 'type': 'COM'}","{'word': '인터프리터', 'start': 720, 'end': 724, 'type': 'COM'}",no_relation
218,"예를 들어, HTML은 특수 분야 언어이며, HTML의 영역은 웹페이지와 하이퍼텍스트이다.","{'word': '특수 분야 언어', 'start': 1303, 'end': 1310, 'type': 'COM'}","{'word': 'HTML', 'start': 1297, 'end': 1300, 'type': 'COM'}",com:sub_concept
219,"특수 분야 언어의 다른 예로 설정 파일, 스프레드시트, 그리고 심지어는 전자 메일(""보낸이:"", ""받는이:"" 헤더는 처리문을 통하여 본다.)까지도 들 수 있다.","{'word': '특수 분야 언어', 'start': 1341, 'end': 1348, 'type': 'COM'}","{'word': '설정 파일', 'start': 1357, 'end': 1361, 'type': 'COM'}",com:sub_concept
220,"특수 분야 언어의 다른 예로 설정 파일, 스프레드시트, 그리고 심지어는 전자 메일(""보낸이:"", ""받는이:"" 헤더는 처리문을 통하여 본다.)까지도 들 수 있다.","{'word': '특수 분야 언어', 'start': 1341, 'end': 1348, 'type': 'COM'}","{'word': '스프레드시트', 'start': 1364, 'end': 1369, 'type': 'COM'}",com:sub_concept
221,"특수 분야 언어의 다른 예로 설정 파일, 스프레드시트, 그리고 심지어는 전자 메일(""보낸이:"", ""받는이:"" 헤더는 처리문을 통하여 본다.)까지도 들 수 있다.","{'word': '특수 분야 언어', 'start': 1341, 'end': 1348, 'type': 'COM'}","{'word': '전자 메일', 'start': 1381, 'end': 1385, 'type': 'COM'}",com:sub_concept
222,"따라서 특수 분야 언어들은 보통 범용 언어에 ""내장""된다.","{'word': '범용 언어', 'start': 1491, 'end': 1495, 'type': 'COM'}","{'word': '특수 분야 언어', 'start': 1477, 'end': 1484, 'type': 'COM'}",com:sub_concept
223,"선언형 언어는 다른 언어와 같이 문법을 가지고 있고 언어의 단어들이 어떻게 결합되어야 하는지 설명하고 있으며, 어떻게 프로그램의 출력에 맞게 할 것인지를 언어의 문장으로 설명하는 의미구조가 있다.","{'word': '선언형 언어', 'start': 1092, 'end': 1097, 'type': 'COM'}","{'word': '문법', 'start': 1110, 'end': 1111, 'type': 'POH'}",com:sub_concept
224,"선언형 프로그래밍(宣言型 프로그래밍, )은 두 가지 뜻으로 통용되고 있다.","{'word': '선언형 프로그래밍', 'start': 0, 'end': 8, 'type': 'COM'}","{'word': '宣言型 프로그래밍', 'start': 10, 'end': 18, 'type': 'COM'}",com:alter_names
225,"예를 들어, 웹 페이지는 선언형인데 웹페이지는 제목, 글꼴, 본문, 그림과 같이 ""무엇""이 나타나야하는지를 묘사하는 것이지 ""어떤 방법으로"" 컴퓨터 화면에 페이지를 나타내야 하는지를 묘사하는 것이 아니기 때문이다.","{'word': '웹 페이지', 'start': 124, 'end': 128, 'type': 'COM'}","{'word': '웹페이지', 'start': 137, 'end': 140, 'type': 'COM'}",com:alter_names
226,"또 다른 정의에 따르면, 프로그램이 함수형 프로그래밍 언어, 논리형 프로그래밍 언어, 혹은 제한형 프로그래밍 언어로 쓰인 경우에 ""선언형""이라고 한다.","{'word': '프로그램', 'start': 432, 'end': 435, 'type': 'COM'}","{'word': '제한형 프로그래밍 언어', 'start': 469, 'end': 480, 'type': 'COM'}",com:made_of
227,"이렇게 하면 프로그래머가 특수 분야 언어가 힘을 발휘하는 분야에서 이것을 이용할 수 있고, 특수 분야 언어로 하기 어렵거나 불가능한 문제는 범용 언어를 이용할 수 있다.","{'word': '프로그래머', 'start': 1513, 'end': 1517, 'type': 'PER'}","{'word': '특수 분야 언어', 'start': 1557, 'end': 1564, 'type': 'COM'}",no_relation
228,"간단히 말하여, 명령형 프로그램은 알고리즘을 명시하고 목표는 명시하지 않는 데 반해 선언형 프로그램은 목표를 명시하고 알고리즘을 명시하지 않는 것이다.","{'word': '명령형 프로그램', 'start': 342, 'end': 349, 'type': 'COM'}","{'word': '목표', 'start': 390, 'end': 391, 'type': 'POH'}",no_relation
229,"특히, 제한형 프로그래밍과 논리형 프로그래밍은 필요한 해의 특성을 설명하고(무엇) 그 해를 찾는 데 사용하는 실제 알고리즘은 설명하지 않는다(어떤 방법). 그러나 대부분의 논리형과 제한형 언어들은 알고리즘을 설명할 수 있고, 상세한 부분을 구현할 수 있어서 첫 번째 정의를 따르는 엄밀한 의미의 선언형 프로그래밍 언어는 아니다.","{'word': '프로그래밍', 'start': 591, 'end': 595, 'type': 'COM'}","{'word': '특성', 'start': 616, 'end': 617, 'type': 'POH'}",no_relation
230,"여기서 ""선언형 언어""라는 것은 명령형 언어와 대비되는 이런 프로그래밍 언어들을 통칭하는 것이다.","{'word': '선언형 언어', 'start': 508, 'end': 513, 'type': 'COM'}","{'word': '명령형 언어', 'start': 521, 'end': 526, 'type': 'COM'}",no_relation
231,"특히, 제한형 프로그래밍과 논리형 프로그래밍은 필요한 해의 특성을 설명하고(무엇) 그 해를 찾는 데 사용하는 실제 알고리즘은 설명하지 않는다(어떤 방법). 그러나 대부분의 논리형과 제한형 언어들은 알고리즘을 설명할 수 있고, 상세한 부분을 구현할 수 있어서 첫 번째 정의를 따르는 엄밀한 의미의 선언형 프로그래밍 언어는 아니다.","{'word': '알고리즘', 'start': 693, 'end': 696, 'type': 'COM'}","{'word': '선언형 프로그래밍 언어', 'start': 748, 'end': 759, 'type': 'COM'}",no_relation
232,라이브러리나 프레임워크 내부의 비선언형 부분을 캡슐화하여 이렇게 할 수 있다.,"{'word': '라이브러리', 'start': 811, 'end': 815, 'type': 'COM'}","{'word': '캡슐화', 'start': 837, 'end': 839, 'type': 'COM'}",no_relation
233,"이런 형태의 예가 제이유닛 유닛 테스트 프레임워크에 반영되어 쓰이고 있는데, 이것은 정의만 되어 있으면 프레임워크로 등록하여 유닛을 테스트하는 것을 가능하게 한다.","{'word': '프레임워크', 'start': 913, 'end': 917, 'type': 'COM'}","{'word': '유닛', 'start': 925, 'end': 926, 'type': 'COM'}",no_relation
234,선언형 프로그램에서는 그 언어의 표준 알고리즘으로 처리되는 자료 구조를 작성하거나 선언한다.,"{'word': '선언형 프로그램', 'start': 947, 'end': 954, 'type': 'COM'}","{'word': '자료 구조', 'start': 980, 'end': 984, 'type': 'COM'}",no_relation
235,"예를 들어서 웹페이지를 작성한다고 하면, 페이지가 HTML에서 무엇을 보여주어야 하는지를 선언하고 브라우저의 절차적 알고리즘이 이것을 화면에 표시할 점들로 변환한다.","{'word': '웹페이지', 'start': 1006, 'end': 1009, 'type': 'COM'}","{'word': '절차적 알고리즘', 'start': 1060, 'end': 1067, 'type': 'COM'}",no_relation
236,"선언형 프로그래밍은 특수 분야 언어()의 형태로 자주 사용된다. 여기서 ""분야""이라는 것은 ""언어의 사용 분야""(즉, 그 언어가 표현하는 소재)을 의미한다.","{'word': '선언형 프로그래밍', 'start': 1202, 'end': 1210, 'type': 'COM'}","{'word': '분야', 'start': 1243, 'end': 1244, 'type': 'COM'}",no_relation
237,범용 언어에 내장되지 않는 특수 분야 언어는 같은 프로그램을 작성할 때 내장된 언어보다 더 사용하기 쉬운 경우가 많은데 범용 언어가 지우는 복잡한 개념이 잘 추가되지 않기 때문이다.,"{'word': '범용 언어', 'start': 1601, 'end': 1605, 'type': 'COM'}","{'word': '프로그램', 'start': 1629, 'end': 1632, 'type': 'COM'}",no_relation
238,"이것은 전통적인 포트란과 C, 자바와 같은 명령형 프로그래밍 언어와는 다른 접근방식인데, 명령형 프로그래밍 언어는 프로그래머가 실행될 알고리즘을 명시해주어야 하는 것이다.","{'word': '포트란', 'start': 246, 'end': 248, 'type': 'COM'}","{'word': 'C', 'start': 251, 'end': 251, 'type': 'COM'}",com:similar_tech
239,"이것은 전통적인 포트란과 C, 자바와 같은 명령형 프로그래밍 언어와는 다른 접근방식인데, 명령형 프로그래밍 언어는 프로그래머가 실행될 알고리즘을 명시해주어야 하는 것이다.","{'word': '자바', 'start': 254, 'end': 255, 'type': 'COM'}","{'word': 'C', 'start': 251, 'end': 251, 'type': 'COM'}",com:similar_tech
240,"1978년에 브라이언 커니핸과 데니스 리치가 ""The C Programming Language""라는 책의 초판을 출간했다.","{'word': '브라이언 커니핸과 데니스 리치', 'start': 1280, 'end': 1295, 'type': 'PER'}","{'word': '""The C Programming Language""', 'start': 1298, 'end': 1325, 'type': 'POH'}",per:production
241,C는 1972년 켄 톰슨과 데니스 리치가 벨 연구소에서 일할 당시 새로 개발된 유닉스 운영 체제에서 사용하기 위해 개발한 프로그래밍 언어이다.,"{'word': '켄 톰슨과 데니스 리치', 'start': 9, 'end': 20, 'type': 'PER'}","{'word': 'C', 'start': 0, 'end': 0, 'type': 'COM'}",per:production
242,C는 1972년 켄 톰슨과 데니스 리치가 벨 연구소에서 일할 당시 새로 개발된 유닉스 운영 체제에서 사용하기 위해 개발한 프로그래밍 언어이다.,"{'word': '켄 톰슨', 'start': 9, 'end': 12, 'type': 'PER'}","{'word': '데니스 리치', 'start': 15, 'end': 20, 'type': 'PER'}",per:colleagues
243,"유닉스는 어셈블리가 아닌 언어로 구현된 최초의 운영체제 커널 중의 하나였다.(더 빠른 사례는 PL/I로 쓰인 Multics 시스템, ALGOL로 쓰인 Burroughs B5000을 위한 MCP(Master Control Program)가 있다.) 1977년 경, 리치와 스티븐 C. 존슨이 유닉스 운영체제의 이식성을 향상시키기 위해, C 언어를 추가적으로 변경하였다.","{'word': '리치', 'start': 1162, 'end': 1163, 'type': 'PER'}","{'word': '스티븐 C. 존슨', 'start': 1166, 'end': 1174, 'type': 'PER'}",per:colleagues
244,"1978년에 브라이언 커니핸과 데니스 리치가 ""The C Programming Language""라는 책의 초판을 출간했다.","{'word': '데니스 리치', 'start': 1290, 'end': 1295, 'type': 'PER'}","{'word': '브라이언 커니핸', 'start': 1280, 'end': 1287, 'type': 'PER'}",per:colleagues
245,"켄 톰슨은 BCPL언어를 필요에 맞추어 개조해서 ""B""언어(언어를 개발한 벨 연구소의 B를 따서)라 명명했고, 데니스 리치가 이것을 개선하여 C 언어가 탄생했다.","{'word': '벨 연구소', 'start': 121, 'end': 125, 'type': 'ORG'}","{'word': '""B""언어', 'start': 107, 'end': 111, 'type': 'COM'}",org:production
246,"C 언어의 초기 개발은 1969년부터 1973년까지 4년에 걸쳐 AT&amp;T 벨 연구소에서 이루어 졌으며, 데니스 리치의 말에 따르면, 가장 창의적인 작업이 이루어진 기간은 1972년이었다.","{'word': '벨 연구소', 'start': 587, 'end': 591, 'type': 'ORG'}","{'word': 'C 언어', 'start': 542, 'end': 545, 'type': 'COM'}",org:production
247,"C 언어의 초기 개발은 1969년부터 1973년까지 4년에 걸쳐 AT&amp;T 벨 연구소에서 이루어 졌으며, 데니스 리치의 말에 따르면, 가장 창의적인 작업이 이루어진 기간은 1972년이었다.","{'word': 'AT&amp;T', 'start': 578, 'end': 585, 'type': 'ORG'}","{'word': '벨 연구소', 'start': 587, 'end': 591, 'type': 'ORG'}",org:members
248,C는 1972년 켄 톰슨과 데니스 리치가 벨 연구소에서 일할 당시 새로 개발된 유닉스 운영 체제에서 사용하기 위해 개발한 프로그래밍 언어이다.,"{'word': 'C', 'start': 0, 'end': 0, 'type': 'COM'}","{'word': '1972년', 'start': 3, 'end': 7, 'type': 'DAT'}",com:date_of_prod
249,최종 개발 버전은 2011년도 4월 N1570이었다.,"{'word': 'N1570', 'start': 1953, 'end': 1957, 'type': 'COM'}","{'word': '2011년도 4월', 'start': 1943, 'end': 1951, 'type': 'DAT'}",com:date_of_prod
250,"유닉스는 어셈블리가 아닌 언어로 구현된 최초의 운영체제 커널 중의 하나였다.(더 빠른 사례는 PL/I로 쓰인 Multics 시스템, ALGOL로 쓰인 Burroughs B5000을 위한 MCP(Master Control Program)가 있다.) 1977년 경, 리치와 스티븐 C. 존슨이 유닉스 운영체제의 이식성을 향상시키기 위해, C 언어를 추가적으로 변경하였다.","{'word': '운영체제 커널', 'start': 1041, 'end': 1047, 'type': 'COM'}","{'word': '유닉스', 'start': 1015, 'end': 1017, 'type': 'COM'}",com:sub_concept
251,"C 표준은 1990년대 후반에 더 개정되어, 1999년 ISO/IEC 9899:1999가 출간되었고, 여기서 명시한 규범을 흔히 C99라 부른다.","{'word': 'ISO/IEC 9899:1999', 'start': 1718, 'end': 1734, 'type': 'COM'}","{'word': 'C99', 'start': 1759, 'end': 1761, 'type': 'COM'}",com:alter_names
252,"2011년 ISO/IEC 9899:2011이 출간되었고, 간단하게 C11라고 부른다.","{'word': 'ISO/IEC 9899:2011', 'start': 1859, 'end': 1875, 'type': 'COM'}","{'word': 'C11', 'start': 1890, 'end': 1892, 'type': 'COM'}",com:alter_names
253,C11이 나오기 전까지의 개발 버전을 C1X라고 부른다.,"{'word': '개발 버전', 'start': 1915, 'end': 1919, 'type': 'COM'}","{'word': 'C1X', 'start': 1922, 'end': 1924, 'type': 'COM'}",com:alter_names
254,"2018년 ISO/IEC 9899:2018이 출간되었으며, 간단하게 C17이라고 부른다.","{'word': 'ISO/IEC 9899:2018', 'start': 1969, 'end': 1985, 'type': 'COM'}","{'word': 'C17', 'start': 2001, 'end': 2003, 'type': 'COM'}",com:alter_names
255,이렇게 그룹은 나누는 것을 세그먼트(SEGMENT) 또는 섹션(SECTION)이라는 단어를 사용한다.,"{'word': '세그먼트(SEGMENT)', 'start': 3111, 'end': 3123, 'type': 'COM'}","{'word': '섹션(SECTION)', 'start': 3128, 'end': 3138, 'type': 'COM'}",com:alter_names
256,"유닉스 시스템의 바탕 프로그램은 모두 C로 작성되었고, 수많은 운영 체제의 커널 또한 C로 만들어졌다.","{'word': '유닉스 시스템의 바탕 프로그램', 'start': 171, 'end': 186, 'type': 'COM'}","{'word': 'C', 'start': 192, 'end': 192, 'type': 'COM'}",com:made_of
257,"유닉스 시스템의 바탕 프로그램은 모두 C로 작성되었고, 수많은 운영 체제의 커널 또한 C로 만들어졌다.","{'word': '운영 체제의 커널', 'start': 206, 'end': 214, 'type': 'COM'}","{'word': 'C', 'start': 219, 'end': 219, 'type': 'COM'}",com:made_of
258,이는 오늘날의 널리 쓰이는 거의 모든 운영 체제 커널이 C를 이용해 구현된 이유이기도 하다.,"{'word': '운영 체제 커널', 'start': 280, 'end': 287, 'type': 'COM'}","{'word': 'C', 'start': 290, 'end': 290, 'type': 'COM'}",com:made_of
259,리치와 톰슨에 의해 초기에 PDP-7의 어셈블리 언어로 구현되었던 유닉스 운영체제의 개발과 C 언어의 기원은 밀접하게 연관되어 있다.,"{'word': '유닉스 운영체제', 'start': 771, 'end': 778, 'type': 'COM'}","{'word': '어셈블리 언어', 'start': 756, 'end': 762, 'type': 'COM'}",com:made_of
260,유닉스의 초기 PDP-11 버전은 어셈블리로 개발되었다.,"{'word': 'PDP-11 버전', 'start': 927, 'end': 935, 'type': 'COM'}","{'word': '어셈블리', 'start': 938, 'end': 941, 'type': 'COM'}",com:made_of
261,"켄 톰슨은 BCPL언어를 필요에 맞추어 개조해서 ""B""언어(언어를 개발한 벨 연구소의 B를 따서)라 명명했고, 데니스 리치가 이것을 개선하여 C 언어가 탄생했다.","{'word': 'C 언어', 'start': 159, 'end': 162, 'type': 'COM'}","{'word': '""B""언어', 'start': 107, 'end': 111, 'type': 'COM'}",com:prior_tech
262,"언어의 이름이 'C'인 이유는 그 특징이 'B' 언어에서 유래되었기 때문이며, 켄 톰슨에 의하면, B 언어는 BCPL 언어의 기본만 남긴 버전이다.","{'word': ""'C'"", 'start': 659, 'end': 661, 'type': 'COM'}","{'word': ""'B' 언어"", 'start': 674, 'end': 679, 'type': 'COM'}",com:prior_tech
263,존슨의 Portable C Compiler는 새로운 플랫폼에서의 C의 구현의 기초가 되었다.,"{'word': '존슨', 'start': 1221, 'end': 1222, 'type': 'PER'}","{'word': '새로운 플랫폼', 'start': 1246, 'end': 1252, 'type': 'POH'}",no_relation
264,"커니핸과 리치의 앞 글자만 따서 C 프로그래머들에게는 ""K&amp;R""로 불리는 이 책은, 비공식적이지만 오랫동안 C의 규격과 같은 역할을 했다.","{'word': 'C 프로그래머들', 'start': 1360, 'end': 1367, 'type': 'PER'}","{'word': '""K&amp;R""', 'start': 1372, 'end': 1380, 'type': 'POH'}",no_relation
265,"C 언어의 초기 개발은 1969년부터 1973년까지 4년에 걸쳐 AT&amp;T 벨 연구소에서 이루어 졌으며, 데니스 리치의 말에 따르면, 가장 창의적인 작업이 이루어진 기간은 1972년이었다.","{'word': '데니스 리치', 'start': 604, 'end': 609, 'type': 'PER'}","{'word': '1972년', 'start': 641, 'end': 645, 'type': 'DAT'}",no_relation
266,"만약 malloc 등의 함수를 사용하면, 힙 영역을 사용하겠다는 의미 이기 때문에 힙 영역을 개발자가 선언하여 관리 해야 한다.","{'word': '개발자', 'start': 2429, 'end': 2431, 'type': 'PER'}","{'word': 'malloc', 'start': 2380, 'end': 2385, 'type': 'COM'}",no_relation
267,KGDB를 사용하면 커널 개발자는 일반 응용 프로그램과 마찬가지로 커널을 디버깅할 수 있다.,"{'word': '커널 개발자', 'start': 5735, 'end': 5740, 'type': 'PER'}","{'word': '커널', 'start': 5761, 'end': 5762, 'type': 'COM'}",no_relation
268,"현재는 C 뿐만 아니라 C++, C# 등 다양한 언어를 지원하고 있지만 초기의 마이크로소프트 개발 도구는 C 언어로부터 출발하였다.","{'word': '마이크로소프트', 'start': 4604, 'end': 4610, 'type': 'ORG'}","{'word': 'C#', 'start': 4578, 'end': 4579, 'type': 'COM'}",no_relation
269,"C 언어 표준이 상대적으로 정적으로 남아 있었던 동안, C++는 표준화를 위하여 계속 진화하고 있었다.","{'word': 'C 언어', 'start': 1535, 'end': 1538, 'type': 'COM'}","{'word': '표준화', 'start': 1571, 'end': 1573, 'type': 'POH'}",no_relation
270,"1973년에 codice_1 자료형의 추가로, C 언어는 유닉스의 대부분을 C로 쓸 수 있을 정도로 강력해 졌다.","{'word': '유닉스', 'start': 983, 'end': 985, 'type': 'COM'}","{'word': '1973년', 'start': 951, 'end': 955, 'type': 'DAT'}",no_relation
271,"이처럼 C는 시스템 프로그램 개발에 매우 적합하지만, 응용 프로그램 개발에도 많이 쓰이기도 한다.","{'word': '시스템 프로그램', 'start': 318, 'end': 325, 'type': 'COM'}","{'word': '응용 프로그램', 'start': 341, 'end': 347, 'type': 'COM'}",no_relation
272,"PDP-11의 기능의 일부, 특히 바이트 접근기능을 활용하지 못하는 B 언어의 부족함이 C 언어의 초기 버전의 개발을 이끌었다.","{'word': 'PDP-11', 'start': 847, 'end': 852, 'type': 'COM'}","{'word': 'B 언어', 'start': 885, 'end': 888, 'type': 'COM'}",no_relation
273,"유닉스는 어셈블리가 아닌 언어로 구현된 최초의 운영체제 커널 중의 하나였다.(더 빠른 사례는 PL/I로 쓰인 Multics 시스템, ALGOL로 쓰인 Burroughs B5000을 위한 MCP(Master Control Program)가 있다.) 1977년 경, 리치와 스티븐 C. 존슨이 유닉스 운영체제의 이식성을 향상시키기 위해, C 언어를 추가적으로 변경하였다.","{'word': '유닉스', 'start': 1015, 'end': 1017, 'type': 'COM'}","{'word': '어셈블리', 'start': 1020, 'end': 1023, 'type': 'COM'}",no_relation
274,"유닉스는 어셈블리가 아닌 언어로 구현된 최초의 운영체제 커널 중의 하나였다.(더 빠른 사례는 PL/I로 쓰인 Multics 시스템, ALGOL로 쓰인 Burroughs B5000을 위한 MCP(Master Control Program)가 있다.) 1977년 경, 리치와 스티븐 C. 존슨이 유닉스 운영체제의 이식성을 향상시키기 위해, C 언어를 추가적으로 변경하였다.","{'word': 'PL/I', 'start': 1067, 'end': 1070, 'type': 'COM'}","{'word': 'MCP', 'start': 1119, 'end': 1121, 'type': 'COM'}",no_relation
275,"포트란 77과 같은 언어와 달리, C 소스코드는 free-form 언어로써 형식 코드에 공백을 마음대로 넣을 수 있다.","{'word': '포트란 77', 'start': 2044, 'end': 2049, 'type': 'COM'}","{'word': 'C 소스코드', 'start': 2063, 'end': 2068, 'type': 'COM'}",no_relation
276,"OS에서 응용 프로그램을 실행하거나, CPU의 프로그램을 실행하기 위해 여러가지 영역으로 나누어 메모리를 할당하고 이를 메모리에 올려 실행 한다.","{'word': 'CPU', 'start': 2132, 'end': 2134, 'type': 'COM'}","{'word': 'OS', 'start': 2111, 'end': 2112, 'type': 'COM'}",no_relation
277,C 언어로 개발된 프로그램은 메모리 입장에서 다음과 같은 할당 영역으로 나누어 생각할 수 있다.,"{'word': 'C 언어', 'start': 2193, 'end': 2196, 'type': 'COM'}","{'word': '메모리', 'start': 2209, 'end': 2211, 'type': 'COM'}",no_relation
278,"CPU를 사용하여 개발하여 장치에 넣어 코드를 실행할 때, 힙 영역을 많이 사용하지는 않는다.","{'word': 'CPU', 'start': 2247, 'end': 2249, 'type': 'COM'}","{'word': '힙 영역', 'start': 2280, 'end': 2283, 'type': 'COM'}",no_relation
279,따라서 필요 없다면 메모리 공간을 할당할 필요도 없고 힙관리 프로그램 코드(함수를 개발툴에서 라이브러리 형태로 제공)도 필요하지 않는다.,"{'word': '메모리', 'start': 2311, 'end': 2313, 'type': 'COM'}","{'word': '라이브러리', 'start': 2352, 'end': 2356, 'type': 'COM'}",no_relation
280,C 언어 작성된 코드는 컴파일 과정과 링크 과정을 거치면 실행 파일이 만들어진다.,"{'word': '컴파일', 'start': 2542, 'end': 2544, 'type': 'COM'}","{'word': '파일', 'start': 2564, 'end': 2565, 'type': 'COM'}",no_relation
281,"각 특성별로 나누어 그룹을 지어 메모리에 배치 하는데, 이것을 링커가 한다.","{'word': '링커', 'start': 3088, 'end': 3089, 'type': 'COM'}","{'word': '메모리', 'start': 3071, 'end': 3073, 'type': 'COM'}",no_relation
282,"컴파일마다 각 세그먼트 이름과 구조가 다르지만, 예를 들어 중요한 세그먼트 만 표시 하였다, TEXT와 CONST는 ROM/FLASH에 배치해도 되는 변하지 않는 세그먼트이므로 같은 부류이고, CPU를 설계하고 코드를 직접 쓰는 경우 ROM/FLASH을 이용한다.","{'word': 'TEXT', 'start': 3317, 'end': 3320, 'type': 'COM'}","{'word': 'CPU', 'start': 3373, 'end': 3375, 'type': 'COM'}",no_relation
283,실제 CPU를 다루는 C 언어에서 이런 정보는 중요하다.,"{'word': 'CPU', 'start': 3537, 'end': 3539, 'type': 'COM'}","{'word': 'C 언어', 'start': 3546, 'end': 3549, 'type': 'COM'}",no_relation
284,"C 언어 함수는 표준함수가 있고, 개발 툴에서 제공하는 함수가 있다.","{'word': '표준함수', 'start': 3623, 'end': 3626, 'type': 'COM'}","{'word': '개발 툴', 'start': 3633, 'end': 3636, 'type': 'COM'}",no_relation
285,여러가지 부류가 있고 특성 별로 나누어 lib 파일로 코드를 제공하고 헤더파일로 선언을 알 수 있다.,"{'word': 'lib 파일', 'start': 3675, 'end': 3680, 'type': 'COM'}","{'word': '헤더파일', 'start': 3692, 'end': 3695, 'type': 'COM'}",no_relation
286,유닉스 계열(리눅스)의 시스템에서 주로 사용하는 C/C++ 언어 개발 도구이다.,"{'word': '유닉스 계열', 'start': 3761, 'end': 3766, 'type': 'COM'}","{'word': 'C/C++', 'start': 3788, 'end': 3792, 'type': 'COM'}",no_relation
287,"리눅스의 OS을 제 컴파일하거나, 각종 응용 프로그램 개발에 사용한다. 또한 X-Windows의 개발 도구로도 사용할 수 있다.","{'word': '리눅스', 'start': 3806, 'end': 3808, 'type': 'COM'}","{'word': 'X-Windows', 'start': 3849, 'end': 3857, 'type': 'COM'}",no_relation
288,"전자 장치의 개발 시 임베디드 OS 포팅에서, 리눅스 커널이나 리눅스 커널 기반으로 하는 OS 커널 자체를 개발하는 도구로 사용한다.","{'word': '임베디드', 'start': 3890, 'end': 3893, 'type': 'COM'}","{'word': '리눅스', 'start': 3913, 'end': 3915, 'type': 'COM'}",no_relation
289,리눅스 커널 기반 임베디드에서 실행되는 응용 프로그램 역시 gcc을 많이 사용한다.,"{'word': '리눅스', 'start': 3953, 'end': 3955, 'type': 'COM'}","{'word': 'gcc', 'start': 3986, 'end': 3988, 'type': 'COM'}",no_relation
290,"여러 파일들끼리의 의존성과 각 파일에 필요한 명령을 정의함으로써 프로그램을 컴파일할 수 있으며 최종 프로그램을 만들 수 있는 과정을 서술할 수 있는 표준적인 문법을 가지고 있고, 구조로 기술된 파일(주로 Makefile이라는 파일명)을 [make]가 해석하여 프로그램 빌드를 수행하게 된다.","{'word': 'Makefile', 'start': 4114, 'end': 4121, 'type': 'COM'}","{'word': '최종 프로그램', 'start': 4053, 'end': 4059, 'type': 'COM'}",no_relation
291,이클립스는 다양한 언어와 다양한 OS에서 실행되는 IDE이다.,"{'word': '이클립스', 'start': 4229, 'end': 4232, 'type': 'COM'}","{'word': 'OS', 'start': 4247, 'end': 4248, 'type': 'COM'}",no_relation
292,C/C++언어를 제공하는 IDE으로 리눅스의 경우 기존의 gcc을 사용할 수 있도록 연결 설정만 하면 된다.,"{'word': 'gcc', 'start': 4359, 'end': 4361, 'type': 'COM'}","{'word': 'C/C++언어', 'start': 4327, 'end': 4333, 'type': 'COM'}",no_relation
293,윈도우에서 gcc와 연결하여 C/C++ 언어를 사용하여 프로그램을 개발 할 수 있다.,"{'word': '윈도우', 'start': 4388, 'end': 4390, 'type': 'COM'}","{'word': 'C/C++ 언어', 'start': 4404, 'end': 4411, 'type': 'COM'}",no_relation
294,MinGW는 다양한 언어를 지원하므로 다른 언어로도 이클립스와 연결하여 개발 도구로 사용할 수 있다.,"{'word': 'MinGW', 'start': 4436, 'end': 4440, 'type': 'COM'}","{'word': '이클립스', 'start': 4465, 'end': 4468, 'type': 'COM'}",no_relation
295,"비주얼 스튜디오로는 윈도우 API를 이용한 GUI 프로그램, 명령 줄 인터페이스 환경으로 실행되는 Windows Console Application, 윈도우 서비스, 동적 링크 라이브러리 등의 형태로 소프트웨어를 개발할 수 있고, 최근 버전에서는 모바일 응용 소프트웨어 개발도 지원한다.","{'word': 'GUI 프로그램', 'start': 4658, 'end': 4665, 'type': 'COM'}","{'word': '버전', 'start': 4766, 'end': 4767, 'type': 'COM'}",no_relation
296,비주얼 스튜디오에서 사용 가능한 소프트웨어 개발 키트와 라이브러리는 다음과 같다.,"{'word': '비주얼 스튜디오', 'start': 4795, 'end': 4802, 'type': 'COM'}","{'word': '라이브러리', 'start': 4826, 'end': 4830, 'type': 'COM'}",no_relation
297,윈도우 운영체제의 API를 사용할 수 있게 해주는 툴킷이다.,"{'word': '윈도우', 'start': 4884, 'end': 4886, 'type': 'COM'}","{'word': 'API', 'start': 4894, 'end': 4896, 'type': 'COM'}",no_relation
298,응용프로그램에서 사용 가능한 윈도우 운영체제의 기능은 Windows SDK를 통해 제공된다.,"{'word': '윈도우', 'start': 4934, 'end': 4936, 'type': 'COM'}","{'word': '응용프로그램', 'start': 4918, 'end': 4923, 'type': 'COM'}",no_relation
299,윈도우에서 주로 게임 등을 개발할 때 사용하는 툴킷이다.,"{'word': '윈도우', 'start': 5087, 'end': 5089, 'type': 'COM'}","{'word': '게임', 'start': 5096, 'end': 5097, 'type': 'COM'}",no_relation
300,보통 소프트웨어 개발에서 디버깅의 가장 일반적인 방법은 두가지이다.,"{'word': '소프트웨어', 'start': 5151, 'end': 5155, 'type': 'COM'}","{'word': '디버깅', 'start': 5162, 'end': 5164, 'type': 'COM'}",no_relation
301,GCC 옵션을 디버깅이 되도록 설정하면 디버깅 테이블을 만든다. gdb 실행 중에 이것을 사용한다.,"{'word': '디버깅', 'start': 5245, 'end': 5247, 'type': 'COM'}","{'word': 'gdb', 'start': 5273, 'end': 5275, 'type': 'COM'}",no_relation
302,"GDB을 실행하여 응용 프로그램을 실행하면서 break, 변수, 함수 등의 디버깅을 할 수 있다.","{'word': 'GDB', 'start': 5293, 'end': 5295, 'type': 'COM'}","{'word': '디버깅', 'start': 5335, 'end': 5337, 'type': 'COM'}",no_relation
303,GCC에서 gdb는 서버 구조를 사용할 수 있다.,"{'word': 'GCC', 'start': 5348, 'end': 5350, 'type': 'COM'}","{'word': '서버 구조', 'start': 5359, 'end': 5363, 'type': 'COM'}",no_relation
304,gdb-server을 설치하면 네트워크를 통해 디버깅 환경을 구성할 수 있다.,"{'word': 'gdb-server', 'start': 5376, 'end': 5385, 'type': 'COM'}","{'word': '디버깅', 'start': 5402, 'end': 5404, 'type': 'COM'}",no_relation
305,"예를 들어 임베디드 개발 시 리눅스 커널을 포팅하고, 해당 리눅스 시스템에 gdb-server를 설치하면 다른 환경에서 이를 통해 응용 프로그램을 디버깅 할 수 있다.","{'word': '임베디드', 'start': 5426, 'end': 5429, 'type': 'COM'}","{'word': '응용 프로그램', 'start': 5493, 'end': 5499, 'type': 'COM'}",no_relation
306,임베디드의 많은 경우 자신의 시스템에서는 디버깅이 만만치 않다.,"{'word': '시스템', 'start': 5530, 'end': 5532, 'type': 'COM'}","{'word': '임베디드', 'start': 5514, 'end': 5517, 'type': 'COM'}",no_relation
307,따라서 원격으로 gdb의 실행 결과를 전송 할 수 있고 이 정보를 바탕으로 이클립스와 같은 IDE와 연동할 수 있다.,"{'word': 'gdb', 'start': 5559, 'end': 5561, 'type': 'COM'}","{'word': '이클립스', 'start': 5592, 'end': 5595, 'type': 'COM'}",no_relation
308,원격 디버깅 모드는 리눅스 커널에 사용되는 소스 수준의 디버거인 KGDB에서도 사용된다.,"{'word': '리눅스 커널', 'start': 5685, 'end': 5690, 'type': 'COM'}","{'word': 'KGDB', 'start': 5710, 'end': 5713, 'type': 'COM'}",no_relation
309,이클립스 디버깅은 GDB와 연동해서 구성할 수 있다.,"{'word': '이클립스', 'start': 5821, 'end': 5824, 'type': 'COM'}","{'word': 'GDB', 'start': 5831, 'end': 5833, 'type': 'COM'}",no_relation
310,"자바스크립트는 본래 넷스케이프 커뮤니케이션즈 코퍼레이션의 브렌던 아이크(Brendan Eich)가 처음에는 모카(Mocha)라는 이름으로, 나중에는 라이브스크립트(LiveScript)라는 이름으로 개발하였으며, 최종적으로 자바스크립트가 되었다.","{'word': '브렌던 아이크', 'start': 179, 'end': 185, 'type': 'PER'}","{'word': '자바스크립트', 'start': 147, 'end': 152, 'type': 'COM'}",per:production
311,경쟁적인 제안에 대항하여 자바스크립트 개념을 방어하기 위해 이 기업은 프로토타입이 필요했다. 아이크는 1995년 5월 10일 안에 이를 작성했다.,"{'word': '아이크', 'start': 1601, 'end': 1603, 'type': 'PER'}","{'word': '프로토타입', 'start': 1588, 'end': 1592, 'type': 'COM'}",per:production
312,"기업의 설립자 Marc Andreessen은 HTML에 코드를 웹 페이지 마크업으로 직접 작성하면서 웹 디자이너들과 파트타입 프로그래머들이 이미지, 플러그인 등의 요소를 쉽게 조합할 수 있는 글루 언어(glue language)가 필요했다고 믿었다.","{'word': 'Marc Andreessen', 'start': 1092, 'end': 1106, 'type': 'PER'}","{'word': '설립자', 'start': 1088, 'end': 1090, 'type': 'POH'}",per:title
313,"자바스크립트가 썬 마이크로시스템즈의 자바와 구문이 유사한 점도 있지만, 이는 사실 두 언어 모두 C 언어의 기본 구문에 바탕을 뒀기 때문이고, 자바와 자바스크립트는 직접적인 연관성은 약하다.","{'word': '썬 마이크로시스템즈', 'start': 292, 'end': 301, 'type': 'ORG'}","{'word': '자바', 'start': 304, 'end': 305, 'type': 'COM'}",org:production
314,"1993년, 일리노이 대학교 어배너-섐페인의 NCSA는 최초의 대중적인 그래픽 웹 브라우저인 NCSA 모자이크를 출시하였다.","{'word': 'NCSA', 'start': 603, 'end': 606, 'type': 'ORG'}","{'word': 'NCSA 모자이크', 'start': 630, 'end': 638, 'type': 'COM'}",org:production
315,"1994년, 모자이크 커뮤니케이션스라는 이름의 회사가 캘래포니아주 마운틴 뷰에 설립되었으며 모자이크 넷스케이프를 만들기 위해 오리지널 NCSA 모자이크 개발자들을 고용하였다.","{'word': '모자이크 커뮤니케이션스', 'start': 655, 'end': 666, 'type': 'ORG'}","{'word': '모자이크 넷스케이프', 'start': 699, 'end': 708, 'type': 'COM'}",org:production
316,이름의 최종 선정에 혼란이 야기되었는데 이 언어가 자바 프로그래밍 언어에서 파생되었다는 인상을 심었으며 이러한 선택이 마케팅적인 특징을 보였고 이는 넷스케이프가 당시 인기있는 웹 프로그래밍 언어로서 자바스크립트를 내밀기 위한 것이었다.,"{'word': '넷스케이프', 'start': 1883, 'end': 1887, 'type': 'ORG'}","{'word': '자바스크립트', 'start': 1911, 'end': 1916, 'type': 'COM'}",org:production
317,웹 페이지 향상 언어로서 자바스크립트의 성공에 자극받은 마이크로소프트는 J스크립트로 알려진 호환 언어를 개발하게 되었다.,"{'word': '마이크로소프트', 'start': 2292, 'end': 2298, 'type': 'ORG'}","{'word': 'J스크립트', 'start': 2301, 'end': 2305, 'type': 'COM'}",org:production
318,이 웹 브라우저의 첫 버전인 모자이크 넷스케이프 0.9는 1994년 말에 출시되었다.,"{'word': '모자이크 넷스케이프 0.9', 'start': 862, 'end': 875, 'type': 'COM'}","{'word': '1994년 말', 'start': 878, 'end': 884, 'type': 'DAT'}",com:date_of_prod
319,경쟁적인 제안에 대항하여 자바스크립트 개념을 방어하기 위해 이 기업은 프로토타입이 필요했다. 아이크는 1995년 5월 10일 안에 이를 작성했다.,"{'word': '프로토타입', 'start': 1588, 'end': 1592, 'type': 'COM'}","{'word': '1995년 5월 10일', 'start': 1606, 'end': 1617, 'type': 'DAT'}",com:date_of_prod
320,원래 모카(Mocha)라는 이름으로 개발되었으나 이 언어는 공식적으로 라이브스크립트(LiveScript)로 불렸으며 이 당시 1995년 9월 넷스케이프 내비게이터 2.0의 베타 릴리스가 이루어졌으나 나중에 이름이 자바스크립트로 바뀌었는데 이는 12월 넷스케이프 내비게이터 2.0 베타 3에 채용되었다.,"{'word': '넷스케이프 내비게이터 2.0의 베타', 'start': 1710, 'end': 1728, 'type': 'COM'}","{'word': '1995년 9월', 'start': 1701, 'end': 1708, 'type': 'DAT'}",com:date_of_prod
321,"자바스크립트는 1995년 12월 출시된 넷스케이프 2.0B3에서부터 공개, 채택되었다.","{'word': '넷스케이프 2.0B3', 'start': 2068, 'end': 2078, 'type': 'COM'}","{'word': '1995년 12월', 'start': 2054, 'end': 2062, 'type': 'DAT'}",com:date_of_prod
322,J스크립트는 1996년 8월에 출시된 인터넷 익스플로러 브라우저 3.0부터 지원 되기 시작했다.,"{'word': '인터넷 익스플로러 브라우저 3.0', 'start': 2350, 'end': 2367, 'type': 'COM'}","{'word': '1996년 8월', 'start': 2336, 'end': 2343, 'type': 'DAT'}",com:date_of_prod
323,또한 Node.js와 같은 런타임 환경과 같이 서버 프로그래밍에도 사용되고 있다.,"{'word': '서버 프로그래밍', 'start': 127, 'end': 134, 'type': 'COM'}","{'word': 'Node.js', 'start': 104, 'end': 110, 'type': 'COM'}",com:sub_concept
324,"한편 자바스크립트에서 사용되는 기초적인 문법의 개념으로는 속성과 메소드를 갖는 객체(오브젝트) 개념이 있으며, 변수 선언, 함수 정의, 연산자 그리고 제어문등을 이 프로그래밍 언어의 주요 개념으로 언급할수 있을뿐만아니라 이 언어가 속한 객체 지향 프로그래밍언어(OOP)의 공통적인 주요 개념이기도 한다.","{'word': '객체', 'start': 4348, 'end': 4349, 'type': 'COM'}","{'word': '메소드', 'start': 4340, 'end': 4342, 'type': 'COM'}",com:sub_concept
325,"한편 자바스크립트에서 사용되는 기초적인 문법의 개념으로는 속성과 메소드를 갖는 객체(오브젝트) 개념이 있으며, 변수 선언, 함수 정의, 연산자 그리고 제어문등을 이 프로그래밍 언어의 주요 개념으로 언급할수 있을뿐만아니라 이 언어가 속한 객체 지향 프로그래밍언어(OOP)의 공통적인 주요 개념이기도 한다.","{'word': '객체', 'start': 4348, 'end': 4349, 'type': 'COM'}","{'word': '속성', 'start': 4336, 'end': 4337, 'type': 'COM'}",com:sub_concept
326,"한편 자바스크립트에서 사용되는 기초적인 문법의 개념으로는 속성과 메소드를 갖는 객체(오브젝트) 개념이 있으며, 변수 선언, 함수 정의, 연산자 그리고 제어문등을 이 프로그래밍 언어의 주요 개념으로 언급할수 있을뿐만아니라 이 언어가 속한 객체 지향 프로그래밍언어(OOP)의 공통적인 주요 개념이기도 한다.","{'word': '객체 지향 프로그래밍언어(OOP)', 'start': 4436, 'end': 4453, 'type': 'COM'}","{'word': '자바스크립트', 'start': 4307, 'end': 4312, 'type': 'COM'}",com:sub_concept
327,"자바스크립트는 본래 넷스케이프 커뮤니케이션즈 코퍼레이션의 브렌던 아이크(Brendan Eich)가 처음에는 모카(Mocha)라는 이름으로, 나중에는 라이브스크립트(LiveScript)라는 이름으로 개발하였으며, 최종적으로 자바스크립트가 되었다.","{'word': '자바스크립트', 'start': 271, 'end': 276, 'type': 'COM'}","{'word': '모카(Mocha)', 'start': 207, 'end': 215, 'type': 'COM'}",com:alter_names
328,"자바스크립트는 본래 넷스케이프 커뮤니케이션즈 코퍼레이션의 브렌던 아이크(Brendan Eich)가 처음에는 모카(Mocha)라는 이름으로, 나중에는 라이브스크립트(LiveScript)라는 이름으로 개발하였으며, 최종적으로 자바스크립트가 되었다.","{'word': '자바스크립트', 'start': 271, 'end': 276, 'type': 'COM'}","{'word': '라이브스크립트(LiveScript)', 'start': 230, 'end': 248, 'type': 'COM'}",com:alter_names
329,자바스크립트는 ECMA스크립트(ECMAScript)의 표준 사양을 가장 잘 구현한 언어로 인정받고 있으며 ECMAScript 5 (ES5) 까지는 대부분의 브라우저에서 기본적으로 지원되었으나 ECMAScript 6 이후부터는 브라우저 호환성을 위해 트랜스파일러로 컴파일된다.,"{'word': 'ECMA스크립트', 'start': 432, 'end': 439, 'type': 'COM'}","{'word': 'ECMAScript', 'start': 441, 'end': 450, 'type': 'COM'}",com:alter_names
330,"이 웹 브라우저의 첫 버전인 모자이크 넷스케이프 0.9는 1994년 말에 출시되었다. 4개월 후 브라우저 시장의 3/4를 잠식하면서 1990년대에 주된 웹 브라우저가 되었다. NCSA의 상표 소유권 문제를 회피하고자 이 브라우저는 같은 해에 ""넷스케이프 내비게이터""로 이름을 바꾸었으며 이 기업은 ""넷스케이프 커뮤니케이션스""라는 이름을 취하였다.","{'word': '모자이크 넷스케이프 0.9', 'start': 862, 'end': 875, 'type': 'COM'}","{'word': '넷스케이프 내비게이터', 'start': 982, 'end': 992, 'type': 'COM'}",com:alter_names
331,라이브스크립트의 이름이 자바스크립트로 변경된 것은 대략 넷스케이프가 자사의 넷스케이프 내비게이터 웹 브라우저에 자바 기술에 대한 지원을 포함하기 시작할 즈음이다.,"{'word': '라이브스크립트', 'start': 1955, 'end': 1961, 'type': 'COM'}","{'word': '자바스크립트', 'start': 1968, 'end': 1973, 'type': 'COM'}",com:alter_names
332,"""자바스크립트""(JavaScript)는 이제 오라클의 상표이다.","{'word': '자바스크립트', 'start': 2593, 'end': 2598, 'type': 'COM'}","{'word': 'JavaScript', 'start': 2601, 'end': 2610, 'type': 'COM'}",com:alter_names
333,"자바스크립트가 썬 마이크로시스템즈의 자바와 구문이 유사한 점도 있지만, 이는 사실 두 언어 모두 C 언어의 기본 구문에 바탕을 뒀기 때문이고, 자바와 자바스크립트는 직접적인 연관성은 약하다.","{'word': '자바스크립트', 'start': 284, 'end': 289, 'type': 'COM'}","{'word': 'C 언어', 'start': 338, 'end': 341, 'type': 'COM'}",com:prior_tech
334,"자바스크립트가 썬 마이크로시스템즈의 자바와 구문이 유사한 점도 있지만, 이는 사실 두 언어 모두 C 언어의 기본 구문에 바탕을 뒀기 때문이고, 자바와 자바스크립트는 직접적인 연관성은 약하다.","{'word': '자바', 'start': 304, 'end': 305, 'type': 'COM'}","{'word': 'C 언어', 'start': 338, 'end': 341, 'type': 'COM'}",com:prior_tech
335,자바스크립트는 ECMA스크립트(ECMAScript)의 표준 사양을 가장 잘 구현한 언어로 인정받고 있으며 ECMAScript 5 (ES5) 까지는 대부분의 브라우저에서 기본적으로 지원되었으나 ECMAScript 6 이후부터는 브라우저 호환성을 위해 트랜스파일러로 컴파일된다.,"{'word': 'ECMAScript 6', 'start': 531, 'end': 542, 'type': 'COM'}","{'word': 'ECMAScript 5', 'start': 483, 'end': 494, 'type': 'COM'}",com:prior_tech
336,이것은 자바와 자바스크립트 간에는 구문이 유사하다는 점(양쪽 모두 C에 바탕을 두었기 때문에) 외에는 실제 관련성이 없었기 때문이다.,"{'word': '자바', 'start': 2126, 'end': 2127, 'type': 'COM'}","{'word': 'C', 'start': 2159, 'end': 2159, 'type': 'COM'}",com:prior_tech
337,이것은 자바와 자바스크립트 간에는 구문이 유사하다는 점(양쪽 모두 C에 바탕을 두었기 때문에) 외에는 실제 관련성이 없었기 때문이다.,"{'word': '자바스크립트', 'start': 2130, 'end': 2135, 'type': 'COM'}","{'word': 'C', 'start': 2159, 'end': 2159, 'type': 'COM'}",com:prior_tech
338,"자바스크립트와 함께 자주 쓰이는 용어인 DOM은 사실 ECMA스크립트 표준의 일부가 아니며, 그것은 자체로 하나의 표준이고 XML에 기반을 둔다.","{'word': 'DOM', 'start': 2532, 'end': 2534, 'type': 'COM'}","{'word': 'XML', 'start': 2579, 'end': 2581, 'type': 'COM'}",com:prior_tech
339,"1995년, 넷스케이프 커뮤니케이션스는 스킴 프로그래밍 언어를 넷스케이프 내비게이터에 임베디드하기 위해 브렌던 아이크를 영입하였다.","{'word': '브렌던 아이크', 'start': 1282, 'end': 1288, 'type': 'PER'}","{'word': '넷스케이프 커뮤니케이션스', 'start': 1231, 'end': 1243, 'type': 'ORG'}",no_relation
340,"기업의 설립자 Marc Andreessen은 HTML에 코드를 웹 페이지 마크업으로 직접 작성하면서 웹 디자이너들과 파트타입 프로그래머들이 이미지, 플러그인 등의 요소를 쉽게 조합할 수 있는 글루 언어(glue language)가 필요했다고 믿었다.","{'word': '웹 디자이너', 'start': 1140, 'end': 1145, 'type': 'PER'}","{'word': '플러그인', 'start': 1167, 'end': 1170, 'type': 'COM'}",no_relation
341,"그러나 NCSA 모자이크와 코드는 의도적으로 공유하지 않았다. 이 기업의 브라우저의 내부 코드명은 모질라였으며 이는 ""Mosaic and Godzilla""에서 비롯된 용어이다..","{'word': 'NCSA 모자이크', 'start': 750, 'end': 758, 'type': 'ORG'}","{'word': '""Mosaic and Godzilla""', 'start': 811, 'end': 831, 'type': 'POH'}",no_relation
342,시작 전에 넷스케이프 커뮤니케이션스는 넷스케이프 내비게이터 썬의 더 정적인 프로그래밍 언어인 자바를 포함시키기 위해 썬 마이크로시스템즈와 협업했으며 이는 사용자에게 웹 기술 및 플랫폼을 채택시키려는 마이크로소프트와 경쟁하기 위해서였다.,"{'word': '넷스케이프 커뮤니케이션스', 'start': 1304, 'end': 1316, 'type': 'ORG'}","{'word': '마이크로소프트', 'start': 1409, 'end': 1415, 'type': 'ORG'}",no_relation
343,"넷스케이프 커뮤니케이션스가 발명, 구현한 기술 및 모질라 재단과 같은 독립 기관의 라이선스 하에 사용된다.","{'word': '넷스케이프 커뮤니케이션스', 'start': 2628, 'end': 2640, 'type': 'ORG'}","{'word': '모질라', 'start': 2656, 'end': 2658, 'type': 'ORG'}",no_relation
344,"넷스케이프 커뮤니케이션스는 이때 자신들이 만들기 바랐던 스크립트 언어가 자바를 구현할 것이고 비슷한 문법을 채용하는 것이 좋겠다고 생각했으며 펄, 파이썬, Tcl, 스킴 등 기타 언어를 채택하는 것을 배제하였다.","{'word': '넷스케이프 커뮤니케이션스', 'start': 1430, 'end': 1442, 'type': 'ORG'}","{'word': '파이썬', 'start': 1512, 'end': 1514, 'type': 'COM'}",no_relation
345,"IE 브라우저에서의 자바스크립트 사용은 실제로는 J스크립트의 사용을 의미하는 것이었다. 이에 대한 표준화 요구는 ECMA스크립트에 대한 ECMA-262 표준의 기반이 되었으며, 1996년 11월 이후 세 번째 판까지 출판됐다.","{'word': '자바스크립트', 'start': 2394, 'end': 2399, 'type': 'COM'}","{'word': 'ECMA-262', 'start': 2459, 'end': 2466, 'type': 'POH'}",no_relation
346,"여기서처럼 HTML과 자바스크립트 간에는 광범위한 호환성을 보장하는 동전의 양면성 같은 구조를 엿볼 수 있는데, 이것이 가능한 것은 DOM 때문이라고 말할 수 있다.","{'word': 'HTML', 'start': 4112, 'end': 4115, 'type': 'COM'}","{'word': '호환성', 'start': 4134, 'end': 4136, 'type': 'POH'}",no_relation
347,한편 자바스크립트는 HTML과의 연동관계에서 HTML의 로딩시점 또는 초기화와 관련된 즉시 실행 함수(Immediately invoked function expression)를 제공한다.,"{'word': '자바스크립트', 'start': 4202, 'end': 4207, 'type': 'COM'}","{'word': '로딩시점', 'start': 4230, 'end': 4233, 'type': 'POH'}",no_relation
348,4개월 후 브라우저 시장의 3/4를 잠식하면서 1990년대에 주된 웹 브라우저가 되었다.,"{'word': '브라우저', 'start': 900, 'end': 903, 'type': 'COM'}","{'word': '1990년대', 'start': 920, 'end': 925, 'type': 'DAT'}",no_relation
349,자바스크립트()는 객체 기반의 스크립트 프로그래밍 언어이다.,"{'word': '자바스크립트', 'start': 0, 'end': 5, 'type': 'COM'}","{'word': '프로그래밍', 'start': 22, 'end': 26, 'type': 'COM'}",no_relation
350,"이 언어는 웹 브라우저 내에서 주로 사용하며, 다른 응용 프로그램의 내장 객체에도 접근할 수 있는 기능을 가지고 있다.","{'word': '응용 프로그램', 'start': 63, 'end': 69, 'type': 'COM'}","{'word': '웹 브라우저', 'start': 40, 'end': 45, 'type': 'COM'}",no_relation
351,&lt;p&gt;브라우저가 자바스크립트 기능을 지원하지 않거나 자바스크립트 기능이 꺼져 있습니다.,"{'word': '브라우저', 'start': 3007, 'end': 3010, 'type': 'COM'}","{'word': '자바스크립트', 'start': 3033, 'end': 3038, 'type': 'COM'}",no_relation
352,이름과 구문 외에는 자바보다 셀프나 스킴과 유사성이 많다.,"{'word': '셀프', 'start': 407, 'end': 408, 'type': 'COM'}","{'word': '스킴', 'start': 411, 'end': 412, 'type': 'COM'}",com:similar_tech
353,논리학자 해스켈 커리에서 이름을 따왔다.,"{'word': '해스켈 커리', 'start': 39, 'end': 44, 'type': 'PER'}","{'word': '논리학자', 'start': 34, 'end': 37, 'type': 'POH'}",per:title
354,위원회의 노력은 1997년 말까지 다양한 설계안으로 이어져 마침내 ‘하스켈 98’이라는 성과가 나왔다.,"{'word': '위원회', 'start': 363, 'end': 365, 'type': 'ORG'}","{'word': '‘하스켈 98’', 'start': 400, 'end': 407, 'type': 'COM'}",org:production
355,매사추세츠 공과대학교와 글래스고 대학교가 개발한 버전은 병렬화가 가능하기 때문에 ‘병렬 하스켈’이라고 불린다.,"{'word': '매사추세츠 공과대학교와 글래스고 대학교', 'start': 1404, 'end': 1424, 'type': 'ORG'}","{'word': '‘병렬 하스켈’', 'start': 1449, 'end': 1456, 'type': 'COM'}",org:production
356,1985년에 개발된 미란다가 하스켈의 전신이라고 할 수 있다.,"{'word': '미란다', 'start': 137, 'end': 139, 'type': 'COM'}","{'word': '1985년', 'start': 126, 'end': 130, 'type': 'DAT'}",com:date_of_prod
357,하스켈의 첫 버전(‘하스켈 1.0’)은 1990년에 완성되었다.,"{'word': '하스켈의 첫 버전', 'start': 327, 'end': 335, 'type': 'COM'}","{'word': '1990년', 'start': 349, 'end': 353, 'type': 'DAT'}",com:date_of_prod
358,하스켈 98 언어 표준은 1999년 1월 〈하스켈 98 보고서〉()라는 이름으로 정식 공개되었다.,"{'word': '하스켈 98 언어 표준', 'start': 586, 'end': 597, 'type': 'COM'}","{'word': '1999년 1월', 'start': 600, 'end': 607, 'type': 'DAT'}",com:date_of_prod
359,그리고 2003년 1월에는 〈하스켈 98 언어와 라이브러리: 개정 보고서〉()라는 이름으로 개정판이 나왔다.,"{'word': '〈하스켈 98 언어와 라이브러리: 개정 보고서〉', 'start': 656, 'end': 681, 'type': 'COM'}","{'word': '2003년 1월', 'start': 645, 'end': 652, 'type': 'DAT'}",com:date_of_prod
360,"새로운 표준은 비공식적으로 ‘하스켈 프라임’()이라는 이름으로 불렸으며, 2009년 11월 새로운 표준의 첫 번째 판인 하스켈 2010이 발표되었다.","{'word': '하스켈 2010', 'start': 899, 'end': 906, 'type': 'COM'}","{'word': '2009년 11월', 'start': 873, 'end': 881, 'type': 'DAT'}",com:date_of_prod
361,"하스켈 98은 교육용이나 확장을 덧붙이는 토대로 쓸 수 있는 안정적이고, 작고, 이식성 좋은 언어 표준을 의도한 결과물로서 표준 라이브러리가 포함되어 있었다.","{'word': '하스켈 98', 'start': 421, 'end': 426, 'type': 'COM'}","{'word': '표준 라이브러리', 'start': 490, 'end': 497, 'type': 'COM'}",com:sub_concept
362,"수학의 한 특이 분야인 범주론의 개념들, 특히 함수의 개념의 추상화된 형태인 사상과 모나드(monad)를 차용하여 가져온 언어인데, 이를 통해 함수를 대상으로써 다룸에 있어서 명확성을 가질 수 있다.","{'word': '수학', 'start': 1203, 'end': 1204, 'type': 'COM'}","{'word': '범주론', 'start': 1216, 'end': 1218, 'type': 'COM'}",com:sub_concept
363,하스켈 또는 해스켈( )은 순수 함수형 프로그래밍 언어이다.,"{'word': '하스켈', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': '해스켈', 'start': 7, 'end': 9, 'type': 'COM'}",com:alter_names
364,"서브버전과 비슷한 버전 관리 체계인 다크스()가 하스켈로 만들어지기도 했고, 린스파이어는 시스템 도구 개발을 위한 언어로 하스켈을 선택했다.","{'word': '다크스', 'start': 1884, 'end': 1886, 'type': 'COM'}","{'word': '하스켈', 'start': 1891, 'end': 1893, 'type': 'COM'}",com:made_of
365,1985년에 개발된 미란다가 하스켈의 전신이라고 할 수 있다.,"{'word': '하스켈', 'start': 142, 'end': 144, 'type': 'COM'}","{'word': '미란다', 'start': 137, 'end': 139, 'type': 'COM'}",com:prior_tech
366,또한 위원회는 하스켈 98의 확장 기능과 더불어 하스켈 98에 실험적인 기능을 덧붙이거나 합친 변형이 만들어지는 것을 열렬히 환영했다.,"{'word': '위원회', 'start': 513, 'end': 515, 'type': 'ORG'}","{'word': '변형', 'start': 563, 'end': 564, 'type': 'POH'}",no_relation
367,"그러므로 본디 ‘해스켈’로 불러야 하지만, 대한민국에서는 ‘하스켈’이 프로그래밍 언어를 가리키는 말로 널리 쓰여 굳어졌다.","{'word': '‘해스켈’', 'start': 65, 'end': 69, 'type': 'COM'}","{'word': '대한민국', 'start': 81, 'end': 84, 'type': 'POH'}",no_relation
368,"하스켈 2010은 다른 프로그래밍 언어와 호환할 수 있는 인터페이스인 외부 함수 인터페이스를 지원하고, 일부 문법이 변경되었으며, ""n""+""k"" 패턴이라 불리는 문법 형식이 금지되었다.","{'word': '인터페이스', 'start': 961, 'end': 965, 'type': 'COM'}","{'word': '패턴', 'start': 997, 'end': 998, 'type': 'POH'}",no_relation
369,이 언어와 하스켈의 가장 큰 차이점은 입출력을 위해 모나드 대신에 유일형을 사용한다는 것이다.,"{'word': '하스켈', 'start': 1675, 'end': 1677, 'type': 'COM'}","{'word': '유일형', 'start': 1706, 'end': 1708, 'type': 'POH'}",no_relation
370,"하스켈 사용자의 수는 상대적으로 적은 편이지만, 그 강력함 때문에 몇몇 프로젝트를 쉽게 해주었다.","{'word': '하스켈', 'start': 1722, 'end': 1724, 'type': 'COM'}","{'word': '프로젝트', 'start': 1762, 'end': 1765, 'type': 'POH'}",no_relation
371,"1987년 오리건주 포틀랜드에서 열린 ‘함수형 프로그래밍 언어와 컴퓨터 구조에 관한 총회’()에서 있었던 회의에서, 난립하고 있는 함수형 언어들을 통합 정리해서 훗날 언어 설계의 기반이 될 수 있는 일반적인 순수 함수형 프로그래밍 언어를 만들자는 데에 참가자들의 뜻이 모였고 위원회가 발족되었다.","{'word': '함수형 언어', 'start': 234, 'end': 239, 'type': 'COM'}","{'word': '1987년', 'start': 161, 'end': 165, 'type': 'DAT'}",no_relation
372,2002년을 기준으로 하스켈은 느긋한 계산법을 쓰는 함수형 언어 가운데 가장 활발한 연구가 이루어지는 언어로 볼 수 있다.,"{'word': '하스켈', 'start': 1327, 'end': 1329, 'type': 'COM'}","{'word': '2002년', 'start': 1315, 'end': 1319, 'type': 'DAT'}",no_relation
373,"퍼그스()는 펄 6의 컴파일러와 인터프리터를 구현한 것인데, 개발 기간은 지극히 짧았지만 만들어진 지 몇 달도 채 되지 않아 꽤 쓸 만하다는 평을 받았다.","{'word': '퍼그스', 'start': 1777, 'end': 1779, 'type': 'COM'}","{'word': '몇 달', 'start': 1834, 'end': 1836, 'type': 'DAT'}",no_relation
374,하스켈을 실제 컴퓨터로 쓸 수 있게 구현한 ‘글래스고 하스켈 컴파일러’와 ‘허그스’가 사실상의 표준 역할을 하면서 하스켈은 지금도 끊임없이 발전하고 있다.,"{'word': '컴파일러', 'start': 736, 'end': 739, 'type': 'COM'}","{'word': '하스켈', 'start': 766, 'end': 768, 'type': 'COM'}",no_relation
375,"하스켈의 특징으로는 패턴 맞춤, 커링, 조건제시법, 가드, 연산자 정의 등을 들 수 있다.","{'word': '커링', 'start': 1038, 'end': 1039, 'type': 'COM'}","{'word': '가드', 'start': 1049, 'end': 1050, 'type': 'COM'}",no_relation
376,"이후 병렬화와 분산 처리를 더욱 강화한 ‘분산 하스켈’과 에덴 프로그래밍 언어가 나왔고, 느긋한 계산법 대신 적극적인 계산법을 쓰는 ‘적극적 하스켈’이 있으며 하스켈에 객체 지향 개념을 도입한 버전으로 ‘하스켈++’, ‘오하스켈’, 몬드리안 프로그래밍 언어 등등이 있다.","{'word': '‘분산 하스켈’', 'start': 1488, 'end': 1495, 'type': 'COM'}","{'word': '‘적극적 하스켈’', 'start': 1540, 'end': 1548, 'type': 'COM'}",no_relation
377,하스켈과 비슷한 언어로 그래픽 사용자 인터페이스 개발에 새로운 방법을 도입한 클린이 있다.,"{'word': '하스켈', 'start': 1618, 'end': 1620, 'type': 'COM'}","{'word': '클린', 'start': 1661, 'end': 1662, 'type': 'COM'}",com:similar_tech
378,"서브버전과 비슷한 버전 관리 체계인 다크스()가 하스켈로 만들어지기도 했고, 린스파이어는 시스템 도구 개발을 위한 언어로 하스켈을 선택했다.","{'word': '서브버전', 'start': 1864, 'end': 1867, 'type': 'COM'}","{'word': '다크스', 'start': 1884, 'end': 1886, 'type': 'COM'}",com:similar_tech
379,"C#( 또는 C 샵)는 마이크로소프트에서 개발한 객체 지향 프로그래밍 언어로, 닷넷 프레임워크의 한 부분으로 만들어졌으며 나중에 ECMA (ECMA-334)와 ISO (ISO/IEC/23270)의 표준으로 자리잡았다.","{'word': '마이크로소프트', 'start': 13, 'end': 19, 'type': 'ORG'}","{'word': 'C#', 'start': 0, 'end': 1, 'type': 'COM'}",org:production
380,"1999년 1월, 아네르스 하일스베르가 이끄는 팀이 새로운 언어인 Cool(C-like Object Oriented Language)을 개발했다.","{'word': '아네르스 하일스베르가 이끄는 팀', 'start': 1333, 'end': 1349, 'type': 'ORG'}","{'word': 'Cool', 'start': 1360, 'end': 1363, 'type': 'COM'}",org:production
381,"1999년 1월, 아네르스 하일스베르가 이끄는 팀이 새로운 언어인 Cool(C-like Object Oriented Language)을 개발했다.","{'word': 'Cool', 'start': 1360, 'end': 1363, 'type': 'COM'}","{'word': '1999년 1월', 'start': 1323, 'end': 1330, 'type': 'DAT'}",com:date_of_prod
382,2000년 7월 PDC에서 닷넷 프로젝트가 발표될 때 즈음 Cool의 이름은 C#으로 정해졌고 클래스 라이브러리와 ASP.NET 런타임은 C#으로 옮겨갔다.,"{'word': '닷넷 프로젝트', 'start': 1479, 'end': 1485, 'type': 'COM'}","{'word': '2000년 7월', 'start': 1464, 'end': 1471, 'type': 'DAT'}",com:date_of_prod
383,"즉, 모든 인스턴스나 메서드는 반드시 특정 클래스의 멤버로 소속되어야 한다.","{'word': '클래스', 'start': 3205, 'end': 3207, 'type': 'COM'}","{'word': '인스턴스', 'start': 3187, 'end': 3190, 'type': 'COM'}",com:sub_concept
384,"즉, 모든 인스턴스나 메서드는 반드시 특정 클래스의 멤버로 소속되어야 한다.","{'word': '클래스', 'start': 3205, 'end': 3207, 'type': 'COM'}","{'word': '메서드', 'start': 3193, 'end': 3195, 'type': 'COM'}",com:sub_concept
385,확장 메서드는 정적 클래스의 멤버로 있어야 하며 이 때에도 대상 클래스의 private 멤버에는 접근 할 수 없다.,"{'word': '정적 클래스', 'start': 3268, 'end': 3273, 'type': 'COM'}","{'word': '확장 메서드', 'start': 3260, 'end': 3265, 'type': 'COM'}",com:sub_concept
386,"C#( 또는 C 샵)는 마이크로소프트에서 개발한 객체 지향 프로그래밍 언어로, 닷넷 프레임워크의 한 부분으로 만들어졌으며 나중에 ECMA (ECMA-334)와 ISO (ISO/IEC/23270)의 표준으로 자리잡았다.","{'word': 'C#', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': 'C 샵', 'start': 7, 'end': 9, 'type': 'COM'}",com:alter_names
387,2000년 7월 PDC에서 닷넷 프로젝트가 발표될 때 즈음 Cool의 이름은 C#으로 정해졌고 클래스 라이브러리와 ASP.NET 런타임은 C#으로 옮겨갔다.,"{'word': 'Cool', 'start': 1497, 'end': 1500, 'type': 'COM'}","{'word': 'C#', 'start': 1507, 'end': 1508, 'type': 'COM'}",com:alter_names
388,C#은 ISO 소위원회 JTC 1/SC 22에 ISO/IEC 23270:2003으로 제출되었으나 철회 후 ISO/IEC 23270:2006으로 등록되었다.,"{'word': 'C#', 'start': 1552, 'end': 1553, 'type': 'COM'}","{'word': 'ISO/IEC 23270:2006', 'start': 1611, 'end': 1628, 'type': 'COM'}",com:alter_names
389,C++ 언어와 비교할 때 C#은 다음과 같은 점에서 단순화되거나 확장되었다.,"{'word': 'C#', 'start': 1990, 'end': 1991, 'type': 'COM'}","{'word': 'C++', 'start': 1976, 'end': 1978, 'type': 'COM'}",com:prior_tech
390,마이크로소프트는 언어의 최종 이름을 Cool로 유지할지도 고려해봤지만 상표 문제로 인해 이뤄지지 않았다.,"{'word': '마이크로소프트', 'start': 1405, 'end': 1411, 'type': 'ORG'}","{'word': '상표', 'start': 1444, 'end': 1445, 'type': 'POH'}",no_relation
391,"그러나 광고나 패키지 포장 등 가능한 경우, 마이크로소프트에서는 의도한 대로 올림표를 사용한다.","{'word': '마이크로소프트', 'start': 1907, 'end': 1913, 'type': 'ORG'}","{'word': '올림표', 'start': 1925, 'end': 1927, 'type': 'POH'}",no_relation
392,"마찬가지로 올림표는 네 개의 ""+"" 기호와 비슷하므로 C++를 한번 더 증가시켰다는 뜻도 지닌다.","{'word': 'C++', 'start': 1759, 'end': 1761, 'type': 'COM'}","{'word': '올림표', 'start': 1735, 'end': 1737, 'type': 'POH'}",no_relation
393,"또한 C/C++에는 없던 #region, #endregion 지시자가 새로 추가되었다.","{'word': 'C/C++', 'start': 2981, 'end': 2985, 'type': 'COM'}","{'word': '지시자', 'start': 3012, 'end': 3014, 'type': 'POH'}",no_relation
394,이것은 Java 와 다르고 C 와 C++ 처럼 (string[] args) 가 붙지 않으며 보통 빈칸이다.,"{'word': 'Java', 'start': 395, 'end': 398, 'type': 'COM'}","{'word': 'C++', 'start': 410, 'end': 412, 'type': 'COM'}",no_relation
395,"C#은 닷넷 프로그램이 동작하는 닷넷 플랫폼을 가장 직접적으로 반영하고, 또한 닷넷 플랫폼에 강하게 의존하는 프로그래밍 언어이다.","{'word': 'C#', 'start': 859, 'end': 860, 'type': 'COM'}","{'word': '플랫폼', 'start': 906, 'end': 908, 'type': 'COM'}",no_relation
396,C#은 그 문법적인 특성이 자바와 상당히 유사하며 C#을 통하여 다룰 수 있는 닷넷 플랫폼의 기술들조차도 자바를 염두에 둔 것이 많아서 자바와 가장 많이 비교되고 있다. 하지만 C#은 자바와 달리 불안전 코드(unsafe code)와 같은 기술을 통하여 플랫폼 간 상호 운용성에 상당히 많은 노력을 기울이고 있다.,"{'word': '닷넷 플랫폼', 'start': 976, 'end': 981, 'type': 'COM'}","{'word': '자바', 'start': 947, 'end': 948, 'type': 'COM'}",no_relation
397,C#은 그 문법적인 특성이 자바와 상당히 유사하며 C#을 통하여 다룰 수 있는 닷넷 플랫폼의 기술들조차도 자바를 염두에 둔 것이 많아서 자바와 가장 많이 비교되고 있다. 하지만 C#은 자바와 달리 불안전 코드(unsafe code)와 같은 기술을 통하여 플랫폼 간 상호 운용성에 상당히 많은 노력을 기울이고 있다.,"{'word': '자바', 'start': 1035, 'end': 1036, 'type': 'COM'}","{'word': '불안전 코드', 'start': 1042, 'end': 1047, 'type': 'COM'}",no_relation
398,"C#의 기본 자료형은 닷넷의 객체 모델을 따르고 있고, 런타임 차원에서 쓰레기 수집(garbage collection)이 되며 또한 클래스, 인터페이스, 위임, 예외와 같이 객체 지향 언어로서 가져야 할 모든 요소들이 포함되어 있다.","{'word': '닷넷', 'start': 1120, 'end': 1121, 'type': 'COM'}","{'word': '클래스', 'start': 1182, 'end': 1184, 'type': 'COM'}",no_relation
399,닷넷 프레임워크를 개발하던 시절 클래스 라이브러리는 SMC(Simple Managed C)라 불리는 관리 코드(managed code)를 사용했었다.,"{'word': '프레임워크', 'start': 1242, 'end': 1246, 'type': 'COM'}","{'word': '라이브러리', 'start': 1261, 'end': 1265, 'type': 'COM'}",no_relation
400,C++에서 포인터는 특정한 형식의 인스턴스 또는 주소값을 가리키기 위한 목적으로 할당되는 주소값을 기억하기 위한 변수로 취급되지만,"{'word': '포인터', 'start': 2072, 'end': 2074, 'type': 'COM'}","{'word': '인스턴스', 'start': 2085, 'end': 2088, 'type': 'COM'}",no_relation
401,그래서 C++의 포인터와 같은 쓰임새를 C#으로 이식할 수 없는 경우가 상당히 많다.,"{'word': 'C++', 'start': 2192, 'end': 2194, 'type': 'COM'}","{'word': 'C#', 'start': 2210, 'end': 2211, 'type': 'COM'}",no_relation
402,C#에서 리플렉션으로 확장하여 사용하는 것이 가능하다. 리플렉션은 자바 언어의 리플렉션과 같은 개념이다.,"{'word': 'C#', 'start': 2792, 'end': 2793, 'type': 'COM'}","{'word': '자바', 'start': 2829, 'end': 2830, 'type': 'COM'}",no_relation
403,C/C++에서 매크로 상수나 매크로 함수 등을 위해 사용되던 #define이 C#에서는 매우 제한적인 용도로 사용된다.,"{'word': 'C#', 'start': 2954, 'end': 2955, 'type': 'COM'}","{'word': '매크로 함수', 'start': 2927, 'end': 2932, 'type': 'COM'}",no_relation
404,C++와 자바의 문법과 비슷한 문법을 가지고 있다.,"{'word': 'C++', 'start': 122, 'end': 124, 'type': 'COM'}","{'word': '자바', 'start': 127, 'end': 128, 'type': 'COM'}",com:similar_tech
405,"C#의 기본 문법은 C, C++, 자바 등 C 스타일 언어와 유사하다.","{'word': 'C#', 'start': 1936, 'end': 1937, 'type': 'COM'}","{'word': 'C 스타일 언어', 'start': 1960, 'end': 1967, 'type': 'COM'}",com:similar_tech
406,애플리케이션 프레임워크(application Framework)는 소프트웨어 개발자가 응용 소프트웨어의 표준 구조를 구현하기 위해 사용하는 소프트웨어 프레임워크로 구성된다.,"{'word': '애플리케이션 프레임워크', 'start': 0, 'end': 11, 'type': 'COM'}","{'word': '소프트웨어 프레임워크', 'start': 78, 'end': 88, 'type': 'COM'}",com:made_of
407,애플리케이션 프레임워크(application Framework)는 소프트웨어 개발자가 응용 소프트웨어의 표준 구조를 구현하기 위해 사용하는 소프트웨어 프레임워크로 구성된다.,"{'word': '소프트웨어 개발자', 'start': 37, 'end': 45, 'type': 'PER'}","{'word': '프레임워크', 'start': 84, 'end': 88, 'type': 'COM'}",no_relation
408,재사용할 수 있는 수많은 코드를 프레임워크로 통합함으로써 개발자가 새로운 애플리케이션을 위한 표준 코드를 다시 작성하지 않아도 같이 사용된다.,"{'word': '개발자', 'start': 209, 'end': 211, 'type': 'PER'}","{'word': '프레임워크', 'start': 195, 'end': 199, 'type': 'COM'}",no_relation
409,그 까닭은 GUI 응용 프로그램의 기본 구조의 표준화를 촉진하는 경향이 있기 때문이다.,"{'word': 'GUI', 'start': 309, 'end': 311, 'type': 'COM'}","{'word': '표준화', 'start': 329, 'end': 331, 'type': 'POH'}",no_relation
410,"즉, 프로그래밍에서 특정 운영 체제를 위한 응용 프로그램 표준 구조를 구현하는 클래스와 라이브러리 모임이다. 간단하게 프레임워크라고도 부른다.","{'word': '프로그래밍', 'start': 100, 'end': 104, 'type': 'COM'}","{'word': '프레임워크', 'start': 163, 'end': 167, 'type': 'COM'}",no_relation
411,응용 프로그램의 기본 코드 구조가 명백하므로 표준 프레임워크를 사용하면 자동으로 GUI 툴을 만드게 된다. 프레임워크의 구현은 객체 지향 프로그래밍 기법이 사용되고 있는 응용 프로그램 고유의 클래스가 프레임워크의 기존 클래스를 상속할 수 있다.,"{'word': 'GUI', 'start': 397, 'end': 399, 'type': 'COM'}","{'word': '클래스', 'start': 474, 'end': 476, 'type': 'COM'}",no_relation
412,"절차적 프로그래밍(節次的 프로그래밍, )은 절차지향 프로그래밍 혹은 절차지향적 프로그래밍이라고도 불리는 프로그래밍 패러다임의 일종으로서, 때때로 명령형 프로그래밍과 동의어로 쓰이기도 하지만, 프로시저 호출의 개념을 바탕으로 하고 있는 프로그래밍 패러다임을 의미하기도 한다.","{'word': '프로그래밍 패러다임', 'start': 58, 'end': 67, 'type': 'COM'}","{'word': '절차적 프로그래밍', 'start': 0, 'end': 8, 'type': 'COM'}",com:sub_concept
413,알골과 같은 언어가 절차적 프로그래밍 언어의 표준적인 예이다.,"{'word': '절차적 프로그래밍 언어', 'start': 1562, 'end': 1573, 'type': 'COM'}","{'word': '알골', 'start': 1551, 'end': 1552, 'type': 'COM'}",com:sub_concept
414,"알골과 같은 언어가 절차적 프로그래밍 언어의 표준적인 예이다. 그 밖에 포트란, PL/I, 모듈라-2, 에이다, 베이직, C 등이 있다.","{'word': '절차적 프로그래밍 언어', 'start': 1562, 'end': 1573, 'type': 'COM'}","{'word': '포트란', 'start': 1591, 'end': 1593, 'type': 'COM'}",com:sub_concept
415,"알골과 같은 언어가 절차적 프로그래밍 언어의 표준적인 예이다. 그 밖에 포트란, PL/I, 모듈라-2, 에이다, 베이직, C 등이 있다.","{'word': '절차적 프로그래밍 언어', 'start': 1562, 'end': 1573, 'type': 'COM'}","{'word': '에이다', 'start': 1609, 'end': 1611, 'type': 'COM'}",com:sub_concept
416,"절차적 프로그래밍(節次的 프로그래밍, )은 절차지향 프로그래밍 혹은 절차지향적 프로그래밍이라고도 불리는 프로그래밍 패러다임의 일종으로서, 때때로 명령형 프로그래밍과 동의어로 쓰이기도 하지만, 프로시저 호출의 개념을 바탕으로 하고 있는 프로그래밍 패러다임을 의미하기도 한다.","{'word': '절차적 프로그래밍', 'start': 0, 'end': 8, 'type': 'COM'}","{'word': '節次的 프로그래밍', 'start': 10, 'end': 18, 'type': 'COM'}",com:alter_names
417,"프로시저는 루틴, 하위프로그램, 서브루틴, 메서드, 함수(수학적 함수와는 다르고 함수형 프로그래밍에 있는 함수와는 비슷한 의미이다.)라고도 하는데, 간단히 말하여 수행되어야 할 연속적인 계산 과정을 포함하고 있다.","{'word': '프로시저', 'start': 153, 'end': 156, 'type': 'COM'}","{'word': '루틴', 'start': 159, 'end': 160, 'type': 'COM'}",com:alter_names
418,"프로시저는 루틴, 하위프로그램, 서브루틴, 메서드, 함수(수학적 함수와는 다르고 함수형 프로그래밍에 있는 함수와는 비슷한 의미이다.)라고도 하는데, 간단히 말하여 수행되어야 할 연속적인 계산 과정을 포함하고 있다.","{'word': '프로시저', 'start': 153, 'end': 156, 'type': 'COM'}","{'word': '하위프로그램', 'start': 163, 'end': 168, 'type': 'COM'}",com:alter_names
419,"프로시저는 루틴, 하위프로그램, 서브루틴, 메서드, 함수(수학적 함수와는 다르고 함수형 프로그래밍에 있는 함수와는 비슷한 의미이다.)라고도 하는데, 간단히 말하여 수행되어야 할 연속적인 계산 과정을 포함하고 있다.","{'word': '프로시저', 'start': 153, 'end': 156, 'type': 'COM'}","{'word': '함수', 'start': 182, 'end': 183, 'type': 'COM'}",com:alter_names
420,"더 간단하고, 독립적이고, 다시 사용할 수 있기 때문에 프로시저는 프로그램 라이브러리를 포함하여 서로 다른 사람들이나 단체에서 작성한 코드의 조각들을 담을 수 있는 훌륭한 그릇이다.","{'word': '단체', 'start': 1002, 'end': 1003, 'type': 'ORG'}","{'word': '그릇', 'start': 1032, 'end': 1033, 'type': 'POH'}",no_relation
421,크고 복잡한 프로그램을 작성할 때 모듈성은 꼭 필요하다.,"{'word': '프로그램', 'start': 437, 'end': 440, 'type': 'COM'}","{'word': '모듈성', 'start': 449, 'end': 451, 'type': 'POH'}",no_relation
422,모듈성은 프로시저에 어떤 형태의 입력과 출력이 이루어지는지 명확한 규칙을 정하여 구현할 수 있다.,"{'word': '모듈성', 'start': 462, 'end': 464, 'type': 'COM'}","{'word': '출력', 'start': 484, 'end': 485, 'type': 'POH'}",no_relation
423,유효범위(스코프)는 프로시저가 모듈성을 잘 지킬 수 있게 해 준다.,"{'word': '프로시저', 'start': 590, 'end': 593, 'type': 'COM'}","{'word': '유효범위', 'start': 579, 'end': 582, 'type': 'POH'}",no_relation
424,"모듈성이 덜한 프로시저는 빨리 만든 간단한 프로그램에서 사용되기도 하는데 실행환경에서 많은 변수들과 소통하는 경향이 있고, 다른 프로시저가 변수값을 수정할 수 있을지도 모르게 된다.","{'word': '프로시저', 'start': 791, 'end': 794, 'type': 'COM'}","{'word': '변수값', 'start': 861, 'end': 863, 'type': 'POH'}",no_relation
425,여러 변수가 프로그램의 다양한 부분들 사이에서 관계가 있다면 이것은 모듈성을 약하게 한다.,"{'word': '프로그램', 'start': 892, 'end': 895, 'type': 'COM'}","{'word': '모듈성', 'start': 923, 'end': 925, 'type': 'POH'}",no_relation
426,"현재까지 남아있는 대부분의 절차적 프로그래밍 언어는 명령형 프로그래밍 언어이기도 한데, 이것은 실행 환경의 상태(state)로 명시적인 참조를 하기 때문이다.","{'word': '절차적 프로그래밍 언어', 'start': 1053, 'end': 1064, 'type': 'COM'}","{'word': '참조', 'start': 1114, 'end': 1115, 'type': 'POH'}",no_relation
427,"이것은 ""변수""(프로세서 레지스터에 대응될 수도 있다)로부터 시작해서 로고 프로그래밍 언어의 ""거북이"" 위치 같은 것(화면상의 커서부터 시작해서 방바닥 주변에 있는 장치들까지도)까지 어떤 것이든 될 수 있다.","{'word': '프로세서', 'start': 1136, 'end': 1139, 'type': 'COM'}","{'word': '거북이', 'start': 1180, 'end': 1182, 'type': 'POH'}",no_relation
428,"프로시저와 프로시저의 입력과 출력을 다루는 대신에 객체지향 프로그램들은 ""객체""를 다룬다.","{'word': '프로시저', 'start': 1369, 'end': 1372, 'type': 'COM'}","{'word': '""객체""', 'start': 1403, 'end': 1406, 'type': 'POH'}",no_relation
429,연산은 객체에게 내부 프로시저 중에 하나(혹은 상속받은 것)를 수행하라고 요청하는 것으로 이루어지며 이런 방법으로 하여 내부 상태를 다룬다.,"{'word': '프로시저', 'start': 1426, 'end': 1429, 'type': 'COM'}","{'word': '내부 상태', 'start': 1481, 'end': 1485, 'type': 'POH'}",no_relation
430,절차적 프로그래밍 언어들은 절차적 프로그래밍 접근 방식을 따름으로써 프로그래머의 작업을 수월하게 한다.,"{'word': '프로그래밍', 'start': 1497, 'end': 1501, 'type': 'COM'}","{'word': '프로그래머', 'start': 1531, 'end': 1535, 'type': 'PER'}",no_relation
431,"프로그램의 아무 위치에서나 프로시저를 호출할 수 있는데, 다른 프로시저에서도 호출 가능하고 심지어는 자기 자신에서도 호출 가능하다.","{'word': '프로그램', 'start': 273, 'end': 276, 'type': 'COM'}","{'word': '프로시저', 'start': 288, 'end': 291, 'type': 'COM'}",no_relation
432,절차적 프로그래밍은 복잡도가 지나치지 않고 유지보수하기 쉽기 때문에 단순한 순차적 프로그래밍이나 비구조적 프로그래밍보다 여러 상황에서 장점이 많다.,"{'word': '절차적 프로그래밍', 'start': 347, 'end': 355, 'type': 'COM'}","{'word': '순차적 프로그래밍', 'start': 389, 'end': 397, 'type': 'COM'}",no_relation
433,좀 더 최근에 나온 객체지향 프로그래밍을 통하면 좀 더 세련된 형태의 모듈화를 할 수 있다.,"{'word': '객체지향 프로그래밍', 'start': 1322, 'end': 1331, 'type': 'COM'}","{'word': '모듈화', 'start': 1350, 'end': 1352, 'type': 'COM'}",no_relation
434,객체 지향 언어의 시초는 1960년 노위지안 컴퓨팅 센터의 조한 달과 크리스틴이 발표한 시뮬라67이다.,"{'word': '조한 달과 크리스틴', 'start': 390, 'end': 399, 'type': 'PER'}","{'word': '시뮬라67', 'start': 406, 'end': 410, 'type': 'COM'}",per:production
435,1990년대 중반 이후로 각광받고 있는 객체 지향 언어는 자바로 가전 제품에 사용될 소프트웨어의 개발 목적으로 썬 마이크로시스템즈의 제임스 고슬링에 의하여 고안된 언어이다.,"{'word': '제임스 고슬링', 'start': 2292, 'end': 2298, 'type': 'PER'}","{'word': '자바', 'start': 2250, 'end': 2251, 'type': 'COM'}",per:production
436,"1993년 고슬링은 월드 와이드 웹에 자바 언어를 적용할 것을 결정하면서 핫자바라는 웹 브라우저를 개발하였고, 이는 1995년 이후 넷스케이프사 쪽에서 지원을 받게 되었다.","{'word': '고슬링', 'start': 2321, 'end': 2323, 'type': 'PER'}","{'word': '핫자바', 'start': 2356, 'end': 2358, 'type': 'COM'}",per:production
437,브래드 콕스가 개발한 오브젝티브-C는 C++와 마찬가지로 C와 객체 지향 언어를 혼합한 언어이다.,"{'word': '브래드 콕스', 'start': 2511, 'end': 2516, 'type': 'PER'}","{'word': '오브젝티브-C', 'start': 2523, 'end': 2529, 'type': 'COM'}",per:production
438,객체 지향 언어의 시초는 1960년 노위지안 컴퓨팅 센터의 조한 달과 크리스틴이 발표한 시뮬라67이다.,"{'word': '조한 달', 'start': 390, 'end': 393, 'type': 'PER'}","{'word': '크리스틴', 'start': 396, 'end': 399, 'type': 'PER'}",per:colleagues
439,객체 지향 언어로서의 실질적 원조는 제록스 기업의 팰러앨토 연구소에서 앨런 케이의 책임 하에 만들어진 스몰토크이다.,"{'word': '팰러앨토 연구소', 'start': 672, 'end': 679, 'type': 'ORG'}","{'word': '스몰토크', 'start': 701, 'end': 704, 'type': 'COM'}",org:production
440,에이다는 1980년대 초 객체 지향 프로그래밍 언어로 미 국방성에서 개발한 것이다.,"{'word': '미 국방성', 'start': 1202, 'end': 1206, 'type': 'ORG'}","{'word': '에이다', 'start': 1172, 'end': 1174, 'type': 'COM'}",org:production
441,미 국방성은 에이다 개발 전까지 코볼과 포트란을 이용하여 시스템을 개발하였는데 프로젝트 규모가 점점 커져 가면서 그것의 유지와 보수 비용의 문제가 따랐다.,"{'word': '미 국방성', 'start': 1219, 'end': 1223, 'type': 'ORG'}","{'word': '에이다', 'start': 1226, 'end': 1228, 'type': 'COM'}",org:production
442,"미 국방성은 새로운 언어에 대한 정의를 공모하였으며, 여러 업체들이 제시한 언어들을 기준으로 에이다를 정의하였다.","{'word': '미 국방성', 'start': 1371, 'end': 1375, 'type': 'ORG'}","{'word': '에이다', 'start': 1423, 'end': 1425, 'type': 'COM'}",org:production
443,객체 지향 언어로서의 실질적 원조는 제록스 기업의 팰러앨토 연구소에서 앨런 케이의 책임 하에 만들어진 스몰토크이다.,"{'word': '제록스 기업', 'start': 664, 'end': 669, 'type': 'ORG'}","{'word': '팰러앨토 연구소', 'start': 672, 'end': 679, 'type': 'ORG'}",org:members
444,그 중 AT&amp;T의 벨 연구소에서 비야네 스트롭스트룹등에 의해 개발된 C++는 가장 많은 사용자를 확보하고 있는 객체지향 언어다.,"{'word': 'AT&amp;T', 'start': 1931, 'end': 1938, 'type': 'ORG'}","{'word': '벨 연구소', 'start': 1941, 'end': 1945, 'type': 'ORG'}",org:members
445,객체 지향 언어의 시초는 1960년 노위지안 컴퓨팅 센터의 조한 달과 크리스틴이 발표한 시뮬라67이다.,"{'word': '시뮬라67', 'start': 406, 'end': 410, 'type': 'COM'}","{'word': '1960년', 'start': 371, 'end': 375, 'type': 'DAT'}",com:date_of_prod
446,1970년대 말 스몰토크가 만들어질 당시 제록스에서는 3가지 가정을 하고 이 가정에 초점을 맞추어 스몰토크의 문법과 의미를 정의하였다.,"{'word': '스몰토크', 'start': 808, 'end': 811, 'type': 'COM'}","{'word': '1970년대 말', 'start': 799, 'end': 806, 'type': 'DAT'}",com:date_of_prod
447,에이다는 1980년대 초 객체 지향 프로그래밍 언어로 미 국방성에서 개발한 것이다.,"{'word': '에이다', 'start': 1172, 'end': 1174, 'type': 'COM'}","{'word': '1980년대 초', 'start': 1177, 'end': 1184, 'type': 'DAT'}",com:date_of_prod
448,"1993년 고슬링은 월드 와이드 웹에 자바 언어를 적용할 것을 결정하면서 핫자바라는 웹 브라우저를 개발하였고, 이는 1995년 이후 넷스케이프사 쪽에서 지원을 받게 되었다.","{'word': '핫자바라는 웹 브라우저', 'start': 2356, 'end': 2367, 'type': 'COM'}","{'word': '1993년', 'start': 2315, 'end': 2319, 'type': 'DAT'}",com:date_of_prod
449,객체 지향 프로그래밍()은 컴퓨터 프로그래밍의 패러다임 중 하나이다.,"{'word': '컴퓨터 프로그래밍', 'start': 15, 'end': 23, 'type': 'COM'}","{'word': '객체 지향 프로그래밍', 'start': 0, 'end': 10, 'type': 'COM'}",com:sub_concept
450,"시뮬라67이 채택하고 있는 가장 중요한 개념은 클래스의 도입으로서 이 아이디어는 스몰토크, C++ 등에도 사용되었다. 하지만 시뮬라 67의 발표 이후 10여년 간 객체 지향 언어는 전혀 주목을 받지 못하였다.","{'word': '시뮬라67', 'start': 415, 'end': 419, 'type': 'COM'}","{'word': '클래스', 'start': 441, 'end': 443, 'type': 'COM'}",com:sub_concept
451,"초기의 C++는 C에 클래스 개념만 도입된 것에 지나지 않았으나, 중복, 상속, 가상 함수, 추상 클래스, 예외 처리와 같은 다양한 기능이 추가되면서 점차 향상되고 있다.","{'word': 'C++', 'start': 2040, 'end': 2042, 'type': 'COM'}","{'word': '중복', 'start': 2073, 'end': 2074, 'type': 'COM'}",com:sub_concept
452,"초기의 C++는 C에 클래스 개념만 도입된 것에 지나지 않았으나, 중복, 상속, 가상 함수, 추상 클래스, 예외 처리와 같은 다양한 기능이 추가되면서 점차 향상되고 있다.","{'word': 'C++', 'start': 2040, 'end': 2042, 'type': 'COM'}","{'word': '추상 클래스', 'start': 2088, 'end': 2093, 'type': 'COM'}",com:sub_concept
453,"초기의 C++는 C에 클래스 개념만 도입된 것에 지나지 않았으나, 중복, 상속, 가상 함수, 추상 클래스, 예외 처리와 같은 다양한 기능이 추가되면서 점차 향상되고 있다.","{'word': 'C++', 'start': 2040, 'end': 2042, 'type': 'COM'}","{'word': '예외 처리', 'start': 2096, 'end': 2100, 'type': 'COM'}",com:sub_concept
454,"객체 지향 프로그래밍의 특징은 기본적으로 자료 추상화, 상속, 다형 개념, 동적 바인딩 등이 있으며 추가적으로 다중 상속 등의 특징이 존재한다.","{'word': '객체 지향 프로그래밍', 'start': 2606, 'end': 2616, 'type': 'COM'}","{'word': '자료 추상화', 'start': 2629, 'end': 2634, 'type': 'COM'}",com:sub_concept
455,"객체 지향 프로그래밍의 특징은 기본적으로 자료 추상화, 상속, 다형 개념, 동적 바인딩 등이 있으며 추가적으로 다중 상속 등의 특징이 존재한다.","{'word': '객체 지향 프로그래밍', 'start': 2606, 'end': 2616, 'type': 'COM'}","{'word': '상속', 'start': 2637, 'end': 2638, 'type': 'COM'}",com:sub_concept
456,"객체 지향 프로그래밍의 특징은 기본적으로 자료 추상화, 상속, 다형 개념, 동적 바인딩 등이 있으며 추가적으로 다중 상속 등의 특징이 존재한다.","{'word': '객체 지향 프로그래밍', 'start': 2606, 'end': 2616, 'type': 'COM'}","{'word': '동적 바인딩', 'start': 2648, 'end': 2653, 'type': 'COM'}",com:sub_concept
457,"객체 지향 프로그래밍의 특징은 기본적으로 자료 추상화, 상속, 다형 개념, 동적 바인딩 등이 있으며 추가적으로 다중 상속 등의 특징이 존재한다.","{'word': '객체 지향 프로그래밍', 'start': 2606, 'end': 2616, 'type': 'COM'}","{'word': '다중 상속', 'start': 2668, 'end': 2672, 'type': 'COM'}",com:sub_concept
458,"객체 지향 프로그래밍에서 일반적으로 추상 자료형을 클래스, 추상 자료형의 인스턴스를 객체, 추상 자료형에서 정의된 연산을 메소드(함수), 메소드의 호출을 생성자라고 한다.","{'word': '추상 자료형', 'start': 2979, 'end': 2984, 'type': 'COM'}","{'word': '클래스', 'start': 2987, 'end': 2989, 'type': 'COM'}",com:alter_names
459,"객체 지향 프로그래밍에서 일반적으로 추상 자료형을 클래스, 추상 자료형의 인스턴스를 객체, 추상 자료형에서 정의된 연산을 메소드(함수), 메소드의 호출을 생성자라고 한다.","{'word': '추상 자료형의 인스턴스', 'start': 2992, 'end': 3003, 'type': 'COM'}","{'word': '객체', 'start': 3006, 'end': 3007, 'type': 'COM'}",com:alter_names
460,"객체 지향 프로그래밍에서 일반적으로 추상 자료형을 클래스, 추상 자료형의 인스턴스를 객체, 추상 자료형에서 정의된 연산을 메소드(함수), 메소드의 호출을 생성자라고 한다.","{'word': '추상 자료형에서 정의된 연산', 'start': 3010, 'end': 3024, 'type': 'COM'}","{'word': '메소드(함수)', 'start': 3027, 'end': 3033, 'type': 'COM'}",com:alter_names
461,"객체 지향 프로그래밍에서 일반적으로 추상 자료형을 클래스, 추상 자료형의 인스턴스를 객체, 추상 자료형에서 정의된 연산을 메소드(함수), 메소드의 호출을 생성자라고 한다.","{'word': '메소드의 호출', 'start': 3036, 'end': 3042, 'type': 'COM'}","{'word': '생성자', 'start': 3045, 'end': 3047, 'type': 'COM'}",com:alter_names
462,미 국방성은 에이다 개발 전까지 코볼과 포트란을 이용하여 시스템을 개발하였는데 프로젝트 규모가 점점 커져 가면서 그것의 유지와 보수 비용의 문제가 따랐다.,"{'word': '시스템', 'start': 1251, 'end': 1253, 'type': 'COM'}","{'word': '코볼과 포트란', 'start': 1237, 'end': 1243, 'type': 'COM'}",com:made_of
463,그 당시에는 파스칼이 인기가 좋아서 에이다의 문법은 기본적으로 파스칼의 문법을 기반으로 하였다.,"{'word': '에이다의 문법', 'start': 1455, 'end': 1461, 'type': 'COM'}","{'word': '파스칼의 문법', 'start': 1470, 'end': 1476, 'type': 'COM'}",com:prior_tech
464,C++는 C를 기반으로 하기 때문에 많은 프로그래머들의 인기를 받고 있지만 그로 인하여 객체 지향성을 제대로 반영하지 못하고 있다는 비난을 받기도 한다.,"{'word': 'C++', 'start': 2132, 'end': 2134, 'type': 'COM'}","{'word': 'C', 'start': 2137, 'end': 2137, 'type': 'COM'}",com:prior_tech
465,사람이 말로 표현 가능한 모든 것을 객체라 할 수 있다.,"{'word': '사람', 'start': 2769, 'end': 2770, 'type': 'PER'}","{'word': '객체', 'start': 2789, 'end': 2790, 'type': 'POH'}",no_relation
466,현재 많은 컴퓨터 사용자들은 그들의 응용 프로그램을 스스로 개발하지 않는다. 이러한 점 때문에 스몰토크의 순수성과 독창성에 비하여 크게 성공하진 못하였다.,"{'word': '컴퓨터 사용자', 'start': 1091, 'end': 1097, 'type': 'PER'}","{'word': '스몰토크', 'start': 1138, 'end': 1141, 'type': 'COM'}",no_relation
467,"이는 시스템의 신뢰도를 높이기 위한 중요한 기능이며, 미 국방성 프로젝트가 중요시 하는 신뢰도를 증가시키기 위한 필수적인 기능으로 볼 수 있다. 하지만 에이다는 큰 단점을 가지고 있었는데, 상속의 개념을 언어에 반영하지 않았다.","{'word': '미 국방성', 'start': 1546, 'end': 1550, 'type': 'ORG'}","{'word': '신뢰도', 'start': 1565, 'end': 1567, 'type': 'POH'}",no_relation
468,"1970년대 컴퓨터 산업을 주도한 IBM, AT&amp;T, 미 국방성 등에서 관심을 두지 않았기 때문에 시뮬라 67은 실용적인 언어로 발전하지는 못하였다. 하지만 이의 학문적 가치는 인정받고 있다.","{'word': 'IBM', 'start': 551, 'end': 553, 'type': 'ORG'}","{'word': '시뮬라 67', 'start': 591, 'end': 596, 'type': 'COM'}",no_relation
469,"각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.","{'word': '데이터', 'start': 145, 'end': 147, 'type': 'COM'}","{'word': '메시지', 'start': 134, 'end': 136, 'type': 'POH'}",no_relation
470,"또한 프로그래밍을 더 배우기 쉽게 하고 소프트웨어 개발과 보수를 간편하게 하며, 보다 직관적인 코드 분석을 가능하게 하는 장점이 있다.","{'word': '프로그래밍', 'start': 225, 'end': 229, 'type': 'COM'}","{'word': '보수', 'start': 254, 'end': 255, 'type': 'POH'}",no_relation
471,그러나 지나친 프로그램의 객체화 경향은 실제 세계의 모습을 그대로 반영하지 못한다는 비판을 받기도 한다.,"{'word': '프로그램', 'start': 306, 'end': 309, 'type': 'COM'}","{'word': '실제 세계', 'start': 320, 'end': 324, 'type': 'POH'}",no_relation
472,"이는 시스템의 신뢰도를 높이기 위한 중요한 기능이며, 미 국방성 프로젝트가 중요시 하는 신뢰도를 증가시키기 위한 필수적인 기능으로 볼 수 있다. 하지만 에이다는 큰 단점을 가지고 있었는데, 상속의 개념을 언어에 반영하지 않았다.","{'word': '에이다', 'start': 1601, 'end': 1603, 'type': 'COM'}","{'word': '상속', 'start': 1622, 'end': 1623, 'type': 'POH'}",no_relation
473,또한 에이다는 대부분의 객체 지향 언어가 대부분 동적 바인딩 방식을 채택하고 있는 반면에 정적 바인딩방식을 사용하고 있었다.,"{'word': '객체 지향 언어', 'start': 1657, 'end': 1664, 'type': 'COM'}","{'word': '정적 바인딩방식', 'start': 1694, 'end': 1701, 'type': 'POH'}",no_relation
474,특히 언어의 단순성 입장에서 객체 지향 패러다임에 충실하게 언어가 고안되었기 때문에 C++보다 오용의 소지가 다소 적다.,"{'word': 'C++', 'start': 2490, 'end': 2492, 'type': 'COM'}","{'word': '단순성', 'start': 2450, 'end': 2452, 'type': 'POH'}",no_relation
475,추상 자료형은 자료형의 자료 표현과 자료형의 연산을 캡슐화한 것으로 접근 제어를 통해서 자료형의 정보를 은닉할 수 있다.,"{'word': '추상 자료형', 'start': 2891, 'end': 2896, 'type': 'COM'}","{'word': '정보', 'start': 2945, 'end': 2946, 'type': 'POH'}",no_relation
476,상속은 새로운 클래스가 기존의 클래스의 자료와 연산을 이용할 수 있게 하는 기능이다.,"{'word': '클래스', 'start': 3063, 'end': 3065, 'type': 'COM'}","{'word': '연산', 'start': 3081, 'end': 3082, 'type': 'POH'}",no_relation
477,상속을 통해서 기존의 클래스를 상속받은 하위 클래스를 이용해 프로그램의 요구에 맞추어 클래스를 수정할 수 있고 클래스 간의 종속 관계를 형성함으로써 객체를 조직화할 수 있다.,"{'word': '프로그램', 'start': 3239, 'end': 3242, 'type': 'COM'}","{'word': '상속', 'start': 3205, 'end': 3206, 'type': 'POH'}",no_relation
478,클래스들의 기능이 동시에 필요할 때 용이하나 클래스의 상속 관계에 혼란을 줄 수 있고(예: 다이아몬드 상속) 프로그래밍 언어에 따라 사용 가능 유무가 다르므로 주의해서 사용해야 한다.,"{'word': '프로그래밍 언어', 'start': 3409, 'end': 3416, 'type': 'COM'}","{'word': '다이아몬드', 'start': 3399, 'end': 3403, 'type': 'POH'}",no_relation
479,동적 바인딩은 프로그램의 한 개체나 기호를 실행 과정에 여러 속성이나 연산에 바인딩함으로써 다형 개념을 실현한다.,"{'word': '동적 바인딩', 'start': 3719, 'end': 3724, 'type': 'COM'}","{'word': '기호', 'start': 3739, 'end': 3740, 'type': 'POH'}",no_relation
480,"소프트웨어 공학의 관점에서 볼 때 S/W의 질을 향상하기 위해 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 지향해야 하는데, OOP의 경우 하나의 문제 해결을 위한 데이터를 클래스에 모아 놓은 데이터형을 사용함으로써 응집력을 강화하고, 클래스간에 독립적인 디자인을 함으로써 결합력을 약하게 한다.","{'word': '소프트웨어', 'start': 3783, 'end': 3787, 'type': 'COM'}","{'word': '약한 결합력', 'start': 3843, 'end': 3848, 'type': 'POH'}",no_relation
481,"소프트웨어 공학의 관점에서 볼 때 S/W의 질을 향상하기 위해 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 지향해야 하는데, OOP의 경우 하나의 문제 해결을 위한 데이터를 클래스에 모아 놓은 데이터형을 사용함으로써 응집력을 강화하고, 클래스간에 독립적인 디자인을 함으로써 결합력을 약하게 한다.","{'word': 'OOP', 'start': 3876, 'end': 3878, 'type': 'COM'}","{'word': '응집력', 'start': 3927, 'end': 3929, 'type': 'POH'}",no_relation
482,마지막으로 모든 사람이 각자의 응용 프로그램을 쉽게 개발할 수 있어야 한다는 것이었다. 첫 번째와 두 번째 가정은 현실에서 거의 사실화 되었으나 마지막 가정은 제록스의 실수였다.,"{'word': '응용 프로그램', 'start': 1002, 'end': 1008, 'type': 'COM'}","{'word': '제록스', 'start': 1074, 'end': 1076, 'type': 'ORG'}",no_relation
483,"시뮬라67이 채택하고 있는 가장 중요한 개념은 클래스의 도입으로서 이 아이디어는 스몰토크, C++ 등에도 사용되었다. 하지만 시뮬라 67의 발표 이후 10여년 간 객체 지향 언어는 전혀 주목을 받지 못하였다.","{'word': '시뮬라 67', 'start': 485, 'end': 490, 'type': 'COM'}","{'word': '10여년', 'start': 499, 'end': 502, 'type': 'DAT'}",no_relation
484,객체 지향 언어는 프로그래밍 언어가 많은 지원을 받기 시작하고 발전하기 시작한 1990년 대 초반에 많은 발전이 있었다.,"{'word': '프로그래밍 언어', 'start': 1724, 'end': 1731, 'type': 'COM'}","{'word': '1990년', 'start': 1758, 'end': 1762, 'type': 'DAT'}",no_relation
485,"객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 ""객체""들의 모임으로 파악하고자 하는 것이다.","{'word': '명령어', 'start': 62, 'end': 64, 'type': 'COM'}","{'word': '객체', 'start': 101, 'end': 102, 'type': 'COM'}",no_relation
486,"첫 번째는 전 세계의 모든 사람이 컴퓨터를 사용할 것이라는 가정이었고, 두 번째는 모든 사용자가 그래픽이 지원되는 모니터와 마우스를 기본 설비로 사용하며 윈도 환경에서 작업할 것이라는 가정이었다.","{'word': '컴퓨터', 'start': 894, 'end': 896, 'type': 'COM'}","{'word': '그래픽', 'start': 929, 'end': 931, 'type': 'COM'}",no_relation
487,"C++, 델파이, FoxPro와 같은 프로그램들은 객체 지향 언어에 가장 큰 영향을 미쳤던 GUI의 발전에 따라 점점 향상되었다.","{'word': 'C++', 'start': 1854, 'end': 1856, 'type': 'COM'}","{'word': 'GUI', 'start': 1905, 'end': 1907, 'type': 'COM'}",no_relation
488,"객체 지향 프로그래밍은 자료 추상화를 기초로 하여 상속, 다형 개념, 동적 바인딩이 시스템의 복잡성을 제어하기 위해 서로 맞물려 기능하는 것이다.","{'word': '시스템', 'start': 2734, 'end': 2736, 'type': 'COM'}","{'word': '자료 추상화', 'start': 2700, 'end': 2705, 'type': 'COM'}",no_relation
489,자료 추상화는 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단히 만드는 것이다.,"{'word': '프로그램', 'start': 2838, 'end': 2841, 'type': 'COM'}","{'word': '자료 추상화', 'start': 2801, 'end': 2806, 'type': 'COM'}",no_relation
490,"상속을 받는 새로운 클래스를 부클래스, 파생 클래스, 하위 클래스, 자식 클래스라고 하며 새로운 클래스가 상속하는 기존의 클래스를 기반 클래스, 상위 클래스, 부모 클래스라고 한다.","{'word': '기반 클래스', 'start': 3176, 'end': 3181, 'type': 'COM'}","{'word': '부클래스', 'start': 3119, 'end': 3122, 'type': 'COM'}",no_relation
491,다형성 개념이란 어떤 한 요소에 여러 개념을 넣어 놓는 것으로 일반적으로 오버라이딩(같은 이름의 메소드가 여러 클래스에서 다른 기능을 하는 것)이나 오버로딩(같은 이름의 메소드가 인자의 개수나 자료형에 따라서 다른 기능을 하는 것)을 의미한다.,"{'word': '오버라이딩', 'start': 3492, 'end': 3496, 'type': 'COM'}","{'word': '메소드', 'start': 3505, 'end': 3507, 'type': 'COM'}",no_relation
492,동적 바인딩은 실행 시간 중에 일어나거나 실행 과정에서 변경될 수 있는 바인딩으로 컴파일 시간에 완료되어 변화하지 않는 정적 바인딩과 대비되는 개념이다.,"{'word': '컴파일', 'start': 3679, 'end': 3681, 'type': 'COM'}","{'word': '동적 바인딩', 'start': 3633, 'end': 3638, 'type': 'COM'}",no_relation
493,오브젝티브-C는 C++보다는 스몰토크에 좀 더 가깝게 정의된 언어이다.,"{'word': '오브젝티브-C', 'start': 2566, 'end': 2572, 'type': 'COM'}","{'word': '스몰토크', 'start': 2582, 'end': 2585, 'type': 'COM'}",com:similar_tech
494,"컴퓨터 언어()라는 용어는 컴퓨터와의 커뮤니케이션에 쓰이는 다양한 종류의 언어들을 일컫는 말로서, 흔히 사용되는 프로그래밍 언어라는 용어의 뜻을 확장한 용어이다.","{'word': '컴퓨터 언어', 'start': 0, 'end': 5, 'type': 'COM'}","{'word': '프로그래밍 언어', 'start': 63, 'end': 70, 'type': 'COM'}",com:sub_concept
495,프로그래밍 언어는 컴퓨터 언어의 부분집합이다.,"{'word': '컴퓨터 언어', 'start': 101, 'end': 106, 'type': 'COM'}","{'word': '프로그래밍 언어', 'start': 91, 'end': 98, 'type': 'COM'}",com:sub_concept
496,오늘날 대부분의 소프트웨어는 고급 언어로 작성된다.,"{'word': '소프트웨어', 'start': 337, 'end': 341, 'type': 'COM'}","{'word': '고급 언어', 'start': 344, 'end': 348, 'type': 'COM'}",com:made_of
497,사람이 읽을 수 있는 언어는 사람이 직접 사용하여 컴퓨터와 커뮤니케이트하게 해주는 용도로 쓰일 수 있다.,"{'word': '사람', 'start': 479, 'end': 480, 'type': 'PER'}","{'word': '컴퓨터', 'start': 507, 'end': 509, 'type': 'COM'}",no_relation
498,고급(high level) 언어와 저급(low level)언어로 나뉠 수 있다.,"{'word': '고급(high level) 언어', 'start': 152, 'end': 168, 'type': 'COM'}","{'word': '저급(low level)언어', 'start': 171, 'end': 185, 'type': 'COM'}",no_relation
499,"고급 언어는 저급 언어보다 사용하기 쉽고, 더 추상적이며, 더 이식 가능성이 높게 디자인된다.","{'word': '저급 언어', 'start': 204, 'end': 208, 'type': 'COM'}","{'word': '고급 언어', 'start': 197, 'end': 201, 'type': 'COM'}",no_relation
500,"어떤 언어의 경우에는, 문법적으로 올바른 프로그램들은 저급 언어로 컴파일(compile)되어 컴퓨터 상에서 실행(execute)되게 된다.","{'word': '컴파일', 'start': 287, 'end': 289, 'type': 'COM'}","{'word': '프로그램', 'start': 273, 'end': 276, 'type': 'COM'}",no_relation
501,그 후 오브젝트 코드로 컴파일되고 난 뒤 기계어로 변환된다.,"{'word': '기계어', 'start': 380, 'end': 382, 'type': 'COM'}","{'word': '오브젝트 코드', 'start': 361, 'end': 367, 'type': 'COM'}",no_relation
502,사람이 읽을 수 있는(human-readable) 언어와 사람이 읽을 수 없는 언어로 분류할 수 있다.,"{'word': '사람이 읽을 수 없는 언어', 'start': 453, 'end': 466, 'type': 'COM'}","{'word': '사람이 읽을 수 있는(human-readable) 언어', 'start': 421, 'end': 450, 'type': 'COM'}",no_relation
503,최초로 공개된 JIT 컴파일러는 일반적으로 1960년 존 매카시의 리스프에 공이 주어진다.,"{'word': '최초로 공개된 JIT 컴파일러', 'start': 1308, 'end': 1323, 'type': 'COM'}","{'word': '1960년', 'start': 1332, 'end': 1336, 'type': 'DAT'}",com:date_of_prod
504,일반적인 인터프러터 언어(예시: cpython)는 바이트코드나 소스코드를 최적화 과정이 없이 번역하기 때문에 성능이 낮다.,"{'word': '인터프러터 언어', 'start': 768, 'end': 775, 'type': 'COM'}","{'word': 'cpython', 'start': 781, 'end': 787, 'type': 'COM'}",com:sub_concept
505,"반면 정적으로 컴파일하는 언어(예시: c 언어)는 실행 전에 무조건 컴파일을 해야하기 때문에 다양한 플랫폼에 맞게 컴파일을 하려면 시간이 오래 걸린다. ""동적 컴파일 환경""은 실행 과정에서 컴파일을 할 수 있기 위해 만들어졌다.","{'word': '정적으로 컴파일하는 언어', 'start': 835, 'end': 847, 'type': 'COM'}","{'word': 'c 언어', 'start': 853, 'end': 856, 'type': 'COM'}",com:sub_concept
506,JIT 컴파일() 또는 동적 번역()은 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법이다.,"{'word': 'JIT 컴파일', 'start': 0, 'end': 6, 'type': 'COM'}","{'word': '동적 번역', 'start': 13, 'end': 17, 'type': 'COM'}",com:alter_names
507,"전통적인 입장에서 컴퓨터 프로그램을 만드는 방법은 두 가지가 있는데, 인터프리트 방식과 정적 컴파일 방식으로 나눌 수 있다.","{'word': '인터프리트 방식', 'start': 99, 'end': 106, 'type': 'COM'}","{'word': '정적 컴파일 방식', 'start': 109, 'end': 117, 'type': 'COM'}",no_relation
508,"이 중 인터프리트 방식은 실행 중 프로그래밍 언어를 읽어가면서 해당 기능에 대응하는 기계어 코드를 실행하며, 반면 정적 컴파일은 실행하기 전에 프로그램 코드를 기계어로 번역한다.","{'word': '인터프리트 방식', 'start': 134, 'end': 141, 'type': 'COM'}","{'word': '기계어 코드', 'start': 177, 'end': 182, 'type': 'COM'}",no_relation
509,"이 중 인터프리트 방식은 실행 중 프로그래밍 언어를 읽어가면서 해당 기능에 대응하는 기계어 코드를 실행하며, 반면 정적 컴파일은 실행하기 전에 프로그램 코드를 기계어로 번역한다.","{'word': '인터프리트 방식', 'start': 134, 'end': 141, 'type': 'COM'}","{'word': '정적 컴파일', 'start': 194, 'end': 199, 'type': 'COM'}",no_relation
510,"JIT 컴파일러는 두 가지의 방식을 혼합한 방식으로 생각할 수 있는데, 실행 시점에서 인터프리트 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지한다.","{'word': '코드', 'start': 305, 'end': 306, 'type': 'COM'}","{'word': '기계어 코드', 'start': 335, 'end': 340, 'type': 'COM'}",no_relation
511,"최근의 자바 가상 머신과 .NET, V8(node.js)에서는 JIT 컴파일을 지원한다.","{'word': '자바 가상 머신', 'start': 361, 'end': 368, 'type': 'COM'}","{'word': 'V8', 'start': 377, 'end': 378, 'type': 'COM'}",no_relation
512,"즉, 자바 컴파일러가 자바 프로그램 코드를 바이트코드로 변환한 다음, 실제 바이트코드를 실행하는 시점에서 자바 가상 머신이 바이트코드를 JIT 컴파일을 통해 기계어로 변환한다.","{'word': '바이트코드', 'start': 431, 'end': 435, 'type': 'COM'}","{'word': '기계어', 'start': 495, 'end': 497, 'type': 'COM'}",no_relation
513,바이트코드 컴파일러는 소스 코드를 중간언어인 바이트코드로 변환한다.,"{'word': '컴파일러', 'start': 512, 'end': 515, 'type': 'COM'}","{'word': '바이트코드', 'start': 531, 'end': 535, 'type': 'COM'}",no_relation
514,바이트코드는 기계어는 아니지만 가상 머신에 의해 기계어로 손쉽게 변환할 수 있는 코드이다.,"{'word': '바이트코드', 'start': 544, 'end': 548, 'type': 'COM'}","{'word': '기계어', 'start': 551, 'end': 553, 'type': 'COM'}",no_relation
515,JIT 컴파일러는 바이트코드를 읽어 빠른 속도로 기계어를 생성할 수 있다.,"{'word': 'JIT 컴파일러', 'start': 595, 'end': 602, 'type': 'COM'}","{'word': '기계어', 'start': 622, 'end': 624, 'type': 'COM'}",no_relation
516,"이런 기계어 변환은 코드가 실행되는 과정에 실시간으로 일어나며(그래서 Just-In-Time이다), 전체 코드의 필요한 부분만 변환한다.","{'word': '기계어', 'start': 640, 'end': 642, 'type': 'COM'}","{'word': '코드', 'start': 696, 'end': 697, 'type': 'COM'}",no_relation
517,기계어로 변환된 코드는 캐시에 저장되기 때문에 재사용시 컴파일을 다시 할 필요가 없다.,"{'word': '캐시', 'start': 727, 'end': 728, 'type': 'COM'}","{'word': '컴파일', 'start': 745, 'end': 747, 'type': 'COM'}",no_relation
518,JIT는 정적 컴파일러 만큼 빠르면서 인터프러터 언어의 빠른 응답속도를 추구하기 위해 사용한다.,"{'word': 'JIT', 'start': 960, 'end': 962, 'type': 'COM'}","{'word': '인터프러터 언어', 'start': 981, 'end': 988, 'type': 'COM'}",no_relation
519,바이트코드 컴파일러가 시간이 많이 소요되는 최적화를 미리 해주기 때문에 바이트코드에서 기계어 번역은 훨씬 빠르게 진행될 수 있다.,"{'word': '바이트코드', 'start': 1014, 'end': 1018, 'type': 'COM'}","{'word': '최적화', 'start': 1038, 'end': 1040, 'type': 'COM'}",no_relation
520,"플랫폼 별로 가상 머신을 개발하는 과정은 컴파일러를 만드는 것보다 간단한데, 그 이유는","{'word': '플랫폼', 'start': 1136, 'end': 1138, 'type': 'COM'}","{'word': '컴파일러', 'start': 1159, 'end': 1162, 'type': 'COM'}",no_relation
521,"JIT 코드는 일반적인 인터프러터 언어에 비해 훨씬 좋은 성능을 낸다. 심지어 경우에 따라 정적 컴파일러 언어보다 좋은 성능을 내곤 하는데, 이는 실행 과정에 컴파일을 할 수 있기 때문에 가지는 장점이라고 할 수 있다:","{'word': 'JIT 코드', 'start': 1185, 'end': 1190, 'type': 'COM'}","{'word': '정적 컴파일러 언어', 'start': 1236, 'end': 1245, 'type': 'COM'}",no_relation
522,"컴파일 언어(compiled language)는 구현체들이 일반적으로 컴파일러(소스 코드로부터 기계어를 생성해내는 변환기)이면서 인터프리터(런타임 전 변환 과정을 거치지 않는, 소스 코드의 단계별 실행기)가 아닌 프로그래밍 언어이다.","{'word': '컴파일러', 'start': 39, 'end': 42, 'type': 'COM'}","{'word': '인터프리터', 'start': 72, 'end': 76, 'type': 'COM'}",no_relation
523,"1967년, ""CACM""에 데이크스트라의 ""GOTO문의 해로움""(Go to statement considered harmful)라는 서한이 실렸다.","{'word': '데이크스트라', 'start': 1747, 'end': 1752, 'type': 'PER'}","{'word': '서한', 'start': 1806, 'end': 1807, 'type': 'POH'}",per:production
524,데이크스트라의 초창기 가드 명령어 언어같은 어떤 언어에서는 구조를 완전히 둘러싸는 codice_8와 같은 구문으로 구조의 단일성을 강조한다.,"{'word': '데이크스트라', 'start': 476, 'end': 481, 'type': 'PER'}","{'word': '초창기 가드 명령어 언어', 'start': 484, 'end': 496, 'type': 'COM'}",per:production
525,"하향식 설계를 할 때, 설계자는 큰 규모의 프로그램을 더 작은 공정으로 나누어 구현하고, 각각 검사한 다음에 전체 프로그램으로 합친다.","{'word': '설계자', 'start': 897, 'end': 899, 'type': 'PER'}","{'word': '하향식 설계', 'start': 884, 'end': 889, 'type': 'COM'}",per:production
526,"1967년, ""CACM""에 데이크스트라의 ""GOTO문의 해로움""(Go to statement considered harmful)라는 서한이 실렸다.","{'word': '데이크스트라', 'start': 1747, 'end': 1752, 'type': 'PER'}","{'word': 'GOTO문의 해로움', 'start': 1756, 'end': 1765, 'type': 'COM'}",per:production
527,카누스는 좀 더 완화된 구조 제한을 제안했다.,"{'word': '카누스', 'start': 2386, 'end': 2388, 'type': 'PER'}","{'word': '좀 더 완화된 구조 제한', 'start': 2391, 'end': 2403, 'type': 'COM'}",per:production
528,"프랭크 루빈은 그 해에 """"GOTO문의 해로움""의 해로움""('Go to statement considered harmful' considered harmful)이라는 글을 썼다.","{'word': '프랭크 루빈', 'start': 2872, 'end': 2877, 'type': 'PER'}","{'word': '""GOTO문의 해로움""의 해로움', 'start': 2886, 'end': 2902, 'type': 'COM'}",per:production
529,프로시저가 2개의 종료점을 갖기 때문에 데이크스트라의 구조적 프로그래밍의 규칙에 어긋난다.,"{'word': '데이크스트라', 'start': 3930, 'end': 3935, 'type': 'PER'}","{'word': '구조적 프로그래밍의 규칙', 'start': 3938, 'end': 3950, 'type': 'COM'}",per:production
530,"데이크스트라가 쓴 ""GOTO문의 해로움""이라는 논문은 이후 ""...의 해로움""이라는 유행을 낳기도 하였다.","{'word': '데이크스트라', 'start': 4876, 'end': 4881, 'type': 'PER'}","{'word': 'GOTO문의 해로움', 'start': 4887, 'end': 4896, 'type': 'COM'}",per:production
531,구조적 프로그램 이론가들은 1970년대 IBM의 연구원 밀즈가 구조적 프로그래밍 이론에 대한 그의 해석을 뉴욕타임즈의 인덱싱 시스템 개발자들에게 적용한 일이 있은 후에 대부분이 합의를 봤다.,"{'word': '밀즈', 'start': 2629, 'end': 2630, 'type': 'PER'}","{'word': 'IBM의 연구원', 'start': 2620, 'end': 2627, 'type': 'POH'}",per:title
532,"각각의 상태 변화를 분리하여 하위프로그램을 만들고 변수를 이용하여 활동중인 상태를 나타내면 가능하긴 하다. 하지만, 카누스를 포함한 일부 프로그래머들은 상태의 변화를 새로운 상태로 직접 분기하는 것을 더 좋아한다.","{'word': '카누스', 'start': 4417, 'end': 4419, 'type': 'PER'}","{'word': '프로그래머', 'start': 4429, 'end': 4433, 'type': 'POH'}",per:title
533,"이 내용들은 1960년대 후반과 1970년대 초반에 개발되었는데 주로 데이크스트라, 플로이드, 호, 그리즈가 많은 공헌을 했다.","{'word': '데이크스트라', 'start': 1633, 'end': 1638, 'type': 'PER'}","{'word': '플로이드', 'start': 1641, 'end': 1644, 'type': 'PER'}",per:colleagues
534,"이 내용들은 1960년대 후반과 1970년대 초반에 개발되었는데 주로 데이크스트라, 플로이드, 호, 그리즈가 많은 공헌을 했다.","{'word': '데이크스트라', 'start': 1633, 'end': 1638, 'type': 'PER'}","{'word': '그리즈', 'start': 1650, 'end': 1652, 'type': 'PER'}",per:colleagues
535,루빈은 물론이거니와 양보하라고 한 다른 필자들까지도 날카롭게 비판한 데이크스트라의 응답과 함께 수많은 반대 의견이 뒤따랐다.,"{'word': '루빈', 'start': 2972, 'end': 2973, 'type': 'PER'}","{'word': '다른 필자들', 'start': 2991, 'end': 2996, 'type': 'PER'}",per:colleagues
536,"그는 1969년""구조적 프로그래밍에 대한 글""에서 이렇게 썼다.:","{'word': '구조적 프로그래밍에 대한 글', 'start': 2146, 'end': 2160, 'type': 'COM'}","{'word': '1969년', 'start': 2140, 'end': 2144, 'type': 'DAT'}",com:date_of_prod
537,"1974년, 그의 논문, ""GOTO문이 포함된 구조적 프로그래밍""에서 직접적인 분기를 하여 입증가능성을 희생시키지 않으면서도 더 간결하고 효율적인 코드를 작성할 수 있는 몇 가지 예제를 보였다.","{'word': 'GOTO문이 포함된 구조적 프로그래밍', 'start': 2292, 'end': 2311, 'type': 'COM'}","{'word': '1974년', 'start': 2277, 'end': 2281, 'type': 'DAT'}",com:date_of_prod
538,구조적 프로그래밍()은 구조화 프로그래밍으로도 불리며 프로그래밍 패러다임의 일종인 절차적 프로그래밍의 하위 개념으로 볼 수 있다.,"{'word': '절차적 프로그래밍', 'start': 46, 'end': 54, 'type': 'COM'}","{'word': '구조적 프로그래밍', 'start': 0, 'end': 8, 'type': 'COM'}",com:sub_concept
539,"저수준의 관점에서 구조적 프로그램은 간단하고, 계층적인 프로그램 제어 구조로 구성된다.","{'word': '구조적 프로그램', 'start': 280, 'end': 287, 'type': 'COM'}","{'word': '프로그램 제어 구조', 'start': 301, 'end': 310, 'type': 'COM'}",com:sub_concept
540,"더 간단한 구문들은 또 다른 제어 구조일 수도 있고, 할당문이나 프로시저 호출과 같은 기본 구문일 수도 있다.","{'word': '기본 구문', 'start': 419, 'end': 423, 'type': 'COM'}","{'word': '할당문', 'start': 401, 'end': 403, 'type': 'COM'}",com:sub_concept
541,"더 간단한 구문들은 또 다른 제어 구조일 수도 있고, 할당문이나 프로시저 호출과 같은 기본 구문일 수도 있다.","{'word': '기본 구문', 'start': 419, 'end': 423, 'type': 'COM'}","{'word': '프로시저 호출', 'start': 407, 'end': 413, 'type': 'COM'}",com:sub_concept
542,"C 같은 다른 언어들은 구조의 단일성을 강조하지 않는데, 잘못 이해하거나 잘못 수정할 수 있는 위험이 커지는 것은 아니다.","{'word': '언어', 'start': 563, 'end': 564, 'type': 'COM'}","{'word': 'C', 'start': 555, 'end': 555, 'type': 'COM'}",com:sub_concept
543,"코드 작성자는 큰 조각의 코드를 이해하기 쉬운 크기의 작은 하부 프로그램(함수, 프로시저, 메서드, 블록, 등)으로 나누어야 한다.","{'word': '큰 조각의 코드', 'start': 632, 'end': 639, 'type': 'COM'}","{'word': '하부 프로그램', 'start': 657, 'end': 663, 'type': 'COM'}",com:sub_concept
544,"코드 작성자는 큰 조각의 코드를 이해하기 쉬운 크기의 작은 하부 프로그램(함수, 프로시저, 메서드, 블록, 등)으로 나누어야 한다.","{'word': '하부 프로그램', 'start': 657, 'end': 663, 'type': 'COM'}","{'word': '함수, 프로시저, 메서드, 블록', 'start': 665, 'end': 681, 'type': 'COM'}",com:sub_concept
545,"하향식 설계를 할 때, 설계자는 큰 규모의 프로그램을 더 작은 공정으로 나누어 구현하고, 각각 검사한 다음에 전체 프로그램으로 합친다.","{'word': '전체 프로그램', 'start': 945, 'end': 951, 'type': 'COM'}","{'word': '더 작은 공정', 'start': 914, 'end': 920, 'type': 'COM'}",com:sub_concept
546,"모든 절차적 프로그래밍 언어에서 구조적 프로그래밍을 할 수 있다. 1970년쯤부터 구조적 프로그래밍이 인기있는 기법이 되었기 때문에, 대부분의 새로 나온 절차적 프로그래밍 언어들이 구조적 프로그래밍을 고취시키기 위한 특징을 추가하였고 구조화되지 않은 프로그래밍을 쉽게 하기 위한 특징들은 남겨둔 것들도 있었다.","{'word': '절차적 프로그래밍 언어', 'start': 963, 'end': 974, 'type': 'COM'}","{'word': '구조적 프로그래밍', 'start': 978, 'end': 986, 'type': 'COM'}",com:sub_concept
547,잘 알려진 구조적 프로그래밍 언어에는 파스칼(Pascal)과 에이다(Ada)가 있다.,"{'word': '구조적 프로그래밍 언어', 'start': 1140, 'end': 1151, 'type': 'COM'}","{'word': '파스칼', 'start': 1155, 'end': 1157, 'type': 'COM'}",com:sub_concept
548,잘 알려진 구조적 프로그래밍 언어에는 파스칼(Pascal)과 에이다(Ada)가 있다.,"{'word': '구조적 프로그래밍 언어', 'start': 1140, 'end': 1151, 'type': 'COM'}","{'word': '에이다', 'start': 1168, 'end': 1170, 'type': 'COM'}",com:sub_concept
549,"이런 점은 구조적 프로그래밍 운동에서 나온 것은 아니지만, 이런 구조들은 중앙 처리 장치의 명령 주기뿐만 아니라 튜링 기계의 동작을 설명하는 데 충분하다.","{'word': '중앙 처리 장치', 'start': 1325, 'end': 1332, 'type': 'COM'}","{'word': '명령 주기', 'start': 1335, 'end': 1339, 'type': 'COM'}",com:sub_concept
550,"이 글에서 그는 뵘과 야코피니의 증명을 인용하면서, 고급언어에서 GOTO 명령을 제거하는 것이 코드의 질을 높일 수 있다고 했다.","{'word': '고급언어', 'start': 1844, 'end': 1847, 'type': 'COM'}","{'word': 'GOTO 명령', 'start': 1851, 'end': 1857, 'type': 'COM'}",com:sub_concept
551,"그것은 프로그램의 순서도를 그린다면 왼쪽에는 아래쪽으로 가는 가지(branches)만, 오른쪽에는 위쪽으로 가는 가지만 그려야하며 그 가지들이 서로 교차하지 않아야 한다는 것이다.","{'word': '프로그램의 순서도', 'start': 2416, 'end': 2424, 'type': 'COM'}","{'word': '가지', 'start': 2446, 'end': 2447, 'type': 'COM'}",com:sub_concept
552,"포트란, 코볼, 베이직과 같이 프로그래밍 구조가 원래 취약한 고급 프로그래밍 언어들은 이제 그런 구조를 가지고 있다.","{'word': '고급 프로그래밍 언어', 'start': 3146, 'end': 3156, 'type': 'COM'}","{'word': '포트란', 'start': 3112, 'end': 3114, 'type': 'COM'}",com:sub_concept
553,"포트란, 코볼, 베이직과 같이 프로그래밍 구조가 원래 취약한 고급 프로그래밍 언어들은 이제 그런 구조를 가지고 있다.","{'word': '고급 프로그래밍 언어', 'start': 3146, 'end': 3156, 'type': 'COM'}","{'word': '코볼', 'start': 3117, 'end': 3118, 'type': 'COM'}",com:sub_concept
554,"포트란, 코볼, 베이직과 같이 프로그래밍 구조가 원래 취약한 고급 프로그래밍 언어들은 이제 그런 구조를 가지고 있다.","{'word': '고급 프로그래밍 언어', 'start': 3146, 'end': 3156, 'type': 'COM'}","{'word': '베이직', 'start': 3121, 'end': 3123, 'type': 'COM'}",com:sub_concept
555,"프로그래머가 경험을 쌓을수록 엄격한 의미의 구조적 프로그래밍을 침해하는 어떤 부분이 있는지를 이해하기가 쉽다는 것을 알았고, 널리 퍼진 몇몇 프로그래밍 언어들은 직접적인 분기문을 제한하고 있으며 예외처리를 이런 상황에서 사용할 수 있게 하고 있다.","{'word': '프로그래밍 언어들', 'start': 3305, 'end': 3313, 'type': 'COM'}","{'word': '예외처리', 'start': 3335, 'end': 3338, 'type': 'COM'}",com:sub_concept
556,주요한 산업용 언어들은 자바와 같은 언어들을 제외하고는 프로시저 내에서의 직접 분기를 위하여 GOTO문을 여전히 유지하고 있다.,"{'word': '산업용 언어들', 'start': 3369, 'end': 3375, 'type': 'COM'}","{'word': 'GOTO문', 'start': 3417, 'end': 3421, 'type': 'COM'}",com:sub_concept
557,"C는 continue, break, return과 같이 여러가지 경로로 구조에서 빠져나가는 것을 허용하고, 더 새로운 언어들은 레이블한 루프(전자와 비슷하지만 제일 안쪽 루프 뿐만 아니라 그 이상도 빠져나갈 수 있게 해 준다)와 예외처리를 지원한다.","{'word': '더 새로운 언어들', 'start': 4217, 'end': 4225, 'type': 'COM'}","{'word': '레이블한 루프', 'start': 4228, 'end': 4234, 'type': 'COM'}",com:sub_concept
558,"C는 continue, break, return과 같이 여러가지 경로로 구조에서 빠져나가는 것을 허용하고, 더 새로운 언어들은 레이블한 루프(전자와 비슷하지만 제일 안쪽 루프 뿐만 아니라 그 이상도 빠져나갈 수 있게 해 준다)와 예외처리를 지원한다.","{'word': '더 새로운 언어들', 'start': 4217, 'end': 4225, 'type': 'COM'}","{'word': '예외처리', 'start': 4285, 'end': 4288, 'type': 'COM'}",com:sub_concept
559,특히 구문분석기와 통신 규약 같은 프로그램들은 상태들이 있어서 기본 구조들로 줄이기가 쉽지 않다.,"{'word': '통신 규약', 'start': 4307, 'end': 4311, 'type': 'COM'}","{'word': '상태들', 'start': 4323, 'end': 4325, 'type': 'COM'}",com:sub_concept
560,구조적 프로그래밍()은 구조화 프로그래밍으로도 불리며 프로그래밍 패러다임의 일종인 절차적 프로그래밍의 하위 개념으로 볼 수 있다.,"{'word': '구조적 프로그래밍', 'start': 0, 'end': 8, 'type': 'COM'}","{'word': '구조화 프로그래밍', 'start': 13, 'end': 21, 'type': 'COM'}",com:alter_names
561,잘 알려진 구조적 프로그래밍 언어에는 파스칼(Pascal)과 에이다(Ada)가 있다.,"{'word': '파스칼', 'start': 1155, 'end': 1157, 'type': 'COM'}","{'word': 'Pascal', 'start': 1159, 'end': 1164, 'type': 'COM'}",com:alter_names
562,잘 알려진 구조적 프로그래밍 언어에는 파스칼(Pascal)과 에이다(Ada)가 있다.,"{'word': '에이다', 'start': 1168, 'end': 1170, 'type': 'COM'}","{'word': 'Ada', 'start': 1172, 'end': 1174, 'type': 'COM'}",com:alter_names
563,구조적 프로그래밍의 선구적 실천가(얼리어답터)인 플로저는 구조적 프로그램 정리에 대한 그의 반응을 이렇게 설명했다.:,"{'word': '선구적 실천가', 'start': 1677, 'end': 1683, 'type': 'COM'}","{'word': '얼리어답터', 'start': 1685, 'end': 1689, 'type': 'COM'}",com:alter_names
564,"1967년, ""CACM""에 데이크스트라의 ""GOTO문의 해로움""(Go to statement considered harmful)라는 서한이 실렸다.","{'word': 'Go to statement considered harmful', 'start': 1768, 'end': 1801, 'type': 'COM'}","{'word': 'GOTO문의 해로움', 'start': 1756, 'end': 1765, 'type': 'COM'}",com:alter_names
565,컴파일러와 그래프 이론에 정통해 있는 많은 사람들이 축소 가능한 흐름도(reducible flow graphs)만을 허용해야한다고 이 생각을 옹호했다.,"{'word': '축소 가능한 흐름도', 'start': 2542, 'end': 2551, 'type': 'COM'}","{'word': 'reducible flow graphs', 'start': 2553, 'end': 2573, 'type': 'COM'}",com:alter_names
566,역사적으로 구조적 프로그램을 작성하기 위하여 몇가지 다른 구조화 기법과 방법론이 개발되어왔다.,"{'word': '구조적 프로그램', 'start': 124, 'end': 131, 'type': 'COM'}","{'word': '구조화 기법과 방법론', 'start': 150, 'end': 160, 'type': 'COM'}",com:made_of
567,구조적 프로그램 정리는 구조적 프로그래밍의 이론적 기반이 되었다.,"{'word': '구조적 프로그래밍', 'start': 1195, 'end': 1203, 'type': 'COM'}","{'word': '구조적 프로그램 정리', 'start': 1182, 'end': 1192, 'type': 'COM'}",com:made_of
568,"정리에 따르면, 프로그램을 결합하는 3가지 방법인 순차, 분기, 반복만으로 충분히 계산가능 함수를 표현할 수 있다.","{'word': '계산가능 함수', 'start': 1265, 'end': 1271, 'type': 'COM'}","{'word': '순차, 분기, 반복', 'start': 1247, 'end': 1256, 'type': 'COM'}",com:made_of
569,"구조적 프로그래밍에 대한 논의는 많은 새로운 언어를 낳았으며, 기존의 언어에 구조적인 면이 추가되는 등 언어의 발전에 도움이 되었다. 그리고 이후에 나온 프로그래밍 패러다임들에도 영향을 끼쳤다.","{'word': '프로그래밍 패러다임', 'start': 4558, 'end': 4567, 'type': 'COM'}","{'word': '구조적 프로그래밍에 대한 논의', 'start': 4472, 'end': 4487, 'type': 'COM'}",com:prior_tech
570,GOTO문을 없애거나 GOTO문에 대한 의존성을 줄여주는 것으로 가장 유명하다.,"{'word': 'GOTO문', 'start': 85, 'end': 89, 'type': 'COM'}","{'word': '의존성', 'start': 95, 'end': 97, 'type': 'COM'}",no_relation
571,"일반적으로 프로그램은 전역 변수는 거의 사용하지 않아야 하고 대신에 하부 프로그램은 지역 변수를 사용하거나, 값이나 참조에 의한 인자를 받아야 한다.","{'word': '지역 변수', 'start': 745, 'end': 749, 'type': 'COM'}","{'word': '전역 변수', 'start': 710, 'end': 714, 'type': 'COM'}",no_relation
572,"이런 기법은 전체 프로그램을 한번에 이해하지 않고, 분리된 작은 코드 조각을 쉽게 이해하는 데 도움을 준다.","{'word': '분리된 작은 코드 조각', 'start': 811, 'end': 822, 'type': 'COM'}","{'word': '기법', 'start': 785, 'end': 786, 'type': 'COM'}",no_relation
573,구조적 프로그래밍은 항상 그런 것은 아니지만 하향식 설계와 관련이 있다.,"{'word': '구조적 프로그래밍', 'start': 843, 'end': 851, 'type': 'COM'}","{'word': '하향식 설계', 'start': 868, 'end': 873, 'type': 'COM'}",no_relation
574,"따라서 이런 의미에서 프로세서는 항상 ""구조적 프로그램""을 실행한다.","{'word': '구조적 프로그램', 'start': 1393, 'end': 1400, 'type': 'COM'}","{'word': '프로세서', 'start': 1383, 'end': 1386, 'type': 'COM'}",no_relation
575,구조적 프로그램이 아닌 기억 장치의 다른 부분에서 읽는 명령을 수행해도 그러하다.,"{'word': '구조적 프로그램', 'start': 1410, 'end': 1417, 'type': 'COM'}","{'word': '기억 장치', 'start': 1423, 'end': 1427, 'type': 'COM'}",no_relation
576,"비록 플로저가 언급했듯이 다수의 프로그래머들이 이 정리에 익숙하지 않다고 해도, 이런 프로그래머들을 양성할 가치가 충분히 있을 정도로 몇 년간 소프트웨어 개발은 간결성, 품질, 개발 시간의 측면에서 향상되었다.","{'word': '소프트웨어 개발', 'start': 2002, 'end': 2009, 'type': 'COM'}","{'word': '프로그래머', 'start': 1970, 'end': 1974, 'type': 'COM'}",no_relation
577,도널드 커누스(Donald Knuth)는 프로그램이 입증가능성을 염두에 두고 작성되어야 한다는 원리는 받아들였으나 GOTO문을 없애는 것은 받아들이지 않았고 지금도 받아들이지 않는다.,"{'word': '프로그램', 'start': 2197, 'end': 2200, 'type': 'COM'}","{'word': 'GOTO문', 'start': 2238, 'end': 2242, 'type': 'COM'}",no_relation
578,1987년이 되어서도 여전히 컴퓨터 과학 간행물에서 구조적 프로그래밍에 대해 의문점이 제기되었다.,"{'word': '구조적 프로그래밍', 'start': 2846, 'end': 2854, 'type': 'COM'}","{'word': '컴퓨터 과학 간행물', 'start': 2833, 'end': 2842, 'type': 'COM'}",no_relation
579,"20세기의 막바지에 이르자, 대부분의 컴퓨터 과학자들은 구조적 프로그래밍의 개념을 배우고 적용하는 것은 유용하다고 확신했다.","{'word': '컴퓨터 과학자', 'start': 3063, 'end': 3069, 'type': 'COM'}","{'word': '구조적 프로그래밍', 'start': 3073, 'end': 3081, 'type': 'COM'}",no_relation
580,"대부분의 경우에 하위프로그램에 여러 개의 시작점이 있는 것은 아니지만, 여러 개의 종료점을 가지는 경우는 있다.","{'word': '시작점', 'start': 3552, 'end': 3554, 'type': 'COM'}","{'word': '종료점', 'start': 3575, 'end': 3577, 'type': 'COM'}",no_relation
581,다음은 파일에서 자료를 읽어서 처리하는 간단한 프로시저의 전형적인 예이다:,"{'word': '프로시저', 'start': 3667, 'end': 3670, 'type': 'COM'}","{'word': '파일', 'start': 3645, 'end': 3646, 'type': 'COM'}",no_relation
582,"에러 상황이 더 있다면, 청소 규칙이 서로 달라서, 오히려 goto문을 사용한 비구조적인 것보다 훨씬 읽거나 이해하기 어렵게 될 것이다.","{'word': '에러 상황', 'start': 3990, 'end': 3994, 'type': 'COM'}","{'word': '청소 규칙', 'start': 4004, 'end': 4008, 'type': 'COM'}",no_relation
583,반면에 그런 규칙을 따르지 않는 구조적 프로그래밍은 코드를 아주 깔끔하고 읽기 쉽게 할 것이다.,"{'word': '코드', 'start': 4096, 'end': 4097, 'type': 'COM'}","{'word': '구조적 프로그래밍', 'start': 4085, 'end': 4093, 'type': 'COM'}",no_relation
584,구조적 프로그래밍은 프로그래머의 습관을 바꾸었다.,"{'word': '구조적 프로그래밍', 'start': 4581, 'end': 4589, 'type': 'COM'}","{'word': '프로그래머', 'start': 4592, 'end': 4596, 'type': 'COM'}",no_relation
585,프로그램의 정확성을 증명하는 문제를 떠나서 데이크스트라가 그의 논문에서 말한 대로 시간에 따라 변하는 동적인 과정을 시각화하는 것은 인간에게 매우 어려운 일이다.,"{'word': '프로그램', 'start': 4609, 'end': 4612, 'type': 'COM'}","{'word': '시각화', 'start': 4674, 'end': 4676, 'type': 'COM'}",no_relation
586,꼭 GOTO문만의 문제가 아니라 구조화된 흐름 제어문을 사용한다고 할지라도 너무 복잡하게 중첩되어 있거나 스코프의 길이가 너무 긴 코드를 작성한다거나 너무 긴 길이의 하위프로그램을 작성하는 일을 가급적 피하게 경향이 생겼다.,"{'word': '구조화된 흐름 제어문', 'start': 4718, 'end': 4728, 'type': 'COM'}","{'word': '하위프로그램', 'start': 4793, 'end': 4798, 'type': 'COM'}",no_relation
587,데이크스트라가 구조적 프로그래밍을 표준 교육과정에 편입시키는 데는 성공했지만 엄격한 조건을 고수하는 데는 성공하지 못하였다.,"{'word': '데이크스트라', 'start': 3437, 'end': 3442, 'type': 'PER'}","{'word': '표준 교육과정', 'start': 3456, 'end': 3462, 'type': 'POH'}",no_relation
588,"에츠허르 데이크스트라가 확인한 3가지 형태의 구조는 순차, 선택, 반복이다.","{'word': '에츠허르 데이크스트라', 'start': 433, 'end': 443, 'type': 'PER'}","{'word': '구조', 'start': 458, 'end': 459, 'type': 'COM'}",no_relation
589,"데이크스트라는 구조의 종류를 제한하는 것이 프로그래머가 생각하는 데 집중하는 것을 돕고, 관리 가능한 절차로 분석하여 프로그램의 유효성을 더 간단히 보장할 수 있다고 했다.","{'word': '데이크스트라', 'start': 2040, 'end': 2045, 'type': 'PER'}","{'word': '프로그래머', 'start': 2064, 'end': 2068, 'type': 'COM'}",no_relation
590,GOTO문 제멋대로 사용하는 것을 받아들이는 프로그래밍 교육자들은 찾기가 힘들어졌다.,"{'word': '프로그래밍 교육자', 'start': 3203, 'end': 3211, 'type': 'PER'}","{'word': 'GOTO문', 'start': 3178, 'end': 3182, 'type': 'COM'}",no_relation
591,"데이크스트라가 밀즈의 해석이 출판된 것들과 다르다며 비판하였지만, 다른 회사의 관리자들까지도 구조적 프로그래밍의 채택을 지원하기 위하여 밀즈의 해석을 인용했다.","{'word': '데이크스트라', 'start': 2727, 'end': 2732, 'type': 'PER'}","{'word': '밀즈', 'start': 2735, 'end': 2736, 'type': 'PER'}",no_relation
592,"이 제어 구조들은 하나의 구문으로 간주되며, 동시에 더 간단한 구문들을 결합시키는 방법이다.","{'word': '제어 구조들', 'start': 321, 'end': 326, 'type': 'COM'}","{'word': '하나의 구문', 'start': 329, 'end': 334, 'type': 'COM'}",com:similar_tech
593,"포트란, 코볼, 베이직과 같이 프로그래밍 구조가 원래 취약한 고급 프로그래밍 언어들은 이제 그런 구조를 가지고 있다.","{'word': '포트란', 'start': 3112, 'end': 3114, 'type': 'COM'}","{'word': '코볼', 'start': 3117, 'end': 3118, 'type': 'COM'}",com:similar_tech
594,"포트란, 코볼, 베이직과 같이 프로그래밍 구조가 원래 취약한 고급 프로그래밍 언어들은 이제 그런 구조를 가지고 있다.","{'word': '포트란', 'start': 3112, 'end': 3114, 'type': 'COM'}","{'word': '베이직', 'start': 3121, 'end': 3123, 'type': 'COM'}",com:similar_tech
595,새로운 언어를 만들려는 의의는 박사 논문을 위한 스트롭스트룹의 프로그래밍 경험에서 비롯되었다.,"{'word': '스트롭스트룹', 'start': 170, 'end': 175, 'type': 'PER'}","{'word': '박사 논문', 'start': 160, 'end': 164, 'type': 'POH'}",per:production
596,C++는 AT&amp;T 벨 연구소의 비야네 스트롭스트룹이 C언어 기반으로 1983년 발표하여 발전한 프로그래밍 언어이다.,"{'word': '비야네 스트롭스트룹', 'start': 21, 'end': 30, 'type': 'PER'}","{'word': 'C++', 'start': 0, 'end': 2, 'type': 'COM'}",per:production
597,"1979년, 덴마크의 컴퓨터 과학자 비야네 스트롭스트룹은 C++의 선구자격 언어인 ""C with Classes"" 작업에 착수하였다.","{'word': '비야네 스트롭스트룹', 'start': 89, 'end': 98, 'type': 'PER'}","{'word': 'C with Classes', 'start': 116, 'end': 129, 'type': 'COM'}",per:production
598,"1979년, 덴마크의 컴퓨터 과학자 비야네 스트롭스트룹은 C++의 선구자격 언어인 ""C with Classes"" 작업에 착수하였다.","{'word': '비야네 스트롭스트룹', 'start': 89, 'end': 98, 'type': 'PER'}","{'word': '컴퓨터 과학자', 'start': 81, 'end': 87, 'type': 'POH'}",per:title
599,C++는 AT&amp;T 벨 연구소의 비야네 스트롭스트룹이 C언어 기반으로 1983년 발표하여 발전한 프로그래밍 언어이다.,"{'word': '벨 연구소', 'start': 14, 'end': 18, 'type': 'ORG'}","{'word': 'C++', 'start': 0, 'end': 2, 'type': 'COM'}",org:production
600,C++는 AT&amp;T 벨 연구소의 비야네 스트롭스트룹이 C언어 기반으로 1983년 발표하여 발전한 프로그래밍 언어이다.,"{'word': 'C++', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': '1983년', 'start': 42, 'end': 46, 'type': 'DAT'}",com:date_of_prod
601,"1979년, 덴마크의 컴퓨터 과학자 비야네 스트롭스트룹은 C++의 선구자격 언어인 ""C with Classes"" 작업에 착수하였다.","{'word': 'C with Classes', 'start': 116, 'end': 129, 'type': 'COM'}","{'word': '1979년', 'start': 69, 'end': 73, 'type': 'DAT'}",com:date_of_prod
602,"1983년, ""C with Classes""라는 이름은 가상 함수, 함수 이름, 연산자 오버로딩, 참조, 제약조건, type-safe free-store 메모리 할당 (new/delete), 개선된 자료형 검사, BCPL 스타일의 1줄 코멘트(//)를 포함한 새로운 기능들을 추가하면서 ""C++""로 변경되었다.","{'word': 'C++', 'start': 456, 'end': 458, 'type': 'COM'}","{'word': '1983년', 'start': 296, 'end': 300, 'type': 'DAT'}",com:date_of_prod
603,1985년 C++ 프로그래밍 언어 제1판이 출시되었으며 당시 공식표준이 없었기 때문에 이 언어의 절대적인 참조 문헌이 되었다.,"{'word': 'C++ 프로그래밍 언어 제1판', 'start': 475, 'end': 490, 'type': 'COM'}","{'word': '1985년', 'start': 469, 'end': 473, 'type': 'DAT'}",com:date_of_prod
604,최초의 C++ 상용 구현체는 같은 해 10월에 출시되었다.,"{'word': '최초의 C++ 상용 구현체', 'start': 540, 'end': 553, 'type': 'COM'}","{'word': '같은 해 10월', 'start': 556, 'end': 563, 'type': 'DAT'}",com:date_of_prod
605,C++는 AT&amp;T 벨 연구소의 비야네 스트롭스트룹이 C언어 기반으로 1983년 발표하여 발전한 프로그래밍 언어이다.,"{'word': '프로그래밍 언어', 'start': 57, 'end': 64, 'type': 'COM'}","{'word': 'C++', 'start': 0, 'end': 2, 'type': 'COM'}",com:sub_concept
606,"처음에 스트롭스트룹의 ""C with Classes""는 C 컴파일러(Cpre)에 클래스, 상속 클래스, 스트롱 타이핑, 인라인 확장, 기본 인수를 포함한 여러 기능들을 추가하였다.","{'word': 'C with Classes', 'start': 209, 'end': 222, 'type': 'COM'}","{'word': '상속 클래스', 'start': 245, 'end': 250, 'type': 'COM'}",com:sub_concept
607,"1983년, ""C with Classes""라는 이름은 가상 함수, 함수 이름, 연산자 오버로딩, 참조, 제약조건, type-safe free-store 메모리 할당 (new/delete), 개선된 자료형 검사, BCPL 스타일의 1줄 코멘트(//)를 포함한 새로운 기능들을 추가하면서 ""C++""로 변경되었다.","{'word': 'C++', 'start': 456, 'end': 458, 'type': 'COM'}","{'word': '가상 함수', 'start': 326, 'end': 330, 'type': 'COM'}",com:sub_concept
608,"1983년, ""C with Classes""라는 이름은 가상 함수, 함수 이름, 연산자 오버로딩, 참조, 제약조건, type-safe free-store 메모리 할당 (new/delete), 개선된 자료형 검사, BCPL 스타일의 1줄 코멘트(//)를 포함한 새로운 기능들을 추가하면서 ""C++""로 변경되었다.","{'word': 'C++', 'start': 456, 'end': 458, 'type': 'COM'}","{'word': '오버로딩', 'start': 344, 'end': 347, 'type': 'COM'}",com:sub_concept
609,"그 후, C 언어의 표준 규격이 바뀔 때 const 수식 등 C++의 기능이 C 언어에 받아들이기도 했다.","{'word': 'C++', 'start': 837, 'end': 839, 'type': 'COM'}","{'word': 'const 수식', 'start': 826, 'end': 833, 'type': 'COM'}",com:sub_concept
610,"처음에 스트롭스트룹의 ""C with Classes""는 C 컴파일러(Cpre)에 클래스, 상속 클래스, 스트롱 타이핑, 인라인 확장, 기본 인수를 포함한 여러 기능들을 추가하였다.","{'word': 'C 컴파일러', 'start': 226, 'end': 231, 'type': 'COM'}","{'word': 'Cpre', 'start': 233, 'end': 236, 'type': 'COM'}",com:alter_names
611,"1983년, ""C with Classes""라는 이름은 가상 함수, 함수 이름, 연산자 오버로딩, 참조, 제약조건, type-safe free-store 메모리 할당 (new/delete), 개선된 자료형 검사, BCPL 스타일의 1줄 코멘트(//)를 포함한 새로운 기능들을 추가하면서 ""C++""로 변경되었다.","{'word': 'C with Classes', 'start': 304, 'end': 317, 'type': 'COM'}","{'word': 'C++', 'start': 456, 'end': 458, 'type': 'COM'}",com:alter_names
612,초기의 C++은 C 위에 놓인 트랜스레이터로 구현되었다.,"{'word': 'C++', 'start': 693, 'end': 695, 'type': 'COM'}","{'word': '트랜스레이터', 'start': 706, 'end': 711, 'type': 'COM'}",com:made_of
613,C++는 AT&amp;T 벨 연구소의 비야네 스트롭스트룹이 C언어 기반으로 1983년 발표하여 발전한 프로그래밍 언어이다.,"{'word': 'C++', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': 'C', 'start': 33, 'end': 33, 'type': 'COM'}",com:prior_tech
614,"1979년, 덴마크의 컴퓨터 과학자 비야네 스트롭스트룹은 C++의 선구자격 언어인 ""C with Classes"" 작업에 착수하였다.","{'word': 'C++', 'start': 101, 'end': 103, 'type': 'COM'}","{'word': 'C with Classes', 'start': 116, 'end': 129, 'type': 'COM'}",com:prior_tech
615,"즉, C++ 프로그램을 일단 C 프로그램으로 변환하고 나서 C 컴파일러로 컴파일하는 식이었고 따라서 C 언어에 대해 상위 호환성을 갖는 언어였다.","{'word': 'C++ 프로그램', 'start': 724, 'end': 731, 'type': 'COM'}","{'word': 'C 프로그램', 'start': 737, 'end': 742, 'type': 'COM'}",com:prior_tech
616,"C 언어에 객체지향 프로그래밍을 지원하기 위한 내용이 덧붙여진 것이라고 할 수도 있지만, 애초부터 객체지향을 염두에 두고 만들어진 언어와는 다르게, 단지 더 좋은 C 언어로서 수속형 언어로 취급하기도 한다.","{'word': '수속형 언어', 'start': 671, 'end': 676, 'type': 'COM'}","{'word': '객체지향', 'start': 628, 'end': 631, 'type': 'COM'}",no_relation
617,자바 가상 머신은 설계자인 제임스 고슬링()에 따르면 UCSD 파스칼의 p-코드()와 스몰토크 VM에 영향을 받았다고 한다.,"{'word': '제임스 고슬링', 'start': 360, 'end': 366, 'type': 'PER'}","{'word': '자바 가상 머신', 'start': 345, 'end': 352, 'type': 'COM'}",per:production
618,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '운영 체제 개발사', 'start': 2337, 'end': 2345, 'type': 'ORG'}","{'word': '자바 VM', 'start': 2385, 'end': 2389, 'type': 'COM'}",org:production
619,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': 'GNU', 'start': 2397, 'end': 2399, 'type': 'ORG'}","{'word': '오픈 소스 자바 가상 머신', 'start': 2489, 'end': 2502, 'type': 'COM'}",org:production
620,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '아파치 소프트웨어 재단', 'start': 2407, 'end': 2418, 'type': 'ORG'}","{'word': '오픈 소스 자바 가상 머신', 'start': 2489, 'end': 2502, 'type': 'COM'}",org:production
621,이러한 공개 소프트웨어 단체의 움직임에 따라 썬 마이크로시스템즈에서도 자사의 자바 가상 머신 및 개발 도구 킷을 오픈 소스 정책에 맞추어 공개한 상황이다.,"{'word': '썬 마이크로시스템즈', 'start': 2536, 'end': 2545, 'type': 'ORG'}","{'word': '자바 가상 머신', 'start': 2554, 'end': 2561, 'type': 'COM'}",org:production
622,이러한 공개 소프트웨어 단체의 움직임에 따라 썬 마이크로시스템즈에서도 자사의 자바 가상 머신 및 개발 도구 킷을 오픈 소스 정책에 맞추어 공개한 상황이다.,"{'word': '썬 마이크로시스템즈', 'start': 2536, 'end': 2545, 'type': 'ORG'}","{'word': '개발 도구 킷', 'start': 2565, 'end': 2571, 'type': 'COM'}",org:production
623,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다. 이러한 공개 소프트웨어 단체의 움직임에 따라 썬 마이크로시스템즈에서도 자사의 자바 가상 머신 및 개발 도구 킷을 오픈 소스 정책에 맞추어 공개한 상황이다.","{'word': '공개 소프트웨어 단체', 'start': 2515, 'end': 2525, 'type': 'ORG'}","{'word': 'GNU', 'start': 2397, 'end': 2399, 'type': 'ORG'}",org:members
624,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다. 이러한 공개 소프트웨어 단체의 움직임에 따라 썬 마이크로시스템즈에서도 자사의 자바 가상 머신 및 개발 도구 킷을 오픈 소스 정책에 맞추어 공개한 상황이다.","{'word': '공개 소프트웨어 단체', 'start': 2515, 'end': 2525, 'type': 'ORG'}","{'word': '아파치 소프트웨어 재단', 'start': 2407, 'end': 2418, 'type': 'ORG'}",org:members
625,"자바 가상 머신은 이 두 가상 머신처럼 스택 기반이어서 대다수의 명령어가 스택 선두에서 피연산자를 택하고 결과는 다시 스택에 넣는다. 스택 상의 피연산자 타입을 구분하고 명령어에 스택 상의 피연산자 타입을 기술하는 면에서는 p-코드와 유사하며 실제 구조에는 차이가 있지만 가비지 컬렉션을 사용하고 객체와 메서드 호출 개념이 있다는 점에서는 스몰토크 가상 머신과 영향을 받았다고 볼 수 있다. 하지만 p-코드가 타입 안전성을 담보하지 못해 메모리 내용을 망가뜨릴 수 있다는 점, 그리고 스몰토크 가상 머신이 동적 타입을 사용하는 스몰토크 언어 자체와 마찬가지로 타입 구분을 하지 않는다는 점에서는 자바 가상 머신과 다르다.","{'word': '자바 가상 머신', 'start': 415, 'end': 422, 'type': 'COM'}","{'word': '가비지 컬렉션', 'start': 567, 'end': 573, 'type': 'COM'}",com:sub_concept
626,"자바 가상 머신은 이 두 가상 머신처럼 스택 기반이어서 대다수의 명령어가 스택 선두에서 피연산자를 택하고 결과는 다시 스택에 넣는다. 스택 상의 피연산자 타입을 구분하고 명령어에 스택 상의 피연산자 타입을 기술하는 면에서는 p-코드와 유사하며 실제 구조에는 차이가 있지만 가비지 컬렉션을 사용하고 객체와 메서드 호출 개념이 있다는 점에서는 스몰토크 가상 머신과 영향을 받았다고 볼 수 있다. 하지만 p-코드가 타입 안전성을 담보하지 못해 메모리 내용을 망가뜨릴 수 있다는 점, 그리고 스몰토크 가상 머신이 동적 타입을 사용하는 스몰토크 언어 자체와 마찬가지로 타입 구분을 하지 않는다는 점에서는 자바 가상 머신과 다르다.","{'word': '자바 가상 머신', 'start': 415, 'end': 422, 'type': 'COM'}","{'word': '메서드 호출 개념', 'start': 585, 'end': 593, 'type': 'COM'}",com:sub_concept
627,특히 자바 가상 머신 위에서 동적인 스크립트 언어가 널리 쓰이게 되면서 자바(프로그래밍 언어)에서는 동적 타입 언어()를 지원하기 위한 추가 명령과 API가 추가되었다.,"{'word': '프로그래밍 언어', 'start': 1049, 'end': 1056, 'type': 'COM'}","{'word': '자바', 'start': 1046, 'end': 1047, 'type': 'COM'}",com:sub_concept
628,특히 자바 가상 머신 위에서 동적인 스크립트 언어가 널리 쓰이게 되면서 자바(프로그래밍 언어)에서는 동적 타입 언어()를 지원하기 위한 추가 명령과 API가 추가되었다.,"{'word': '자바', 'start': 1046, 'end': 1047, 'type': 'COM'}","{'word': 'API', 'start': 1089, 'end': 1091, 'type': 'COM'}",com:sub_concept
629,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'JVM 바이트코드 대 자바스크립트 컴파일러', 'start': 1412, 'end': 1434, 'type': 'COM'}","{'word': 'TeaVM', 'start': 1438, 'end': 1442, 'type': 'COM'}",com:sub_concept
630,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'JVM 바이트코드 대 자바스크립트 컴파일러', 'start': 1412, 'end': 1434, 'type': 'COM'}","{'word': 'Dragome Web SDK에 포함된 컴파일러', 'start': 1445, 'end': 1469, 'type': 'COM'}",com:sub_concept
631,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'JVM 바이트코드 대 자바스크립트 컴파일러', 'start': 1412, 'end': 1434, 'type': 'COM'}","{'word': 'Bck2Brwsr', 'start': 1472, 'end': 1480, 'type': 'COM'}",com:sub_concept
632,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'JVM 바이트코드 대 자바스크립트 컴파일러', 'start': 1412, 'end': 1434, 'type': 'COM'}","{'word': 'j2js-compiler', 'start': 1483, 'end': 1495, 'type': 'COM'}",com:sub_concept
633,"참고로 자바 플랫폼은 자바 SE, 자바 EE, 자바 ME, 자바 카드로 구분되나 자바 가상 머신 규격은 이 분류와 일치하지는 않는다.","{'word': '자바 플랫폼', 'start': 1544, 'end': 1549, 'type': 'COM'}","{'word': '자바 SE', 'start': 1552, 'end': 1556, 'type': 'COM'}",com:sub_concept
634,"참고로 자바 플랫폼은 자바 SE, 자바 EE, 자바 ME, 자바 카드로 구분되나 자바 가상 머신 규격은 이 분류와 일치하지는 않는다.","{'word': '자바 플랫폼', 'start': 1544, 'end': 1549, 'type': 'COM'}","{'word': '자바 EE', 'start': 1559, 'end': 1563, 'type': 'COM'}",com:sub_concept
635,"참고로 자바 플랫폼은 자바 SE, 자바 EE, 자바 ME, 자바 카드로 구분되나 자바 가상 머신 규격은 이 분류와 일치하지는 않는다.","{'word': '자바 플랫폼', 'start': 1544, 'end': 1549, 'type': 'COM'}","{'word': '자바 ME', 'start': 1566, 'end': 1570, 'type': 'COM'}",com:sub_concept
636,"참고로 자바 플랫폼은 자바 SE, 자바 EE, 자바 ME, 자바 카드로 구분되나 자바 가상 머신 규격은 이 분류와 일치하지는 않는다.","{'word': '자바 플랫폼', 'start': 1544, 'end': 1549, 'type': 'COM'}","{'word': '자바 카드', 'start': 1573, 'end': 1577, 'type': 'COM'}",com:sub_concept
637,오라클 구현의 경우 자바 SE를 위한 핫스팟 가상 머신은 사용 목적에 따라 최적화와 튜닝이 다른 서버용과 클라이언트용으로 나뉘며 서버용이 주로 자바 EE와 함께 많이 사용된다.,"{'word': '핫스팟 가상 머신', 'start': 1873, 'end': 1881, 'type': 'COM'}","{'word': '서버용', 'start': 1906, 'end': 1908, 'type': 'COM'}",com:sub_concept
638,오라클 구현의 경우 자바 SE를 위한 핫스팟 가상 머신은 사용 목적에 따라 최적화와 튜닝이 다른 서버용과 클라이언트용으로 나뉘며 서버용이 주로 자바 EE와 함께 많이 사용된다.,"{'word': '핫스팟 가상 머신', 'start': 1873, 'end': 1881, 'type': 'COM'}","{'word': '클라이언트용', 'start': 1911, 'end': 1916, 'type': 'COM'}",com:sub_concept
639,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '자바 플랫폼', 'start': 2019, 'end': 2024, 'type': 'COM'}","{'word': 'JVM', 'start': 2014, 'end': 2016, 'type': 'COM'}",com:sub_concept
640,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '웹 브라우저', 'start': 2115, 'end': 2120, 'type': 'COM'}","{'word': '운영', 'start': 2081, 'end': 2082, 'type': 'COM'}",com:sub_concept
641,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '웹 브라우저', 'start': 2115, 'end': 2120, 'type': 'COM'}","{'word': '인터넷 익스플로러', 'start': 2092, 'end': 2100, 'type': 'COM'}",com:sub_concept
642,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '웹 브라우저', 'start': 2115, 'end': 2120, 'type': 'COM'}","{'word': '넷스케이프', 'start': 2103, 'end': 2107, 'type': 'COM'}",com:sub_concept
643,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '플랫폼', 'start': 2129, 'end': 2131, 'type': 'COM'}","{'word': '웹 브라우저', 'start': 2115, 'end': 2120, 'type': 'COM'}",com:sub_concept
644,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '플랫폼', 'start': 2129, 'end': 2131, 'type': 'COM'}","{'word': '휴대전화', 'start': 2150, 'end': 2153, 'type': 'COM'}",com:sub_concept
645,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '플랫폼', 'start': 2129, 'end': 2131, 'type': 'COM'}","{'word': '가전기기', 'start': 2156, 'end': 2159, 'type': 'COM'}",com:sub_concept
646,따라서 자바 플랫폼은 여러 플랫폼을 지원하여 미들웨어로서의 역할과 플랫폼 스스로의 역할을 동시에 수행할 수 있다.,"{'word': '자바 플랫폼', 'start': 2177, 'end': 2182, 'type': 'COM'}","{'word': '미들웨어', 'start': 2198, 'end': 2201, 'type': 'COM'}",com:sub_concept
647,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '오픈 소스 자바 가상 머신', 'start': 2489, 'end': 2502, 'type': 'COM'}","{'word': 'GCJ', 'start': 2402, 'end': 2404, 'type': 'COM'}",com:sub_concept
648,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '오픈 소스 자바 가상 머신', 'start': 2489, 'end': 2502, 'type': 'COM'}","{'word': '하모니', 'start': 2454, 'end': 2456, 'type': 'COM'}",com:sub_concept
649,"자바 가상 머신(, JVM)은 자바 바이트코드를 실행할 수 있는 주체이다.","{'word': '자바 가상 머신', 'start': 0, 'end': 7, 'type': 'COM'}","{'word': 'JVM', 'start': 11, 'end': 13, 'type': 'COM'}",com:alter_names
650,"자바 가상 머신은 설계자인 제임스 고슬링()에 따르면 UCSD 파스칼의 p-코드()와 스몰토크 VM에 영향을 받았다고 한다. 자바 가상 머신은 이 두 가상 머신처럼 스택 기반이어서 대다수의 명령어가 스택 선두에서 피연산자를 택하고 결과는 다시 스택에 넣는다. 스택 상의 피연산자 타입을 구분하고 명령어에 스택 상의 피연산자 타입을 기술하는 면에서는 p-코드와 유사하며 실제 구조에는 차이가 있지만 가비지 컬렉션을 사용하고 객체와 메서드 호출 개념이 있다는 점에서는 스몰토크 가상 머신과 영향을 받았다고 볼 수 있다. 하지만 p-코드가 타입 안전성을 담보하지 못해 메모리 내용을 망가뜨릴 수 있다는 점, 그리고 스몰토크 가상 머신이 동적 타입을 사용하는 스몰토크 언어 자체와 마찬가지로 타입 구분을 하지 않는다는 점에서는 자바 가상 머신과 다르다.","{'word': '스몰토크 VM', 'start': 393, 'end': 399, 'type': 'COM'}","{'word': '스몰토크 가상 머신', 'start': 605, 'end': 614, 'type': 'COM'}",com:alter_names
651,"자바 바이트코드는 주로 자바7로 작성된 소스 코드를 컴파일하여 생성하며 현재 자바 가상 머신의 구조는 자바 언어의 구조를 거의 일대일로 반영하고 있다. 하지만 스칼라 같은 다른 컴파일 언어도 자바 바이트코드를 생성할 수 있으며, 자바로 작성된 자바스크립트 엔진인 라이노() 같은 경우는 옵션에 따라 자바 가상 머신 위에서 인터프리터를 실행하기도 하고 자바 바이트코드를 동적으로 생성하기도 한다.","{'word': '라이노', 'start': 932, 'end': 934, 'type': 'COM'}","{'word': '자바스크립트 엔진', 'start': 921, 'end': 929, 'type': 'COM'}",com:alter_names
652,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '썬 마이크로시스템즈', 'start': 2303, 'end': 2312, 'type': 'COM'}","{'word': '오라클', 'start': 2297, 'end': 2299, 'type': 'COM'}",com:alter_names
653,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '자바 가상 머신', 'start': 2322, 'end': 2329, 'type': 'COM'}","{'word': '자바 VM', 'start': 2385, 'end': 2389, 'type': 'COM'}",com:alter_names
654,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': 'ASF', 'start': 2420, 'end': 2422, 'type': 'COM'}","{'word': '아파치 소프트웨어 재단', 'start': 2407, 'end': 2418, 'type': 'COM'}",com:alter_names
655,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': 'Apache Software Foundation', 'start': 2425, 'end': 2450, 'type': 'COM'}","{'word': '아파치 소프트웨어 재단', 'start': 2407, 'end': 2418, 'type': 'COM'}",com:alter_names
656,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': 'Apache Software Foundation', 'start': 2425, 'end': 2450, 'type': 'COM'}","{'word': 'ASF', 'start': 2420, 'end': 2422, 'type': 'COM'}",com:alter_names
657,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '아파치 소프트웨어 재단', 'start': 2407, 'end': 2418, 'type': 'COM'}","{'word': 'ASF', 'start': 2420, 'end': 2422, 'type': 'COM'}",com:alter_names
658,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': 'ASF', 'start': 2420, 'end': 2422, 'type': 'COM'}","{'word': 'Apache Software Foundation', 'start': 2425, 'end': 2450, 'type': 'COM'}",com:alter_names
659,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '아파치 소프트웨어 재단', 'start': 2407, 'end': 2418, 'type': 'COM'}","{'word': 'Apache Software Foundation', 'start': 2425, 'end': 2450, 'type': 'COM'}",com:alter_names
660,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '하모니', 'start': 2454, 'end': 2456, 'type': 'COM'}","{'word': 'Harmony', 'start': 2458, 'end': 2464, 'type': 'COM'}",com:alter_names
661,"자바 바이트코드는 주로 자바7로 작성된 소스 코드를 컴파일하여 생성하며 현재 자바 가상 머신의 구조는 자바 언어의 구조를 거의 일대일로 반영하고 있다. 하지만 스칼라 같은 다른 컴파일 언어도 자바 바이트코드를 생성할 수 있으며, 자바로 작성된 자바스크립트 엔진인 라이노() 같은 경우는 옵션에 따라 자바 가상 머신 위에서 인터프리터를 실행하기도 하고 자바 바이트코드를 동적으로 생성하기도 한다.","{'word': '자바7', 'start': 798, 'end': 800, 'type': 'COM'}","{'word': '소스 코드', 'start': 807, 'end': 811, 'type': 'COM'}",com:made_of
662,"자바 바이트코드는 주로 자바7로 작성된 소스 코드를 컴파일하여 생성하며 현재 자바 가상 머신의 구조는 자바 언어의 구조를 거의 일대일로 반영하고 있다. 하지만 스칼라 같은 다른 컴파일 언어도 자바 바이트코드를 생성할 수 있으며, 자바로 작성된 자바스크립트 엔진인 라이노() 같은 경우는 옵션에 따라 자바 가상 머신 위에서 인터프리터를 실행하기도 하고 자바 바이트코드를 동적으로 생성하기도 한다.","{'word': '스칼라', 'start': 874, 'end': 876, 'type': 'COM'}","{'word': '자바 바이트코드', 'start': 892, 'end': 899, 'type': 'COM'}",com:made_of
663,"자바 바이트코드는 주로 자바7로 작성된 소스 코드를 컴파일하여 생성하며 현재 자바 가상 머신의 구조는 자바 언어의 구조를 거의 일대일로 반영하고 있다. 하지만 스칼라 같은 다른 컴파일 언어도 자바 바이트코드를 생성할 수 있으며, 자바로 작성된 자바스크립트 엔진인 라이노() 같은 경우는 옵션에 따라 자바 가상 머신 위에서 인터프리터를 실행하기도 하고 자바 바이트코드를 동적으로 생성하기도 한다.","{'word': '자바', 'start': 913, 'end': 914, 'type': 'COM'}","{'word': '라이노', 'start': 932, 'end': 934, 'type': 'COM'}",com:made_of
664,"자바 가상 머신(, JVM)은 자바 바이트코드를 실행할 수 있는 주체이다.","{'word': '자바 가상 머신', 'start': 0, 'end': 7, 'type': 'COM'}","{'word': '자바 바이트코드', 'start': 17, 'end': 24, 'type': 'COM'}",no_relation
665,일반적으로 인터프리터나 JIT 컴파일 방식으로 다른 컴퓨터 위에서 바이트코드를 실행할 수 있도록 구현되나 jop 자바 프로세서처럼 하드웨어와 소프트웨어를 혼합해 구현하는 경우도 있다. (이론적으로는 100% 하드웨어 구현도 가능하나 비효율적이다) 자바 바이트코드는 플랫폼에 독립적이며 모든 자바 가상 머신은 자바 가상 머신 규격에 정의된 대로 자바 바이트코드를 실행한다.,"{'word': '자바 바이트코드', 'start': 180, 'end': 187, 'type': 'COM'}","{'word': '플랫폼', 'start': 190, 'end': 192, 'type': 'COM'}",no_relation
666,따라서 표준 자바 API까지 동일한 동작을 하도록 구현한 상태에서는 이론적으로 모든 자바 프로그램은 CPU나 운영 체제의 종류와 무관하게 동일하게 동작할 것을 보장한다.,"{'word': '운영 체제', 'start': 311, 'end': 315, 'type': 'COM'}","{'word': '표준 자바 API', 'start': 254, 'end': 262, 'type': 'COM'}",no_relation
667,자바 가상 머신은 이 두 가상 머신처럼 스택 기반이어서 대다수의 명령어가 스택 선두에서 피연산자를 택하고 결과는 다시 스택에 넣는다.,"{'word': '명령어', 'start': 451, 'end': 453, 'type': 'COM'}","{'word': '스택', 'start': 437, 'end': 438, 'type': 'COM'}",no_relation
668,"자바 바이트코드는 주로 자바7로 작성된 소스 코드를 컴파일하여 생성하며 현재 자바 가상 머신의 구조는 자바 언어의 구조를 거의 일대일로 반영하고 있다. 하지만 스칼라 같은 다른 컴파일 언어도 자바 바이트코드를 생성할 수 있으며, 자바로 작성된 자바스크립트 엔진인 라이노() 같은 경우는 옵션에 따라 자바 가상 머신 위에서 인터프리터를 실행하기도 하고 자바 바이트코드를 동적으로 생성하기도 한다.","{'word': '자바 가상 머신', 'start': 952, 'end': 959, 'type': 'COM'}","{'word': '인터프리터', 'start': 965, 'end': 969, 'type': 'COM'}",no_relation
669,이러한 다양한 언어 구현이 가능한 것은 다음 특성 때문이라고 할 수 있다.,"{'word': '언어', 'start': 1109, 'end': 1110, 'type': 'COM'}","{'word': '특성', 'start': 1126, 'end': 1127, 'type': 'COM'}",no_relation
670,"2016년 5월 기준으로, 자바폴리는 사용자들이 미수정 자바 라이브러리들을 가져와서 자바스크립트로부터 직접 이들을 호출할 수 있게 하고 있다.","{'word': '자바스크립트', 'start': 1209, 'end': 1214, 'type': 'COM'}","{'word': '자바 라이브러리', 'start': 1193, 'end': 1200, 'type': 'COM'}",no_relation
671,"자바 가상 머신 규격에 추가로 현재 자바 ME의 ()에서 하나 부분 집합, 자바 카드의 클래식 에디션(), 커넥티드 에디션() 각기 하나 씩 부분 집합을 명시하고 있다.","{'word': '자바 카드', 'start': 1657, 'end': 1661, 'type': 'COM'}","{'word': '자바 ME', 'start': 1635, 'end': 1639, 'type': 'COM'}",no_relation
672,"단, 규격이 동일하다고 해서 모두 같은 구현을 사용하지는 않는다.","{'word': '규격', 'start': 1713, 'end': 1714, 'type': 'COM'}","{'word': '구현', 'start': 1732, 'end': 1733, 'type': 'COM'}",no_relation
673,"일례로 자바 SE와 자바 EE, 자바 ME의 ()는 동일한 규격을 사용하고 있으나 함께 정의된 표준 API에서 차이가 있고 사용 환경 자체의 특성에 맞게 만들어진 별도의 구현이 존재한다.","{'word': '자바 EE', 'start': 1758, 'end': 1762, 'type': 'COM'}","{'word': '자바 SE', 'start': 1751, 'end': 1755, 'type': 'COM'}",no_relation
674,"일례로 자바 SE와 자바 EE, 자바 ME의 ()는 동일한 규격을 사용하고 있으나 함께 정의된 표준 API에서 차이가 있고 사용 환경 자체의 특성에 맞게 만들어진 별도의 구현이 존재한다.","{'word': '사용 환경', 'start': 1816, 'end': 1820, 'type': 'COM'}","{'word': '표준 API', 'start': 1800, 'end': 1805, 'type': 'COM'}",no_relation
675,또 자바 ME CDC를 위해서도 적은 메모리와 낮은 CPU 사양에 맞춰진 ()이라고 하는 별도 구현을 제공한다.,"{'word': '메모리', 'start': 1972, 'end': 1974, 'type': 'COM'}","{'word': 'CPU', 'start': 1980, 'end': 1982, 'type': 'COM'}",no_relation
676,사용자는 자바 바이트코드로 컴파일된 자바 프로그램을 실행시키기 위해서 이 자바 가상 머신을 이용하면 된다.,"{'word': '자바 바이트코드', 'start': 2242, 'end': 2249, 'type': 'COM'}","{'word': '자바 가상 머신', 'start': 2278, 'end': 2285, 'type': 'COM'}",no_relation
677,"2016년 5월 기준으로, 자바폴리는 사용자들이 미수정 자바 라이브러리들을 가져와서 자바스크립트로부터 직접 이들을 호출할 수 있게 하고 있다.","{'word': '자바폴리', 'start': 1177, 'end': 1180, 'type': 'COM'}","{'word': '2016년 5월', 'start': 1162, 'end': 1169, 'type': 'DAT'}",no_relation
678,일반적으로 인터프리터나 JIT 컴파일 방식으로 다른 컴퓨터 위에서 바이트코드를 실행할 수 있도록 구현되나 jop 자바 프로세서처럼 하드웨어와 소프트웨어를 혼합해 구현하는 경우도 있다. (이론적으로는 100% 하드웨어 구현도 가능하나 비효율적이다) 자바 바이트코드는 플랫폼에 독립적이며 모든 자바 가상 머신은 자바 가상 머신 규격에 정의된 대로 자바 바이트코드를 실행한다.,"{'word': '인터프리터', 'start': 48, 'end': 52, 'type': 'COM'}","{'word': 'JIT 컴파일', 'start': 55, 'end': 61, 'type': 'COM'}",com:similar_tech
679,자바 가상 머신은 설계자인 제임스 고슬링()에 따르면 UCSD 파스칼의 p-코드()와 스몰토크 VM에 영향을 받았다고 한다.,"{'word': 'p-코드', 'start': 385, 'end': 388, 'type': 'COM'}","{'word': '스몰토크 VM', 'start': 393, 'end': 399, 'type': 'COM'}",com:similar_tech
680,"스택 상의 피연산자 타입을 구분하고 명령어에 스택 상의 피연산자 타입을 기술하는 면에서는 p-코드와 유사하며 실제 구조에는 차이가 있지만 가비지 컬렉션을 사용하고 객체와 메서드 호출 개념이 있다는 점에서는 스몰토크 가상 머신과 영향을 받았다고 볼 수 있다. 하지만 p-코드가 타입 안전성을 담보하지 못해 메모리 내용을 망가뜨릴 수 있다는 점, 그리고 스몰토크 가상 머신이 동적 타입을 사용하는 스몰토크 언어 자체와 마찬가지로 타입 구분을 하지 않는다는 점에서는 자바 가상 머신과 다르다.","{'word': '스몰토크 가상 머신', 'start': 605, 'end': 614, 'type': 'COM'}","{'word': '자바 가상 머신', 'start': 748, 'end': 755, 'type': 'COM'}",com:similar_tech
681,"스택 상의 피연산자 타입을 구분하고 명령어에 스택 상의 피연산자 타입을 기술하는 면에서는 p-코드와 유사하며 실제 구조에는 차이가 있지만 가비지 컬렉션을 사용하고 객체와 메서드 호출 개념이 있다는 점에서는 스몰토크 가상 머신과 영향을 받았다고 볼 수 있다. 하지만 p-코드가 타입 안전성을 담보하지 못해 메모리 내용을 망가뜨릴 수 있다는 점, 그리고 스몰토크 가상 머신이 동적 타입을 사용하는 스몰토크 언어 자체와 마찬가지로 타입 구분을 하지 않는다는 점에서는 자바 가상 머신과 다르다.","{'word': 'p-코드', 'start': 638, 'end': 641, 'type': 'COM'}","{'word': '스몰토크 가상 머신', 'start': 686, 'end': 695, 'type': 'COM'}",com:similar_tech
682,"스택 상의 피연산자 타입을 구분하고 명령어에 스택 상의 피연산자 타입을 기술하는 면에서는 p-코드와 유사하며 실제 구조에는 차이가 있지만 가비지 컬렉션을 사용하고 객체와 메서드 호출 개념이 있다는 점에서는 스몰토크 가상 머신과 영향을 받았다고 볼 수 있다. 하지만 p-코드가 타입 안전성을 담보하지 못해 메모리 내용을 망가뜨릴 수 있다는 점, 그리고 스몰토크 가상 머신이 동적 타입을 사용하는 스몰토크 언어 자체와 마찬가지로 타입 구분을 하지 않는다는 점에서는 자바 가상 머신과 다르다.","{'word': 'p-코드', 'start': 638, 'end': 641, 'type': 'COM'}","{'word': '자바 가상 머신', 'start': 748, 'end': 755, 'type': 'COM'}",com:similar_tech
683,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'TeaVM', 'start': 1438, 'end': 1442, 'type': 'COM'}","{'word': 'j2js-compiler', 'start': 1483, 'end': 1495, 'type': 'COM'}",com:similar_tech
684,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'TeaVM', 'start': 1438, 'end': 1442, 'type': 'COM'}","{'word': 'Bck2Brwsr', 'start': 1472, 'end': 1480, 'type': 'COM'}",com:similar_tech
685,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'Bck2Brwsr', 'start': 1472, 'end': 1480, 'type': 'COM'}","{'word': 'TeaVM', 'start': 1438, 'end': 1442, 'type': 'COM'}",com:similar_tech
686,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'Bck2Brwsr', 'start': 1472, 'end': 1480, 'type': 'COM'}","{'word': 'j2js-compiler', 'start': 1483, 'end': 1495, 'type': 'COM'}",com:similar_tech
687,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'j2js-compiler', 'start': 1483, 'end': 1495, 'type': 'COM'}","{'word': 'Bck2Brwsr', 'start': 1472, 'end': 1480, 'type': 'COM'}",com:similar_tech
688,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'j2js-compiler', 'start': 1483, 'end': 1495, 'type': 'COM'}","{'word': 'TeaVM', 'start': 1438, 'end': 1442, 'type': 'COM'}",com:similar_tech
689,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '마이크로소프트 윈도우', 'start': 2036, 'end': 2046, 'type': 'COM'}","{'word': '리눅스', 'start': 2059, 'end': 2061, 'type': 'COM'}",com:similar_tech
690,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '마이크로소프트 윈도우', 'start': 2036, 'end': 2046, 'type': 'COM'}","{'word': '유닉스', 'start': 2064, 'end': 2066, 'type': 'COM'}",com:similar_tech
691,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '마이크로소프트 윈도우', 'start': 2036, 'end': 2046, 'type': 'COM'}","{'word': 'OS X', 'start': 2069, 'end': 2072, 'type': 'COM'}",com:similar_tech
692,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '리눅스', 'start': 2059, 'end': 2061, 'type': 'COM'}","{'word': '마이크로소프트 윈도우', 'start': 2036, 'end': 2046, 'type': 'COM'}",com:similar_tech
693,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '리눅스', 'start': 2059, 'end': 2061, 'type': 'COM'}","{'word': '유닉스', 'start': 2064, 'end': 2066, 'type': 'COM'}",com:similar_tech
694,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '리눅스', 'start': 2059, 'end': 2061, 'type': 'COM'}","{'word': 'OS X', 'start': 2069, 'end': 2072, 'type': 'COM'}",com:similar_tech
695,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '유닉스', 'start': 2064, 'end': 2066, 'type': 'COM'}","{'word': '리눅스', 'start': 2059, 'end': 2061, 'type': 'COM'}",com:similar_tech
696,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '유닉스', 'start': 2064, 'end': 2066, 'type': 'COM'}","{'word': '마이크로소프트 윈도우', 'start': 2036, 'end': 2046, 'type': 'COM'}",com:similar_tech
697,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '유닉스', 'start': 2064, 'end': 2066, 'type': 'COM'}","{'word': 'OS X', 'start': 2069, 'end': 2072, 'type': 'COM'}",com:similar_tech
698,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': 'OS X', 'start': 2069, 'end': 2072, 'type': 'COM'}","{'word': '유닉스', 'start': 2064, 'end': 2066, 'type': 'COM'}",com:similar_tech
699,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': 'OS X', 'start': 2069, 'end': 2072, 'type': 'COM'}","{'word': '리눅스', 'start': 2059, 'end': 2061, 'type': 'COM'}",com:similar_tech
700,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': 'OS X', 'start': 2069, 'end': 2072, 'type': 'COM'}","{'word': '마이크로소프트 윈도우', 'start': 2036, 'end': 2046, 'type': 'COM'}",com:similar_tech
701,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '인터넷 익스플로러', 'start': 2092, 'end': 2100, 'type': 'COM'}","{'word': '넷스케이프', 'start': 2103, 'end': 2107, 'type': 'COM'}",com:similar_tech
702,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '넷스케이프', 'start': 2103, 'end': 2107, 'type': 'COM'}","{'word': '인터넷 익스플로러', 'start': 2092, 'end': 2100, 'type': 'COM'}",com:similar_tech
703,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '휴대전화', 'start': 2150, 'end': 2153, 'type': 'COM'}","{'word': '가전기기', 'start': 2156, 'end': 2159, 'type': 'COM'}",com:similar_tech
704,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '가전기기', 'start': 2156, 'end': 2159, 'type': 'COM'}","{'word': '휴대전화', 'start': 2150, 'end': 2153, 'type': 'COM'}",com:similar_tech
705,1930년대 알론조 처치가 수학기초론을 연구하는 과정에서 람다 대수의 형식을 제안하였다.,"{'word': '알론조 처치', 'start': 414, 'end': 419, 'type': 'PER'}","{'word': '람다 대수', 'start': 439, 'end': 443, 'type': 'COM'}",per:production
706,"최초의 람다 대수 체계는 논리적인 오류가 있음이 증명되었으나, 처치가 1936년에 그 속에서 계산과 관련된 부분만 따로 빼내어 후에 유형 없는 람다 대수라고 불리게 된 체계를 발표하였다.","{'word': '처치', 'start': 492, 'end': 493, 'type': 'PER'}","{'word': '유형 없는 람다 대수', 'start': 531, 'end': 541, 'type': 'COM'}",per:production
707,람다 대수는 수학자 알론조 처치에 의해 수학기초론 연구의 일환으로 1930년대 소개됐다.,"{'word': '알론조 처치', 'start': 779, 'end': 784, 'type': 'PER'}","{'word': '람다 대수', 'start': 768, 'end': 772, 'type': 'COM'}",per:production
708,최초의 시스템은 스티븐 클레이니와 존 버클리 로서가 클리네-로저 역설을 제창하면서 1935년 논리적 모순을 보이기 위해 도입됐다.,"{'word': '스티븐 클레이니와 존 버클리 로서', 'start': 827, 'end': 844, 'type': 'PER'}","{'word': '클리네-로저 역설', 'start': 847, 'end': 855, 'type': 'COM'}",per:production
709,그 후인 1936년 처치는 독립적으로 현재에는 유형 없는 람다 대수라고 불리는 계산에 관련한 부분을 출판했다.,"{'word': '처치', 'start': 902, 'end': 903, 'type': 'PER'}","{'word': '유형 없는 람다 대수', 'start': 917, 'end': 927, 'type': 'COM'}",per:production
710,람다 대수는 수학자 알론조 처치에 의해 수학기초론 연구의 일환으로 1930년대 소개됐다.,"{'word': '알론조 처치', 'start': 779, 'end': 784, 'type': 'PER'}","{'word': '수학자', 'start': 775, 'end': 777, 'type': 'POH'}",per:title
711,최초의 시스템은 스티븐 클레이니와 존 버클리 로서가 클리네-로저 역설을 제창하면서 1935년 논리적 모순을 보이기 위해 도입됐다.,"{'word': '스티븐 클레이니', 'start': 827, 'end': 834, 'type': 'PER'}","{'word': '존 버클리 로서', 'start': 837, 'end': 844, 'type': 'PER'}",per:colleagues
712,"감사하게도 리처드 몬터규와 언어학자들이 λ-대수를 자연어 (natural language)의 의미론에 적용함으로써, λ-대수는 언어학과컴퓨터 과학 양쪽 분야에서 인정받는 위치를 차지했다.","{'word': '리처드 몬터규', 'start': 1101, 'end': 1107, 'type': 'PER'}","{'word': '언어학자들', 'start': 1110, 'end': 1114, 'type': 'PER'}",per:colleagues
713,1930년대 알론조 처치가 수학기초론을 연구하는 과정에서 람다 대수의 형식을 제안하였다.,"{'word': '람다 대수', 'start': 439, 'end': 443, 'type': 'COM'}","{'word': '1930년대', 'start': 407, 'end': 412, 'type': 'DAT'}",com:date_of_prod
714,"최초의 람다 대수 체계는 논리적인 오류가 있음이 증명되었으나, 처치가 1936년에 그 속에서 계산과 관련된 부분만 따로 빼내어 후에 유형 없는 람다 대수라고 불리게 된 체계를 발표하였다.","{'word': '유형 없는 람다 대수', 'start': 531, 'end': 541, 'type': 'COM'}","{'word': '1936년', 'start': 496, 'end': 500, 'type': 'DAT'}",com:date_of_prod
715,또한 1940년에는 더 약한 형태이지만 논리적 모순이 없는 단순 유형 람다 대수를 도입하였다.,"{'word': '단순 유형 람다 대수', 'start': 595, 'end': 605, 'type': 'COM'}","{'word': '1940년', 'start': 565, 'end': 569, 'type': 'DAT'}",com:date_of_prod
716,최초의 시스템은 스티븐 클레이니와 존 버클리 로서가 클리네-로저 역설을 제창하면서 1935년 논리적 모순을 보이기 위해 도입됐다.,"{'word': '최초의 시스템', 'start': 818, 'end': 824, 'type': 'COM'}","{'word': '1935년', 'start': 864, 'end': 868, 'type': 'DAT'}",com:date_of_prod
717,그 후인 1936년 처치는 독립적으로 현재에는 유형 없는 람다 대수라고 불리는 계산에 관련한 부분을 출판했다.,"{'word': '유형 없는 람다 대수', 'start': 917, 'end': 927, 'type': 'COM'}","{'word': '1936년', 'start': 896, 'end': 900, 'type': 'DAT'}",com:date_of_prod
718,"1940년, 그는 또한 계산적으로는 떨어지지만 논리적으로 무결한 시스템을 공개했다.","{'word': '논리적으로 무결한 시스템', 'start': 979, 'end': 991, 'type': 'COM'}","{'word': '1940년', 'start': 953, 'end': 957, 'type': 'DAT'}",com:date_of_prod
719,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '논리 연산', 'start': 66, 'end': 70, 'type': 'COM'}","{'word': '함수 적용', 'start': 57, 'end': 61, 'type': 'COM'}",com:sub_concept
720,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '논리 연산', 'start': 66, 'end': 70, 'type': 'COM'}","{'word': '추상화', 'start': 52, 'end': 54, 'type': 'COM'}",com:sub_concept
721,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '형식 체계', 'start': 77, 'end': 81, 'type': 'COM'}","{'word': '람다 대수', 'start': 0, 'end': 4, 'type': 'COM'}",com:sub_concept
722,"람다 대수의 항은 변수와 추상화 및 적용 연산을 통해 구성되며 (비순수 람다 대수에서는 상수 역시 구성에 참여한다), 추상화의 기호로는 그리스 문자 람다(λ)가 사용된다.","{'word': '람다 대수의 항', 'start': 86, 'end': 93, 'type': 'COM'}","{'word': '변수', 'start': 96, 'end': 97, 'type': 'COM'}",com:sub_concept
723,"람다 대수의 항은 변수와 추상화 및 적용 연산을 통해 구성되며 (비순수 람다 대수에서는 상수 역시 구성에 참여한다), 추상화의 기호로는 그리스 문자 람다(λ)가 사용된다.","{'word': '람다 대수의 항', 'start': 86, 'end': 93, 'type': 'COM'}","{'word': '추상화', 'start': 100, 'end': 102, 'type': 'COM'}",com:sub_concept
724,"람다 대수의 항은 변수와 추상화 및 적용 연산을 통해 구성되며 (비순수 람다 대수에서는 상수 역시 구성에 참여한다), 추상화의 기호로는 그리스 문자 람다(λ)가 사용된다.","{'word': '람다 대수의 항', 'start': 86, 'end': 93, 'type': 'COM'}","{'word': '적용 연산', 'start': 106, 'end': 110, 'type': 'COM'}",com:sub_concept
725,람다 대수의 항들에 대하여 알파 동치와 베타 축약 등의 연산을 수행할 수 있다.,"{'word': '연산', 'start': 213, 'end': 214, 'type': 'COM'}","{'word': '알파 동치와 베타 축약', 'start': 197, 'end': 208, 'type': 'COM'}",com:sub_concept
726,"알파 동치는 제한 변수를 변경하는 변환으로서 이름 충돌을 방지하기 위해 사용되며, 드 브루인 첨수를 사용할 경우 이는 필요 없다.","{'word': '변환', 'start': 246, 'end': 247, 'type': 'COM'}","{'word': '알파 동치', 'start': 227, 'end': 231, 'type': 'COM'}",com:sub_concept
727,"베타 축약은 함수 적용을 적절한 치환 연산 결과로 대신하는 변환이며, 베타 축약에 대한 주어진 항의 표준형이 (존재할 경우) 알파 동치 아래 유일하다는 사실은 처치-로서 정리의 따름정리이다.","{'word': '변환', 'start': 333, 'end': 334, 'type': 'COM'}","{'word': '베타 축약', 'start': 300, 'end': 304, 'type': 'COM'}",com:sub_concept
728,"람다 대수는 튜링 완전성을 만족시키며, 보편 튜링 기계와 동치이다.","{'word': '람다 대수', 'start': 615, 'end': 619, 'type': 'COM'}","{'word': '튜링 완전성', 'start': 622, 'end': 627, 'type': 'COM'}",com:sub_concept
729,"람다 대수는 프로그래밍 언어 이론에서 중요한 역할을 하며, 리스프를 비롯한 함수형 프로그래밍 언어의 기반이 된다.","{'word': '함수형 프로그래밍 언어', 'start': 695, 'end': 706, 'type': 'COM'}","{'word': '리스프', 'start': 686, 'end': 688, 'type': 'COM'}",com:sub_concept
730,함수는 컴퓨터 과학과 수학의 기초를 이루는 개념이다.,"{'word': '컴퓨터 과학', 'start': 1204, 'end': 1209, 'type': 'COM'}","{'word': '함수', 'start': 1200, 'end': 1201, 'type': 'COM'}",com:sub_concept
731,함수는 컴퓨터 과학과 수학의 기초를 이루는 개념이다.,"{'word': '수학', 'start': 1212, 'end': 1213, 'type': 'COM'}","{'word': '함수', 'start': 1200, 'end': 1201, 'type': 'COM'}",com:sub_concept
732,"람다 대수의 언어는 변수, 상수, 람다 기호, 괄호, 온점으로 구성된다.","{'word': '람다 대수의 언어', 'start': 1874, 'end': 1882, 'type': 'COM'}","{'word': '변수', 'start': 1885, 'end': 1886, 'type': 'COM'}",com:sub_concept
733,"람다 대수의 언어는 변수, 상수, 람다 기호, 괄호, 온점으로 구성된다.","{'word': '람다 대수의 언어', 'start': 1874, 'end': 1882, 'type': 'COM'}","{'word': '괄호', 'start': 1900, 'end': 1901, 'type': 'COM'}",com:sub_concept
734,"람다 대수의 언어는 변수, 상수, 람다 기호, 괄호, 온점으로 구성된다.","{'word': '람다 대수의 언어', 'start': 1874, 'end': 1882, 'type': 'COM'}","{'word': '상수', 'start': 1889, 'end': 1890, 'type': 'COM'}",com:sub_concept
735,"람다 대수의 언어는 변수, 상수, 람다 기호, 괄호, 온점으로 구성된다.","{'word': '람다 대수의 언어', 'start': 1874, 'end': 1882, 'type': 'COM'}","{'word': '람다 기호', 'start': 1893, 'end': 1897, 'type': 'COM'}",com:sub_concept
736,"람다 대수의 언어는 변수, 상수, 람다 기호, 괄호, 온점으로 구성된다.","{'word': '람다 대수의 언어', 'start': 1874, 'end': 1882, 'type': 'COM'}","{'word': '온점', 'start': 1904, 'end': 1905, 'type': 'COM'}",com:sub_concept
737,"변수와 상수는 (후술할) 람다 항의 기초 구성원들이며, 람다 항에 등장하는 자유 변수는 (이후 정의할) 치환 연산을 통해 다른 람다 항으로 치환될 수 있다.","{'word': '람다 항', 'start': 1929, 'end': 1932, 'type': 'COM'}","{'word': '변수와 상수', 'start': 1915, 'end': 1920, 'type': 'COM'}",com:sub_concept
738,람다 기호는 (후술할) 추상화 연산을 나타내는 기호이다.,"{'word': '기호', 'start': 2029, 'end': 2030, 'type': 'COM'}","{'word': '람다 기호', 'start': 2003, 'end': 2007, 'type': 'COM'}",com:sub_concept
739,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '람다 대수', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': 'λ代數', 'start': 6, 'end': 8, 'type': 'COM'}",com:alter_names
740,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '람다 대수', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': '람다 계산', 'start': 24, 'end': 28, 'type': 'COM'}",com:alter_names
741,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '람다 대수', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': '람다 계산법', 'start': 38, 'end': 43, 'type': 'COM'}",com:alter_names
742,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '람다 대수', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': 'λ-대수', 'start': 16, 'end': 19, 'type': 'COM'}",com:alter_names
743,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '람다 대수', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': 'λ計算', 'start': 30, 'end': 32, 'type': 'COM'}",com:alter_names
744,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '람다 대수', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': 'λ計算法', 'start': 45, 'end': 48, 'type': 'COM'}",com:alter_names
745,1960년대에 람다 대수와 프로그래밍 언어의 관계가 명확히 밝혀지기 전까지는 λ-대수는 단지 형식주의 (formalism)일 뿐이었다.,"{'word': '형식주의', 'start': 1071, 'end': 1074, 'type': 'COM'}","{'word': 'formalism', 'start': 1077, 'end': 1085, 'type': 'COM'}",com:alter_names
746,"감사하게도 리처드 몬터규와 언어학자들이 λ-대수를 자연어 (natural language)의 의미론에 적용함으로써, λ-대수는 언어학과컴퓨터 과학 양쪽 분야에서 인정받는 위치를 차지했다.","{'word': '자연어', 'start': 1123, 'end': 1125, 'type': 'COM'}","{'word': 'natural language', 'start': 1128, 'end': 1143, 'type': 'COM'}",com:alter_names
747,람다 추상화를 통해 함수를 정의한다는 것은 함수를 정의하기만 하고 함수를 수행(호출)하지는 않는다는 것을 의미한다.,"{'word': '수행', 'start': 1654, 'end': 1655, 'type': 'COM'}","{'word': '호출', 'start': 1657, 'end': 1658, 'type': 'COM'}",com:alter_names
748,"람다 항에 등장하는 변수들은 자유 변수(自由變數, )와 제한 변수(制限變數, )로 분류된다.","{'word': '자유 변수', 'start': 2551, 'end': 2555, 'type': 'COM'}","{'word': '自由變數', 'start': 2557, 'end': 2560, 'type': 'COM'}",com:alter_names
749,"람다 항에 등장하는 변수들은 자유 변수(自由變數, )와 제한 변수(制限變數, )로 분류된다.","{'word': '제한 변수', 'start': 2566, 'end': 2570, 'type': 'COM'}","{'word': '制限變數', 'start': 2572, 'end': 2575, 'type': 'COM'}",com:alter_names
750,"자유 변수를 갖지 않는 람다 항을 닫힌 람다 항(닫힌λ項, )이라고 한다.","{'word': '닫힌 람다 항', 'start': 2966, 'end': 2972, 'type': 'COM'}","{'word': '닫힌λ項', 'start': 2974, 'end': 2977, 'type': 'COM'}",com:alter_names
751,"주어진 람다 항에 등장하는 자유 변수를 또 다른 람다 항으로 치환(置換, )하는 연산을 정의할 수 있다.","{'word': '치환', 'start': 3126, 'end': 3127, 'type': 'COM'}","{'word': '置換', 'start': 3129, 'end': 3130, 'type': 'COM'}",com:alter_names
752,"치환 연산의 정의는 자연스러우며, 다만 원래 람다 항의 의미가 변질되는 경우에는 알파 변환이 선행되어야 한다 (이는 아래 네 번째 조건의 세 번째 경우에 해당한다). 구체적으로, 람다 항 formula_54, formula_55 및 변수 formula_2에 대하여, formula_2를 formula_55으로 치환한 formula_54의 치환 실례(置換實例, ) formula_113는 formula_54의 구조에 따라 다음과 같이 재귀적으로 정의된다.","{'word': '치환 실례', 'start': 3340, 'end': 3344, 'type': 'COM'}","{'word': '置換實例', 'start': 3346, 'end': 3349, 'type': 'COM'}",com:alter_names
753,"알파 동치(α同値, )는 제한 변수 변경을 통해 주어진 람다 항을 새로운 람다 항으로 변환하는 방법이다.","{'word': '알파 동치', 'start': 3405, 'end': 3409, 'type': 'COM'}","{'word': 'α同値', 'start': 3411, 'end': 3413, 'type': 'COM'}",com:alter_names
754,"베타 축약(β縮約, )은 추상화된 함수의 적용을 적절한 치환 실례로 바꾸는 것을 통해 람다 항을 변환하는 방법이다.","{'word': '베타 축약', 'start': 3695, 'end': 3699, 'type': 'COM'}","{'word': 'β縮約', 'start': 3701, 'end': 3703, 'type': 'COM'}",com:alter_names
755,"람다 항 formula_55이 formula_136와 같은 꼴의 부분 람다 항을 가지지 않는다면, formula_55을 베타 표준형(β標準型, )이라고 한다.","{'word': 'β標準型', 'start': 4189, 'end': 4192, 'type': 'COM'}","{'word': '베타 표준형', 'start': 4182, 'end': 4187, 'type': 'COM'}",com:alter_names
756,람다 추상화를 통해 함수를 정의한다는 것은 함수를 정의하기만 하고 함수를 수행(호출)하지는 않는다는 것을 의미한다.,"{'word': '함수', 'start': 1624, 'end': 1625, 'type': 'COM'}","{'word': '람다 추상화', 'start': 1613, 'end': 1618, 'type': 'COM'}",com:made_of
757,람다 대수의 항들에 대하여 알파 동치와 베타 축약 등의 연산을 수행할 수 있다.,"{'word': '베타 축약', 'start': 204, 'end': 208, 'type': 'COM'}","{'word': '알파 동치', 'start': 197, 'end': 201, 'type': 'COM'}",no_relation
758,"알파 동치는 제한 변수를 변경하는 변환으로서 이름 충돌을 방지하기 위해 사용되며, 드 브루인 첨수를 사용할 경우 이는 필요 없다.","{'word': '이름 충돌', 'start': 252, 'end': 256, 'type': 'COM'}","{'word': '드 브루인 첨수', 'start': 273, 'end': 280, 'type': 'COM'}",no_relation
759,1960년대에 람다 대수와 프로그래밍 언어의 관계가 명확히 밝혀지기 전까지는 λ-대수는 단지 형식주의 (formalism)일 뿐이었다.,"{'word': '프로그래밍 언어', 'start': 1034, 'end': 1041, 'type': 'COM'}","{'word': '람다 대수', 'start': 1027, 'end': 1031, 'type': 'COM'}",no_relation
760,람다 대수는 함수를 단순하게 표현할 수 있도록 하여 '함수의 계산'이라는 개념을 더 깊이 이해할 수 있게 돕는다.,"{'word': '함수', 'start': 1237, 'end': 1238, 'type': 'COM'}","{'word': '람다 대수', 'start': 1230, 'end': 1234, 'type': 'COM'}",no_relation
761,람다 대수의 언어를 사용하여 자연수의 페아노 산술을 다음과 같이 표현할 수 있다.,"{'word': '자연수', 'start': 4420, 'end': 4422, 'type': 'COM'}","{'word': '람다 대수', 'start': 4404, 'end': 4408, 'type': 'COM'}",no_relation
762,"람다 대수는 튜링 완전성을 만족시키며, 보편 튜링 기계와 동치이다.","{'word': '람다 대수', 'start': 615, 'end': 619, 'type': 'COM'}","{'word': '보편 튜링 기계', 'start': 637, 'end': 644, 'type': 'COM'}",com:similar_tech
763,"람다 대수는 그 밖에도 논리학, 철학, 언어학, 컴퓨터 과학 등의 여러 분야에서 응용된다.","{'word': '논리학', 'start': 730, 'end': 732, 'type': 'COM'}","{'word': '컴퓨터 과학', 'start': 744, 'end': 749, 'type': 'COM'}",com:similar_tech
764,기계어(機械語)는 CPU가 직접 해독하고 실행할 수 있는 비트 단위로 쓰인 컴퓨터 언어를 통틀어 일컫는다.,"{'word': '컴퓨터 언어', 'start': 42, 'end': 47, 'type': 'COM'}","{'word': '기계어', 'start': 0, 'end': 2, 'type': 'COM'}",com:sub_concept
765,기계어는 CPU의 종류에 따라서 서로 다른 코드를 갖게 된다.,"{'word': '기계어', 'start': 245, 'end': 247, 'type': 'COM'}","{'word': '코드', 'start': 269, 'end': 270, 'type': 'COM'}",com:sub_concept
766,기계어는 프로그램을 나타내는 가장 낮은 단계의 개념이다.,"{'word': '기계어', 'start': 60, 'end': 62, 'type': 'COM'}","{'word': '프로그램', 'start': 65, 'end': 68, 'type': 'COM'}",no_relation
767,기계어는 어셈블리어와 1 : 1로 쓰일 수 있다.,"{'word': '기계어', 'start': 92, 'end': 94, 'type': 'COM'}","{'word': '어셈블리어', 'start': 97, 'end': 101, 'type': 'COM'}",no_relation
768,다시 말해 컴퓨터 프로그래밍에서 기계어는 대부분 어셈블리어를 거쳐 짜여지게 된다.,"{'word': '어셈블리어', 'start': 147, 'end': 151, 'type': 'COM'}","{'word': '기계어', 'start': 138, 'end': 140, 'type': 'COM'}",no_relation
769,"어셈블리어가 아직 만들어지기 전에는 기계어를 직접 입력하여 프로그램을 작성하기도 했으며, 오늘날에도 흔치는 않지만 그렇게 하는 사람이 있다.","{'word': '기계어', 'start': 186, 'end': 188, 'type': 'COM'}","{'word': '어셈블리어', 'start': 166, 'end': 170, 'type': 'COM'}",no_relation
770,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다.","{'word': '로버트 그리즈머, 롭 파이크, 켄 톰프슨', 'start': 19, 'end': 40, 'type': 'PER'}","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}",per:production
771,"화이트 보드에 새로운 언어에 대한 스케치를 하면서 초기 20% 파트타임 프로젝트로 시작하였다가 2008년 1월 켄 톰프슨이 C 코드를 만들어내는 컴파일러를 만들기 시작했고, 2008년 중반 풀타임 프로젝트로 승격되었다.","{'word': '켄 톰프슨', 'start': 522, 'end': 526, 'type': 'PER'}","{'word': '컴파일러', 'start': 541, 'end': 544, 'type': 'COM'}",per:production
772,"2008년 5월 이안 테일러가 Go 스펙의 초안을 이용해서 GCC 프론트엔드를 만들기 시작했고, 2008년 말 러스 콕스가 참여하면서 프로토타입에서 실질적인 언어와 라이브러리들을 만들기 시작했다.","{'word': '이안 테일러', 'start': 592, 'end': 597, 'type': 'PER'}","{'word': 'GCC 프론트엔드', 'start': 616, 'end': 624, 'type': 'COM'}",per:production
773,"2008년 5월 이안 테일러가 Go 스펙의 초안을 이용해서 GCC 프론트엔드를 만들기 시작했고, 2008년 말 러스 콕스가 참여하면서 프로토타입에서 실질적인 언어와 라이브러리들을 만들기 시작했다.","{'word': '러스 콕스', 'start': 645, 'end': 649, 'type': 'PER'}","{'word': '실질적인 언어와 라이브러리', 'start': 666, 'end': 679, 'type': 'COM'}",per:production
774,"Go를 만들고 있는 개발자들은, 제너릭 등은 급하진 않지만 어느 시점에는 기능이 도입될 것이라고 한다.","{'word': '개발자', 'start': 1787, 'end': 1789, 'type': 'PER'}","{'word': 'Go', 'start': 1776, 'end': 1777, 'type': 'COM'}",per:production
775,"Go는 다른 언어의 긍정적인 특징들을 유지하면서 공통이 되는 문제들을 해결할 새로운 프로그래밍 언어를 설계하기 위해 구글의 엔지니어 Robert Griesemer, 롭 파이크, 켄 톰프슨에 의해 실험적으로 시작되었다.","{'word': 'Robert Griesemer, 롭 파이크, 켄 톰프슨', 'start': 977, 'end': 1006, 'type': 'PER'}","{'word': '엔지니어', 'start': 972, 'end': 975, 'type': 'POH'}",per:title
776,"Go는 다른 언어의 긍정적인 특징들을 유지하면서 공통이 되는 문제들을 해결할 새로운 프로그래밍 언어를 설계하기 위해 구글의 엔지니어 Robert Griesemer, 롭 파이크, 켄 톰프슨에 의해 실험적으로 시작되었다. 이 새로운 언어는 다음의 기능을 포함할 작정이었다: 나중의 인터뷰에서, 언어 설계자 3명 모두 자신들이 C++의 복잡성을 싫어하며 이로 인해 새로운 언어를 설계하는 계기가 되었다고 언급하였다.","{'word': 'Robert Griesemer, 롭 파이크, 켄 톰프슨', 'start': 977, 'end': 1006, 'type': 'PER'}","{'word': '언어 설계자', 'start': 1065, 'end': 1070, 'type': 'POH'}",per:title
777,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다.","{'word': '로버트 그리즈머', 'start': 19, 'end': 26, 'type': 'PER'}","{'word': '롭 파이크', 'start': 29, 'end': 33, 'type': 'PER'}",per:colleagues
778,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다.","{'word': '로버트 그리즈머', 'start': 19, 'end': 26, 'type': 'PER'}","{'word': '켄 톰프슨', 'start': 36, 'end': 40, 'type': 'PER'}",per:colleagues
779,"Go의 초기 디자인은 2007년 9월 21일에 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 인페르노 분산 운영체제와 관련된 작업을 하다가 시작되었다.","{'word': '롭 파이크', 'start': 413, 'end': 417, 'type': 'PER'}","{'word': '로버트 그리즈머', 'start': 403, 'end': 410, 'type': 'PER'}",per:colleagues
780,"Go의 초기 디자인은 2007년 9월 21일에 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 인페르노 분산 운영체제와 관련된 작업을 하다가 시작되었다.","{'word': '롭 파이크', 'start': 413, 'end': 417, 'type': 'PER'}","{'word': '켄 톰프슨', 'start': 420, 'end': 424, 'type': 'PER'}",per:colleagues
781,"Go는 다른 언어의 긍정적인 특징들을 유지하면서 공통이 되는 문제들을 해결할 새로운 프로그래밍 언어를 설계하기 위해 구글의 엔지니어 Robert Griesemer, 롭 파이크, 켄 톰프슨에 의해 실험적으로 시작되었다.","{'word': '켄 톰프슨', 'start': 1002, 'end': 1006, 'type': 'PER'}","{'word': '롭 파이크', 'start': 995, 'end': 999, 'type': 'PER'}",per:colleagues
782,"Go는 다른 언어의 긍정적인 특징들을 유지하면서 공통이 되는 문제들을 해결할 새로운 프로그래밍 언어를 설계하기 위해 구글의 엔지니어 Robert Griesemer, 롭 파이크, 켄 톰프슨에 의해 실험적으로 시작되었다.","{'word': '켄 톰프슨', 'start': 1002, 'end': 1006, 'type': 'PER'}","{'word': 'Robert Griesemer', 'start': 977, 'end': 992, 'type': 'PER'}",per:colleagues
783,"하나는 구글의 셀프 호스팅 컴파일러 툴체인으로서 여러 운영 체제, 모바일 장치, 웹어셈블리를 대상으로 한다.","{'word': '구글', 'start': 234, 'end': 235, 'type': 'ORG'}","{'word': '셀프 호스팅 컴파일러 툴체인', 'start': 238, 'end': 252, 'type': 'COM'}",org:production
784,구글의 생산 시스템 중 일부 및 기타 기업들에 사용되고 있다.,"{'word': '구글', 'start': 868, 'end': 869, 'type': 'ORG'}","{'word': '생산 시스템', 'start': 872, 'end': 877, 'type': 'COM'}",org:production
785,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다.","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': '2009년', 'start': 4, 'end': 8, 'type': 'DAT'}",com:date_of_prod
786,"2009년 11월 10일에 리눅스와 MacOS 플랫폼을 대상으로 공식 발표되었다. Go가 처음 런칭되었을 때는 실무적인 소프트웨어를 만들기에는 준비가 좀 덜 된 상태였지만, 2010년 5월 롭 파이크는 구글에서 실제로 사용되고 있는 부분이 있다고 공개적으로 알리게 되었다.","{'word': 'Go', 'start': 739, 'end': 740, 'type': 'COM'}","{'word': '2009년 11월 10', 'start': 693, 'end': 704, 'type': 'DAT'}",com:date_of_prod
787,2009년 11월에 Go가 발표되었다.,"{'word': 'Go', 'start': 857, 'end': 858, 'type': 'COM'}","{'word': '2009년 11', 'start': 846, 'end': 853, 'type': 'DAT'}",com:date_of_prod
788,Go 1.0은 2012년 3월에 출시되었다.,"{'word': 'Go 1.0', 'start': 1133, 'end': 1138, 'type': 'COM'}","{'word': '2012년 3월', 'start': 1141, 'end': 1148, 'type': 'DAT'}",com:date_of_prod
789,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다. 가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다.","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': '가비지 컬렉션 기능', 'start': 59, 'end': 68, 'type': 'COM'}",com:sub_concept
790,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다. 가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다.","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': '병행성', 'start': 75, 'end': 77, 'type': 'COM'}",com:sub_concept
791,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다. 가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다. 구문이 C와 비슷하지만 메모리 보안, 쓰레기 수집, 구조 타이핑, CSP 스타일 병행성을 제공한다.","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': '메모리 보안', 'start': 121, 'end': 126, 'type': 'COM'}",com:sub_concept
792,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다. 가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다. 구문이 C와 비슷하지만 메모리 보안, 쓰레기 수집, 구조 타이핑, CSP 스타일 병행성을 제공한다.","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': '쓰레기 수집', 'start': 129, 'end': 134, 'type': 'COM'}",com:sub_concept
793,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다. 가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다. 구문이 C와 비슷하지만 메모리 보안, 쓰레기 수집, 구조 타이핑, CSP 스타일 병행성을 제공한다.","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': '구조 타이핑', 'start': 137, 'end': 142, 'type': 'COM'}",com:sub_concept
794,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다. 가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다. 구문이 C와 비슷하지만 메모리 보안, 쓰레기 수집, 구조 타이핑, CSP 스타일 병행성을 제공한다.","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': 'CSP 스타일 병행성', 'start': 145, 'end': 155, 'type': 'COM'}",com:sub_concept
795,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다.","{'word': '프로그래밍 언어', 'start': 47, 'end': 54, 'type': 'COM'}","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}",com:sub_concept
796,"가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다.","{'word': '컴파일 언어', 'start': 99, 'end': 104, 'type': 'COM'}","{'word': '병행성', 'start': 75, 'end': 77, 'type': 'COM'}",com:sub_concept
797,"가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다.","{'word': '컴파일 언어', 'start': 99, 'end': 104, 'type': 'COM'}","{'word': '가비지 컬렉션 기능', 'start': 59, 'end': 68, 'type': 'COM'}",com:sub_concept
798,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다. 가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다.","{'word': '컴파일 언어', 'start': 99, 'end': 104, 'type': 'COM'}","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}",com:sub_concept
799,나머지 하나는 GCC 프론트엔드인 gccgo가 있다.,"{'word': 'GCC 프론트엔드', 'start': 299, 'end': 307, 'type': 'COM'}","{'word': 'gccgo', 'start': 310, 'end': 314, 'type': 'COM'}",com:sub_concept
800,서드파티 트랜스파일러 GopherJS는 프론트엔드 웹 개발을 위해 Go를 자바스크립트로 컴파일한다.,"{'word': '트랜스파일러', 'start': 326, 'end': 331, 'type': 'COM'}","{'word': 'GopherJS', 'start': 333, 'end': 340, 'type': 'COM'}",com:sub_concept
801,2009년 11월 10일에 리눅스와 MacOS 플랫폼을 대상으로 공식 발표되었다.,"{'word': '플랫폼', 'start': 719, 'end': 721, 'type': 'COM'}","{'word': '리눅스', 'start': 708, 'end': 710, 'type': 'COM'}",com:sub_concept
802,2009년 11월 10일에 리눅스와 MacOS 플랫폼을 대상으로 공식 발표되었다.,"{'word': '플랫폼', 'start': 719, 'end': 721, 'type': 'COM'}","{'word': 'MacOS', 'start': 713, 'end': 717, 'type': 'COM'}",com:sub_concept
803,"Go는 다른 언어의 긍정적인 특징들을 유지하면서 공통이 되는 문제들을 해결할 새로운 프로그래밍 언어를 설계하기 위해 구글의 엔지니어 Robert Griesemer, 롭 파이크, 켄 톰프슨에 의해 실험적으로 시작되었다.","{'word': '프로그래밍 언어', 'start': 950, 'end': 957, 'type': 'COM'}","{'word': 'Go', 'start': 903, 'end': 904, 'type': 'COM'}",com:sub_concept
804,GopherJS라는 이름의 서드파티 Go 컴파일러도 존재한다.,"{'word': '서드파티 Go 컴파일러', 'start': 1191, 'end': 1202, 'type': 'COM'}","{'word': 'GopherJS', 'start': 1176, 'end': 1183, 'type': 'COM'}",com:sub_concept
805,"Go의 문법은 대체로 C와 비슷하다: 코드 블록들은 중괄호로 둘러싸고 for, switch, if를 포함한 일반적인 제어구조를 가지고 있다.","{'word': 'Go', 'start': 1272, 'end': 1273, 'type': 'COM'}","{'word': '제어구조', 'start': 1337, 'end': 1340, 'type': 'COM'}",com:sub_concept
806,"Go의 문법은 대체로 C와 비슷하다: 코드 블록들은 중괄호로 둘러싸고 for, switch, if를 포함한 일반적인 제어구조를 가지고 있다. C와 다르게, 한 라인 끝의 세미콜론은 필수가 아닌 옵션이다.","{'word': 'Go', 'start': 1272, 'end': 1273, 'type': 'COM'}","{'word': '한 라인 끝의 세미콜론', 'start': 1359, 'end': 1370, 'type': 'COM'}",com:sub_concept
807,"Go의 문법은 대체로 C와 비슷하다: 코드 블록들은 중괄호로 둘러싸고 for, switch, if를 포함한 일반적인 제어구조를 가지고 있다. C와 다르게, 한 라인 끝의 세미콜론은 필수가 아닌 옵션이다. 변수 선언은 다르게 작성되고 대개 옵션이다.","{'word': 'Go', 'start': 1272, 'end': 1273, 'type': 'COM'}","{'word': '변수 선언', 'start': 1386, 'end': 1390, 'type': 'COM'}",com:sub_concept
808,"Go의 문법은 대체로 C와 비슷하다: 코드 블록들은 중괄호로 둘러싸고 for, switch, if를 포함한 일반적인 제어구조를 가지고 있다. C와 다르게, 한 라인 끝의 세미콜론은 필수가 아닌 옵션이다. 변수 선언은 다르게 작성되고 대개 옵션이다. 형 변환은 명시적으로 해야 한다.","{'word': 'Go', 'start': 1272, 'end': 1273, 'type': 'COM'}","{'word': '형 변환', 'start': 1411, 'end': 1414, 'type': 'COM'}",com:sub_concept
809,"Go의 문법은 대체로 C와 비슷하다: 코드 블록들은 중괄호로 둘러싸고 for, switch, if를 포함한 일반적인 제어구조를 가지고 있다. C와 다르게, 한 라인 끝의 세미콜론은 필수가 아닌 옵션이다. 변수 선언은 다르게 작성되고 대개 옵션이다. 형 변환은 명시적으로 해야 한다. 병행 컴퓨팅을 다루기 위해 ""go""와 ""select"" 키워드가 사용된다.","{'word': 'Go', 'start': 1272, 'end': 1273, 'type': 'COM'}","{'word': '병행 컴퓨팅', 'start': 1430, 'end': 1435, 'type': 'COM'}",com:sub_concept
810,"새로운 타입은 map, 유니코드 문자열, 배열 slice, 그리고 내부 쓰레드 통신을 위한 채널(channel)이 있다.","{'word': '새로운 타입', 'start': 1471, 'end': 1476, 'type': 'COM'}","{'word': 'map', 'start': 1479, 'end': 1481, 'type': 'COM'}",com:sub_concept
811,"새로운 타입은 map, 유니코드 문자열, 배열 slice, 그리고 내부 쓰레드 통신을 위한 채널(channel)이 있다.","{'word': '새로운 타입', 'start': 1471, 'end': 1476, 'type': 'COM'}","{'word': '유니코드 문자열', 'start': 1484, 'end': 1491, 'type': 'COM'}",com:sub_concept
812,"새로운 타입은 map, 유니코드 문자열, 배열 slice, 그리고 내부 쓰레드 통신을 위한 채널(channel)이 있다.","{'word': '새로운 타입', 'start': 1471, 'end': 1476, 'type': 'COM'}","{'word': '배열 slice', 'start': 1494, 'end': 1501, 'type': 'COM'}",com:sub_concept
813,"새로운 타입은 map, 유니코드 문자열, 배열 slice, 그리고 내부 쓰레드 통신을 위한 채널(channel)이 있다.","{'word': '새로운 타입', 'start': 1471, 'end': 1476, 'type': 'COM'}","{'word': '내부 쓰레드 통신을 위한 채널(channel)', 'start': 1508, 'end': 1532, 'type': 'COM'}",com:sub_concept
814,Go는 가비지 컬렉션이 되는 언어이다.,"{'word': '언어', 'start': 1599, 'end': 1600, 'type': 'COM'}","{'word': 'Go', 'start': 1583, 'end': 1584, 'type': 'COM'}",com:sub_concept
815,병행성(concurrency)와 관련된 Go의 구조적인 규칙들(channel과 선택적인 channel input들)은 Tony Hoare의 로부터 가져온 것이다.,"{'word': 'Go', 'start': 1627, 'end': 1628, 'type': 'COM'}","{'word': 'channel과 선택적인 channel input들', 'start': 1640, 'end': 1667, 'type': 'COM'}",com:sub_concept
816,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': 'C++', 'start': 1696, 'end': 1698, 'type': 'COM'}","{'word': '타입 상속', 'start': 1714, 'end': 1718, 'type': 'COM'}",com:sub_concept
817,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': '자바', 'start': 1701, 'end': 1702, 'type': 'COM'}","{'word': '타입 상속', 'start': 1714, 'end': 1718, 'type': 'COM'}",com:sub_concept
818,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': 'C++', 'start': 1696, 'end': 1698, 'type': 'COM'}","{'word': '제너릭', 'start': 1721, 'end': 1723, 'type': 'COM'}",com:sub_concept
819,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': '자바', 'start': 1701, 'end': 1702, 'type': 'COM'}","{'word': '제너릭', 'start': 1721, 'end': 1723, 'type': 'COM'}",com:sub_concept
820,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': 'C++', 'start': 1696, 'end': 1698, 'type': 'COM'}","{'word': '메서드 오버로딩', 'start': 1741, 'end': 1748, 'type': 'COM'}",com:sub_concept
821,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': '자바', 'start': 1701, 'end': 1702, 'type': 'COM'}","{'word': '메서드 오버로딩', 'start': 1741, 'end': 1748, 'type': 'COM'}",com:sub_concept
822,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': 'C++', 'start': 1696, 'end': 1698, 'type': 'COM'}","{'word': '포인터 연산', 'start': 1751, 'end': 1756, 'type': 'COM'}",com:sub_concept
823,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': '자바', 'start': 1701, 'end': 1702, 'type': 'COM'}","{'word': '포인터 연산', 'start': 1751, 'end': 1756, 'type': 'COM'}",com:sub_concept
824,"동시성이란 멀티스레딩, 병렬 컴퓨팅 뿐 아니라, 비동기성 입출력 또한 포함한다.","{'word': '동시성', 'start': 1902, 'end': 1904, 'type': 'COM'}","{'word': '멀티스레딩', 'start': 1908, 'end': 1912, 'type': 'COM'}",com:sub_concept
825,"동시성이란 멀티스레딩, 병렬 컴퓨팅 뿐 아니라, 비동기성 입출력 또한 포함한다.","{'word': '동시성', 'start': 1902, 'end': 1904, 'type': 'COM'}","{'word': '병렬 컴퓨팅', 'start': 1915, 'end': 1920, 'type': 'COM'}",com:sub_concept
826,"동시성이란 멀티스레딩, 병렬 컴퓨팅 뿐 아니라, 비동기성 입출력 또한 포함한다.","{'word': '동시성', 'start': 1902, 'end': 1904, 'type': 'COM'}","{'word': '비동기성 입출력', 'start': 1929, 'end': 1936, 'type': 'COM'}",com:sub_concept
827,"예를 들어, 이벤트 기반 서버와 같이, 데이터베이스나 네트워크 작업과 같이 시간이 많이 걸리는 연산을 하는 동안 프로그램이 다른 일을 하는 것을 말한다.","{'word': '시간이 많이 걸리는 연산', 'start': 1989, 'end': 2001, 'type': 'COM'}","{'word': '네트워크 작업', 'start': 1977, 'end': 1983, 'type': 'COM'}",com:sub_concept
828,"예를 들어, 이벤트 기반 서버와 같이, 데이터베이스나 네트워크 작업과 같이 시간이 많이 걸리는 연산을 하는 동안 프로그램이 다른 일을 하는 것을 말한다.","{'word': '시간이 많이 걸리는 연산', 'start': 1989, 'end': 2001, 'type': 'COM'}","{'word': '데이터베이스', 'start': 1969, 'end': 1974, 'type': 'COM'}",com:sub_concept
829,"예를 들어, 이벤트 기반 서버와 같이, 데이터베이스나 네트워크 작업과 같이 시간이 많이 걸리는 연산을 하는 동안 프로그램이 다른 일을 하는 것을 말한다.","{'word': '프로그램이 다른 일을 하는 것', 'start': 2010, 'end': 2025, 'type': 'COM'}","{'word': '이벤트 기반 서버', 'start': 1954, 'end': 1962, 'type': 'COM'}",com:sub_concept
830,Go는 정적 타입 컴파일 언어의 효율성과 동적 언어처럼 쉬운 프로그래밍을 할 수 있도록 하는 것을 목표로 한다.,"{'word': '정적 타입 컴파일 언어', 'start': 2037, 'end': 2048, 'type': 'COM'}","{'word': '효율성', 'start': 2051, 'end': 2053, 'type': 'COM'}",com:sub_concept
831,Go는 정적 타입 컴파일 언어의 효율성과 동적 언어처럼 쉬운 프로그래밍을 할 수 있도록 하는 것을 목표로 한다.,"{'word': '동적 언어', 'start': 2056, 'end': 2060, 'type': 'COM'}","{'word': '쉬운 프로그래밍', 'start': 2064, 'end': 2071, 'type': 'COM'}",com:sub_concept
832,"Go는 수많은 언어 배포판들과 동일한 종류의 디버깅, 테스트, 코드 검사 도구들을 포함하고 있다.","{'word': 'Go', 'start': 2096, 'end': 2097, 'type': 'COM'}","{'word': '디버깅', 'start': 2121, 'end': 2123, 'type': 'COM'}",com:sub_concept
833,"Go는 수많은 언어 배포판들과 동일한 종류의 디버깅, 테스트, 코드 검사 도구들을 포함하고 있다.","{'word': 'Go', 'start': 2096, 'end': 2097, 'type': 'COM'}","{'word': '코드 검사 도구', 'start': 2131, 'end': 2138, 'type': 'COM'}",com:sub_concept
834,"Go는 수많은 언어 배포판들과 동일한 종류의 디버깅, 테스트, 코드 검사 도구들을 포함하고 있다.","{'word': 'Go', 'start': 2096, 'end': 2097, 'type': 'COM'}","{'word': '테스트', 'start': 2126, 'end': 2128, 'type': 'COM'}",com:sub_concept
835,"그 중에 Go 배포판은 다음을 포함한다: 프로파일링 및 디버깅 지원, 런타임 인스트루먼테이션(이를테면 가비지 컬렉션 일시 정지 등을 위해) 및 레이스 컨디션 테스터(race condition tester)도 포함한다.","{'word': 'Go 배포판', 'start': 2156, 'end': 2161, 'type': 'COM'}","{'word': '프로파일링 및 디버깅 지원', 'start': 2174, 'end': 2187, 'type': 'COM'}",com:sub_concept
836,"그 중에 Go 배포판은 다음을 포함한다: 프로파일링 및 디버깅 지원, 런타임 인스트루먼테이션(이를테면 가비지 컬렉션 일시 정지 등을 위해) 및 레이스 컨디션 테스터(race condition tester)도 포함한다.","{'word': 'Go 배포판', 'start': 2156, 'end': 2161, 'type': 'COM'}","{'word': '레이스 컨디션 테스터', 'start': 2231, 'end': 2241, 'type': 'COM'}",com:sub_concept
837,"그 중에 Go 배포판은 다음을 포함한다: 프로파일링 및 디버깅 지원, 런타임 인스트루먼테이션(이를테면 가비지 컬렉션 일시 정지 등을 위해) 및 레이스 컨디션 테스터(race condition tester)도 포함한다.","{'word': 'Go 배포판', 'start': 2156, 'end': 2161, 'type': 'COM'}","{'word': '런타임 인스트루먼테이션', 'start': 2190, 'end': 2201, 'type': 'COM'}",com:sub_concept
838,"가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다.","{'word': '병행성', 'start': 75, 'end': 77, 'type': 'COM'}","{'word': 'concurrent', 'start': 79, 'end': 88, 'type': 'COM'}",com:alter_names
839,이 언어는 codice_1이라는 도메인 이름 때문에 종종 고랭(Golang)으로도 호칭되지만 정확한 명칭은 Go이다.,"{'word': '고랭', 'start': 196, 'end': 197, 'type': 'COM'}","{'word': 'Golang', 'start': 199, 'end': 204, 'type': 'COM'}",com:alter_names
840,병행성(concurrency)와 관련된 Go의 구조적인 규칙들(channel과 선택적인 channel input들)은 Tony Hoare의 로부터 가져온 것이다.,"{'word': '병행성', 'start': 1605, 'end': 1607, 'type': 'COM'}","{'word': 'concurrency', 'start': 1609, 'end': 1619, 'type': 'COM'}",com:alter_names
841,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': '표명', 'start': 1726, 'end': 1727, 'type': 'COM'}","{'word': 'assertion', 'start': 1729, 'end': 1737, 'type': 'COM'}",com:alter_names
842,Go를 이용해 프로그램들이 서로 소통하면서 상태를 공유하는 동시성(concurrency) 프로그램을 쉽게 만들 수 있다.,"{'word': '동시성', 'start': 1867, 'end': 1869, 'type': 'COM'}","{'word': 'concurrency', 'start': 1871, 'end': 1881, 'type': 'COM'}",com:alter_names
843,"프로파일링 및 디버깅 지원, 런타임 인스트루먼테이션(이를테면 가비지 컬렉션 일시 정지 등을 위해) 및 레이스 컨디션 테스터(race condition tester)도 포함한다.","{'word': 'race condition tester', 'start': 2243, 'end': 2263, 'type': 'COM'}","{'word': '레이스 컨디션 테스터', 'start': 2231, 'end': 2241, 'type': 'COM'}",com:alter_names
844,"아래는 Go로 만든 Hello, World 프로그램이다.","{'word': '프로그램', 'start': 2297, 'end': 2300, 'type': 'COM'}","{'word': 'Go', 'start': 2277, 'end': 2278, 'type': 'COM'}",com:made_of
845,Go로 작성된 일부 저명한 오픈 소스 소프트웨어는 다음과 같다:,"{'word': '오픈 소스 소프트웨어', 'start': 2792, 'end': 2802, 'type': 'COM'}","{'word': 'Go', 'start': 2777, 'end': 2778, 'type': 'COM'}",com:made_of
846,Go를 사용한 일부 저명한 오픈 소스 소프트웨어 프레임워크는 다음과 같다:,"{'word': '오픈 소스 소프트웨어 프레임워크', 'start': 2828, 'end': 2844, 'type': 'COM'}","{'word': 'Go', 'start': 2813, 'end': 2814, 'type': 'COM'}",com:made_of
847,이 밖에도 Go를 사용하는 저명한 기업 및 사이트는 다음과 같다(일반적으로 다른 언어와 함께 사용):,"{'word': '저명한 기업 및 사이트', 'start': 2870, 'end': 2881, 'type': 'COM'}","{'word': 'Go', 'start': 2861, 'end': 2862, 'type': 'COM'}",com:made_of
848,"Go가 처음 런칭되었을 때는 실무적인 소프트웨어를 만들기에는 준비가 좀 덜 된 상태였지만, 2010년 5월 롭 파이크는 구글에서 실제로 사용되고 있는 부분이 있다고 공개적으로 알리게 되었다.","{'word': '소프트웨어', 'start': 760, 'end': 764, 'type': 'COM'}","{'word': '구글', 'start': 806, 'end': 807, 'type': 'COM'}",no_relation
849,GopherJS는 Go 코드를 자바스크립트 코드로 컴파일하며 Go가 프론트엔드 개발에 사용될 수 있게 한다.,"{'word': '자바스크립트 코드', 'start': 1228, 'end': 1236, 'type': 'COM'}","{'word': 'Go 코드', 'start': 1221, 'end': 1225, 'type': 'COM'}",no_relation
850,Go는 그리 좋지 않은 하드웨어에서도 빠르게 컴파일될 수 있도록 디자인되었다.,"{'word': '하드웨어', 'start': 1552, 'end': 1555, 'type': 'COM'}","{'word': 'Go', 'start': 1539, 'end': 1540, 'type': 'COM'}",no_relation
851,2009년 11월 10일에 리눅스와 MacOS 플랫폼을 대상으로 공식 발표되었다.,"{'word': 'MacOS', 'start': 713, 'end': 717, 'type': 'COM'}","{'word': '리눅스', 'start': 708, 'end': 710, 'type': 'COM'}",com:similar_tech
852,"Go의 문법은 대체로 C와 비슷하다: 코드 블록들은 중괄호로 둘러싸고 for, switch, if를 포함한 일반적인 제어구조를 가지고 있다.","{'word': 'Go', 'start': 1272, 'end': 1273, 'type': 'COM'}","{'word': 'C', 'start': 1284, 'end': 1284, 'type': 'COM'}",com:similar_tech
853,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': 'C++', 'start': 1696, 'end': 1698, 'type': 'COM'}","{'word': '자바', 'start': 1701, 'end': 1702, 'type': 'COM'}",com:similar_tech
854,"예를 들어, 이벤트 기반 서버와 같이, 데이터베이스나 네트워크 작업과 같이 시간이 많이 걸리는 연산을 하는 동안 프로그램이 다른 일을 하는 것을 말한다.","{'word': '데이터베이스', 'start': 1969, 'end': 1974, 'type': 'COM'}","{'word': '네트워크 작업', 'start': 1977, 'end': 1983, 'type': 'COM'}",com:similar_tech
855,"TX-0, PDP-1과 같은 컴퓨터들을 이용하여 코딩하던 과거에는 MIT 해커들이 했던 최초의 일은 어셈블러를 작성하는 일이었다.","{'word': '해커', 'start': 499, 'end': 500, 'type': 'PER'}","{'word': '어셈블러', 'start': 514, 'end': 517, 'type': 'COM'}",per:production
856,기계어는 특별한 변환 과정 없이 컴퓨터가 직접 처리할 수 있는 유일한 언어이다.,"{'word': '언어', 'start': 237, 'end': 238, 'type': 'COM'}","{'word': '기계어', 'start': 198, 'end': 200, 'type': 'COM'}",com:sub_concept
857,대부분의 어셈블러는 매크로를 제공하므로 공통이 되는 일련의 명령들을 만들어낼 수 있다.,"{'word': '어셈블러', 'start': 536, 'end': 539, 'type': 'COM'}","{'word': '매크로', 'start': 542, 'end': 544, 'type': 'COM'}",com:sub_concept
858,"저급 프로그래밍 언어 （低級 프로그래밍 言語）또는 로우 레벨 프로그래밍 언어()란 컴퓨터가 이해하기 쉽게 작성된 프로그래밍 언어로, 일반적으로 기계어와 어셈블리어를 일컫는다.","{'word': '저급 프로그래밍 언어', 'start': 0, 'end': 10, 'type': 'COM'}","{'word': '로우 레벨 프로그래밍 언어', 'start': 28, 'end': 41, 'type': 'COM'}",com:alter_names
859,실행속도가 매우 빠르지만 배우기가 어려우며 유지보수가 힘든 것이 단점이다.,"{'word': '실행속도', 'start': 98, 'end': 101, 'type': 'COM'}","{'word': '유지보수', 'start': 122, 'end': 125, 'type': 'COM'}",no_relation
860,저급언어와 반대되는 것으로 고급 프로그래밍 언어가 있다.,"{'word': '저급언어', 'start': 166, 'end': 169, 'type': 'COM'}","{'word': '고급 프로그래밍 언어', 'start': 181, 'end': 191, 'type': 'COM'}",no_relation
861,현재 프로그래머들은 대개 기계어로 직접 프로그램을 작성하지는 않는데 그 까닭은 고급 언어가 자동으로 다루는 수많은 세부 사항들을 신경써야 하기 때문이다.,"{'word': '고급 언어', 'start': 287, 'end': 291, 'type': 'COM'}","{'word': '기계어', 'start': 257, 'end': 259, 'type': 'COM'}",no_relation
862,"모든 명령마다 수많은 코드를 기억하고 찾아야 하고, 수정하기 또한 매우 어렵다.","{'word': '명령', 'start': 332, 'end': 333, 'type': 'COM'}","{'word': '코드', 'start': 341, 'end': 342, 'type': 'COM'}",no_relation
863,아래는 n번째 피보나치 수를 계산하는 32비트 x86 기계어를 표현한 16진 기능의 예이다:,"{'word': '기계어', 'start': 404, 'end': 406, 'type': 'COM'}","{'word': 'x86', 'start': 400, 'end': 402, 'type': 'COM'}",no_relation
864,2세대 언어는 기계어 최상단에 추상적인 수준을 제공한다.,"{'word': '2세대 언어', 'start': 426, 'end': 431, 'type': 'COM'}","{'word': '기계어', 'start': 434, 'end': 436, 'type': 'COM'}",no_relation
865,"아래는 상단의 피보나치 수 계산기와 동일하지만, MASM 문법을 이용하여 x86 어셈블리어로 표현한 것이다:","{'word': '어셈블리어', 'start': 625, 'end': 629, 'type': 'COM'}","{'word': '계산기', 'start': 595, 'end': 597, 'type': 'COM'}",no_relation
866,줄리아(Julia)는 고성능의 수치 해석 및 계산과학의 필요사항을 만족시키면서 일반 목적 프로그래밍에도 효과적으로 사용될 수 있도록 설계된 고급 동적 프로그래밍 언어이다.,"{'word': '고급 동적 프로그래밍 언어', 'start': 78, 'end': 91, 'type': 'COM'}","{'word': '줄리아', 'start': 0, 'end': 2, 'type': 'COM'}",com:sub_concept
867,"줄리아 공식 배포판은 줄리아의 REPL 통신 세션 셸을 포함하고 있으며, 테스트 코드를 빠르게 실험하기 위해 사용할 수 있다.","{'word': '줄리아', 'start': 108, 'end': 110, 'type': 'COM'}","{'word': 'REPL 통신 세션 셸', 'start': 113, 'end': 124, 'type': 'COM'}",com:sub_concept
868,줄리아(Julia)는 고성능의 수치 해석 및 계산과학의 필요사항을 만족시키면서 일반 목적 프로그래밍에도 효과적으로 사용될 수 있도록 설계된 고급 동적 프로그래밍 언어이다.,"{'word': '줄리아', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': 'Julia', 'start': 4, 'end': 8, 'type': 'COM'}",com:alter_names
869,"다음 부분은 샘플 세션 예제의 하나로서, 문자열들은 printLn에 의해 자동으로 이어붙여진다.","{'word': '문자열', 'start': 190, 'end': 192, 'type': 'COM'}","{'word': 'printLn', 'start': 196, 'end': 202, 'type': 'COM'}",no_relation
870,그런 경우에는 제조사가 만든 문서에서 쓰이는 것이 가장 자주 쓰이게 된다.,"{'word': '제조사', 'start': 348, 'end': 350, 'type': 'ORG'}","{'word': '문서', 'start': 356, 'end': 357, 'type': 'POH'}",org:production
871,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '저급 언어', 'start': 67, 'end': 71, 'type': 'COM'}","{'word': 'assembler language', 'start': 19, 'end': 36, 'type': 'COM'}",com:sub_concept
872,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '저급 언어', 'start': 67, 'end': 71, 'type': 'COM'}","{'word': '어셈블러 언어', 'start': 11, 'end': 17, 'type': 'COM'}",com:sub_concept
873,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '저급 언어', 'start': 67, 'end': 71, 'type': 'COM'}","{'word': '어셈블리어', 'start': 0, 'end': 4, 'type': 'COM'}",com:sub_concept
874,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '컴퓨터 프로그래밍', 'start': 56, 'end': 64, 'type': 'COM'}","{'word': '저급 언어', 'start': 67, 'end': 71, 'type': 'COM'}",com:sub_concept
875,어셈블러(assembler)는 어셈블리어를 기계어 형태의 오브젝트 코드로 해석해 주는 컴퓨터 언어 번역 프로그램을 말한다.,"{'word': '컴퓨터 언어 번역 프로그램', 'start': 430, 'end': 443, 'type': 'COM'}","{'word': '어셈블러', 'start': 382, 'end': 385, 'type': 'COM'}",com:sub_concept
876,"어셈블러는 기본 컴퓨터 명령어들을, 컴퓨터 프로세서가 기본 연산을 수행하는데 사용할 수 있는 비트 패턴으로 변환시키는 프로그램이다.","{'word': '프로그램', 'start': 517, 'end': 520, 'type': 'COM'}","{'word': '어셈블러', 'start': 451, 'end': 454, 'type': 'COM'}",com:sub_concept
877,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 어셈블러', 'start': 903, 'end': 913, 'type': 'COM'}","{'word': '고급 제어 구조', 'start': 916, 'end': 923, 'type': 'COM'}",com:sub_concept
878,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 어셈블러', 'start': 903, 'end': 913, 'type': 'COM'}","{'word': '높은 수준의 프로시져', 'start': 926, 'end': 936, 'type': 'COM'}",com:sub_concept
879,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 어셈블러', 'start': 903, 'end': 913, 'type': 'COM'}","{'word': '높은 수준의 자료형 추상화', 'start': 950, 'end': 963, 'type': 'COM'}",com:sub_concept
880,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 어셈블러', 'start': 903, 'end': 913, 'type': 'COM'}","{'word': '함수 선언 및 호출', 'start': 938, 'end': 947, 'type': 'COM'}",com:sub_concept
881,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 어셈블러', 'start': 903, 'end': 913, 'type': 'COM'}","{'word': '높은 수준의 언어 추상화 기능', 'start': 968, 'end': 983, 'type': 'COM'}",com:sub_concept
882,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 언어 추상화 기능', 'start': 968, 'end': 983, 'type': 'COM'}","{'word': '높은 수준의 자료형 추상화', 'start': 950, 'end': 963, 'type': 'COM'}",com:sub_concept
883,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 언어 추상화 기능', 'start': 968, 'end': 983, 'type': 'COM'}","{'word': '함수 선언 및 호출', 'start': 938, 'end': 947, 'type': 'COM'}",com:sub_concept
884,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 언어 추상화 기능', 'start': 968, 'end': 983, 'type': 'COM'}","{'word': '높은 수준의 프로시져', 'start': 926, 'end': 936, 'type': 'COM'}",com:sub_concept
885,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 언어 추상화 기능', 'start': 968, 'end': 983, 'type': 'COM'}","{'word': '고급 제어 구조', 'start': 916, 'end': 923, 'type': 'COM'}",com:sub_concept
886,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': 'RISC 기반 아키텍처', 'start': 1028, 'end': 1039, 'type': 'COM'}","{'word': '현대의 어셈블러', 'start': 1045, 'end': 1052, 'type': 'COM'}",com:sub_concept
887,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': '현대의 어셈블러', 'start': 1045, 'end': 1052, 'type': 'COM'}","{'word': 'HP PA-RISC', 'start': 1013, 'end': 1022, 'type': 'COM'}",com:sub_concept
888,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': '현대의 어셈블러', 'start': 1045, 'end': 1052, 'type': 'COM'}","{'word': 'Sun Sparc', 'start': 1002, 'end': 1010, 'type': 'COM'}",com:sub_concept
889,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': '현대의 어셈블러', 'start': 1045, 'end': 1052, 'type': 'COM'}","{'word': 'MIPS', 'start': 996, 'end': 999, 'type': 'COM'}",com:sub_concept
890,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': '중앙처리장치', 'start': 1075, 'end': 1080, 'type': 'COM'}","{'word': '파이프라인', 'start': 1083, 'end': 1087, 'type': 'COM'}",com:sub_concept
891,그러나 현대의 컴퓨터는 납득하기 어려운 지연 없이 다중 패스 어셈블리를 수행한다.,"{'word': '현대의 컴퓨터', 'start': 1369, 'end': 1375, 'type': 'COM'}","{'word': '다중 패스 어셈블리', 'start': 1393, 'end': 1402, 'type': 'COM'}",com:sub_concept
892,다중 패스 어셈블러는 링크 프로세스를 더 빠르게 한다는 장점이 있다.,"{'word': '다중 패스 어셈블러', 'start': 1411, 'end': 1420, 'type': 'COM'}","{'word': '링크 프로세스', 'start': 1423, 'end': 1429, 'type': 'COM'}",com:sub_concept
893,더 복잡한 고급 어셈블러는 다음과 같은 언어 추상물을 제공한다:,"{'word': '고급 어셈블러', 'start': 1456, 'end': 1462, 'type': 'COM'}","{'word': '언어 추상물', 'start': 1472, 'end': 1477, 'type': 'COM'}",com:sub_concept
894,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '어셈블리어', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': '어셈블러 언어', 'start': 11, 'end': 17, 'type': 'COM'}",com:alter_names
895,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '어셈블리어', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': 'assembler language', 'start': 19, 'end': 36, 'type': 'COM'}",com:alter_names
896,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '어셈블러 언어', 'start': 11, 'end': 17, 'type': 'COM'}","{'word': '어셈블리어', 'start': 0, 'end': 4, 'type': 'COM'}",com:alter_names
897,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '어셈블러 언어', 'start': 11, 'end': 17, 'type': 'COM'}","{'word': 'assembler language', 'start': 19, 'end': 36, 'type': 'COM'}",com:alter_names
898,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': 'assembler language', 'start': 19, 'end': 36, 'type': 'COM'}","{'word': '어셈블리어', 'start': 0, 'end': 4, 'type': 'COM'}",com:alter_names
899,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': 'assembler language', 'start': 19, 'end': 36, 'type': 'COM'}","{'word': '어셈블러 언어', 'start': 11, 'end': 17, 'type': 'COM'}",com:alter_names
900,어셈블러(assembler)는 어셈블리어를 기계어 형태의 오브젝트 코드로 해석해 주는 컴퓨터 언어 번역 프로그램을 말한다.,"{'word': '어셈블러', 'start': 382, 'end': 385, 'type': 'COM'}","{'word': 'assembler', 'start': 387, 'end': 395, 'type': 'COM'}",com:alter_names
901,"몇몇 사람들은 이러한 명령어들을 어셈블러 언어라고 부르며, 어셈블리 언어라고 부르는 사람들도 있다.","{'word': '어셈블러 언어', 'start': 543, 'end': 549, 'type': 'COM'}","{'word': '명령어', 'start': 537, 'end': 539, 'type': 'COM'}",com:alter_names
902,"몇몇 사람들은 이러한 명령어들을 어셈블러 언어라고 부르며, 어셈블리 언어라고 부르는 사람들도 있다.","{'word': '어셈블리 언어', 'start': 558, 'end': 564, 'type': 'COM'}","{'word': '명령어', 'start': 537, 'end': 539, 'type': 'COM'}",com:alter_names
903,"몇몇 사람들은 이러한 명령어들을 어셈블러 언어라고 부르며, 어셈블리 언어라고 부르는 사람들도 있다.","{'word': '명령어', 'start': 537, 'end': 539, 'type': 'COM'}","{'word': '어셈블러 언어', 'start': 543, 'end': 549, 'type': 'COM'}",com:alter_names
904,"몇몇 사람들은 이러한 명령어들을 어셈블러 언어라고 부르며, 어셈블리 언어라고 부르는 사람들도 있다.","{'word': '어셈블리 언어', 'start': 558, 'end': 564, 'type': 'COM'}","{'word': '어셈블러 언어', 'start': 543, 'end': 549, 'type': 'COM'}",com:alter_names
905,"몇몇 사람들은 이러한 명령어들을 어셈블러 언어라고 부르며, 어셈블리 언어라고 부르는 사람들도 있다.","{'word': '어셈블러 언어', 'start': 543, 'end': 549, 'type': 'COM'}","{'word': '어셈블리 언어', 'start': 558, 'end': 564, 'type': 'COM'}",com:alter_names
906,"몇몇 사람들은 이러한 명령어들을 어셈블러 언어라고 부르며, 어셈블리 언어라고 부르는 사람들도 있다.","{'word': '명령어', 'start': 537, 'end': 539, 'type': 'COM'}","{'word': '어셈블리 언어', 'start': 558, 'end': 564, 'type': 'COM'}",com:alter_names
907,니모닉 기호(mnemonics)를 opcode로 변환하고 메모리 위치와 기타 존재물에 따라 식별자를 다시 분석함으로써 목적 코드를 만들어낸다.,"{'word': '니모닉 기호', 'start': 581, 'end': 586, 'type': 'COM'}","{'word': 'mnemonics', 'start': 588, 'end': 596, 'type': 'COM'}",com:alter_names
908,거꾸로 기계어를 어셈블리어로 바꾸는 것은 “역(逆)어셈블러”(disassembler)이다.,"{'word': '역(逆)어셈블러', 'start': 685, 'end': 692, 'type': 'COM'}","{'word': 'disassembler', 'start': 695, 'end': 706, 'type': 'COM'}",com:alter_names
909,거꾸로 기계어를 어셈블리어로 바꾸는 것은 “역(逆)어셈블러”(disassembler)이다.,"{'word': 'disassembler', 'start': 695, 'end': 706, 'type': 'COM'}","{'word': '역(逆)어셈블러', 'start': 685, 'end': 692, 'type': 'COM'}",com:alter_names
910,어셈블러가 실행되는 단계를 어셈블리 타임이라고 한다.,"{'word': '어셈블리 타임', 'start': 1216, 'end': 1222, 'type': 'COM'}","{'word': '어셈블러가 실행되는 단계', 'start': 1201, 'end': 1213, 'type': 'COM'}",com:alter_names
911,기계어는 실제로 컴퓨터의 CPU가 읽어서 실행할 수 있는 0과 1로 이루어진 명령어의 조합이다.,"{'word': '기계어', 'start': 1486, 'end': 1488, 'type': 'COM'}","{'word': '명령어의 조합', 'start': 1529, 'end': 1535, 'type': 'COM'}",com:alter_names
912,이러한 각 명령어에 대해 사람이 알아보기 쉬운 니모닉 기호(mnemonic symbol)를 정해 사람이 좀 더 쉽게 컴퓨터의 행동을 제어할 수 있도록 한 것이 어셈블리 언어이다.,"{'word': '니모닉 기호', 'start': 1566, 'end': 1571, 'type': 'COM'}","{'word': 'mnemonic symbol', 'start': 1573, 'end': 1587, 'type': 'COM'}",com:alter_names
913,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '어셈블리어', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': '기계어', 'start': 40, 'end': 42, 'type': 'COM'}",no_relation
914,"컴퓨터 구조에 따라 사용하는 기계어가 달라지며, 따라서 기계어에 대응되어 만들어지는 어셈블리어도 각각 다르게 된다.","{'word': '기계어', 'start': 107, 'end': 109, 'type': 'COM'}","{'word': '어셈블리어', 'start': 123, 'end': 127, 'type': 'COM'}",no_relation
915,"컴퓨터 CPU마다 지원하는 오퍼레이션의 타입과 개수는 제각각이며, 레지스터의 크기와 개수, 저장된 데이터 형의 표현도 각기 다르다.","{'word': '오퍼레이션', 'start': 156, 'end': 160, 'type': 'COM'}","{'word': '레지스터', 'start': 178, 'end': 181, 'type': 'COM'}",no_relation
916,"모든 범용 컴퓨터는 기본적으로 동일한 기능을 수행하지만, 기능을 어떤 과정을 거쳐 수행할지는 다를 수 있으며, 이런 차이는 어셈블리어에 반영되게 된다.","{'word': '범용 컴퓨터', 'start': 218, 'end': 223, 'type': 'COM'}","{'word': '어셈블리어', 'start': 284, 'end': 288, 'type': 'COM'}",no_relation
917,"어셈블러는 기본 컴퓨터 명령어들을, 컴퓨터 프로세서가 기본 연산을 수행하는데 사용할 수 있는 비트 패턴으로 변환시키는 프로그램이다.","{'word': '기본 컴퓨터 명령어', 'start': 457, 'end': 466, 'type': 'COM'}","{'word': '컴퓨터 프로세서', 'start': 471, 'end': 478, 'type': 'COM'}",no_relation
918,"고급 언어와는 달리 어셈블리어는 간단한 문장에 대해 기계어와 일대일 대응 관계가 있지만, 자주 쓰이는 몇 명령은 둘 이상의 기계어 명령을 묶어 하나의 어셈블리 명령어에 대응시키기도 한다.","{'word': '기계어', 'start': 741, 'end': 743, 'type': 'COM'}","{'word': '어셈블리어', 'start': 723, 'end': 727, 'type': 'COM'}",no_relation
919,"이것은 어셈블리 명령 부호를 오피코드로 해석할 뿐만 아니라 메모리의 위치들을 이름으로 표시하는 기능, 매크로를 통한 문장 치환 기능 등을 함께 제공한다.","{'word': '어셈블리 명령 부호', 'start': 821, 'end': 830, 'type': 'COM'}","{'word': '오피코드', 'start': 833, 'end': 836, 'type': 'COM'}",no_relation
920,"이 어셈블러는 1950년대부터 계속 쓰여 왔으며, 고급 언어를 위한 컴파일러에 견주어 보면 구조가 매우 간단하다.","{'word': '컴파일러', 'start': 1144, 'end': 1147, 'type': 'COM'}","{'word': '어셈블러', 'start': 1108, 'end': 1111, 'type': 'COM'}",no_relation
921,크로스 어셈블러는 다른 프로세서를 위한 코드를 만든다.,"{'word': '크로스 어셈블러', 'start': 1170, 'end': 1177, 'type': 'COM'}","{'word': '프로세서', 'start': 1183, 'end': 1186, 'type': 'COM'}",no_relation
922,"어셈블러에는 두 가지 종류가 있는데, 실행 프로그램을 만들기 위해 얼마나 많은 패스가 소스를 거치는지에 따라 다르다.","{'word': '어셈블러', 'start': 1231, 'end': 1234, 'type': 'COM'}","{'word': '실행 프로그램', 'start': 1252, 'end': 1258, 'type': 'COM'}",no_relation
923,게다가 단일 명령 집합에 대해 여러 니모닉과 통사론이 대응될 수 있다.,"{'word': '니모닉', 'start': 320, 'end': 322, 'type': 'COM'}","{'word': '통사론', 'start': 325, 'end': 327, 'type': 'COM'}",com:similar_tech
924,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': 'MIPS', 'start': 996, 'end': 999, 'type': 'COM'}","{'word': 'Sun Sparc', 'start': 1002, 'end': 1010, 'type': 'COM'}",com:similar_tech
925,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': 'MIPS', 'start': 996, 'end': 999, 'type': 'COM'}","{'word': 'HP PA-RISC', 'start': 1013, 'end': 1022, 'type': 'COM'}",com:similar_tech
926,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': 'HP PA-RISC', 'start': 1013, 'end': 1022, 'type': 'COM'}","{'word': 'MIPS', 'start': 996, 'end': 999, 'type': 'COM'}",com:similar_tech
927,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': 'Sun Sparc', 'start': 1002, 'end': 1010, 'type': 'COM'}","{'word': 'MIPS', 'start': 996, 'end': 999, 'type': 'COM'}",com:similar_tech
928,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': 'Sun Sparc', 'start': 1002, 'end': 1010, 'type': 'COM'}","{'word': 'HP PA-RISC', 'start': 1013, 'end': 1022, 'type': 'COM'}",com:similar_tech
929,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': 'HP PA-RISC', 'start': 1013, 'end': 1022, 'type': 'COM'}","{'word': 'Sun Sparc', 'start': 1002, 'end': 1010, 'type': 'COM'}",com:similar_tech
930,역사적으로 바이트코드는 대부분의 명령 집합이 0개 이상의 매개 변수를 갖는 1바이트 크기의 명령 코드(opcode)였기 때문에 바이트코드라 불리게 되었다.,"{'word': '명령 코드', 'start': 178, 'end': 182, 'type': 'COM'}","{'word': '바이트코드', 'start': 133, 'end': 137, 'type': 'COM'}",com:sub_concept
931,이러한 형태의 바이트코드 인터프리터는 높은 이식성을 갖는다.,"{'word': '바이트코드 인터프리터', 'start': 605, 'end': 615, 'type': 'COM'}","{'word': '이식성', 'start': 621, 'end': 623, 'type': 'POH'}",com:sub_concept
932,"바이트코드(, portable code, p-code)는 특정 하드웨어가 아닌 가상 컴퓨터에서 돌아가는 실행 프로그램을 위한 이진 표현법이다.","{'word': '바이트코드', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': 'p-code', 'start': 23, 'end': 28, 'type': 'COM'}",com:alter_names
933,"하드웨어가 아닌 소프트웨어에 의해 처리되기 때문에, 보통 기계어보다 더 추상적이다.","{'word': '하드웨어', 'start': 80, 'end': 83, 'type': 'COM'}","{'word': '소프트웨어', 'start': 89, 'end': 93, 'type': 'COM'}",no_relation
934,"바이트코드는 특정 하드웨어에 대한 의존성을 줄이고, 인터프리팅도 쉬운 결과물을 생성하고자 하는 프로그래밍 언어에 의해, 출력 코드의 한 형태로 사용된다.","{'word': '바이트코드', 'start': 214, 'end': 218, 'type': 'COM'}","{'word': '하드웨어', 'start': 224, 'end': 227, 'type': 'COM'}",no_relation
935,"컴파일되어 만들어진 바이트코드는 특정 하드웨어의 기계 코드를 만드는 컴파일러의 입력으로 사용되거나, 가상 컴퓨터에서 바로 실행된다.","{'word': '바이트코드', 'start': 311, 'end': 315, 'type': 'COM'}","{'word': '컴파일러', 'start': 338, 'end': 341, 'type': 'COM'}",no_relation
936,"사람이 읽기 쉽도록 쓰인 소스 코드와 비교하면, 바이트 코드는 덜 추상적이며, 더 간결하고, 더 컴퓨터 중심적이다.","{'word': '소스 코드', 'start': 388, 'end': 392, 'type': 'COM'}","{'word': '바이트 코드', 'start': 401, 'end': 406, 'type': 'COM'}",no_relation
937,예를 들어 바이트코드는 변수의 접근 범위(지역변수 또는 전역변수 인지 여부) 등과 같은 의미 분석 단계의 결과를 부호화한다.,"{'word': '바이트코드', 'start': 445, 'end': 449, 'type': 'COM'}","{'word': '전역변수', 'start': 470, 'end': 473, 'type': 'COM'}",no_relation
938,바이트코드 프로그램은 보통 한 번에 하나의 명령어를 읽은 후 실행한다.,"{'word': '바이트코드 프로그램', 'start': 557, 'end': 566, 'type': 'COM'}","{'word': '명령어', 'start': 581, 'end': 583, 'type': 'COM'}",no_relation
939,"또 다른 형태로서 실시간 번역기 또는 저스트 인 타임(just-in-time, JIT) 컴파일러라 불리는 시스템은 실행 중에 필요에 따라서 바이트코드를 기계어로 번역한다.","{'word': '바이트코드', 'start': 709, 'end': 713, 'type': 'COM'}","{'word': '기계어', 'start': 716, 'end': 718, 'type': 'COM'}",no_relation
940,"이 방법은 가상 컴퓨터의 이식성을 없애지만, 바이트코드 자체에 대한 이식성을 잃지는 않는다.","{'word': '바이트코드', 'start': 752, 'end': 756, 'type': 'COM'}","{'word': '가상 컴퓨터', 'start': 733, 'end': 738, 'type': 'COM'}",no_relation
941,"예를 들어, 자바와 C# 코드는 보통 바이트코드 형태로 컴파일되어 저장되며, 실행 전에 JIT 컴파일러에 의해 기계 코드로 번역된다.","{'word': '자바', 'start': 786, 'end': 787, 'type': 'COM'}","{'word': 'JIT 컴파일러', 'start': 828, 'end': 835, 'type': 'COM'}",no_relation
942,"이 번역으로 인해 프로그램 실행 전에 지연시간이 발생하게 되지만, 보통 인터프리터보다는 훨씬 좋은 성능을 보여 준다.","{'word': '지연시간', 'start': 875, 'end': 878, 'type': 'COM'}","{'word': '프로그램', 'start': 864, 'end': 867, 'type': 'COM'}",no_relation
943,그래서 일반적으로 소스 코드를 직접 분석/실행하는 것보다 더 좋은 성능을 보여 준다.,"{'word': '소스 코드', 'start': 519, 'end': 523, 'type': 'COM'}","{'word': '성능', 'start': 546, 'end': 547, 'type': 'POH'}",no_relation
944,사용자는 직접 이러한 소프트웨어를 제작하고도 이를 중요하게 여기지 않을 때가 많다.,"{'word': '사용자', 'start': 835, 'end': 837, 'type': 'PER'}","{'word': '소프트웨어', 'start': 847, 'end': 851, 'type': 'COM'}",per:production
945,"발전소는 전기를 생산하지만, 전등과 같은 응용품을 이용하기 전에는 그 자체가 빛을 내는 등의 사용자가 바라는 기능을 수행하지는 않는다.","{'word': '발전소', 'start': 396, 'end': 398, 'type': 'ORG'}","{'word': '전기', 'start': 401, 'end': 402, 'type': 'POH'}",org:production
946,응용 소프트웨어() 또는 애플리케이션은 운영 체제에서 실행되는 모든 소프트웨어를 뜻한다.,"{'word': '소프트웨어', 'start': 38, 'end': 42, 'type': 'COM'}","{'word': '애플리케이션', 'start': 14, 'end': 19, 'type': 'COM'}",com:sub_concept
947,응용 소프트웨어() 또는 애플리케이션은 운영 체제에서 실행되는 모든 소프트웨어를 뜻한다.,"{'word': '소프트웨어', 'start': 38, 'end': 42, 'type': 'COM'}","{'word': '응용 소프트웨어', 'start': 0, 'end': 7, 'type': 'COM'}",com:sub_concept
948,"따라서, 워드프로세서, 스프레드시트, 웹브라우저들뿐만 아니라 컴파일러나 링커 등도 응용 소프트웨어에 속한다.","{'word': '응용 소프트웨어', 'start': 96, 'end': 103, 'type': 'COM'}","{'word': '링커', 'start': 90, 'end': 91, 'type': 'COM'}",com:sub_concept
949,"따라서, 워드프로세서, 스프레드시트, 웹브라우저들뿐만 아니라 컴파일러나 링커 등도 응용 소프트웨어에 속한다.","{'word': '응용 소프트웨어', 'start': 96, 'end': 103, 'type': 'COM'}","{'word': '컴파일러', 'start': 84, 'end': 87, 'type': 'COM'}",com:sub_concept
950,"따라서, 워드프로세서, 스프레드시트, 웹브라우저들뿐만 아니라 컴파일러나 링커 등도 응용 소프트웨어에 속한다.","{'word': '응용 소프트웨어', 'start': 96, 'end': 103, 'type': 'COM'}","{'word': '웹브라우저', 'start': 71, 'end': 75, 'type': 'COM'}",com:sub_concept
951,"따라서, 워드프로세서, 스프레드시트, 웹브라우저들뿐만 아니라 컴파일러나 링커 등도 응용 소프트웨어에 속한다.","{'word': '응용 소프트웨어', 'start': 96, 'end': 103, 'type': 'COM'}","{'word': '스프레드시트', 'start': 63, 'end': 68, 'type': 'COM'}",com:sub_concept
952,"따라서, 워드프로세서, 스프레드시트, 웹브라우저들뿐만 아니라 컴파일러나 링커 등도 응용 소프트웨어에 속한다.","{'word': '응용 소프트웨어', 'start': 96, 'end': 103, 'type': 'COM'}","{'word': '워드프로세서', 'start': 55, 'end': 60, 'type': 'COM'}",com:sub_concept
953,또는 좁은 의미에서는 OS 위에서 사용자가 직접 사용하게되는 소프트웨어들을 뜻한다.,"{'word': 'OS', 'start': 123, 'end': 124, 'type': 'COM'}","{'word': '소프트웨어', 'start': 145, 'end': 149, 'type': 'COM'}",com:sub_concept
954,이런 경우 컴파일러나 링커등 시스템소프트웨어를 제외한 워드프로세서등의 소프트웨어들만을 주로 뜻한다.,"{'word': '시스템소프트웨어', 'start': 174, 'end': 181, 'type': 'COM'}","{'word': '링커', 'start': 170, 'end': 171, 'type': 'COM'}",com:sub_concept
955,이런 경우 컴파일러나 링커등 시스템소프트웨어를 제외한 워드프로세서등의 소프트웨어들만을 주로 뜻한다.,"{'word': '시스템소프트웨어', 'start': 174, 'end': 181, 'type': 'COM'}","{'word': '컴파일러', 'start': 164, 'end': 167, 'type': 'COM'}",com:sub_concept
956,이런 경우 컴파일러나 링커등 시스템소프트웨어를 제외한 워드프로세서등의 소프트웨어들만을 주로 뜻한다.,"{'word': '소프트웨어', 'start': 197, 'end': 201, 'type': 'COM'}","{'word': '워드프로세서', 'start': 188, 'end': 193, 'type': 'COM'}",com:sub_concept
957,응용 프로그램 제품군은 하나의 꾸러미로 묶인 여러 개의 응용 프로그램을 말한다.,"{'word': '응용 프로그램 제품군', 'start': 472, 'end': 482, 'type': 'COM'}","{'word': '응용 프로그램', 'start': 503, 'end': 509, 'type': 'COM'}",com:sub_concept
958,"워드 프로세서와 스프레드시트, 그 밖에 몇몇의 응용 프로그램들이 함께 포함된 마이크로소프트 오피스가 대표적인 예이다.","{'word': '마이크로소프트 오피스', 'start': 560, 'end': 570, 'type': 'COM'}","{'word': '스프레드시트', 'start': 526, 'end': 531, 'type': 'COM'}",com:sub_concept
959,"워드 프로세서와 스프레드시트, 그 밖에 몇몇의 응용 프로그램들이 함께 포함된 마이크로소프트 오피스가 대표적인 예이다.","{'word': '마이크로소프트 오피스', 'start': 560, 'end': 570, 'type': 'COM'}","{'word': '워드 프로세서', 'start': 517, 'end': 523, 'type': 'COM'}",com:sub_concept
960,하나의 꾸러미로 묶인 응용 프로그램들은 대개 사용자가 배우거나 사용하기 쉽게 짜여진 일관된 사용자 인터페이스를 사용한다.,"{'word': '응용 프로그램', 'start': 595, 'end': 601, 'type': 'COM'}","{'word': '사용자 인터페이스', 'start': 634, 'end': 642, 'type': 'COM'}",com:sub_concept
961,"VCR, DVD 플레이어, 전자레인지와 같은 임베디드 시스템에서는 응용 소프트웨어와 운영 체제 소프트웨어를 구별하기 어려울 수도 있다.","{'word': '임베디드 시스템', 'start': 907, 'end': 914, 'type': 'COM'}","{'word': '전자레인지', 'start': 897, 'end': 901, 'type': 'COM'}",com:sub_concept
962,"VCR, DVD 플레이어, 전자레인지와 같은 임베디드 시스템에서는 응용 소프트웨어와 운영 체제 소프트웨어를 구별하기 어려울 수도 있다.","{'word': '임베디드 시스템', 'start': 907, 'end': 914, 'type': 'COM'}","{'word': 'DVD 플레이어', 'start': 887, 'end': 894, 'type': 'COM'}",com:sub_concept
963,"VCR, DVD 플레이어, 전자레인지와 같은 임베디드 시스템에서는 응용 소프트웨어와 운영 체제 소프트웨어를 구별하기 어려울 수도 있다.","{'word': '임베디드 시스템', 'start': 907, 'end': 914, 'type': 'COM'}","{'word': 'VCR', 'start': 882, 'end': 884, 'type': 'COM'}",com:sub_concept
964,간단하게 줄여서 애플리케이션이라고 하며 준말로 앱(app)이라도 부른다.,"{'word': '애플리케이션', 'start': 276, 'end': 281, 'type': 'COM'}","{'word': '앱(app)', 'start': 293, 'end': 298, 'type': 'COM'}",com:alter_names
965,이렇게 뜻을 한정할 경우 응용 소프트웨어는 시스템 소프트웨어의 여집합이라고도 생각할 수 있다.,"{'word': '응용 소프트웨어', 'start': 228, 'end': 235, 'type': 'COM'}","{'word': '시스템 소프트웨어', 'start': 238, 'end': 246, 'type': 'COM'}",no_relation
966,"쉽지만 꽤 정확하지는 않은 비유를 쓰자면, 이것은 하드웨어의 세계에서 전기 불빛을 응용 프로그램(애플리케이션)이라 하고, 발전소를 시스템이라고 할 수 있다.","{'word': '하드웨어', 'start': 336, 'end': 339, 'type': 'COM'}","{'word': '응용 프로그램', 'start': 354, 'end': 360, 'type': 'COM'}",no_relation
967,그리고 이들은 보통 사용자의 편의를 위해 응용 프로그램 사이에 상호 작용하는 기능을 가진다.,"{'word': '사용자', 'start': 662, 'end': 664, 'type': 'COM'}","{'word': '응용 프로그램', 'start': 674, 'end': 680, 'type': 'COM'}",no_relation
968,"예를 들어, 한 스프레드시트에 워드 프로세서의 문서를 포함할 수 있고, 게다가 다른 종류의 스프레드시트 응용 프로그램에서 이 스프레드시트의 문서를 만들 수도 있다.","{'word': '스프레드시트', 'start': 712, 'end': 717, 'type': 'COM'}","{'word': '워드 프로세서', 'start': 720, 'end': 726, 'type': 'COM'}",no_relation
969,사용자 소프트웨어는 시스템이 사용자에 특화된 요구에 적합하도록 만든다.,"{'word': '사용자 소프트웨어', 'start': 795, 'end': 803, 'type': 'COM'}","{'word': '시스템', 'start': 806, 'end': 808, 'type': 'COM'}",no_relation
970,"VCR, DVD 플레이어, 전자레인지와 같은 임베디드 시스템에서는 응용 소프트웨어와 운영 체제 소프트웨어를 구별하기 어려울 수도 있다.","{'word': '응용 소프트웨어', 'start': 919, 'end': 926, 'type': 'COM'}","{'word': '운영 체제 소프트웨어', 'start': 929, 'end': 939, 'type': 'COM'}",com:similar_tech
971,"마이크로소프트 파운데이션 클래스 라이브러리(, MFC)는 마이크로소프트에서 만든 윈도 API를 C++로 둘러 싼 라이브러리이다.","{'word': '마이크로소프트', 'start': 56, 'end': 62, 'type': 'ORG'}","{'word': '마이크로소프트 파운데이션 클래스 라이브러리', 'start': 24, 'end': 46, 'type': 'COM'}",org:production
972,마이크로소프트는 개발도구 시장에서 경쟁력을 얻기 위해 C++을 활용하여 MFC를 만들었다.,"{'word': '마이크로소프트', 'start': 234, 'end': 240, 'type': 'ORG'}","{'word': 'MFC', 'start': 274, 'end': 276, 'type': 'COM'}",org:production
973,MFC의 구조는 후에 시맨틱사에 매각된 매킨토시의 TCL(Think Class Library)에서 영향을 받았다.,"{'word': '매킨토시', 'start': 307, 'end': 310, 'type': 'ORG'}","{'word': 'TCL(Think Class Library)', 'start': 313, 'end': 336, 'type': 'COM'}",org:production
974,볼랜드의 터보 C++과 터보 파스칼에서는 OWL(Object Windows Library)이란 경쟁제품이 있었다.,"{'word': '볼랜드의 터보 C++과 터보 파스칼', 'start': 349, 'end': 367, 'type': 'ORG'}","{'word': 'OWL(Object Windows Library)', 'start': 372, 'end': 398, 'type': 'COM'}",org:production
975,"그 이후 볼랜드는 OWL의 개발을 중단하고, 이를 대체하는 VCL을 개발하여 델파이와 C++빌더에서 사용하고 있다.","{'word': '볼랜드', 'start': 520, 'end': 522, 'type': 'ORG'}","{'word': 'VCL', 'start': 548, 'end': 550, 'type': 'COM'}",org:production
976,"그 이후 볼랜드는 OWL의 개발을 중단하고, 이를 대체하는 VCL을 개발하여 델파이와 C++빌더에서 사용하고 있다.","{'word': '볼랜드', 'start': 520, 'end': 522, 'type': 'ORG'}","{'word': 'OWL', 'start': 525, 'end': 527, 'type': 'COM'}",org:production
977,"마이크로소프트에서 MFC가 만들어졌음에도 많은 프로그래머들에게 MFC는 너무 복잡했기 때문에, 마이크로소프트는 상용 소프트웨어 개발에 비주얼 베이직을 쓰라고 권장하였다.","{'word': '마이크로소프트', 'start': 609, 'end': 615, 'type': 'ORG'}","{'word': 'MFC', 'start': 619, 'end': 621, 'type': 'COM'}",org:production
978,"Mainsoft가 만든 유닉스용 MFC가 있으며, 1990년대 마이크로소프트는 맥 OS용 MFC를 만들기도 했지만, 계속 개발하지 않았다.","{'word': 'Mainsoft', 'start': 1306, 'end': 1313, 'type': 'ORG'}","{'word': '유닉스용 MFC', 'start': 1319, 'end': 1326, 'type': 'COM'}",org:production
979,"Mainsoft가 만든 유닉스용 MFC가 있으며, 1990년대 마이크로소프트는 맥 OS용 MFC를 만들기도 했지만, 계속 개발하지 않았다.","{'word': '마이크로소프트', 'start': 1341, 'end': 1347, 'type': 'ORG'}","{'word': '맥 OS용 MFC', 'start': 1350, 'end': 1358, 'type': 'COM'}",org:production
980,MFC는 1992년 16비트 윈도용 마이크로소프트 C/C++ 7.0 컴파일러에서 처음 도입되었다.,"{'word': '윈도용 마이크로소프트 C/C++ 7.0 컴파일러', 'start': 152, 'end': 177, 'type': 'COM'}","{'word': 'MFC', 'start': 136, 'end': 138, 'type': 'COM'}",com:sub_concept
981,그 당시에는 C++이 소프트웨어 제품 개발 언어로 활용되기 시작하던 때였다.,"{'word': '소프트웨어 제품 개발 언어', 'start': 203, 'end': 216, 'type': 'COM'}","{'word': 'C++', 'start': 198, 'end': 200, 'type': 'COM'}",com:sub_concept
982,C++빌더는 MFC를 라이선스 받아 포함하고 있다.,"{'word': 'C++빌더', 'start': 580, 'end': 584, 'type': 'COM'}","{'word': 'MFC', 'start': 587, 'end': 589, 'type': 'COM'}",com:sub_concept
983,비주얼 베이직을 강조하면서도 새 버전의 비주얼 스튜디오에는 항상 MFC가 공급되었다.,"{'word': '비주얼 스튜디오', 'start': 849, 'end': 856, 'type': 'COM'}","{'word': 'MFC', 'start': 863, 'end': 865, 'type': 'COM'}",com:sub_concept
984,"MFC가 처음 도입되었을 때 마이크로소프트는 기본적인 C++ 문법에 메시지 처리, 예외 처리, 런타임 처리, 동적 클래스 객체 생성을 위한 매크로를 추가해 C++ 언어를 확장하려 했다.","{'word': 'C++ 문법', 'start': 935, 'end': 940, 'type': 'COM'}","{'word': '메시지 처리', 'start': 943, 'end': 948, 'type': 'COM'}",com:sub_concept
985,"MFC가 처음 도입되었을 때 마이크로소프트는 기본적인 C++ 문법에 메시지 처리, 예외 처리, 런타임 처리, 동적 클래스 객체 생성을 위한 매크로를 추가해 C++ 언어를 확장하려 했다.","{'word': 'C++ 문법', 'start': 935, 'end': 940, 'type': 'COM'}","{'word': '예외 처리', 'start': 951, 'end': 955, 'type': 'COM'}",com:sub_concept
986,"MFC가 처음 도입되었을 때 마이크로소프트는 기본적인 C++ 문법에 메시지 처리, 예외 처리, 런타임 처리, 동적 클래스 객체 생성을 위한 매크로를 추가해 C++ 언어를 확장하려 했다.","{'word': 'C++ 문법', 'start': 935, 'end': 940, 'type': 'COM'}","{'word': '런타임 처리', 'start': 958, 'end': 963, 'type': 'COM'}",com:sub_concept
987,"MFC가 처음 도입되었을 때 마이크로소프트는 기본적인 C++ 문법에 메시지 처리, 예외 처리, 런타임 처리, 동적 클래스 객체 생성을 위한 매크로를 추가해 C++ 언어를 확장하려 했다.","{'word': 'C++ 문법', 'start': 935, 'end': 940, 'type': 'COM'}","{'word': '동적 클래스 객체 생성', 'start': 966, 'end': 977, 'type': 'COM'}",com:sub_concept
988,이런 매크로를 활용한 시스템은 컴파일러의 타입 검사를 무시하므로 버그를 가져올 수 있었다.,"{'word': '컴파일러', 'start': 1026, 'end': 1029, 'type': 'COM'}","{'word': '타입 검사', 'start': 1032, 'end': 1036, 'type': 'COM'}",com:sub_concept
989,"게다가 MFC의 문서/뷰 프레임워크는 데이터 모델과 유저 인터페이스, 제어 로직을 분리한다는 MVC 디자인을 자연스럽게 만들어준다.","{'word': 'MFC', 'start': 1200, 'end': 1202, 'type': 'COM'}","{'word': '문서/뷰 프레임워크', 'start': 1205, 'end': 1214, 'type': 'COM'}",com:sub_concept
990,"게다가 MFC의 문서/뷰 프레임워크는 데이터 모델과 유저 인터페이스, 제어 로직을 분리한다는 MVC 디자인을 자연스럽게 만들어준다.","{'word': 'MVC 디자인', 'start': 1248, 'end': 1254, 'type': 'COM'}","{'word': '데이터 모델', 'start': 1217, 'end': 1222, 'type': 'COM'}",com:sub_concept
991,"게다가 MFC의 문서/뷰 프레임워크는 데이터 모델과 유저 인터페이스, 제어 로직을 분리한다는 MVC 디자인을 자연스럽게 만들어준다.","{'word': 'MVC 디자인', 'start': 1248, 'end': 1254, 'type': 'COM'}","{'word': '유저 인터페이스', 'start': 1225, 'end': 1232, 'type': 'COM'}",com:sub_concept
992,"게다가 MFC의 문서/뷰 프레임워크는 데이터 모델과 유저 인터페이스, 제어 로직을 분리한다는 MVC 디자인을 자연스럽게 만들어준다.","{'word': 'MVC 디자인', 'start': 1248, 'end': 1254, 'type': 'COM'}","{'word': '제어 로직', 'start': 1235, 'end': 1239, 'type': 'COM'}",com:sub_concept
993,"MFC Feature Pack을 지원하여, 리본 메뉴 등의 UI를 IDE에서 자동으로 작성해준다.","{'word': 'UI', 'start': 1417, 'end': 1418, 'type': 'COM'}","{'word': '리본 메뉴', 'start': 1408, 'end': 1412, 'type': 'COM'}",com:sub_concept
994,"마이크로소프트 파운데이션 클래스 라이브러리 마이크로소프트 파운데이션 클래스 라이브러리(, MFC)는 마이크로소프트에서 만든 윈도 API를 C++로 둘러 싼 라이브러리이다.","{'word': '마이크로소프트 파운데이션 클래스 라이브러리', 'start': 0, 'end': 22, 'type': 'COM'}","{'word': 'MFC', 'start': 50, 'end': 52, 'type': 'COM'}",com:alter_names
995,"마이크로소프트 파운데이션 클래스 라이브러리(, MFC)는 마이크로소프트에서 만든 윈도 API를 C++로 둘러 싼 라이브러리이다.","{'word': '마이크로소프트 파운데이션 클래스 라이브러리', 'start': 24, 'end': 46, 'type': 'COM'}","{'word': 'MFC', 'start': 50, 'end': 52, 'type': 'COM'}",com:alter_names
996,마이크로소프트는 개발도구 시장에서 경쟁력을 얻기 위해 C++을 활용하여 MFC를 만들었다.,"{'word': 'MFC', 'start': 274, 'end': 276, 'type': 'COM'}","{'word': 'C++', 'start': 264, 'end': 266, 'type': 'COM'}",com:made_of
997,MFC와 비주얼 베이직의 후속작으로 Windows Forms가 출시되었으며 C++ 관리 모드 확장으로 쓸 수 있다.,"{'word': 'MFC와 비주얼 베이직', 'start': 704, 'end': 715, 'type': 'COM'}","{'word': 'Windows Forms', 'start': 724, 'end': 736, 'type': 'COM'}",com:prior_tech
998,"마이크로소프트에서 MFC가 만들어졌음에도 많은 프로그래머들에게 MFC는 너무 복잡했기 때문에, 마이크로소프트는 상용 소프트웨어 개발에 비주얼 베이직을 쓰라고 권장하였다.","{'word': '프로그래머', 'start': 635, 'end': 639, 'type': 'PER'}","{'word': 'MFC', 'start': 644, 'end': 646, 'type': 'COM'}",no_relation
999,그래서 많은 프로그래머들이 MFC를 사용하게 되었다.,"{'word': '프로그래머', 'start': 882, 'end': 886, 'type': 'PER'}","{'word': 'MFC', 'start': 890, 'end': 892, 'type': 'COM'}",no_relation
1000,"객체 지향 모델을 더 엄격하게 따르고 있었기 때문에, OWL은 한때 MFC보다 인기 있었다. 하지만 윈도의 새로운 기능에 대한 업데이트가 늦어지게 되면서, 시장 지배력을 잃어버렸다.","{'word': 'OWL', 'start': 443, 'end': 445, 'type': 'COM'}","{'word': 'MFC', 'start': 451, 'end': 453, 'type': 'COM'}",no_relation
1001,비주얼 스튜디오 2005 출시와 함께 닷넷 프레임워크의 기능들을 더 쉬운 문법으로 쓸 수 있게 되었다.,"{'word': '비주얼 스튜디오 2005', 'start': 769, 'end': 781, 'type': 'COM'}","{'word': '닷넷 프레임워크', 'start': 790, 'end': 797, 'type': 'COM'}",no_relation
1002,32비트 버전의 MFC부터 이것이 개선되었다.,"{'word': 'MFC', 'start': 1069, 'end': 1071, 'type': 'COM'}","{'word': '32비트', 'start': 1060, 'end': 1063, 'type': 'COM'}",no_relation
1003,MFC의 가장 큰 장점은 윈도 API를 객체지향적으로 프로그래밍할 수 있다는 것이다.,"{'word': 'MFC', 'start': 1086, 'end': 1088, 'type': 'COM'}","{'word': '윈도 API', 'start': 1100, 'end': 1105, 'type': 'COM'}",no_relation
1004,또한 윈도의 자원과 연관된 형들은 그들을 생성한 객체가 죽게 되면 자동으로 핸들을 해제해 준다는 장점도 있다.,"{'word': '윈도', 'start': 1137, 'end': 1138, 'type': 'COM'}","{'word': '객체', 'start': 1161, 'end': 1162, 'type': 'COM'}",no_relation
1005,하지만 MFC는 다중 운영체제를 지원하지 않는다는 약점이 있다.,"{'word': 'MFC', 'start': 1274, 'end': 1276, 'type': 'COM'}","{'word': '다중 운영체제', 'start': 1279, 'end': 1285, 'type': 'COM'}",no_relation
1006,"Eisler (development lead), St. John, and Engstrom (program manager)은 함께 이 문제를 해결하여 솔루션을 내놓았는데 이 이름이 DirectX이다.","{'word': 'Engstrom', 'start': 1349, 'end': 1356, 'type': 'PER'}","{'word': 'program manager', 'start': 1359, 'end': 1373, 'type': 'POH'}",per:title
1007,"마이크로소프트의 3명의 직원 Craig Eisler, Alex St. John, Eric Engstrom은 프로그래머들이 마이크로소프트의 이전 운영 체제인 MS-DOS를 더 나은 플랫폼으로 보는 경향이 있었기 때문에 걱정이 있었다.","{'word': 'Craig Eisler', 'start': 865, 'end': 876, 'type': 'PER'}","{'word': 'Alex St. John', 'start': 879, 'end': 891, 'type': 'PER'}",per:colleagues
1008,"마이크로소프트의 3명의 직원 Craig Eisler, Alex St. John, Eric Engstrom은 프로그래머들이 마이크로소프트의 이전 운영 체제인 MS-DOS를 더 나은 플랫폼으로 보는 경향이 있었기 때문에 걱정이 있었다.","{'word': 'Craig Eisler', 'start': 865, 'end': 876, 'type': 'PER'}","{'word': 'Eric Engstrom', 'start': 894, 'end': 906, 'type': 'PER'}",per:colleagues
1009,"마이크로소프트의 3명의 직원 Craig Eisler, Alex St. John, Eric Engstrom은 프로그래머들이 마이크로소프트의 이전 운영 체제인 MS-DOS를 더 나은 플랫폼으로 보는 경향이 있었기 때문에 걱정이 있었다.","{'word': 'Alex St. John', 'start': 879, 'end': 891, 'type': 'PER'}","{'word': 'Eric Engstrom', 'start': 894, 'end': 906, 'type': 'PER'}",per:colleagues
1010,"Eisler (development lead), St. John, and Engstrom (program manager)은 함께 이 문제를 해결하여 솔루션을 내놓았는데 이 이름이 DirectX이다.","{'word': 'Eisler', 'start': 1308, 'end': 1313, 'type': 'PER'}","{'word': 'St. John', 'start': 1335, 'end': 1342, 'type': 'PER'}",per:colleagues
1011,"Eisler (development lead), St. John, and Engstrom (program manager)은 함께 이 문제를 해결하여 솔루션을 내놓았는데 이 이름이 DirectX이다.","{'word': 'Eisler', 'start': 1308, 'end': 1313, 'type': 'PER'}","{'word': 'Engstrom', 'start': 1349, 'end': 1356, 'type': 'PER'}",per:colleagues
1012,"Eisler (development lead), St. John, and Engstrom (program manager)은 함께 이 문제를 해결하여 솔루션을 내놓았는데 이 이름이 DirectX이다.","{'word': 'St. John', 'start': 1335, 'end': 1342, 'type': 'PER'}","{'word': 'Engstrom', 'start': 1349, 'end': 1356, 'type': 'PER'}",per:colleagues
1013,"1994년 말, 마이크로소프트는 다음 운영 체제인 윈도우 95를 출시할 준비가 되었다.","{'word': '마이크로소프트', 'start': 809, 'end': 815, 'type': 'ORG'}","{'word': '윈도우 95', 'start': 828, 'end': 833, 'type': 'COM'}",org:production
1014,"Microsoft DirectX()는 멀티미디어, 특히 게임 프로그래밍에서 마이크로소프트 플랫폼에서 작업을 위한 API의 집합이다.","{'word': 'API', 'start': 63, 'end': 65, 'type': 'COM'}","{'word': 'Microsoft DirectX', 'start': 0, 'end': 16, 'type': 'COM'}",com:sub_concept
1015,다이렉트엑스는 또한 게임뿐 아니라 최근에 나온 3차원 그래픽 하드웨어를 사용하여 높은 품질의 3차원 그래픽을 빠르게 렌더링할 수 있기 때문에 소프트웨어 업계 전반에서 사용되기도 한다.,"{'word': '다이렉트엑스', 'start': 153, 'end': 158, 'type': 'COM'}","{'word': '3차원 그래픽 하드웨어', 'start': 179, 'end': 190, 'type': 'COM'}",com:sub_concept
1016,다이렉트엑스 런타임과 소프트웨어 개발킷은 무료이지만 개조는 할 수 없는 클로즈드 소스(오픈 소스의 반대 개념) 소프트웨어이다.,"{'word': '클로즈드 소스', 'start': 296, 'end': 302, 'type': 'COM'}","{'word': '다이렉트엑스 런타임과 소프트웨어 개발킷', 'start': 256, 'end': 276, 'type': 'COM'}",com:sub_concept
1017,"다이렉트엑스 런타임은 원래 컴퓨터 게임 개발자들에게만 공개되었으나, 최근에는 기본적으로 윈도우에 포함되어 있다.","{'word': '윈도우', 'start': 376, 'end': 378, 'type': 'COM'}","{'word': '다이렉트엑스 런타임', 'start': 327, 'end': 336, 'type': 'COM'}",com:sub_concept
1018,그 까닭은 이러한 새로운 버전들은 윈도우 비스타에 도입되었던 새로운 윈도우 디스플레이 드라이버 모델이 있어야 동작하기 때문이다.,"{'word': '윈도우 비스타', 'start': 571, 'end': 577, 'type': 'COM'}","{'word': '윈도우 디스플레이 드라이버 모델', 'start': 590, 'end': 606, 'type': 'COM'}",com:sub_concept
1019,"새로운 비스타/WDDM 그래픽스 구조에는 데스크톱 창 관리자와 같이, 그래픽 하드웨어를 여러 개의 응용 프로그램과 서비스에 가상화할 수 있게 도와 주는 새로운 비디오 메모리 관리자를 포함하고 있다.","{'word': '비스타/WDDM 그래픽스 구조', 'start': 693, 'end': 708, 'type': 'COM'}","{'word': '비디오 메모리 관리자', 'start': 778, 'end': 788, 'type': 'COM'}",com:sub_concept
1020,"1994년 말, 마이크로소프트는 다음 운영 체제인 윈도우 95를 출시할 준비가 되었다.","{'word': '운영 체제', 'start': 821, 'end': 825, 'type': 'COM'}","{'word': '윈도우 95', 'start': 828, 'end': 833, 'type': 'COM'}",com:sub_concept
1021,"마이크로소프트의 3명의 직원 Craig Eisler, Alex St. John, Eric Engstrom은 프로그래머들이 마이크로소프트의 이전 운영 체제인 MS-DOS를 더 나은 플랫폼으로 보는 경향이 있었기 때문에 걱정이 있었다.","{'word': '운영 체제', 'start': 929, 'end': 933, 'type': 'COM'}","{'word': 'MS-DOS', 'start': 936, 'end': 941, 'type': 'COM'}",com:sub_concept
1022,라이온킹 비디오 게임의 윈도우 포팅에 관한 부정적인 반응이 함께했다.,"{'word': '라이온킹 비디오 게임', 'start': 1085, 'end': 1095, 'type': 'COM'}","{'word': '윈도우 포팅', 'start': 1098, 'end': 1103, 'type': 'COM'}",com:sub_concept
1023,"도스는 비디오 카드, 키보드, 마우스, 사운드 장치, 그리고 시스템의 나머지 모든 부분들에 직접 접근을 허용하였던 반면에 윈도우 95는 보호 메모리 모델이 포함되어 이 모든 것들에 대한 접근을 제한하였다.","{'word': '도스', 'start': 1124, 'end': 1125, 'type': 'COM'}","{'word': '비디오 카드', 'start': 1128, 'end': 1133, 'type': 'COM'}",com:sub_concept
1024,"도스는 비디오 카드, 키보드, 마우스, 사운드 장치, 그리고 시스템의 나머지 모든 부분들에 직접 접근을 허용하였던 반면에 윈도우 95는 보호 메모리 모델이 포함되어 이 모든 것들에 대한 접근을 제한하였다.","{'word': '도스', 'start': 1124, 'end': 1125, 'type': 'COM'}","{'word': '키보드', 'start': 1136, 'end': 1138, 'type': 'COM'}",com:sub_concept
1025,"도스는 비디오 카드, 키보드, 마우스, 사운드 장치, 그리고 시스템의 나머지 모든 부분들에 직접 접근을 허용하였던 반면에 윈도우 95는 보호 메모리 모델이 포함되어 이 모든 것들에 대한 접근을 제한하였다.","{'word': '도스', 'start': 1124, 'end': 1125, 'type': 'COM'}","{'word': '마우스', 'start': 1141, 'end': 1143, 'type': 'COM'}",com:sub_concept
1026,"도스는 비디오 카드, 키보드, 마우스, 사운드 장치, 그리고 시스템의 나머지 모든 부분들에 직접 접근을 허용하였던 반면에 윈도우 95는 보호 메모리 모델이 포함되어 이 모든 것들에 대한 접근을 제한하였다.","{'word': '도스', 'start': 1124, 'end': 1125, 'type': 'COM'}","{'word': '사운드 장치', 'start': 1146, 'end': 1151, 'type': 'COM'}",com:sub_concept
1027,"도스는 비디오 카드, 키보드, 마우스, 사운드 장치, 그리고 시스템의 나머지 모든 부분들에 직접 접근을 허용하였던 반면에 윈도우 95는 보호 메모리 모델이 포함되어 이 모든 것들에 대한 접근을 제한하였다.","{'word': '윈도우 95', 'start': 1192, 'end': 1197, 'type': 'COM'}","{'word': '보호 메모리 모델', 'start': 1200, 'end': 1208, 'type': 'COM'}",com:sub_concept
1028,"Microsoft DirectX()는 멀티미디어, 특히 게임 프로그래밍에서 마이크로소프트 플랫폼에서 작업을 위한 API의 집합이다.","{'word': 'Microsoft DirectX', 'start': 0, 'end': 16, 'type': 'COM'}","{'word': '게임 프로그래밍', 'start': 31, 'end': 38, 'type': 'COM'}",no_relation
1029,"다이렉트엑스는 마이크로소프트 윈도우, 세가, 드림캐스트, 마이크로소프트 엑스박스 및 엑스박스 360을 위한 비디오 게임 개발에 널리 쓰인다.","{'word': '다이렉트엑스', 'start': 74, 'end': 79, 'type': 'COM'}","{'word': '마이크로소프트 윈도우', 'start': 82, 'end': 92, 'type': 'COM'}",no_relation
1030,"다이렉트엑스는 마이크로소프트 윈도우, 세가, 드림캐스트, 마이크로소프트 엑스박스 및 엑스박스 360을 위한 비디오 게임 개발에 널리 쓰인다.","{'word': '다이렉트엑스', 'start': 74, 'end': 79, 'type': 'COM'}","{'word': '마이크로소프트 엑스박스 및 엑스박스 360', 'start': 106, 'end': 128, 'type': 'COM'}",no_relation
1031,"다이렉트엑스는 마이크로소프트 윈도우, 세가, 드림캐스트, 마이크로소프트 엑스박스 및 엑스박스 360을 위한 비디오 게임 개발에 널리 쓰인다.","{'word': '다이렉트엑스', 'start': 74, 'end': 79, 'type': 'COM'}","{'word': '세가', 'start': 95, 'end': 96, 'type': 'COM'}",no_relation
1032,"다이렉트엑스는 마이크로소프트 윈도우, 세가, 드림캐스트, 마이크로소프트 엑스박스 및 엑스박스 360을 위한 비디오 게임 개발에 널리 쓰인다.","{'word': '다이렉트엑스', 'start': 74, 'end': 79, 'type': 'COM'}","{'word': '드림캐스트', 'start': 99, 'end': 103, 'type': 'COM'}",no_relation
1033,상위 버전으로 업데이트하고 싶을 경우 마이크로소프트의 공식 홈페이지를 통해 설치할 수 있다.,"{'word': '마이크로소프트', 'start': 411, 'end': 417, 'type': 'COM'}","{'word': '버전', 'start': 393, 'end': 394, 'type': 'COM'}",no_relation
1034,그래서 DirectX 조건에 맞더라도 드라이버가 윈도우 디스플레이 드라이버 모델을 지원하지 않으면 사용할 수 없다.,"{'word': 'DirectX', 'start': 628, 'end': 634, 'type': 'COM'}","{'word': '윈도우 디스플레이 드라이버 모델', 'start': 651, 'end': 667, 'type': 'COM'}",no_relation
1035,"마이크로소프트는 프로그래머들을 위한 조속한 솔루션이 필요했는데, 이 운영 체제가 출시되기 수개월 밖에 안 남았기 때문이다.","{'word': '마이크로소프트', 'start': 1239, 'end': 1245, 'type': 'COM'}","{'word': '운영 체제', 'start': 1277, 'end': 1281, 'type': 'COM'}",no_relation
1036,이 라이브러리들 가운데 대다수가 크로스플랫폼이거나 오픈 코드에 기반을 두고 있다.,"{'word': '크로스플랫폼', 'start': 1543, 'end': 1548, 'type': 'COM'}","{'word': '오픈 코드', 'start': 1553, 'end': 1557, 'type': 'COM'}",no_relation
1037,"Direct3D 9Ex, Direct3D 10은 윈도우 비스타 이상, Direct3D 11은 윈도우 비스타 SP2 또는 윈도우 7 이상, Direct3D 12는 윈도우 10에서만 사용할 수 있다.","{'word': 'Direct3D 9Ex', 'start': 442, 'end': 453, 'type': 'COM'}","{'word': 'Direct3D 10', 'start': 456, 'end': 466, 'type': 'COM'}",com:similar_tech
1038,"Direct3D 9Ex, Direct3D 10은 윈도우 비스타 이상, Direct3D 11은 윈도우 비스타 SP2 또는 윈도우 7 이상, Direct3D 12는 윈도우 10에서만 사용할 수 있다.","{'word': 'Direct3D 9Ex', 'start': 442, 'end': 453, 'type': 'COM'}","{'word': 'Direct3D 11', 'start': 481, 'end': 491, 'type': 'COM'}",com:similar_tech
1039,"Direct3D 9Ex, Direct3D 10은 윈도우 비스타 이상, Direct3D 11은 윈도우 비스타 SP2 또는 윈도우 7 이상, Direct3D 12는 윈도우 10에서만 사용할 수 있다.","{'word': 'Direct3D 9Ex', 'start': 442, 'end': 453, 'type': 'COM'}","{'word': 'Direct3D 12', 'start': 519, 'end': 529, 'type': 'COM'}",com:similar_tech
1040,"Direct3D 9Ex, Direct3D 10은 윈도우 비스타 이상, Direct3D 11은 윈도우 비스타 SP2 또는 윈도우 7 이상, Direct3D 12는 윈도우 10에서만 사용할 수 있다.","{'word': '윈도우 비스타', 'start': 469, 'end': 475, 'type': 'COM'}","{'word': '윈도우 비스타 SP2', 'start': 494, 'end': 504, 'type': 'COM'}",com:similar_tech
1041,"Direct3D 9Ex, Direct3D 10은 윈도우 비스타 이상, Direct3D 11은 윈도우 비스타 SP2 또는 윈도우 7 이상, Direct3D 12는 윈도우 10에서만 사용할 수 있다.","{'word': '윈도우 비스타', 'start': 469, 'end': 475, 'type': 'COM'}","{'word': '윈도우 7', 'start': 509, 'end': 513, 'type': 'COM'}",com:similar_tech
1042,"Direct3D 9Ex, Direct3D 10은 윈도우 비스타 이상, Direct3D 11은 윈도우 비스타 SP2 또는 윈도우 7 이상, Direct3D 12는 윈도우 10에서만 사용할 수 있다.","{'word': '윈도우 비스타', 'start': 469, 'end': 475, 'type': 'COM'}","{'word': '윈도우 10', 'start': 532, 'end': 537, 'type': 'COM'}",com:similar_tech
1043,"MS-DOS가 게임 프로그래밍을 위한 더 나은 플랫폼으로 비쳐졌는데, 그 이유는 윈도우 95용으로 개발된 게임이 거의 없어서 운영 체제가 큰 성공을 거두지 못할 것으로 생각되었기 때문이다.","{'word': 'MS-DOS', 'start': 979, 'end': 984, 'type': 'COM'}","{'word': '윈도우 95', 'start': 1024, 'end': 1029, 'type': 'COM'}",com:similar_tech
1044,DirectX 계열의 응용 프로그램 프로그래밍 인터페이스에 대한 대안으로 대부분의 기능이 있는 OpenGL이 있다.,"{'word': 'DirectX', 'start': 1419, 'end': 1425, 'type': 'COM'}","{'word': 'OpenGL', 'start': 1472, 'end': 1477, 'type': 'COM'}",com:similar_tech
1045,"이 밖에도 SDL, 알레그로, 오픈맥스, OpenAL, FMOD가 있다.","{'word': 'SDL', 'start': 1490, 'end': 1492, 'type': 'COM'}","{'word': '알레그로', 'start': 1495, 'end': 1498, 'type': 'COM'}",com:similar_tech
1046,"이 밖에도 SDL, 알레그로, 오픈맥스, OpenAL, FMOD가 있다.","{'word': 'SDL', 'start': 1490, 'end': 1492, 'type': 'COM'}","{'word': '오픈맥스', 'start': 1501, 'end': 1504, 'type': 'COM'}",com:similar_tech
1047,"이 밖에도 SDL, 알레그로, 오픈맥스, OpenAL, FMOD가 있다.","{'word': 'SDL', 'start': 1490, 'end': 1492, 'type': 'COM'}","{'word': 'OpenAL', 'start': 1507, 'end': 1512, 'type': 'COM'}",com:similar_tech
1048,"이 밖에도 SDL, 알레그로, 오픈맥스, OpenAL, FMOD가 있다.","{'word': 'SDL', 'start': 1490, 'end': 1492, 'type': 'COM'}","{'word': 'FMOD', 'start': 1515, 'end': 1518, 'type': 'COM'}",com:similar_tech
1049,"또, DirectX와 똑같은 API를 둔 다른 대안으로 와인을 들 수 있다.","{'word': 'DirectX', 'start': 1574, 'end': 1580, 'type': 'COM'}","{'word': '와인', 'start': 1602, 'end': 1603, 'type': 'COM'}",com:similar_tech
1050,"소프트웨어 개발()은 애플리케이션, 프레임워크, 기타 소프트웨어 구성 요소의 개발과 유지보수에 수반되는 구상, 디자인, 프로그래밍, 문서화, 테스트, 버그 수정의 과정이다.","{'word': '소프트웨어 개발', 'start': 0, 'end': 7, 'type': 'COM'}","{'word': '애플리케이션, 프레임워크, 기타 소프트웨어 구성 요소의 개발', 'start': 12, 'end': 44, 'type': 'COM'}",com:sub_concept
1051,"소프트웨어 개발()은 애플리케이션, 프레임워크, 기타 소프트웨어 구성 요소의 개발과 유지보수에 수반되는 구상, 디자인, 프로그래밍, 문서화, 테스트, 버그 수정의 과정이다.","{'word': '소프트웨어 개발', 'start': 0, 'end': 7, 'type': 'COM'}","{'word': '구상, 디자인, 프로그래밍, 문서화, 테스트, 버그 수정', 'start': 58, 'end': 88, 'type': 'COM'}",com:sub_concept
1052,소프트웨어 개발은 소스 코드의 작성과 유지보수를 수반하지만 더 넓은 의미에서 보면 일반적으로 계획되고 구조화된 과정 속에서 소프트웨어의 마지막 표명을 통해 원하는 소프트웨어의 개념으로부터 발생하는 모든 과정을 포괄한다.,"{'word': '소프트웨어 개발', 'start': 97, 'end': 104, 'type': 'COM'}","{'word': '소스 코드의 작성과 유지보수', 'start': 107, 'end': 121, 'type': 'COM'}",com:sub_concept
1053,"또, 소프트웨어 개발은 소프트웨어 제품이 탄생하는데 수반되는 연구, 신개발, 프로토타입, 수정, 재사용, 리엔지니어링, 유지보수 등의 기타 활동도 포함한다.","{'word': '소프트웨어 개발', 'start': 223, 'end': 230, 'type': 'COM'}","{'word': '연구, 신개발, 프로토타입, 수정, 재사용, 리엔지니어링, 유지보수', 'start': 254, 'end': 290, 'type': 'COM'}",com:sub_concept
1054,소프트웨어 개발에 다음과 같은 단계들을 공유한다:,"{'word': '소프트웨어 개발', 'start': 308, 'end': 315, 'type': 'COM'}","{'word': '단계', 'start': 325, 'end': 326, 'type': 'POH'}",no_relation
1055,프로토타입 기반 언어의 가장 원조격인 프로그래밍 언어인 셀프는 데이비드 엉거와 랜덜 스미스가 개발했다.,"{'word': '데이비드 엉거', 'start': 273, 'end': 279, 'type': 'PER'}","{'word': '랜덜 스미스', 'start': 282, 'end': 287, 'type': 'PER'}",per:colleagues
1056,"프로토타입 기반 프로그래밍은 객체지향 프로그래밍의 한 형태의 갈래로 클래스가 없고, 클래스 기반 언어에서 상속을 사용하는 것과는 다르게, 객체를 원형(프로토타입)으로 하여 복제의 과정을 통하여 객체의 동작 방식을 다시 사용할 수 있다.","{'word': '객체지향 프로그래밍', 'start': 16, 'end': 25, 'type': 'COM'}","{'word': '프로토타입 기반 프로그래밍', 'start': 0, 'end': 13, 'type': 'COM'}",com:sub_concept
1057,"클래스기반 언어에서 '클래스'는 동작 방식인 메소드의 모임으로 동작하고, 모든 인스턴스의 구조는 동일하고, 인스턴스는 객체의 자료를 가지고 있다.","{'word': '클래스기반 언어', 'start': 533, 'end': 540, 'type': 'COM'}","{'word': '클래스', 'start': 545, 'end': 547, 'type': 'COM'}",com:sub_concept
1058,"클래스기반 언어에서 '클래스'는 동작 방식인 메소드의 모임으로 동작하고, 모든 인스턴스의 구조는 동일하고, 인스턴스는 객체의 자료를 가지고 있다.","{'word': '클래스기반 언어', 'start': 533, 'end': 540, 'type': 'COM'}","{'word': '인스턴스', 'start': 593, 'end': 596, 'type': 'COM'}",com:sub_concept
1059,"클래스기반 언어에서, 클래스의 생성자를 통하거나 필요하다면 생성자와 생성자의 매개변수를 통하여 인스턴스를 새로 만든다.","{'word': '클래스기반 언어', 'start': 1148, 'end': 1155, 'type': 'COM'}","{'word': '인스턴스', 'start': 1201, 'end': 1204, 'type': 'COM'}",com:sub_concept
1060,"클래스기반 언어에서, 클래스의 생성자를 통하거나 필요하다면 생성자와 생성자의 매개변수를 통하여 인스턴스를 새로 만든다. 결과로 만들어진 인스턴스는 선택된 클래스의 설계와 행동을 따르게 된다.","{'word': '클래스기반 언어', 'start': 1148, 'end': 1155, 'type': 'COM'}","{'word': '인스턴스', 'start': 1224, 'end': 1227, 'type': 'COM'}",com:sub_concept
1061,'복제'는 원래 있던 객체의 프로토타입의 행동을 복제하여 새 객체를 생성하는 과정을 거친다.,"{'word': '객체', 'start': 1822, 'end': 1823, 'type': 'COM'}","{'word': '프로토타입', 'start': 1826, 'end': 1830, 'type': 'COM'}",com:sub_concept
1062,이런 이유로 대부분의 프로토타입기반 언어들은 자료와 메서드 두가지 모두 슬롯으로 관리한다.,"{'word': '프로토타입기반 언어', 'start': 2527, 'end': 2536, 'type': 'COM'}","{'word': '자료', 'start': 2540, 'end': 2541, 'type': 'COM'}",com:sub_concept
1063,이런 이유로 대부분의 프로토타입기반 언어들은 자료와 메서드 두가지 모두 슬롯으로 관리한다.,"{'word': '프로토타입기반 언어', 'start': 2527, 'end': 2536, 'type': 'COM'}","{'word': '메서드', 'start': 2544, 'end': 2546, 'type': 'COM'}",com:sub_concept
1064,"프로토타입 객체는 정확히 복사되지만, 다른 이름이나 참조값을 갖는다.","{'word': '프로토타입 객체', 'start': 2640, 'end': 2647, 'type': 'COM'}","{'word': '참조값', 'start': 2669, 'end': 2671, 'type': 'COM'}",com:sub_concept
1065,이렇게 접근하면 객체 작성자가 한 부모 객체의 자식 객체들간에 부수효과를 신경쓰지 않고 복제할 수 있다는 이점이 있다.,"{'word': '부모 객체', 'start': 2750, 'end': 2754, 'type': 'COM'}","{'word': '자식 객체', 'start': 2757, 'end': 2761, 'type': 'COM'}",com:sub_concept
1066,"프로토타입기반 시스템을 비판하고 클래스기반 객체 모델을 지지하는 사람들은 프로그래밍 언어의 정적 타입 시스템을 지지하는 사람들이 동적 타입 시스템에 대하여 우려하는 것과 비슷한 점을 우려하고 있다(자료형 참조). 특히, 프로그램의 정확성, 안전성, 예측성, 효율을 떨어뜨린다고 우려한다.","{'word': '프로그래밍 언어', 'start': 3326, 'end': 3333, 'type': 'COM'}","{'word': '정적 타입 시스템', 'start': 3336, 'end': 3344, 'type': 'COM'}",com:sub_concept
1067,"프로토타입기반 시스템을 비판하고 클래스기반 객체 모델을 지지하는 사람들은 프로그래밍 언어의 정적 타입 시스템을 지지하는 사람들이 동적 타입 시스템에 대하여 우려하는 것과 비슷한 점을 우려하고 있다(자료형 참조). 특히, 프로그램의 정확성, 안전성, 예측성, 효율을 떨어뜨린다고 우려한다.","{'word': '프로그램', 'start': 3408, 'end': 3411, 'type': 'COM'}","{'word': '정확성', 'start': 3414, 'end': 3416, 'type': 'COM'}",com:sub_concept
1068,"프로토타입기반 시스템을 비판하고 클래스기반 객체 모델을 지지하는 사람들은 프로그래밍 언어의 정적 타입 시스템을 지지하는 사람들이 동적 타입 시스템에 대하여 우려하는 것과 비슷한 점을 우려하고 있다(자료형 참조). 특히, 프로그램의 정확성, 안전성, 예측성, 효율을 떨어뜨린다고 우려한다.","{'word': '프로그램', 'start': 3408, 'end': 3411, 'type': 'COM'}","{'word': '안전성', 'start': 3419, 'end': 3421, 'type': 'COM'}",com:sub_concept
1069,"프로토타입기반 시스템을 비판하고 클래스기반 객체 모델을 지지하는 사람들은 프로그래밍 언어의 정적 타입 시스템을 지지하는 사람들이 동적 타입 시스템에 대하여 우려하는 것과 비슷한 점을 우려하고 있다(자료형 참조). 특히, 프로그램의 정확성, 안전성, 예측성, 효율을 떨어뜨린다고 우려한다.","{'word': '프로그램', 'start': 3408, 'end': 3411, 'type': 'COM'}","{'word': '예측성', 'start': 3424, 'end': 3426, 'type': 'COM'}",com:sub_concept
1070,"프로토타입기반 시스템을 비판하고 클래스기반 객체 모델을 지지하는 사람들은 프로그래밍 언어의 정적 타입 시스템을 지지하는 사람들이 동적 타입 시스템에 대하여 우려하는 것과 비슷한 점을 우려하고 있다(자료형 참조). 특히, 프로그램의 정확성, 안전성, 예측성, 효율을 떨어뜨린다고 우려한다.","{'word': '프로그램', 'start': 3408, 'end': 3411, 'type': 'COM'}","{'word': '효율', 'start': 3429, 'end': 3430, 'type': 'COM'}",com:sub_concept
1071,"정확성, 안전성, 예측성의 관점에서 보면, 클래스는 타입과 비슷하며, 실제로 대부분의 정적 타입 객체지향 언어에서 클래스는 타입의 역할을 한다.","{'word': '정적 타입 객체지향 언어', 'start': 3494, 'end': 3506, 'type': 'COM'}","{'word': '클래스', 'start': 3510, 'end': 3512, 'type': 'COM'}",com:sub_concept
1072,그리고 클래스의 인스턴스는 주어진 방식대로 동작하리라는 확실한 보장이 된다.,"{'word': '클래스', 'start': 3531, 'end': 3533, 'type': 'COM'}","{'word': '인스턴스', 'start': 3536, 'end': 3539, 'type': 'COM'}",com:sub_concept
1073,"프로토타입기반 프로그래밍은 클래스리스(""class-less""), 프로토타입 지향(prototype-oriented) 혹은 인스턴스 기반(instance-based) 프로그래밍이라고도 한다.","{'word': '프로토타입기반', 'start': 132, 'end': 138, 'type': 'COM'}","{'word': '클래스리스', 'start': 147, 'end': 151, 'type': 'COM'}",com:alter_names
1074,"프로토타입기반 프로그래밍은 클래스리스(""class-less""), 프로토타입 지향(prototype-oriented) 혹은 인스턴스 기반(instance-based) 프로그래밍이라고도 한다.","{'word': '프로토타입기반', 'start': 132, 'end': 138, 'type': 'COM'}","{'word': '프로토타입 지향', 'start': 168, 'end': 175, 'type': 'COM'}",com:alter_names
1075,"프로토타입기반 프로그래밍은 클래스리스(""class-less""), 프로토타입 지향(prototype-oriented) 혹은 인스턴스 기반(instance-based) 프로그래밍이라고도 한다.","{'word': '프로토타입기반', 'start': 132, 'end': 138, 'type': 'COM'}","{'word': '인스턴스 기반', 'start': 200, 'end': 206, 'type': 'COM'}",com:alter_names
1076,"프로토타입기반 프로그래밍은 클래스리스(""class-less""), 프로토타입 지향(prototype-oriented) 혹은 인스턴스 기반(instance-based) 프로그래밍이라고도 한다.","{'word': '클래스리스', 'start': 147, 'end': 151, 'type': 'COM'}","{'word': 'class-less', 'start': 154, 'end': 163, 'type': 'COM'}",com:alter_names
1077,"프로토타입기반 프로그래밍은 클래스리스(""class-less""), 프로토타입 지향(prototype-oriented) 혹은 인스턴스 기반(instance-based) 프로그래밍이라고도 한다.","{'word': '프로토타입 지향', 'start': 168, 'end': 175, 'type': 'COM'}","{'word': 'prototype-oriented', 'start': 177, 'end': 194, 'type': 'COM'}",com:alter_names
1078,"프로토타입기반 프로그래밍은 클래스리스(""class-less""), 프로토타입 지향(prototype-oriented) 혹은 인스턴스 기반(instance-based) 프로그래밍이라고도 한다.","{'word': '인스턴스 기반', 'start': 200, 'end': 206, 'type': 'COM'}","{'word': 'instance-based', 'start': 208, 'end': 221, 'type': 'COM'}",com:alter_names
1079,순수 프로토타입은 '연쇄적' 프로토타입이라고도 하는데 케보가 그 예이다.,"{'word': '순수 프로토타입', 'start': 2566, 'end': 2573, 'type': 'COM'}","{'word': ""'연쇄적' 프로토타입"", 'start': 2576, 'end': 2586, 'type': 'COM'}",com:alter_names
1080,"그러나 케보는 위임 방식에서 주로 쓰는 분류상의 원형을 사용하지 않고, 추가적인 기본형을 제공하여 '가족 닮음'(family reseemblances)라고 하는 유사한 객체들을 모아서 변화를 적용한다.","{'word': '가족 닮음', 'start': 3068, 'end': 3072, 'type': 'COM'}","{'word': 'family reseemblances', 'start': 3075, 'end': 3094, 'type': 'COM'}",com:alter_names
1081,테스트는 C 버전에서 복사한 리삭으로 작성된 MPEG-2 코덱으로 하였다.,"{'word': 'MPEG-2 코덱', 'start': 3799, 'end': 3807, 'type': 'COM'}","{'word': '리삭', 'start': 3790, 'end': 3791, 'type': 'COM'}",com:made_of
1082,"프로토타입 기반 프로그래밍은, 학습의 과정의 주요한 특징으로 프로토타입이나 이그젬플러를 강조하는, 인지 심리학과 같은 특정 학문과 관련되어 있는 경우가 많다.","{'word': '프로토타입 기반 프로그래밍', 'start': 960, 'end': 973, 'type': 'COM'}","{'word': '인지 심리학', 'start': 1015, 'end': 1020, 'type': 'POH'}",no_relation
1083,"하나는 원래 있던 객체를 '복제(cloning)'하는 방법이고, 다른 하나는 '무(無)에서(""ex nihilo"")' 객체를 생성하는 방법이다.","{'word': '객체', 'start': 1302, 'end': 1303, 'type': 'COM'}","{'word': '복제', 'start': 1307, 'end': 1308, 'type': 'POH'}",no_relation
1084,"클래스리스 프로그래밍은 최근에 와서 많이 유명해졌는데, 자바스크립트와 모픽 프레임워크를 사용하는 스퀵에 적용되었고, 그 외에 세실, 뉴튼스크립트, 아이오, 무, 리볼, 케보 등에 적용되었다.(#프로토타입 기반 언어 목록 참고.)","{'word': '자바스크립트', 'start': 327, 'end': 332, 'type': 'COM'}","{'word': '모픽 프레임워크', 'start': 335, 'end': 342, 'type': 'COM'}",no_relation
1085,"클래스기반 언어에서 객체는 일반적으로 두 가지 형태가 있다. '클래스'는 객체의 기본적인 만듦새와 기능을 정의하고, '인스턴스'는 ""사용할 수 있는"" 객체로 특정 클래스의 양식을 기반으로 한다.","{'word': '클래스', 'start': 459, 'end': 461, 'type': 'COM'}","{'word': '인스턴스', 'start': 490, 'end': 493, 'type': 'COM'}",no_relation
1086,프로토타입기반 프로그래밍을 지지하는 사람들은 클래스기반 언어에서는 개발자가 클래스들 사이의 분류와 관계에 먼저 초점을 맞추기 쉽다고 한다.,"{'word': '프로토타입기반 프로그래밍', 'start': 649, 'end': 661, 'type': 'COM'}","{'word': '클래스기반 언어', 'start': 674, 'end': 681, 'type': 'COM'}",no_relation
1087,"이와는 달리, 프로토타입기반 프로그래밍은 프로그래머가 여러 가지 표본의 동작 방식에 초점을 맞추고, 이 객체들을 나중에 클래스와 비슷한 방식의 ""객체의 원형""으로 분류하는 것은 나중에 걱정해도 된다.","{'word': '프로토타입기반 프로그래밍', 'start': 735, 'end': 747, 'type': 'COM'}","{'word': '프로그래머', 'start': 750, 'end': 754, 'type': 'COM'}",no_relation
1088,"많은 프로토타입기반 체계가 실행시간에 프로토타입을 대체하기 쉬우나, 클래스기반 객체지향 체계에서는 최초의 동적 객체지향 체계인 스몰토크와 같이 프로그램의 실행 중에 클래스를 바꿀 수 있는 것은 몇 가지 되지 않는다.","{'word': '프로토타입기반 체계', 'start': 842, 'end': 851, 'type': 'COM'}","{'word': '클래스기반 객체지향 체계', 'start': 877, 'end': 889, 'type': 'COM'}",no_relation
1089,"많은 프로토타입기반 체계가 실행시간에 프로토타입을 대체하기 쉬우나, 클래스기반 객체지향 체계에서는 최초의 동적 객체지향 체계인 스몰토크와 같이 프로그램의 실행 중에 클래스를 바꿀 수 있는 것은 몇 가지 되지 않는다.","{'word': '프로토타입기반 체계', 'start': 842, 'end': 851, 'type': 'COM'}","{'word': '동적 객체지향 체계', 'start': 898, 'end': 907, 'type': 'COM'}",no_relation
1090,프로토타입 기반 체계의 대부분은 인터프리터이고 동적 타입 프로그래밍 언어이다. 하지만 프로토타입기반의 정적 타입의 체계가 기술적으로 가능하다.,"{'word': '프로토타입 기반 체계', 'start': 1049, 'end': 1059, 'type': 'COM'}","{'word': '동적 타입 프로그래밍 언어', 'start': 1075, 'end': 1088, 'type': 'COM'}",no_relation
1091,"""무에서"" 객체를 생성할 수 있는 체계는 이미 있던 프로토타입을 복제하지 않고 아무것도 없는 상태에서 새로운 객체를 생성할 수 있게 해 준다.","{'word': '프로토타입', 'start': 1452, 'end': 1456, 'type': 'COM'}","{'word': '객체', 'start': 1484, 'end': 1485, 'type': 'COM'}",no_relation
1092,"많은 프로토타입기반 언어에서 기본 객체 프로토타입인 ""codice_1"" 프로토타입이 있는데, 여기에 공통적으로 필요한 메서드가 들어있고, 모든 객체의 마스터 프로토타입으로 사용된다. ""무에서"" 객체를 창조하는 방식의 유용한 한 가지는 새 객체의 슬롯 이름이 최상위의 ""codice_1"" 객체와 네임스페이스 충돌이 일어나지 않는다는 것이다.","{'word': '프로토타입기반 언어', 'start': 1556, 'end': 1565, 'type': 'COM'}","{'word': '메서드', 'start': 1619, 'end': 1621, 'type': 'COM'}",no_relation
1093,"모질라 자바스크립트는 객체의 ""codice_3"" 프로퍼티를 codice_4로 지정하면 이것이 가능하도록 구현되어 있다.","{'word': '모질라 자바스크립트', 'start': 1743, 'end': 1752, 'type': 'COM'}","{'word': '객체', 'start': 1755, 'end': 1756, 'type': 'COM'}",no_relation
1094,어떤 체계에서 복제된 자식 객체는 명시적으로 프로토타입과 '위임'(delegation)이나 '닮음'(resemblance)으로 연관되어 있다.,"{'word': '자식 객체', 'start': 1919, 'end': 1923, 'type': 'COM'}","{'word': '프로토타입', 'start': 1932, 'end': 1936, 'type': 'COM'}",no_relation
1095,그래서 프로토타입을 변경하면 복제품에 영향을 끼친다.,"{'word': '프로토타입', 'start': 1991, 'end': 1995, 'type': 'COM'}","{'word': '복제품', 'start': 2003, 'end': 2005, 'type': 'COM'}",no_relation
1096,"포스와 케보 같은 다른 체계에서는 프로토타입을 번식시키는 이런 방식을 따르지 않고, 대신에 프로토타입을 수정하더라도 복제품에는 영향을 끼치지 않는 ""연쇄된"" 형태를 사용하여 원본 객체를 수정하더라도 그 자손으로 자동 번식되지 않는다.","{'word': '포스와 케보', 'start': 2017, 'end': 2022, 'type': 'COM'}","{'word': '프로토타입', 'start': 2036, 'end': 2040, 'type': 'COM'}",no_relation
1097,"실행시간에 '위임'하는 프로토타입기반의 언어들은 올바른 메서드로 동적 디스패치를 할 수 있거나, 맞는 자료 조각에 이를 때까지 객체에서 프로토타입으로 간단히 위임 포인터를 연속적으로 따라가서 찾을 수 있다.","{'word': '프로토타입기반의 언어', 'start': 2161, 'end': 2171, 'type': 'COM'}","{'word': '위임 포인터', 'start': 2236, 'end': 2241, 'type': 'COM'}",no_relation
1098,객체들 사이에서 동작을 공유하는 것을 확립하기 위해 필요한 것들은 위임 포인터뿐이다.,"{'word': '객체', 'start': 2264, 'end': 2265, 'type': 'COM'}","{'word': '위임 포인터', 'start': 2301, 'end': 2306, 'type': 'COM'}",no_relation
1099,클래스기반 객체지향 언어에서 클래스와 인스턴스의 관계와 달리 프로토타입과 파생된 객체는 이 연결을 통하여 프로토타입과 자식 객체가 메모리나 구조적인 유사성을 가질 필요가 없다.,"{'word': '클래스', 'start': 2328, 'end': 2330, 'type': 'COM'}","{'word': '인스턴스', 'start': 2333, 'end': 2336, 'type': 'COM'}",no_relation
1100,"마찬가지로, 자식 객체는 클래스 기반의 연관된 클래스의 구조를 재배치하지 않고 계속해서 수정할 수 있다.","{'word': '자식 객체', 'start': 2418, 'end': 2422, 'type': 'COM'}","{'word': '클래스의 구조', 'start': 2437, 'end': 2443, 'type': 'COM'}",no_relation
1101,"또 중요한 점은, 자료뿐만 아니라 메서드도 추가되거나 변경될 수 있다는 것이다.","{'word': '자료', 'start': 2480, 'end': 2481, 'type': 'COM'}","{'word': '메서드', 'start': 2489, 'end': 2491, 'type': 'COM'}",no_relation
1102,원본 프로토타입에서 복제된 객체로 포인터는 보이지 않는다.,"{'word': '원본 프로토타입', 'start': 2607, 'end': 2614, 'type': 'COM'}","{'word': '포인터', 'start': 2626, 'end': 2628, 'type': 'COM'}",no_relation
1103,메서드와 속성은 대응되는 것으로 중복된다.,"{'word': '메서드', 'start': 2707, 'end': 2709, 'type': 'COM'}","{'word': '속성', 'start': 2712, 'end': 2713, 'type': 'COM'}",no_relation
1104,"또 다른 이점은, 디스패치 중 메서드 미리보기의 계산 비용이 위임에 비해서 급격히 줄어든다는 것이다.","{'word': '디스패치', 'start': 2808, 'end': 2811, 'type': 'COM'}","{'word': '메서드 미리보기', 'start': 2815, 'end': 2822, 'type': 'COM'}",no_relation
1105,위임을 하면 적합한 메서드나 슬롯을 찾는 것을 실패한다면 전체 위임 사슬에서 찾아봐야 하기 때문이다.,"{'word': '메서드', 'start': 2866, 'end': 2868, 'type': 'COM'}","{'word': '슬롯', 'start': 2871, 'end': 2872, 'type': 'COM'}",no_relation
1106,연쇄 접근 방식의 단점은 시스템을 통해 바뀌는 것을 번식시키는 데에 조직적으로 어렵다는 것이다.,"{'word': '연쇄 접근 방식', 'start': 2912, 'end': 2919, 'type': 'COM'}","{'word': '시스템', 'start': 2926, 'end': 2928, 'type': 'COM'}",no_relation
1107,프로토타입에 변화가 생기면 이것은 복제품에 즉시 혹은 자동적으로 적용되지 않는다.,"{'word': '프로토타입', 'start': 2966, 'end': 2970, 'type': 'COM'}","{'word': '복제품', 'start': 2985, 'end': 2987, 'type': 'COM'}",no_relation
1108,다른 단점은 이 형태를 세련되게 구현하지 못하면 원형과 복제품이 같은 부분에서 복제품들이 위임 형태에 비해서 메모리가 더 많이 낭비된다는 것이다.,"{'word': '원형', 'start': 3152, 'end': 3153, 'type': 'COM'}","{'word': '복제품', 'start': 3156, 'end': 3158, 'type': 'COM'}",no_relation
1109,그러나 케보에서 실제로 하고 있는 접근 방식처럼 공유하도록 구현하고 자료는 배후에 두는 방식으로 프로그래밍에 대한 연쇄적 행동이 가능하다.,"{'word': '케보', 'start': 3211, 'end': 3212, 'type': 'COM'}","{'word': '프로그래밍', 'start': 3261, 'end': 3265, 'type': 'COM'}",no_relation
1110,"프로토타입기반 시스템을 비판하고 클래스기반 객체 모델을 지지하는 사람들은 프로그래밍 언어의 정적 타입 시스템을 지지하는 사람들이 동적 타입 시스템에 대하여 우려하는 것과 비슷한 점을 우려하고 있다(자료형 참조). 특히, 프로그램의 정확성, 안전성, 예측성, 효율을 떨어뜨린다고 우려한다.","{'word': '프로토타입기반 시스템', 'start': 3285, 'end': 3295, 'type': 'COM'}","{'word': '클래스기반 객체 모델', 'start': 3303, 'end': 3313, 'type': 'COM'}",no_relation
1111,"프로토타입기반 시스템을 비판하고 클래스기반 객체 모델을 지지하는 사람들은 프로그래밍 언어의 정적 타입 시스템을 지지하는 사람들이 동적 타입 시스템에 대하여 우려하는 것과 비슷한 점을 우려하고 있다(자료형 참조). 특히, 프로그램의 정확성, 안전성, 예측성, 효율을 떨어뜨린다고 우려한다.","{'word': '정적 타입 시스템', 'start': 3336, 'end': 3344, 'type': 'COM'}","{'word': '동적 타입 시스템', 'start': 3357, 'end': 3365, 'type': 'COM'}",no_relation
1112,"효율성의 관점에서 보면, 클래스를 선언하면 대부분의 컴파일러는 더 효율적인 메서드와 인스턴스 변수 미리보기가 가능하여 최적화하기 쉽게 된다.","{'word': '클래스', 'start': 3584, 'end': 3586, 'type': 'COM'}","{'word': '컴파일러', 'start': 3599, 'end': 3602, 'type': 'COM'}",no_relation
1113,"효율성의 관점에서 보면, 클래스를 선언하면 대부분의 컴파일러는 더 효율적인 메서드와 인스턴스 변수 미리보기가 가능하여 최적화하기 쉽게 된다.","{'word': '클래스', 'start': 3584, 'end': 3586, 'type': 'COM'}","{'word': '메서드', 'start': 3612, 'end': 3614, 'type': 'COM'}",no_relation
1114,"효율성의 관점에서 보면, 클래스를 선언하면 대부분의 컴파일러는 더 효율적인 메서드와 인스턴스 변수 미리보기가 가능하여 최적화하기 쉽게 된다.","{'word': '클래스', 'start': 3584, 'end': 3586, 'type': 'COM'}","{'word': '인스턴스 변수', 'start': 3617, 'end': 3623, 'type': 'COM'}",no_relation
1115,"셀프 (프로그래밍 언어)에서 보면, 클래스기반에 비해서 프로토타입 기반 체계는 수행 속도를 빠르게 하는 컴파일과 인터프리트 기술을 개발하는 데 많은 시간이 걸린다.","{'word': '클래스기반', 'start': 3669, 'end': 3673, 'type': 'COM'}","{'word': '프로토타입 기반 체계', 'start': 3680, 'end': 3690, 'type': 'COM'}",no_relation
1116,"셀프 (프로그래밍 언어)에서 보면, 클래스기반에 비해서 프로토타입 기반 체계는 수행 속도를 빠르게 하는 컴파일과 인터프리트 기술을 개발하는 데 많은 시간이 걸린다.","{'word': '컴파일', 'start': 3707, 'end': 3709, 'type': 'COM'}","{'word': '인터프리트 기술', 'start': 3712, 'end': 3719, 'type': 'COM'}",no_relation
1117,예를 들어 리삭 컴파일러는 C만큼이나 빨리 코드를 만든다.,"{'word': '리삭 컴파일러', 'start': 3747, 'end': 3753, 'type': 'COM'}","{'word': 'C', 'start': 3756, 'end': 3756, 'type': 'COM'}",no_relation
1118,이 테스트 결과로 리삭 버전이 C 버전보다 1.9% 속도가 느리지만 37%만큼 줄 수가 적었다.,"{'word': '리삭 버전', 'start': 3826, 'end': 3830, 'type': 'COM'}","{'word': 'C 버전', 'start': 3833, 'end': 3836, 'type': 'COM'}",no_relation
1119,"마지막으로, 비록 자바스크립트와 같은 언어들이 유명세를 떨치고, 시장에 침투하고 있지만 프로토타입기반 언어가 소프트웨어 개발자들 사이에서 익숙하지 않아서 때문에 많은 비판을 받는다.","{'word': '자바스크립트', 'start': 3880, 'end': 3885, 'type': 'COM'}","{'word': '프로토타입기반 언어', 'start': 3919, 'end': 3928, 'type': 'COM'}",no_relation
1120,그래서 ECMA스크립트 표준의 4번째판이 자바스크립트를 클래스기반 언어로 만들려고 하고 있다.,"{'word': 'ECMA스크립트 표준', 'start': 3976, 'end': 3986, 'type': 'COM'}","{'word': '자바스크립트', 'start': 3995, 'end': 4000, 'type': 'COM'}",no_relation
1121,"게다가 프로토타입기반 체계가 상대적으로 기발하고 별로 사용되지 않고 있으며, 소프트웨어를 개발할 때 널리 퍼지지 못하여 최고관행과 멀기 때문이다.","{'word': '프로토타입기반 체계', 'start': 4029, 'end': 4038, 'type': 'COM'}","{'word': '소프트웨어', 'start': 4068, 'end': 4072, 'type': 'COM'}",no_relation
1122,비구조적 프로그래밍은 하나의 연속된 덩어리에 모든 코드를 넣는 프로그래밍 패러다임이다.,"{'word': '프로그래밍 패러다임', 'start': 35, 'end': 44, 'type': 'COM'}","{'word': '비구조적 프로그래밍', 'start': 0, 'end': 9, 'type': 'COM'}",com:sub_concept
1123,비구조적 프로그래밍 언어는 코드의 특정부분으로 건너뛰는 GOTO문과 같은 흐름 제어문에 의존할 수밖에 없다.,"{'word': '비구조적 프로그래밍 언어', 'start': 138, 'end': 150, 'type': 'COM'}","{'word': 'GOTO문', 'start': 169, 'end': 173, 'type': 'COM'}",com:sub_concept
1124,그러나 프로그램 구조는 항상 조건문과 GOTO문을 조합하여 구현할 수 있기 때문에 구조가 모든 언어에서 필요한 것은 아니다.,"{'word': '프로그램 구조', 'start': 273, 'end': 279, 'type': 'COM'}","{'word': '조건문', 'start': 285, 'end': 287, 'type': 'COM'}",com:sub_concept
1125,그러나 프로그램 구조는 항상 조건문과 GOTO문을 조합하여 구현할 수 있기 때문에 구조가 모든 언어에서 필요한 것은 아니다.,"{'word': '프로그램 구조', 'start': 273, 'end': 279, 'type': 'COM'}","{'word': 'GOTO문', 'start': 290, 'end': 294, 'type': 'COM'}",com:sub_concept
1126,"어셈블리어는 대체로 비구조적 언어인데, 기본이 되는 기계어 코드가 구조적이지 않기 때문이다.","{'word': '비구조적 언어', 'start': 497, 'end': 503, 'type': 'COM'}","{'word': '어셈블리어', 'start': 486, 'end': 490, 'type': 'COM'}",com:sub_concept
1127,"구조화되지 않은 원시 코드는 읽고 디버그하기가 매우 어렵고, 구조적인 작성을 지원하는 프로그래밍 언어에서는 추천하지 않는다.","{'word': '원시 코드', 'start': 208, 'end': 212, 'type': 'COM'}","{'word': '프로그래밍 언어', 'start': 247, 'end': 254, 'type': 'COM'}",no_relation
1128,"GOTO문을 쓰는 것에 수행 속도상의 이점은 없다. (실제로, 컴파일러가 최적화 할 수 있는 것들을 혼란시켜 오히려 불이익이 될 수도 있다.)","{'word': 'GOTO문', 'start': 406, 'end': 410, 'type': 'COM'}","{'word': '컴파일러', 'start': 441, 'end': 444, 'type': 'COM'}",no_relation
1129,어셈블리 언어에 있는 유일한 구조는 함수의 시작과 끝 같이 컴파일 도구에서 쓰는 것들이다.,"{'word': '어셈블리 언어', 'start': 538, 'end': 544, 'type': 'COM'}","{'word': '컴파일 도구', 'start': 571, 'end': 576, 'type': 'COM'}",no_relation
1130,"비구조적 프로그래밍은 하나의 연속된 덩어리에 모든 코드를 넣는 프로그래밍 패러다임이다. 대비되는 개념으로는 구조적 프로그래밍이 있는데, 이는 프로그램의 작업이 (함수나 서브루틴으로 알려진) 더 작은 부분으로 나누어 필요할 때마다 호출하는 것이다.","{'word': '비구조적 프로그래밍', 'start': 0, 'end': 9, 'type': 'COM'}","{'word': '구조적 프로그래밍', 'start': 60, 'end': 68, 'type': 'COM'}",com:similar_tech
1131,MS-DOS의 배치 파일과 같은 많은 스크립트 언어나 베이직이나 포트란 같이 오래된 언어에서는 여전히 사용되기도 한다.,"{'word': '베이직', 'start': 369, 'end': 371, 'type': 'COM'}","{'word': '포트란', 'start': 375, 'end': 377, 'type': 'COM'}",com:similar_tech
1132,2002년 2월 마이크로소프트는 3년 8개월간의 침묵을 깨고 비주얼 스튜디오 닷넷의 베타를 내놓았다.,"{'word': '마이크로소프트', 'start': 1458, 'end': 1464, 'type': 'ORG'}","{'word': '비주얼 스튜디오 닷넷의 베타', 'start': 1483, 'end': 1497, 'type': 'COM'}",org:production
1133,1997년 2월에 출시된 마이크로소프트의 첫 비주얼 스튜디오이다.,"{'word': '마이크로소프트의 첫 비주얼 스튜디오', 'start': 356, 'end': 374, 'type': 'COM'}","{'word': '1997년 2월', 'start': 342, 'end': 349, 'type': 'DAT'}",com:date_of_prod
1134,다음 버전 6.0은 1998년 6월에 출시되었다.,"{'word': '다음 버전 6.0', 'start': 528, 'end': 536, 'type': 'COM'}","{'word': '1998년 6월', 'start': 539, 'end': 546, 'type': 'DAT'}",com:date_of_prod
1135,2002년 2월 마이크로소프트는 3년 8개월간의 침묵을 깨고 비주얼 스튜디오 닷넷의 베타를 내놓았다.,"{'word': '비주얼 스튜디오 닷넷의 베타', 'start': 1483, 'end': 1497, 'type': 'COM'}","{'word': '2002년 2월', 'start': 1449, 'end': 1456, 'type': 'DAT'}",com:date_of_prod
1136,2003년 4월 출시된 비주얼 스튜디오 닷넷 2003은 마이너 업그레이드이다.,"{'word': '비주얼 스튜디오 닷넷 2003', 'start': 2111, 'end': 2126, 'type': 'COM'}","{'word': '2003년 4월', 'start': 2098, 'end': 2105, 'type': 'DAT'}",com:date_of_prod
1137,2006년 9월 13일에 서비스 팩 1이 발표되었다.,"{'word': '서비스 팩 1', 'start': 2454, 'end': 2460, 'type': 'COM'}","{'word': '2006년 9월 13일', 'start': 2440, 'end': 2451, 'type': 'DAT'}",com:date_of_prod
1138,"2005년 11월 17일 비주얼 스튜디오 2005가 출시되었으며, 이 버전부터 닷넷이라는 꼬리표를 뗐지만 업그레이드된 닷넷 프레임워크를 사용한다.","{'word': '비주얼 스튜디오 2005', 'start': 2484, 'end': 2496, 'type': 'COM'}","{'word': '2005년 11월 17일', 'start': 2470, 'end': 2482, 'type': 'DAT'}",com:date_of_prod
1139,비주얼 스튜디오 2012는 2012년 8월 2일 출시되었다.,"{'word': '비주얼 스튜디오 2012', 'start': 4159, 'end': 4171, 'type': 'COM'}","{'word': '2012년 8월 2일', 'start': 4174, 'end': 4184, 'type': 'DAT'}",com:date_of_prod
1140,비주얼 스튜디오 2013 RC는 2013년 9월 9일 MSDN을 통해 개발자들에게 제공되었다.,"{'word': '비주얼 스튜디오 2013 RC', 'start': 4316, 'end': 4331, 'type': 'COM'}","{'word': '2013년 9월 9일', 'start': 4334, 'end': 4344, 'type': 'DAT'}",com:date_of_prod
1141,비주얼 스튜디오 2013 업데이트 1 (2013.1)이 2014년 1월 20일 공개되었다.,"{'word': '비주얼 스튜디오 2013 업데이트 1', 'start': 4369, 'end': 4388, 'type': 'COM'}","{'word': '2014년 1월 20일', 'start': 4400, 'end': 4411, 'type': 'DAT'}",com:date_of_prod
1142,"2017년 3월 7일, 비주얼 스튜디오 2017이 최종 이름으로 공식 발표되었다.","{'word': '비주얼 스튜디오 2017', 'start': 4767, 'end': 4779, 'type': 'COM'}","{'word': '2017년 3월 7일', 'start': 4754, 'end': 4764, 'type': 'DAT'}",com:date_of_prod
1143,"이후 2019년 2월 27일 RC 버전이 공개되었고, 2019년 4월 2일 정식 버전이 출시되었다.","{'word': 'RC 버전', 'start': 4880, 'end': 4884, 'type': 'COM'}","{'word': '2019년 2월 27일', 'start': 4867, 'end': 4878, 'type': 'DAT'}",com:date_of_prod
1144,"이후 2019년 2월 27일 RC 버전이 공개되었고, 2019년 4월 2일 정식 버전이 출시되었다.","{'word': '정식 버전', 'start': 4906, 'end': 4910, 'type': 'COM'}","{'word': '2019년 4월 2일', 'start': 4894, 'end': 4904, 'type': 'DAT'}",com:date_of_prod
1145,모든 구성 요소는 버전 6.0을 달고 나왔다.,"{'word': '버전 6.0', 'start': 566, 'end': 571, 'type': 'COM'}","{'word': '모든 구성 요소', 'start': 556, 'end': 563, 'type': 'COM'}",com:sub_concept
1146,비주얼 스튜디오 6.0의 비주얼 베이직 6.0이 대부분의 비주얼 베이직 프로그래머가 알고 있는 것이다.,"{'word': '비주얼 스튜디오 6.0', 'start': 625, 'end': 636, 'type': 'COM'}","{'word': '비주얼 베이직 6.0', 'start': 639, 'end': 649, 'type': 'COM'}",com:sub_concept
1147,비주얼 베이직 닷넷은 이전 버전의 비주얼 베이직과는 달랐다. 또한 비주얼 J++를 포함하는 마지막 버전이 되었다.,"{'word': '비주얼 베이직 닷넷', 'start': 683, 'end': 692, 'type': 'COM'}","{'word': '비주얼 J++', 'start': 720, 'end': 726, 'type': 'COM'}",com:sub_concept
1148,"비주얼 J++의 마이크로소프트 자바 확장 때문에 선과 마이크로소프트 사이에 분쟁이 있었으며, 자바 VM 기반의 개발 환경을 더 이상 출시하지 못하게 되었다.","{'word': '비주얼 J++', 'start': 747, 'end': 753, 'type': 'COM'}","{'word': '마이크로소프트 자바 확장', 'start': 756, 'end': 768, 'type': 'COM'}",com:sub_concept
1149,비주얼 베이직은 버전 6.0과 버전 7.0 사이의 차이가 매우 크기 때문에 완전히 다른 프로그래밍 언어로 보는 견해가 강하다.,"{'word': '프로그래밍 언어', 'start': 970, 'end': 977, 'type': 'COM'}","{'word': '비주얼 베이직', 'start': 921, 'end': 927, 'type': 'COM'}",com:sub_concept
1150,MSIL이라는 간접 언어로 컴파일된 다음 실행 시간에 플랫폼에 맞게 컴파일되는 것이다.,"{'word': '간접 언어', 'start': 1588, 'end': 1592, 'type': 'COM'}","{'word': 'MSIL', 'start': 1580, 'end': 1583, 'type': 'COM'}",com:sub_concept
1151,비주얼 J#은 자바 문법을 사용하지만 닷넷 프레임워크 용으로 컴파일된다.,"{'word': '비주얼 J#', 'start': 1726, 'end': 1731, 'type': 'COM'}","{'word': '자바 문법', 'start': 1734, 'end': 1738, 'type': 'COM'}",com:sub_concept
1152,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '비주얼 스튜디오 2003', 'start': 2277, 'end': 2289, 'type': 'COM'}","{'word': '아카데믹', 'start': 2302, 'end': 2305, 'type': 'COM'}",com:sub_concept
1153,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '비주얼 스튜디오 2003', 'start': 2277, 'end': 2289, 'type': 'COM'}","{'word': '프로페셔널', 'start': 2308, 'end': 2312, 'type': 'COM'}",com:sub_concept
1154,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '비주얼 스튜디오 2003', 'start': 2277, 'end': 2289, 'type': 'COM'}","{'word': '엔터프라이즈 디벨로퍼', 'start': 2315, 'end': 2325, 'type': 'COM'}",com:sub_concept
1155,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '비주얼 스튜디오 2003', 'start': 2277, 'end': 2289, 'type': 'COM'}","{'word': '엔터프라이즈 아키텍트', 'start': 2328, 'end': 2338, 'type': 'COM'}",com:sub_concept
1156,"제네릭 프로그래밍 기능이 C#, Visual Basic .NET, Visual C++ CLR, Visual J#에 추가되었다.","{'word': 'C#', 'start': 2632, 'end': 2633, 'type': 'COM'}","{'word': '제네릭 프로그래밍', 'start': 2618, 'end': 2626, 'type': 'COM'}",com:sub_concept
1157,"제네릭 프로그래밍 기능이 C#, Visual Basic .NET, Visual C++ CLR, Visual J#에 추가되었다.","{'word': 'Visual Basic .NET', 'start': 2636, 'end': 2652, 'type': 'COM'}","{'word': '제네릭 프로그래밍', 'start': 2618, 'end': 2626, 'type': 'COM'}",com:sub_concept
1158,"제네릭 프로그래밍 기능이 C#, Visual Basic .NET, Visual C++ CLR, Visual J#에 추가되었다.","{'word': 'Visual C++ CLR', 'start': 2655, 'end': 2668, 'type': 'COM'}","{'word': '제네릭 프로그래밍', 'start': 2618, 'end': 2626, 'type': 'COM'}",com:sub_concept
1159,"제네릭 프로그래밍 기능이 C#, Visual Basic .NET, Visual C++ CLR, Visual J#에 추가되었다.","{'word': 'Visual J#', 'start': 2671, 'end': 2679, 'type': 'COM'}","{'word': '제네릭 프로그래밍', 'start': 2618, 'end': 2626, 'type': 'COM'}",com:sub_concept
1160,비주얼 스튜디오 2005는 64비트 지원도 하게 되었다.,"{'word': '비주얼 스튜디오 2005', 'start': 2725, 'end': 2737, 'type': 'COM'}","{'word': '64비트', 'start': 2740, 'end': 2743, 'type': 'COM'}",com:sub_concept
1161,플랫폼 SDK에만 64비트 컴파일러 및 라이브러리가 있었으며 비주얼 C++ 닷넷 2003의 경우는 마이크로소프트에 전자 우편을 보내야 했다.,"{'word': '플랫폼 SDK', 'start': 2832, 'end': 2838, 'type': 'COM'}","{'word': '64비트 컴파일러 및 라이브러리', 'start': 2842, 'end': 2858, 'type': 'COM'}",com:sub_concept
1162,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '비주얼 스튜디오 2005', 'start': 2911, 'end': 2923, 'type': 'COM'}","{'word': '익스프레스', 'start': 2931, 'end': 2935, 'type': 'COM'}",com:sub_concept
1163,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '비주얼 스튜디오 2005', 'start': 2911, 'end': 2923, 'type': 'COM'}","{'word': '스탠더드', 'start': 2938, 'end': 2941, 'type': 'COM'}",com:sub_concept
1164,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '비주얼 스튜디오 2005', 'start': 2911, 'end': 2923, 'type': 'COM'}","{'word': '프로페셔널', 'start': 2944, 'end': 2948, 'type': 'COM'}",com:sub_concept
1165,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '비주얼 스튜디오 2005', 'start': 2911, 'end': 2923, 'type': 'COM'}","{'word': '툴즈 포 오피스', 'start': 2951, 'end': 2958, 'type': 'COM'}",com:sub_concept
1166,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '비주얼 스튜디오 2005', 'start': 2911, 'end': 2923, 'type': 'COM'}","{'word': '팀 시스템', 'start': 2961, 'end': 2965, 'type': 'COM'}",com:sub_concept
1167,비주얼 스튜디오 2005 때와 마찬가지로 익스프레스 에디션을 제공하고 있다.,"{'word': '비주얼 스튜디오 2005', 'start': 3769, 'end': 3781, 'type': 'COM'}","{'word': '익스프레스 에디션', 'start': 3792, 'end': 3800, 'type': 'COM'}",com:sub_concept
1168,비주얼 스튜디오 2005에서 제공되었던 Visual J# 개발 환경은 익스프레스 에디션을 포함하여 이 버전에서는 제공되지 않고 있다.,"{'word': '비주얼 스튜디오 2005', 'start': 3812, 'end': 3824, 'type': 'COM'}","{'word': 'Visual J# 개발 환경', 'start': 3834, 'end': 3848, 'type': 'COM'}",com:sub_concept
1169,또한 새 버전의 Visual C++ 컴파일러에서는 최근 활발한 논의 및 개정이 진행 중인 C++0x 사양을 지원한다.,"{'word': 'Visual C++ 컴파일러', 'start': 4037, 'end': 4051, 'type': 'COM'}","{'word': 'C++0x 사양', 'start': 4078, 'end': 4085, 'type': 'COM'}",com:sub_concept
1170,또한 새 버전의 Visual C++ 컴파일러에서는 최근 활발한 논의 및 개정이 진행 중인 C++14/17 사양을 일부 지원한다.,"{'word': 'Visual C++ 컴파일러', 'start': 4520, 'end': 4534, 'type': 'COM'}","{'word': 'C++14/17 사양', 'start': 4561, 'end': 4571, 'type': 'COM'}",com:sub_concept
1171,64비트만 지원하는 최초의 비주얼 스튜디오 버전이다.,"{'word': '비주얼 스튜디오', 'start': 5056, 'end': 5063, 'type': 'COM'}","{'word': '64비트', 'start': 5041, 'end': 5044, 'type': 'COM'}",com:sub_concept
1172,"비주얼 스튜디오 팀 서비스(vsts)는 소스 코드 관리(팀 파운데이션 버전 제어 또는 깃), 보고, 요구 사항 관리, 프로젝트 관리 (애자일 소프트웨어 개발), 테스트 및 출시 관리 기능을 제공하는 마이크로소프트의 제품이다.","{'word': '비주얼 스튜디오 팀 서비스', 'start': 5185, 'end': 5198, 'type': 'COM'}","{'word': '소스 코드 관리', 'start': 5207, 'end': 5214, 'type': 'COM'}",com:sub_concept
1173,"비주얼 스튜디오 팀 서비스(vsts)는 소스 코드 관리(팀 파운데이션 버전 제어 또는 깃), 보고, 요구 사항 관리, 프로젝트 관리 (애자일 소프트웨어 개발), 테스트 및 출시 관리 기능을 제공하는 마이크로소프트의 제품이다.","{'word': '비주얼 스튜디오 팀 서비스', 'start': 5185, 'end': 5198, 'type': 'COM'}","{'word': '보고', 'start': 5237, 'end': 5238, 'type': 'COM'}",com:sub_concept
1174,"비주얼 스튜디오 팀 서비스(vsts)는 소스 코드 관리(팀 파운데이션 버전 제어 또는 깃), 보고, 요구 사항 관리, 프로젝트 관리 (애자일 소프트웨어 개발), 테스트 및 출시 관리 기능을 제공하는 마이크로소프트의 제품이다.","{'word': '비주얼 스튜디오 팀 서비스', 'start': 5185, 'end': 5198, 'type': 'COM'}","{'word': '요구 사항 관리', 'start': 5241, 'end': 5248, 'type': 'COM'}",com:sub_concept
1175,"비주얼 스튜디오 팀 서비스(vsts)는 소스 코드 관리(팀 파운데이션 버전 제어 또는 깃), 보고, 요구 사항 관리, 프로젝트 관리 (애자일 소프트웨어 개발), 테스트 및 출시 관리 기능을 제공하는 마이크로소프트의 제품이다.","{'word': '비주얼 스튜디오 팀 서비스', 'start': 5185, 'end': 5198, 'type': 'COM'}","{'word': '프로젝트 관리', 'start': 5251, 'end': 5257, 'type': 'COM'}",com:sub_concept
1176,"비주얼 스튜디오 팀 서비스(vsts)는 소스 코드 관리(팀 파운데이션 버전 제어 또는 깃), 보고, 요구 사항 관리, 프로젝트 관리 (애자일 소프트웨어 개발), 테스트 및 출시 관리 기능을 제공하는 마이크로소프트의 제품이다.","{'word': '비주얼 스튜디오 팀 서비스', 'start': 5185, 'end': 5198, 'type': 'COM'}","{'word': '테스트 및 출시 관리 기능', 'start': 5275, 'end': 5288, 'type': 'COM'}",com:sub_concept
1177,"마이크로소프트 비주얼 스튜디오(Microsoft Visual Studio)는 마이크로소프트 윈도우, macOS에서 작동하며, 다양한 언어로 프로그래밍할 수 있는 마이크로소프트의 통합 개발 환경이다.","{'word': '마이크로소프트 비주얼 스튜디오', 'start': 17, 'end': 32, 'type': 'COM'}","{'word': 'Microsoft Visual Studio', 'start': 34, 'end': 56, 'type': 'COM'}",com:alter_names
1178,RC(Release Cantidate)를 거쳐 베타 버전을 지나 새로운 제품이 나오고 Express 버전이 나왔다.,"{'word': 'RC', 'start': 4094, 'end': 4095, 'type': 'COM'}","{'word': 'Release Cantidate', 'start': 4097, 'end': 4113, 'type': 'COM'}",com:alter_names
1179,"버전은 15.0으로, 2016년 11월 16일 RC(Release Candidate)버전이 공개되었다.","{'word': 'RC', 'start': 4633, 'end': 4634, 'type': 'COM'}","{'word': 'Release Candidate', 'start': 4636, 'end': 4652, 'type': 'COM'}",com:alter_names
1180,"비주얼 스튜디오 팀 서비스(vsts)는 소스 코드 관리(팀 파운데이션 버전 제어 또는 깃), 보고, 요구 사항 관리, 프로젝트 관리 (애자일 소프트웨어 개발), 테스트 및 출시 관리 기능을 제공하는 마이크로소프트의 제품이다.","{'word': '비주얼 스튜디오 팀 서비스', 'start': 5185, 'end': 5198, 'type': 'COM'}","{'word': 'vsts', 'start': 5200, 'end': 5203, 'type': 'COM'}",com:alter_names
1181,C++ 관리되는 확장이라는 새로운 도구를 통해서 C++ 언어로 닷넷 프로그램을 짤 수 있게 되었다.,"{'word': '닷넷 프로그램', 'start': 1902, 'end': 1908, 'type': 'COM'}","{'word': 'C++ 언어', 'start': 1894, 'end': 1899, 'type': 'COM'}",com:made_of
1182,"비주얼 스튜디오 버전 4.0 이전에, 비주얼 베이직 3, 비주얼 C++, 비주얼 폭스프로, 비주얼 소스세이프가 별도의 제품으로 있었다.","{'word': '비주얼 스튜디오 버전 4.0', 'start': 266, 'end': 280, 'type': 'COM'}","{'word': '비주얼 베이직 3', 'start': 287, 'end': 295, 'type': 'COM'}",com:prior_tech
1183,"비주얼 스튜디오 버전 4.0 이전에, 비주얼 베이직 3, 비주얼 C++, 비주얼 폭스프로, 비주얼 소스세이프가 별도의 제품으로 있었다.","{'word': '비주얼 스튜디오 버전 4.0', 'start': 266, 'end': 280, 'type': 'COM'}","{'word': '비주얼 C++', 'start': 298, 'end': 304, 'type': 'COM'}",com:prior_tech
1184,"비주얼 스튜디오 버전 4.0 이전에, 비주얼 베이직 3, 비주얼 C++, 비주얼 폭스프로, 비주얼 소스세이프가 별도의 제품으로 있었다.","{'word': '비주얼 스튜디오 버전 4.0', 'start': 266, 'end': 280, 'type': 'COM'}","{'word': '비주얼 폭스프로', 'start': 307, 'end': 314, 'type': 'COM'}",com:prior_tech
1185,"비주얼 스튜디오 버전 4.0 이전에, 비주얼 베이직 3, 비주얼 C++, 비주얼 폭스프로, 비주얼 소스세이프가 별도의 제품으로 있었다.","{'word': '비주얼 스튜디오 버전 4.0', 'start': 266, 'end': 280, 'type': 'COM'}","{'word': '비주얼 소스세이프', 'start': 317, 'end': 325, 'type': 'COM'}",com:prior_tech
1186,비주얼 베이직 닷넷은 이전 버전의 비주얼 베이직과는 달랐다.,"{'word': '비주얼 베이직 닷넷', 'start': 683, 'end': 692, 'type': 'COM'}","{'word': '이전 버전의 비주얼 베이직', 'start': 695, 'end': 708, 'type': 'COM'}",com:prior_tech
1187,실제 명칭에서도 비주얼 베이직이라는 정식 명칭은 6.0 및 그 이전 버전에 대해서 사용할 수 있으며 7.0 이후부터는 비주얼 베이직 닷넷 이라고 부르게 되었다.,"{'word': '비주얼 베이직 닷넷', 'start': 1058, 'end': 1067, 'type': 'COM'}","{'word': '비주얼 베이직', 'start': 1001, 'end': 1007, 'type': 'COM'}",com:prior_tech
1188,비주얼 J++는 더 이상 새 버전이 나오지 않고 있으며 대신 비주얼 J#이 새롭게 소개되었다. 하지만 비주얼 J#에 대한 비판의 목소리가 매우 높으며 실제 프로젝트에서 채택되어 이용되는 사례는 거의 없는 것으로 보인다.,"{'word': '비주얼 J#', 'start': 1205, 'end': 1210, 'type': 'COM'}","{'word': '비주얼 J++', 'start': 1171, 'end': 1177, 'type': 'COM'}",com:prior_tech
1189,"또한 C#라는 새로운 언어를 소개하였으며, 비주얼 J++의 후속작 비주얼 J#을 소개하였다.","{'word': '비주얼 J#', 'start': 1711, 'end': 1716, 'type': 'COM'}","{'word': '비주얼 J++', 'start': 1698, 'end': 1704, 'type': 'COM'}",com:prior_tech
1190,비주얼 스튜디오 2013 업데이트 1 (2013.1)이 2014년 1월 20일 공개되었다. 이 버전은 고객의 일부 주요 의 - 비주얼 스튜디오 2013의 차기 버전이다.,"{'word': '비주얼 스튜디오 2013 업데이트 1', 'start': 4369, 'end': 4388, 'type': 'COM'}","{'word': '비주얼 스튜디오 2013', 'start': 4440, 'end': 4452, 'type': 'COM'}",com:prior_tech
1191,비주얼 스튜디오 2019의 차기작인 비주얼 스튜디오 2022는 매우 큰 것부터 바뀌었다.,"{'word': '비주얼 스튜디오 2022', 'start': 4940, 'end': 4952, 'type': 'COM'}","{'word': '비주얼 스튜디오 2019', 'start': 4920, 'end': 4932, 'type': 'COM'}",com:prior_tech
1192,"인터페이스가 더 단정해졌으며, 사용자 정의할 수 있는 부분도 많아졌다.","{'word': '사용자', 'start': 1983, 'end': 1985, 'type': 'PER'}","{'word': '인터페이스', 'start': 1966, 'end': 1970, 'type': 'COM'}",no_relation
1193,비주얼 스튜디오 닷넷 2002의 경우 무료로 60일 평가판을 사용할 수 있다.,"{'word': '비주얼 스튜디오 닷넷 2002', 'start': 2036, 'end': 2051, 'type': 'COM'}","{'word': '60일 평가판', 'start': 2061, 'end': 2067, 'type': 'POH'}",no_relation
1194,익스프레스 에디션의 등장으로 기존과 같은 개별 언어에 대한 제품의 분리 판매는 더 이상 시행하지 않게 되었다.,"{'word': '익스프레스 에디션', 'start': 3452, 'end': 3460, 'type': 'COM'}","{'word': '제품', 'start': 3485, 'end': 3486, 'type': 'POH'}",no_relation
1195,비주얼 스튜디오의 미리보기판은 빌드 2013 콘퍼런스에서 발표되어 2013년 7월 26일부터 사용이 가능했다.,"{'word': '비주얼 스튜디오의 미리보기판', 'start': 4254, 'end': 4268, 'type': 'COM'}","{'word': '빌드 2013 콘퍼런스', 'start': 4271, 'end': 4282, 'type': 'POH'}",no_relation
1196,C++ 버전이 올라갔으며 현재는 프리뷰 상태인데 배경색이 검은색에서 하얀색으로 바뀌었다.,"{'word': 'C++ 버전', 'start': 4970, 'end': 4975, 'type': 'COM'}","{'word': '프리뷰 상태', 'start': 4988, 'end': 4993, 'type': 'POH'}",no_relation
1197,"마이크로소프트 비주얼 스튜디오(Microsoft Visual Studio)는 마이크로소프트 윈도우, macOS에서 작동하며, 다양한 언어로 프로그래밍할 수 있는 마이크로소프트의 통합 개발 환경이다.","{'word': '마이크로소프트 비주얼 스튜디오', 'start': 17, 'end': 32, 'type': 'COM'}","{'word': '마이크로소프트 윈도우', 'start': 60, 'end': 70, 'type': 'COM'}",no_relation
1198,"마이크로소프트 비주얼 스튜디오(Microsoft Visual Studio)는 마이크로소프트 윈도우, macOS에서 작동하며, 다양한 언어로 프로그래밍할 수 있는 마이크로소프트의 통합 개발 환경이다.","{'word': '마이크로소프트 비주얼 스튜디오', 'start': 17, 'end': 32, 'type': 'COM'}","{'word': 'macOS', 'start': 73, 'end': 77, 'type': 'COM'}",no_relation
1199,"프로그램, 웹 사이트, 웹 프로그램 등을 개발할 수 있다.","{'word': '프로그램', 'start': 128, 'end': 131, 'type': 'COM'}","{'word': '웹 사이트', 'start': 134, 'end': 138, 'type': 'COM'}",no_relation
1200,"프로그램, 웹 사이트, 웹 프로그램 등을 개발할 수 있다.","{'word': '프로그램', 'start': 128, 'end': 131, 'type': 'COM'}","{'word': '웹 프로그램', 'start': 141, 'end': 146, 'type': 'COM'}",no_relation
1201,"프로그램, 웹 사이트, 웹 프로그램 등을 개발할 수 있다.","{'word': '웹 사이트', 'start': 134, 'end': 138, 'type': 'COM'}","{'word': '웹 프로그램', 'start': 141, 'end': 146, 'type': 'COM'}",no_relation
1202,"비주얼 인터데브와 마이크로소프트 개발자 네트워크의 일부분이 들어 있었다. ""마이크로소프트의 첫 통합 개발 환경이다"".","{'word': '비주얼 인터데브', 'start': 462, 'end': 469, 'type': 'COM'}","{'word': '마이크로소프트 개발자 네트워크', 'start': 472, 'end': 487, 'type': 'COM'}",no_relation
1203,마이크로소프트가 닷넷 프레임워크에 신경을 쓰는 4년간 핵심 개발자 도구였다.,"{'word': '마이크로소프트', 'start': 582, 'end': 588, 'type': 'COM'}","{'word': '닷넷 프레임워크', 'start': 591, 'end': 598, 'type': 'COM'}",no_relation
1204,"역시 비주얼 베이직과 비주얼 폭스프로는 독립된 도구로 남아 있었고, 비주얼 J++과 비주얼 인터데브도 더 이상 통합된 개발 환경을 이루지 못하게 되었다.","{'word': '비주얼 베이직', 'start': 838, 'end': 844, 'type': 'COM'}","{'word': '비주얼 폭스프로', 'start': 847, 'end': 854, 'type': 'COM'}",no_relation
1205,"역시 비주얼 베이직과 비주얼 폭스프로는 독립된 도구로 남아 있었고, 비주얼 J++과 비주얼 인터데브도 더 이상 통합된 개발 환경을 이루지 못하게 되었다.","{'word': '비주얼 J++', 'start': 873, 'end': 879, 'type': 'COM'}","{'word': '비주얼 인터데브', 'start': 882, 'end': 889, 'type': 'COM'}",no_relation
1206,비주얼 폭스프로는 한 차례 닷넷 프레임워크 기반의 개발 도구로 독립 발매된 적이 있으며 최근에는 CodePlex를 통하여 오픈 소스 제품으로 론칭할 예정이다.,"{'word': '비주얼 폭스프로', 'start': 1082, 'end': 1089, 'type': 'COM'}","{'word': 'CodePlex', 'start': 1136, 'end': 1143, 'type': 'COM'}",no_relation
1207,비주얼 인터데브 역시 더 이상 새 버전은 나오지 않고 있다. 하지만 비주얼 스튜디오 닷넷 2002 이후부터 지원되는 ASP 닷넷 기반의 통합 웹 개발 환경을 통하여 비주얼 인터데브의 기존 기능과 함께 업그레이드된 기능을 사용할 수 있게 되었다.,"{'word': '비주얼 인터데브', 'start': 1294, 'end': 1301, 'type': 'COM'}","{'word': '비주얼 스튜디오 닷넷 2002', 'start': 1332, 'end': 1347, 'type': 'COM'}",no_relation
1208,자바 바이트코드처럼 닷넷 프레임워크의 관리되는 코드는 기계어로 컴파일되지 않는다.,"{'word': '자바 바이트코드', 'start': 1534, 'end': 1541, 'type': 'COM'}","{'word': '닷넷 프레임워크', 'start': 1545, 'end': 1552, 'type': 'COM'}",no_relation
1209,모노나 DotGNU 같은 도구로 MSIL 언어의 프로그램을 실행시킬 수도 있다.,"{'word': '모노', 'start': 1629, 'end': 1630, 'type': 'COM'}","{'word': 'DotGNU', 'start': 1633, 'end': 1638, 'type': 'COM'}",no_relation
1210,"비주얼 베이직은 비주얼 베이직 닷넷으로 바뀌었고, 기존의 비주얼 베이직의 문법적인 사양을 닷넷에 맞게 개선한 점 이외에는 완전히 다른 프로그래밍 언어와 개발 환경으로 자리잡았다.","{'word': '비주얼 베이직', 'start': 1767, 'end': 1773, 'type': 'COM'}","{'word': '비주얼 베이직 닷넷', 'start': 1776, 'end': 1785, 'type': 'COM'}",no_relation
1211,비주얼 스튜디오 닷넷 환경은 비주얼 폭스프로를 제외한 모든 언어를 통합한다.,"{'word': '비주얼 스튜디오 닷넷 환경', 'start': 1923, 'end': 1936, 'type': 'COM'}","{'word': '비주얼 폭스프로', 'start': 1939, 'end': 1946, 'type': 'COM'}",no_relation
1212,"내부 버전은 7.1이며, 닷넷 프레임워크가 업그레이드되었고 모바일 장치를 위한 프로그래밍이 가능해졌다.","{'word': '닷넷 프레임워크', 'start': 2156, 'end': 2163, 'type': 'COM'}","{'word': '모바일 장치', 'start': 2175, 'end': 2180, 'type': 'COM'}",no_relation
1213,"C++ 컴파일러가 더욱 더 표준을 준수하게 되었고, 무료 버전도 사용할 수 있게 되었다.","{'word': 'C++ 컴파일러', 'start': 2200, 'end': 2207, 'type': 'COM'}","{'word': '무료 버전', 'start': 2229, 'end': 2233, 'type': 'COM'}",no_relation
1214,"C++ 컴파일러가 더욱 더 표준을 준수하게 되었고, 무료 버전도 사용할 수 있게 되었다. 이 무료 버전은 후에 익스프레스 에디션이 된다.","{'word': 'C++ 컴파일러', 'start': 2200, 'end': 2207, 'type': 'COM'}","{'word': '익스프레스 에디션', 'start': 2262, 'end': 2270, 'type': 'COM'}",no_relation
1215,또한 엔터프라이즈 템플릿이란 기능으로 거대한 개발 팀의 코딩 스타일이나 정책을 쉽게 조정할 수 있게 되었다.,"{'word': '엔터프라이즈 템플릿', 'start': 2382, 'end': 2391, 'type': 'COM'}","{'word': '코딩 스타일', 'start': 2410, 'end': 2415, 'type': 'COM'}",no_relation
1216,현재 윈도우 비스타를 위한 특별 업데이트와 함께 공식적으로 비주얼 스튜디오 2005 서비스 팩 1을 사용할 수 있다.,"{'word': '윈도우 비스타', 'start': 2555, 'end': 2561, 'type': 'COM'}","{'word': '비주얼 스튜디오 2005 서비스 팩 1', 'start': 2585, 'end': 2605, 'type': 'COM'}",no_relation
1217,비주얼 C++ 2005는 AMD64용 바이너리를 컴파일할 수 있게 되었다.,"{'word': '비주얼 C++ 2005', 'start': 2757, 'end': 2768, 'type': 'COM'}","{'word': 'AMD64용 바이너리', 'start': 2771, 'end': 2781, 'type': 'COM'}",no_relation
1218,이전 버전의 비주얼 스튜디오는 64비트를 지원하지 않았다.,"{'word': '비주얼 스튜디오', 'start': 2806, 'end': 2813, 'type': 'COM'}","{'word': '64비트', 'start': 2816, 'end': 2819, 'type': 'COM'}",no_relation
1219,플랫폼 SDK에만 64비트 컴파일러 및 라이브러리가 있었으며 비주얼 C++ 닷넷 2003의 경우는 마이크로소프트에 전자 우편을 보내야 했다.,"{'word': '비주얼 C++ 닷넷 2003', 'start': 2866, 'end': 2880, 'type': 'COM'}","{'word': '마이크로소프트', 'start': 2887, 'end': 2893, 'type': 'COM'}",no_relation
1220,또한 팀 시스템은 MSDN 가입 여부에 따라서 4개의 버전으로 나뉜다.,"{'word': '팀 시스템', 'start': 3000, 'end': 3004, 'type': 'COM'}","{'word': 'MSDN', 'start': 3007, 'end': 3010, 'type': 'COM'}",no_relation
1221,"익스프레스 에디션은 개인 및 교육 목적으로 사용하는 데 제한이 없으며, 인터넷을 통하여 무료로 다운로드할 수 있다.","{'word': '익스프레스 에디션', 'start': 3037, 'end': 3045, 'type': 'COM'}","{'word': '인터넷', 'start': 3077, 'end': 3079, 'type': 'COM'}",no_relation
1222,"각각의 언어별로 익스프레스 에디션이 있으며 웹 전문 개발 도구인 웹 디벨로퍼 익스프레스, SQL 서버 2005 익스프레스 에디션, MSDN 라이브러리 익스프레스 에디션을 다운로드할 수 있다.","{'word': '웹 디벨로퍼 익스프레스', 'start': 3138, 'end': 3149, 'type': 'COM'}","{'word': 'SQL 서버 2005 익스프레스 에디션', 'start': 3152, 'end': 3172, 'type': 'COM'}",no_relation
1223,"각각의 언어별로 익스프레스 에디션이 있으며 웹 전문 개발 도구인 웹 디벨로퍼 익스프레스, SQL 서버 2005 익스프레스 에디션, MSDN 라이브러리 익스프레스 에디션을 다운로드할 수 있다.","{'word': '웹 디벨로퍼 익스프레스', 'start': 3138, 'end': 3149, 'type': 'COM'}","{'word': 'MSDN 라이브러리 익스프레스 에디션', 'start': 3175, 'end': 3194, 'type': 'COM'}",no_relation
1224,최근에는 윈도우 및 XBOX 360을 위한 게임 전문 개발 도구인 XNA 게임 스튜디오 익스프레스와 하드웨어 제어를 위한 로보틱스 스튜디오 익스프레스 에디션도 함께 배포하고 있다.,"{'word': '윈도우', 'start': 3214, 'end': 3216, 'type': 'COM'}","{'word': 'XBOX 360', 'start': 3220, 'end': 3227, 'type': 'COM'}",no_relation
1225,최근에는 윈도우 및 XBOX 360을 위한 게임 전문 개발 도구인 XNA 게임 스튜디오 익스프레스와 하드웨어 제어를 위한 로보틱스 스튜디오 익스프레스 에디션도 함께 배포하고 있다.,"{'word': 'XNA 게임 스튜디오 익스프레스', 'start': 3246, 'end': 3262, 'type': 'COM'}","{'word': '로보틱스 스튜디오 익스프레스 에디션', 'start': 3277, 'end': 3295, 'type': 'COM'}",no_relation
1226,전체 비주얼 스튜디오에서 누릴 수 있는 이점의 상당수가 누락되어 있지만 익스프레스 에디션 고유의 특혜가 있다.,"{'word': '비주얼 스튜디오', 'start': 3313, 'end': 3320, 'type': 'COM'}","{'word': '익스프레스 에디션', 'start': 3350, 'end': 3358, 'type': 'COM'}",no_relation
1227,익스프레스 에디션 개발 도구는 설치 후 30일 이내에 개인 사용자 등록을 통하여 받을 수 있는 제품 키를 프로그램에 지정하여 인증하여야 한다.,"{'word': '익스프레스 에디션 개발 도구', 'start': 3372, 'end': 3386, 'type': 'COM'}","{'word': '프로그램', 'start': 3431, 'end': 3434, 'type': 'COM'}",no_relation
1228,"비주얼 스튜디오 2005는 Professional은 90일, Team Suite는 180일간 평가할 수 있다.","{'word': 'Professional', 'start': 3529, 'end': 3540, 'type': 'COM'}","{'word': 'Team Suite', 'start': 3548, 'end': 3557, 'type': 'COM'}",no_relation
1229,"윈도우 비스타, 닷넷 프레임워크 3.5 대응 및 LINQ, C# 3.0, 비주얼 베이직 9.0 등의 기능이 포함되었다.","{'word': '윈도우 비스타', 'start': 3647, 'end': 3653, 'type': 'COM'}","{'word': '닷넷 프레임워크 3.5 대응 및 LINQ', 'start': 3656, 'end': 3677, 'type': 'COM'}",no_relation
1230,"윈도우 비스타, 닷넷 프레임워크 3.5 대응 및 LINQ, C# 3.0, 비주얼 베이직 9.0 등의 기능이 포함되었다.","{'word': '윈도우 비스타', 'start': 3647, 'end': 3653, 'type': 'COM'}","{'word': 'C# 3.0', 'start': 3680, 'end': 3685, 'type': 'COM'}",no_relation
1231,"윈도우 비스타, 닷넷 프레임워크 3.5 대응 및 LINQ, C# 3.0, 비주얼 베이직 9.0 등의 기능이 포함되었다.","{'word': '윈도우 비스타', 'start': 3647, 'end': 3653, 'type': 'COM'}","{'word': '비주얼 베이직 9.0', 'start': 3688, 'end': 3698, 'type': 'COM'}",no_relation
1232,웹 개발 환경에서는 프로젝트 내에 포함된 소스 코드에 대해서도 인텔리센스 기능을 지원하게 되었다.,"{'word': '웹 개발 환경', 'start': 3714, 'end': 3720, 'type': 'COM'}","{'word': '프로젝트', 'start': 3725, 'end': 3728, 'type': 'COM'}",no_relation
1233,"윈도우 7, 윈도우 서버 2008 R2 운영 체제를 위한 기술을 제공하며, 닷넷 프레임워크 4.0 대응 및 C# 4.0, 비주얼 베이직 10.0 등의 기능이 새로 포함되어 2010년 4월 12일에 출시하였다.","{'word': '윈도우 7', 'start': 3911, 'end': 3915, 'type': 'COM'}","{'word': '윈도우 서버 2008 R2 운영 체제', 'start': 3918, 'end': 3937, 'type': 'COM'}",no_relation
1234,"윈도우 7, 윈도우 서버 2008 R2 운영 체제를 위한 기술을 제공하며, 닷넷 프레임워크 4.0 대응 및 C# 4.0, 비주얼 베이직 10.0 등의 기능이 새로 포함되어 2010년 4월 12일에 출시하였다.","{'word': '윈도우 7', 'start': 3911, 'end': 3915, 'type': 'COM'}","{'word': '닷넷 프레임워크 4.0 대응 및 C# 4.0', 'start': 3953, 'end': 3976, 'type': 'COM'}",no_relation
1235,"윈도우 7, 윈도우 서버 2008 R2 운영 체제를 위한 기술을 제공하며, 닷넷 프레임워크 4.0 대응 및 C# 4.0, 비주얼 베이직 10.0 등의 기능이 새로 포함되어 2010년 4월 12일에 출시하였다.","{'word': '윈도우 7', 'start': 3911, 'end': 3915, 'type': 'COM'}","{'word': '비주얼 베이직 10.0', 'start': 3979, 'end': 3990, 'type': 'COM'}",no_relation
1236,비주얼 스튜디오 2013 최종판은 닷넷 4.5.1과 더불어 2013년 10월 17일부터 다운로드가 가능하다.,"{'word': '비주얼 스튜디오 2013 최종판', 'start': 4193, 'end': 4209, 'type': 'COM'}","{'word': '닷넷 4.5.1', 'start': 4212, 'end': 4219, 'type': 'COM'}",no_relation
1237,"윈도우 10 운영 체제를 위한 기술을 제공하며, 닷넷 프레임워크 4.6에 대응한다.","{'word': '윈도우 10 운영 체제', 'start': 4464, 'end': 4475, 'type': 'COM'}","{'word': '닷넷 프레임워크 4.6', 'start': 4491, 'end': 4502, 'type': 'COM'}",no_relation
1238,"이 버전에서는 그간 속도 문제가 제기되었던 인스톨러가 교체되었고, 리눅스로의 원격 C++ 빌드 지원, 개발자 도우미에 C++ 언어 추가 등의 기능을 지원한다.","{'word': '리눅스', 'start': 4702, 'end': 4704, 'type': 'COM'}","{'word': '원격 C++ 빌드 지원', 'start': 4708, 'end': 4719, 'type': 'COM'}",no_relation
1239,Vsts는 수많은 통합 개발 환경의 백엔드로 쓸 수 있으나 마이크로소프트 비주얼 스튜디오의 백엔드로 사용할 때 최상의 이점을 제공하도록 설계되어 있다.,"{'word': 'Vsts', 'start': 5311, 'end': 5314, 'type': 'COM'}","{'word': '마이크로소프트 비주얼 스튜디오', 'start': 5344, 'end': 5359, 'type': 'COM'}",no_relation
1240,비주얼 스튜디오에 추가기능이 없을때 비주얼 스튜디오 인스톨러를 쓴다.,"{'word': '비주얼 스튜디오', 'start': 5396, 'end': 5403, 'type': 'COM'}","{'word': '비주얼 스튜디오 인스톨러', 'start': 5416, 'end': 5428, 'type': 'COM'}",no_relation
1241,"마이크로소프트에서는 비주얼 베이직, 비주얼 C#, 비주얼 J# 등 특정한 언어로만 프로그래밍할 수 있는 언어별 버전도 제공하고 있다.","{'word': '비주얼 베이직', 'start': 172, 'end': 178, 'type': 'COM'}","{'word': '비주얼 C#', 'start': 181, 'end': 186, 'type': 'COM'}",com:similar_tech
1242,"마이크로소프트에서는 비주얼 베이직, 비주얼 C#, 비주얼 J# 등 특정한 언어로만 프로그래밍할 수 있는 언어별 버전도 제공하고 있다.","{'word': '비주얼 베이직', 'start': 172, 'end': 178, 'type': 'COM'}","{'word': '비주얼 J#', 'start': 189, 'end': 194, 'type': 'COM'}",com:similar_tech
1243,"마이크로소프트에서는 비주얼 베이직, 비주얼 C#, 비주얼 J# 등 특정한 언어로만 프로그래밍할 수 있는 언어별 버전도 제공하고 있다.","{'word': '비주얼 C#', 'start': 181, 'end': 186, 'type': 'COM'}","{'word': '비주얼 J#', 'start': 189, 'end': 194, 'type': 'COM'}",com:similar_tech
1244,"프로페셔널, 엔터프라이즈 에디션이 존재했으며 비주얼 베이직 5.0, 비주얼 C++ 5.0, 비주얼 J++ 1.1, 비주얼 폭스프로 5.0이 있었다.","{'word': '프로페셔널', 'start': 379, 'end': 383, 'type': 'COM'}","{'word': '엔터프라이즈 에디션', 'start': 386, 'end': 395, 'type': 'COM'}",com:similar_tech
1245,"프로페셔널, 엔터프라이즈 에디션이 존재했으며 비주얼 베이직 5.0, 비주얼 C++ 5.0, 비주얼 J++ 1.1, 비주얼 폭스프로 5.0이 있었다.","{'word': '비주얼 베이직 5.0', 'start': 404, 'end': 414, 'type': 'COM'}","{'word': '비주얼 C++ 5.0', 'start': 417, 'end': 427, 'type': 'COM'}",com:similar_tech
1246,"프로페셔널, 엔터프라이즈 에디션이 존재했으며 비주얼 베이직 5.0, 비주얼 C++ 5.0, 비주얼 J++ 1.1, 비주얼 폭스프로 5.0이 있었다.","{'word': '비주얼 베이직 5.0', 'start': 404, 'end': 414, 'type': 'COM'}","{'word': '비주얼 J++ 1.1', 'start': 430, 'end': 440, 'type': 'COM'}",com:similar_tech
1247,"프로페셔널, 엔터프라이즈 에디션이 존재했으며 비주얼 베이직 5.0, 비주얼 C++ 5.0, 비주얼 J++ 1.1, 비주얼 폭스프로 5.0이 있었다.","{'word': '비주얼 베이직 5.0', 'start': 404, 'end': 414, 'type': 'COM'}","{'word': '비주얼 폭스프로 5.0', 'start': 443, 'end': 454, 'type': 'COM'}",com:similar_tech
1248,"프로페셔널, 엔터프라이즈 에디션이 존재했으며 비주얼 베이직 5.0, 비주얼 C++ 5.0, 비주얼 J++ 1.1, 비주얼 폭스프로 5.0이 있었다.","{'word': '비주얼 C++ 5.0', 'start': 417, 'end': 427, 'type': 'COM'}","{'word': '비주얼 J++ 1.1', 'start': 430, 'end': 440, 'type': 'COM'}",com:similar_tech
1249,"프로페셔널, 엔터프라이즈 에디션이 존재했으며 비주얼 베이직 5.0, 비주얼 C++ 5.0, 비주얼 J++ 1.1, 비주얼 폭스프로 5.0이 있었다.","{'word': '비주얼 C++ 5.0', 'start': 417, 'end': 427, 'type': 'COM'}","{'word': '비주얼 폭스프로 5.0', 'start': 443, 'end': 454, 'type': 'COM'}",com:similar_tech
1250,"프로페셔널, 엔터프라이즈 에디션이 존재했으며 비주얼 베이직 5.0, 비주얼 C++ 5.0, 비주얼 J++ 1.1, 비주얼 폭스프로 5.0이 있었다.","{'word': '비주얼 J++ 1.1', 'start': 430, 'end': 440, 'type': 'COM'}","{'word': '비주얼 폭스프로 5.0', 'start': 443, 'end': 454, 'type': 'COM'}",com:similar_tech
1251,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '아카데믹', 'start': 2302, 'end': 2305, 'type': 'COM'}","{'word': '프로페셔널', 'start': 2308, 'end': 2312, 'type': 'COM'}",com:similar_tech
1252,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '아카데믹', 'start': 2302, 'end': 2305, 'type': 'COM'}","{'word': '엔터프라이즈 디벨로퍼', 'start': 2315, 'end': 2325, 'type': 'COM'}",com:similar_tech
1253,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '아카데믹', 'start': 2302, 'end': 2305, 'type': 'COM'}","{'word': '엔터프라이즈 아키텍트', 'start': 2328, 'end': 2338, 'type': 'COM'}",com:similar_tech
1254,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '프로페셔널', 'start': 2308, 'end': 2312, 'type': 'COM'}","{'word': '엔터프라이즈 디벨로퍼', 'start': 2315, 'end': 2325, 'type': 'COM'}",com:similar_tech
1255,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '엔터프라이즈 디벨로퍼', 'start': 2315, 'end': 2325, 'type': 'COM'}","{'word': '엔터프라이즈 아키텍트', 'start': 2328, 'end': 2338, 'type': 'COM'}",com:similar_tech
1256,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '익스프레스', 'start': 2931, 'end': 2935, 'type': 'COM'}","{'word': '스탠더드', 'start': 2938, 'end': 2941, 'type': 'COM'}",com:similar_tech
1257,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '익스프레스', 'start': 2931, 'end': 2935, 'type': 'COM'}","{'word': '프로페셔널', 'start': 2944, 'end': 2948, 'type': 'COM'}",com:similar_tech
1258,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '스탠더드', 'start': 2938, 'end': 2941, 'type': 'COM'}","{'word': '프로페셔널', 'start': 2944, 'end': 2948, 'type': 'COM'}",com:similar_tech
1259,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '익스프레스', 'start': 2931, 'end': 2935, 'type': 'COM'}","{'word': '툴즈 포 오피스', 'start': 2951, 'end': 2958, 'type': 'COM'}",com:similar_tech
1260,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '스탠더드', 'start': 2938, 'end': 2941, 'type': 'COM'}","{'word': '툴즈 포 오피스', 'start': 2951, 'end': 2958, 'type': 'COM'}",com:similar_tech
1261,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '프로페셔널', 'start': 2944, 'end': 2948, 'type': 'COM'}","{'word': '툴즈 포 오피스', 'start': 2951, 'end': 2958, 'type': 'COM'}",com:similar_tech
1262,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '익스프레스', 'start': 2931, 'end': 2935, 'type': 'COM'}","{'word': '팀 시스템', 'start': 2961, 'end': 2965, 'type': 'COM'}",com:similar_tech
1263,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '스탠더드', 'start': 2938, 'end': 2941, 'type': 'COM'}","{'word': '팀 시스템', 'start': 2961, 'end': 2965, 'type': 'COM'}",com:similar_tech
1264,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '툴즈 포 오피스', 'start': 2951, 'end': 2958, 'type': 'COM'}","{'word': '팀 시스템', 'start': 2961, 'end': 2965, 'type': 'COM'}",com:similar_tech
1265,"버전은 16.0으로, 2018년 6월 6일 마이크로소프트에서 발표했다.","{'word': '마이크로소프트', 'start': 4848, 'end': 4854, 'type': 'ORG'}","{'word': '2018년 6월 6일', 'start': 4836, 'end': 4846, 'type': 'DAT'}",no_relation
1266,절차형 언어로 1964년 다트머스 대학교의 존 케메니(John Kemeny)와 토머스 커츠(Thomas Kurtz)가 개발했다.,"{'word': '존 케메니(John Kemeny)', 'start': 140, 'end': 157, 'type': 'PER'}","{'word': '토머스 커츠(Thomas Kurtz)', 'start': 160, 'end': 179, 'type': 'PER'}",per:colleagues
1267,"초심자용 다목적 기호명령부호(初心者用 多目的 記號命令符號，Beginner's All-purpose Symbolic Instruction Code), 약자 베이직(BASIC, )은 프로그래밍 언어의 하나이다.","{'word': '프로그래밍 언어', 'start': 100, 'end': 107, 'type': 'COM'}","{'word': '베이직', 'start': 86, 'end': 88, 'type': 'COM'}",com:sub_concept
1268,이후의 베이직은 구조화 프로그래밍을 지원하며 코드에서 줄번호가 사라졌다.,"{'word': '베이직', 'start': 547, 'end': 549, 'type': 'COM'}","{'word': '구조화 프로그래밍', 'start': 552, 'end': 560, 'type': 'COM'}",com:sub_concept
1269,다음 예는 현대적인 베이직의 거의 대부분에서 RUN 명령으로 실행할 수 있다.,"{'word': '베이직', 'start': 595, 'end': 597, 'type': 'COM'}","{'word': 'RUN 명령', 'start': 609, 'end': 614, 'type': 'COM'}",com:sub_concept
1270,많은 베이직에서 End 선언문은 빼도 된다.,"{'word': '베이직', 'start': 653, 'end': 655, 'type': 'COM'}","{'word': 'End 선언문', 'start': 659, 'end': 665, 'type': 'COM'}",com:sub_concept
1271,"초심자용 다목적 기호명령부호(初心者用 多目的 記號命令符號，Beginner's All-purpose Symbolic Instruction Code), 약자 베이직(BASIC, )은 프로그래밍 언어의 하나이다.","{'word': '초심자용 다목적 기호명령부호', 'start': 0, 'end': 14, 'type': 'COM'}","{'word': '初心者用 多目的 記號命令符號', 'start': 16, 'end': 30, 'type': 'COM'}",com:alter_names
1272,"초심자용 다목적 기호명령부호(初心者用 多目的 記號命令符號，Beginner's All-purpose Symbolic Instruction Code), 약자 베이직(BASIC, )은 프로그래밍 언어의 하나이다.","{'word': '초심자용 다목적 기호명령부호', 'start': 0, 'end': 14, 'type': 'COM'}","{'word': ""Beginner's All-purpose Symbolic Instruction Code"", 'start': 32, 'end': 79, 'type': 'COM'}",com:alter_names
1273,"초심자용 다목적 기호명령부호(初心者用 多目的 記號命令符號，Beginner's All-purpose Symbolic Instruction Code), 약자 베이직(BASIC, )은 프로그래밍 언어의 하나이다.","{'word': '베이직', 'start': 86, 'end': 88, 'type': 'COM'}","{'word': 'BASIC', 'start': 90, 'end': 94, 'type': 'COM'}",com:alter_names
1274,"교육용으로 개발되어 언어의 문법이 쉬우며, 다트머스의 최초 제품 이래로 인터프리터 방식이 많았으나 최근에는 컴파일러 방식도 많다.","{'word': '인터프리터 방식', 'start': 228, 'end': 235, 'type': 'COM'}","{'word': '컴파일러 방식', 'start': 248, 'end': 254, 'type': 'COM'}",no_relation
1275,현재는 다양한 종류의 베이직이 존재하며 서로 문법도 많이 차이가 난다.,"{'word': '베이직', 'start': 273, 'end': 275, 'type': 'COM'}","{'word': '문법', 'start': 286, 'end': 287, 'type': 'COM'}",no_relation
1276,서로 다른 종류 사이의 소스 코드는 호환되지 않는다.,"{'word': '종류', 'start': 307, 'end': 308, 'type': 'COM'}","{'word': '소스 코드', 'start': 314, 'end': 318, 'type': 'COM'}",no_relation
1277,아래 예는 모든 ANSI/ISO 호환 베이직과 1970년대에서 1980년대에 마이크로 컴퓨터에 설치된 대부분의 베이직에서 동작한다.,"{'word': 'ANSI/ISO', 'start': 340, 'end': 347, 'type': 'COM'}","{'word': '베이직', 'start': 352, 'end': 354, 'type': 'COM'}",no_relation
1278,이러한 기종에 설치된 베이직은 줄번호가 생략된 즉각 모드로 실행할 수도 있다.,"{'word': '베이직', 'start': 442, 'end': 444, 'type': 'COM'}","{'word': '즉각 모드', 'start': 456, 'end': 460, 'type': 'COM'}",no_relation
1279,다음 예를 실행할 때에는 RUN 명령어가 필요없다.,"{'word': '예', 'start': 477, 'end': 477, 'type': 'COM'}","{'word': 'RUN 명령어', 'start': 488, 'end': 494, 'type': 'COM'}",no_relation
1280,사용자 입력 개수 만큼 별 출력.,"{'word': '사용자 입력', 'start': 675, 'end': 680, 'type': 'COM'}","{'word': '출력', 'start': 690, 'end': 691, 'type': 'COM'}",no_relation
1281,"2006년 개발자 그레이든 호아레의 개인 프로젝트로 시작되었으며, 2009년 호아레의 고용주인 모질라가 2010년 처음으로 일반에 공개되었으며, 같은 해 Objective Caml로 작성된 초기 컴파일러에서 Rust로 작성된 컴파일러로 전환되었다. ""rustc""는 2011년 처음으로 자기 자신을 컴파일하는데 성공했다.","{'word': '그레이든 호아레', 'start': 143, 'end': 150, 'type': 'PER'}","{'word': 'Rust', 'start': 249, 'end': 252, 'type': 'COM'}",per:production
1282,"러스트()는 모질라 리서치에서 개발한 범용 프로그래밍 언어이다. ""안전하고, 병렬적이며, 실용적인"" 언어로 디자인되었으며, 순수 함수형 프로그래밍, 액터 기반 병렬 프로그래밍, 명령형 프로그래밍, 객체 지향 프로그래밍 스타일을 지원한다.","{'word': '모질라 리서치', 'start': 7, 'end': 13, 'type': 'ORG'}","{'word': '러스트', 'start': 0, 'end': 2, 'type': 'COM'}",org:production
1283,"모질라의 정책에 따라, 러스트는 전적으로 오픈 소스로 개발되고 있으며, 커뮤니티로부터 피드백을 받고 있다.","{'word': '모질라', 'start': 345, 'end': 347, 'type': 'ORG'}","{'word': '러스트', 'start': 358, 'end': 360, 'type': 'COM'}",org:production
1284,모질라 재단이 러스트의 개발을 후원하고 있다.,"{'word': '모질라 재단', 'start': 405, 'end': 410, 'type': 'ORG'}","{'word': '러스트', 'start': 413, 'end': 415, 'type': 'COM'}",org:production
1285,러스트의 설계에는 모질라의 렌더링 엔진인 서보와 rustc 컴파일러를 개발하면서 쌓인 경험들이 반영되어 있다.,"{'word': '모질라', 'start': 441, 'end': 443, 'type': 'ORG'}","{'word': '서보', 'start': 454, 'end': 455, 'type': 'COM'}",org:production
1286,"러스트()는 모질라 리서치에서 개발한 범용 프로그래밍 언어이다. ""안전하고, 병렬적이며, 실용적인"" 언어로 디자인되었으며, 순수 함수형 프로그래밍, 액터 기반 병렬 프로그래밍, 명령형 프로그래밍, 객체 지향 프로그래밍 스타일을 지원한다.","{'word': '러스트', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': '순수 함수형 프로그래밍', 'start': 69, 'end': 80, 'type': 'COM'}",com:sub_concept
1287,"러스트()는 모질라 리서치에서 개발한 범용 프로그래밍 언어이다. ""안전하고, 병렬적이며, 실용적인"" 언어로 디자인되었으며, 순수 함수형 프로그래밍, 액터 기반 병렬 프로그래밍, 명령형 프로그래밍, 객체 지향 프로그래밍 스타일을 지원한다.","{'word': '러스트', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': '액터 기반 병렬 프로그래밍', 'start': 83, 'end': 96, 'type': 'COM'}",com:sub_concept
1288,"러스트()는 모질라 리서치에서 개발한 범용 프로그래밍 언어이다. ""안전하고, 병렬적이며, 실용적인"" 언어로 디자인되었으며, 순수 함수형 프로그래밍, 액터 기반 병렬 프로그래밍, 명령형 프로그래밍, 객체 지향 프로그래밍 스타일을 지원한다.","{'word': '프로그래밍 언어', 'start': 24, 'end': 31, 'type': 'COM'}","{'word': '러스트', 'start': 0, 'end': 2, 'type': 'COM'}",com:sub_concept
1289,"러스트()는 모질라 리서치에서 개발한 범용 프로그래밍 언어이다. ""안전하고, 병렬적이며, 실용적인"" 언어로 디자인되었으며, 순수 함수형 프로그래밍, 액터 기반 병렬 프로그래밍, 명령형 프로그래밍, 객체 지향 프로그래밍 스타일을 지원한다.","{'word': '러스트', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': '명령형 프로그래밍', 'start': 99, 'end': 107, 'type': 'COM'}",com:sub_concept
1290,"러스트()는 모질라 리서치에서 개발한 범용 프로그래밍 언어이다. ""안전하고, 병렬적이며, 실용적인"" 언어로 디자인되었으며, 순수 함수형 프로그래밍, 액터 기반 병렬 프로그래밍, 명령형 프로그래밍, 객체 지향 프로그래밍 스타일을 지원한다.","{'word': '러스트', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': '객체 지향 프로그래밍 스타일', 'start': 110, 'end': 124, 'type': 'COM'}",com:sub_concept
1291,카고(cargo)는 러스트의 빌드 시스템이다.,"{'word': '러스트', 'start': 504, 'end': 506, 'type': 'COM'}","{'word': '카고(cargo)', 'start': 493, 'end': 501, 'type': 'COM'}",com:sub_concept
1292,러스트는 CPU 병행처리 및 메모리 자원 누수 방지등의 언어 철학 바탕위에 설계된 취지에 맞게 안전성으로 제작된 프로그램은 빌드 과정에서 사전에 불안정한 결과를 방지할 수 있다는 빌드시스템으로까지 이어지는 완전한 안정성을 실현하고 있다,"{'word': '러스트', 'start': 519, 'end': 521, 'type': 'COM'}","{'word': 'CPU 병행처리', 'start': 524, 'end': 531, 'type': 'COM'}",com:sub_concept
1293,러스트는 CPU 병행처리 및 메모리 자원 누수 방지등의 언어 철학 바탕위에 설계된 취지에 맞게 안전성으로 제작된 프로그램은 빌드 과정에서 사전에 불안정한 결과를 방지할 수 있다는 빌드시스템으로까지 이어지는 완전한 안정성을 실현하고 있다,"{'word': '러스트', 'start': 519, 'end': 521, 'type': 'COM'}","{'word': '메모리 자원 누수 방지', 'start': 535, 'end': 546, 'type': 'COM'}",com:sub_concept
1294,타입 시스템은 하스켈의 영향을 받아 타입 클래스를 지원한다.,"{'word': '타입 시스템', 'start': 1081, 'end': 1086, 'type': 'COM'}","{'word': '타입 클래스', 'start': 1101, 'end': 1106, 'type': 'COM'}",com:sub_concept
1295,반면 함수의 인자나 반환값에서는 타입 정보를 빼놓을 수 없다.,"{'word': '함수', 'start': 1180, 'end': 1181, 'type': 'COM'}","{'word': '인자', 'start': 1184, 'end': 1185, 'type': 'COM'}",com:sub_concept
1296,반면 함수의 인자나 반환값에서는 타입 정보를 빼놓을 수 없다.,"{'word': '함수', 'start': 1180, 'end': 1181, 'type': 'COM'}","{'word': '반환값', 'start': 1188, 'end': 1190, 'type': 'COM'}",com:sub_concept
1297,"객체 시스템은 implementation, trait, struct 또는 enum으로 이루어져 있다.","{'word': '객체 시스템', 'start': 1444, 'end': 1449, 'type': 'COM'}","{'word': 'implementation', 'start': 1452, 'end': 1465, 'type': 'COM'}",com:sub_concept
1298,"객체 시스템은 implementation, trait, struct 또는 enum으로 이루어져 있다.","{'word': '객체 시스템', 'start': 1444, 'end': 1449, 'type': 'COM'}","{'word': 'trait', 'start': 1468, 'end': 1472, 'type': 'COM'}",com:sub_concept
1299,"객체 시스템은 implementation, trait, struct 또는 enum으로 이루어져 있다.","{'word': '객체 시스템', 'start': 1444, 'end': 1449, 'type': 'COM'}","{'word': 'struct', 'start': 1475, 'end': 1480, 'type': 'COM'}",com:sub_concept
1300,"객체 시스템은 implementation, trait, struct 또는 enum으로 이루어져 있다.","{'word': '객체 시스템', 'start': 1444, 'end': 1449, 'type': 'COM'}","{'word': 'enum', 'start': 1485, 'end': 1488, 'type': 'COM'}",com:sub_concept
1301,"codice_4 또는 codice_5은 객체의 데이터를 정의하는데 사용되며, codice_6 키워드로 정의하는 implementation은 객체의 멤버 함수를 정의하는데 사용된다.","{'word': '객체', 'start': 1523, 'end': 1524, 'type': 'COM'}","{'word': '데이터', 'start': 1527, 'end': 1529, 'type': 'COM'}",com:sub_concept
1302,"codice_4 또는 codice_5은 객체의 데이터를 정의하는데 사용되며, codice_6 키워드로 정의하는 implementation은 객체의 멤버 함수를 정의하는데 사용된다.","{'word': '객체', 'start': 1579, 'end': 1580, 'type': 'COM'}","{'word': '멤버 함수', 'start': 1583, 'end': 1587, 'type': 'COM'}",com:sub_concept
1303,"객체의 상속은 codice_7을 통해 이루어지며, C++의 다형 상속 문제를 회피하기 위해 trait은 객체의 멤버를 정의할 수 없도록 만들어져 있다.","{'word': 'C++', 'start': 1630, 'end': 1632, 'type': 'COM'}","{'word': '다형 상속 문제', 'start': 1635, 'end': 1642, 'type': 'COM'}",com:sub_concept
1304,"아래 코드는 러스트 1.0 기준이며, 러스트의 문법은 향후 변경될 수 있다.","{'word': '러스트', 'start': 1708, 'end': 1710, 'type': 'COM'}","{'word': '러스트 1.0', 'start': 1694, 'end': 1700, 'type': 'COM'}",com:sub_concept
1305,/* 이 함수는 러스트의 암묵적 반환문을 이용해 작성되었다.,"{'word': '러스트', 'start': 1800, 'end': 1802, 'type': 'COM'}","{'word': '암묵적 반환문', 'start': 1805, 'end': 1811, 'type': 'COM'}",com:sub_concept
1306,"러스트의 `if` 문은 선언문이 아닌 표현식이므로, `if` 문에도 반환값이 존재한다.","{'word': '러스트', 'start': 1825, 'end': 1827, 'type': 'COM'}","{'word': '`if` 문', 'start': 1830, 'end': 1835, 'type': 'COM'}",com:sub_concept
1307,"러스트의 `if` 문은 선언문이 아닌 표현식이므로, `if` 문에도 반환값이 존재한다.","{'word': '`if` 문', 'start': 1854, 'end': 1859, 'type': 'COM'}","{'word': '반환값', 'start': 1863, 'end': 1865, 'type': 'COM'}",com:sub_concept
1308,다음은 러스트의 병행 프로그래밍 기능을 보여주는 예제이다.,"{'word': '러스트', 'start': 2219, 'end': 2221, 'type': 'COM'}","{'word': '병행 프로그래밍', 'start': 2224, 'end': 2231, 'type': 'COM'}",com:sub_concept
1309,"// C나 C++의 단순한 코드 치환 매크로와 달리, 러스트의 매크로는 Scheme과 유사한 구조적 매크로이다.","{'word': 'C', 'start': 2655, 'end': 2655, 'type': 'COM'}","{'word': '코드 치환 매크로', 'start': 2667, 'end': 2675, 'type': 'COM'}",com:sub_concept
1310,"// C나 C++의 단순한 코드 치환 매크로와 달리, 러스트의 매크로는 Scheme과 유사한 구조적 매크로이다.","{'word': 'C++', 'start': 2658, 'end': 2660, 'type': 'COM'}","{'word': '코드 치환 매크로', 'start': 2667, 'end': 2675, 'type': 'COM'}",com:sub_concept
1311,"// C나 C++의 단순한 코드 치환 매크로와 달리, 러스트의 매크로는 Scheme과 유사한 구조적 매크로이다.","{'word': '러스트', 'start': 2682, 'end': 2684, 'type': 'COM'}","{'word': '매크로', 'start': 2687, 'end': 2689, 'type': 'COM'}",com:sub_concept
1312,러스트 0.4 이전 버전은 정적 타입 검사에 더해 타입 상태 분석 기능을 지원하였다.,"{'word': '러스트 0.4 이전 버전', 'start': 2832, 'end': 2844, 'type': 'COM'}","{'word': '정적 타입 검사', 'start': 2847, 'end': 2854, 'type': 'COM'}",com:sub_concept
1313,러스트 0.4 이전 버전은 정적 타입 검사에 더해 타입 상태 분석 기능을 지원하였다.,"{'word': '러스트 0.4 이전 버전', 'start': 2832, 'end': 2844, 'type': 'COM'}","{'word': '타입 상태 분석 기능', 'start': 2860, 'end': 2870, 'type': 'COM'}",com:sub_concept
1314,"러스트 0.2는 처음으로 클래스를 도입하였고, 0.3에는 소멸자와 인터페이스가 도입되었다.","{'word': '러스트 0.2', 'start': 3028, 'end': 3034, 'type': 'COM'}","{'word': '클래스', 'start': 3042, 'end': 3044, 'type': 'COM'}",com:sub_concept
1315,"러스트 0.2는 처음으로 클래스를 도입하였고, 0.3에는 소멸자와 인터페이스가 도입되었다.","{'word': '0.3', 'start': 3054, 'end': 3056, 'type': 'COM'}","{'word': '소멸자', 'start': 3060, 'end': 3062, 'type': 'COM'}",com:sub_concept
1316,"러스트 0.2는 처음으로 클래스를 도입하였고, 0.3에는 소멸자와 인터페이스가 도입되었다.","{'word': '0.3', 'start': 3054, 'end': 3056, 'type': 'COM'}","{'word': '인터페이스', 'start': 3065, 'end': 3069, 'type': 'COM'}",com:sub_concept
1317,"그러나 0.4에 trait 기능이 도입되면서 인터페이스는 trait와 통합되었고, class는 제거되었다.","{'word': '0.4', 'start': 3083, 'end': 3085, 'type': 'COM'}","{'word': 'trait 기능', 'start': 3088, 'end': 3095, 'type': 'COM'}",com:sub_concept
1318,"러스트 파운데이션(Rust Foundation)은 참여형 대규모 오픈 소스 생태계를 유지하고 성장시키는 새로운 접근 방식으로 ""좋은 소프트웨어는 행복하고 잘 지원되는 사람들에 의해 만들어집니다.""라는 모토를 갖고서 러스트(Rust) 프로그래밍 언어와 생태계를 관리하는 독립적인 비영리 조직으로, 프로젝트를 관리하고 개발하는 유지 관리자를 지원하는 데 중점을 두고 있다.","{'word': '러스트 파운데이션', 'start': 3212, 'end': 3220, 'type': 'COM'}","{'word': 'Rust Foundation', 'start': 3222, 'end': 3236, 'type': 'COM'}",com:alter_names
1319,"러스트 파운데이션(Rust Foundation)은 참여형 대규모 오픈 소스 생태계를 유지하고 성장시키는 새로운 접근 방식으로 ""좋은 소프트웨어는 행복하고 잘 지원되는 사람들에 의해 만들어집니다.""라는 모토를 갖고서 러스트(Rust) 프로그래밍 언어와 생태계를 관리하는 독립적인 비영리 조직으로, 프로젝트를 관리하고 개발하는 유지 관리자를 지원하는 데 중점을 두고 있다.","{'word': '러스트', 'start': 3332, 'end': 3334, 'type': 'COM'}","{'word': 'Rust', 'start': 3336, 'end': 3339, 'type': 'COM'}",com:alter_names
1320,러스트 공식홈페이지에서는 '플레이그라운드'(playground) 페이지를 통해서 실시간 빌드 및 실행 테스트 공간을 제공하고있다.,"{'word': ""'플레이그라운드'"", 'start': 3153, 'end': 3161, 'type': 'COM'}","{'word': 'playground', 'start': 3163, 'end': 3172, 'type': 'POH'}",com:alter_names
1321,러스트는 인터넷에서 실행되는 서버 및 클라이언트 프로그램을 개발하는데 적합한 언어를 목표로 설계되었다.,"{'word': '서버 및 클라이언트 프로그램', 'start': 667, 'end': 681, 'type': 'COM'}","{'word': '러스트', 'start': 651, 'end': 653, 'type': 'COM'}",com:made_of
1322,아래는 각각 재귀함수와 반복문을 사용해 작성된 계승 함수이다:,"{'word': '재귀함수', 'start': 1763, 'end': 1766, 'type': 'COM'}","{'word': '계승 함수', 'start': 1782, 'end': 1786, 'type': 'COM'}",com:made_of
1323,아래는 각각 재귀함수와 반복문을 사용해 작성된 계승 함수이다:,"{'word': '반복문', 'start': 1769, 'end': 1771, 'type': 'COM'}","{'word': '계승 함수', 'start': 1782, 'end': 1786, 'type': 'COM'}",com:made_of
1324,// `thread::spawn`을 통해 스레드를 생성한다.,"{'word': '`thread::spawn`', 'start': 2538, 'end': 2552, 'type': 'COM'}","{'word': '스레드', 'start': 2558, 'end': 2560, 'type': 'COM'}",com:made_of
1325,객체 시스템은 러스트 0.2에서 0.4에 거쳐 많은 변화를 겪었다.,"{'word': '0.4', 'start': 3008, 'end': 3010, 'type': 'COM'}","{'word': '러스트 0.2', 'start': 2998, 'end': 3004, 'type': 'COM'}",com:prior_tech
1326,"러스트 0.2는 처음으로 클래스를 도입하였고, 0.3에는 소멸자와 인터페이스가 도입되었다.","{'word': '0.3', 'start': 3054, 'end': 3056, 'type': 'COM'}","{'word': '러스트 0.2', 'start': 3028, 'end': 3034, 'type': 'COM'}",com:prior_tech
1327,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '구글', 'start': 3427, 'end': 3428, 'type': 'ORG'}","{'word': '마이크로소프트', 'start': 3431, 'end': 3437, 'type': 'ORG'}",no_relation
1328,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '구글', 'start': 3427, 'end': 3428, 'type': 'ORG'}","{'word': '모질라 재단', 'start': 3440, 'end': 3445, 'type': 'ORG'}",no_relation
1329,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '구글', 'start': 3427, 'end': 3428, 'type': 'ORG'}","{'word': '아마존 웹 서비스', 'start': 3448, 'end': 3456, 'type': 'ORG'}",no_relation
1330,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '구글', 'start': 3427, 'end': 3428, 'type': 'ORG'}","{'word': '화웨이', 'start': 3459, 'end': 3461, 'type': 'ORG'}",no_relation
1331,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '마이크로소프트', 'start': 3431, 'end': 3437, 'type': 'ORG'}","{'word': '모질라 재단', 'start': 3440, 'end': 3445, 'type': 'ORG'}",no_relation
1332,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '마이크로소프트', 'start': 3431, 'end': 3437, 'type': 'ORG'}","{'word': '아마존 웹 서비스', 'start': 3448, 'end': 3456, 'type': 'ORG'}",no_relation
1333,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '마이크로소프트', 'start': 3431, 'end': 3437, 'type': 'ORG'}","{'word': '화웨이', 'start': 3459, 'end': 3461, 'type': 'ORG'}",no_relation
1334,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '모질라 재단', 'start': 3440, 'end': 3445, 'type': 'ORG'}","{'word': '아마존 웹 서비스', 'start': 3448, 'end': 3456, 'type': 'ORG'}",no_relation
1335,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '모질라 재단', 'start': 3440, 'end': 3445, 'type': 'ORG'}","{'word': '화웨이', 'start': 3459, 'end': 3461, 'type': 'ORG'}",no_relation
1336,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '아마존 웹 서비스', 'start': 3448, 'end': 3456, 'type': 'ORG'}","{'word': '화웨이', 'start': 3459, 'end': 3461, 'type': 'ORG'}",no_relation
1337,"2010년 처음으로 일반에 공개되었으며, 같은 해 Objective Caml로 작성된 초기 컴파일러에서 Rust로 작성된 컴파일러로 전환되었다. ""rustc""는 2011년 처음으로 자기 자신을 컴파일하는데 성공했다.","{'word': '""rustc""', 'start': 272, 'end': 278, 'type': 'COM'}","{'word': '2011년', 'start': 281, 'end': 285, 'type': 'DAT'}",no_relation
1338,2012년 1월 첫 번째 알파 버전인 0.1이 발표되었다.,"{'word': '알파 버전', 'start': 326, 'end': 330, 'type': 'COM'}","{'word': '2012년 1월', 'start': 312, 'end': 319, 'type': 'DAT'}",no_relation
1339,"이 목표에 따라 러스트는 안전성과 병행 프로그래밍, 그리고 메모리 관리의 직접 제어에 초점을 맞추고 있다.","{'word': '병행 프로그래밍', 'start': 728, 'end': 735, 'type': 'COM'}","{'word': '메모리 관리', 'start': 742, 'end': 747, 'type': 'COM'}",no_relation
1340,러스트는 메모리 오류를 발생시키지 않도록 설계되었다.,"{'word': '러스트', 'start': 939, 'end': 941, 'type': 'COM'}","{'word': '메모리 오류', 'start': 944, 'end': 949, 'type': 'COM'}",no_relation
1341,러스트는 널 포인터나 초기화되지 않은 포인터가 존재하지 않도록 강제하고 있다.,"{'word': '러스트', 'start': 969, 'end': 971, 'type': 'COM'}","{'word': '널 포인터', 'start': 974, 'end': 978, 'type': 'COM'}",no_relation
1342,러스트는 널 포인터나 초기화되지 않은 포인터가 존재하지 않도록 강제하고 있다.,"{'word': '러스트', 'start': 969, 'end': 971, 'type': 'COM'}","{'word': '포인터', 'start': 990, 'end': 992, 'type': 'COM'}",no_relation
1343,"모든 변수는 초기값을 가지고 할당되며, 해제된 포인터에 접근하는 코드는 컴파일러가 미리 감지하여 컴파일 오류를 일으킨다.","{'word': '포인터', 'start': 1039, 'end': 1041, 'type': 'COM'}","{'word': '컴파일러', 'start': 1053, 'end': 1056, 'type': 'COM'}",no_relation
1344,"또한, 변수 선언 시 타입을 지정하지 않아도 컴파일러가 타입 추론을 통해 해당 변수의 타입을 지정할 수 있다.","{'word': '컴파일러', 'start': 1140, 'end': 1143, 'type': 'COM'}","{'word': '변수', 'start': 1159, 'end': 1160, 'type': 'COM'}",no_relation
1345,병행 프로그래밍은 얼랭과 유사한 actor 기반의 모델을 사용하고 있다.,"{'word': '병행 프로그래밍', 'start': 1212, 'end': 1219, 'type': 'COM'}","{'word': '얼랭', 'start': 1222, 'end': 1223, 'type': 'COM'}",no_relation
1346,각각의 태스크는 데이터를 직접 공유하지 않고 메시지 전달을 통해서만 데이터를 교환할 수 있다.,"{'word': '태스크', 'start': 1257, 'end': 1259, 'type': 'COM'}","{'word': '데이터', 'start': 1262, 'end': 1264, 'type': 'COM'}",no_relation
1347,"메시지를 복사할 때 생기는 성능 저하를 막기 위해, unique box의 경우 데이터 복사 없이 메시지를 전달할 수 있다.","{'word': 'unique box', 'start': 1335, 'end': 1344, 'type': 'COM'}","{'word': '데이터 복사', 'start': 1350, 'end': 1355, 'type': 'COM'}",no_relation
1348,"unique box는 하나의 객체만이 소유할 수 있고, 다른 태스크로 전달될 경우 데이터 복사 없이 소유권만 바뀌게 된다.","{'word': 'unique box', 'start': 1375, 'end': 1384, 'type': 'COM'}","{'word': '태스크', 'start': 1409, 'end': 1411, 'type': 'COM'}",no_relation
1349,아래는 각각 재귀함수와 반복문을 사용해 작성된 계승 함수이다:,"{'word': '재귀함수', 'start': 1763, 'end': 1766, 'type': 'COM'}","{'word': '반복문', 'start': 1769, 'end': 1771, 'type': 'COM'}",no_relation
1350,// `mut` 키워드는 값이 바뀔 수 있는 변수를 가리킨다.,"{'word': '`mut` 키워드', 'start': 1971, 'end': 1979, 'type': 'COM'}","{'word': '변수', 'start': 1993, 'end': 1994, 'type': 'COM'}",no_relation
1351,return result; // 위의 예제와 달리 명시적 반환문을 사용한다,"{'word': '예제', 'start': 2062, 'end': 2063, 'type': 'COM'}","{'word': '반환문', 'start': 2073, 'end': 2075, 'type': 'COM'}",no_relation
1352,// 1.21 버전부터는 for_each가 가능해졌다.,"{'word': '1.21 버전', 'start': 2131, 'end': 2137, 'type': 'COM'}","{'word': 'for_each', 'start': 2142, 'end': 2149, 'type': 'COM'}",no_relation
1353,/* 이 함수는 각각 병렬적으로 실행되는 10개의 스레드를 만든다.,"{'word': '함수', 'start': 2253, 'end': 2254, 'type': 'COM'}","{'word': '스레드', 'start': 2276, 'end': 2278, 'type': 'COM'}",no_relation
1354,"각각의 스레드가 stdout에 접근을 시도함에 따라, 한 행에 여러 문자열이 섞여서","{'word': '스레드', 'start': 2290, 'end': 2292, 'type': 'COM'}","{'word': 'stdout', 'start': 2295, 'end': 2300, 'type': 'COM'}",no_relation
1355,"// 변수 message는 변경이 불가능하므로, 여러 개의 태스크에서 동시에 접근해도 안전하다.","{'word': '변수 message', 'start': 2353, 'end': 2362, 'type': 'COM'}","{'word': '태스크', 'start': 2383, 'end': 2385, 'type': 'COM'}",no_relation
1356,// `for` 반복문은 `Iterator` trait을 구현하는 어떤 객체에 대해서나 사용할 수 있다.,"{'word': '`for` 반복문', 'start': 2460, 'end': 2468, 'type': 'COM'}","{'word': '`Iterator` trait', 'start': 2471, 'end': 2486, 'type': 'COM'}",no_relation
1357,"// println! 은 매크로이며, 컴파일 시간에 변수의 형 검사가 이루어진다.","{'word': '매크로', 'start': 2620, 'end': 2622, 'type': 'COM'}","{'word': '컴파일', 'start': 2627, 'end': 2629, 'type': 'COM'}",no_relation
1358,타입 상태 분석 기능은 선언문 전후에 codice_8 키워드를 사용하여 해당 선언문이 의도대로 동작하는지 컴파일시에 검사할 수 있었다.,"{'word': '타입 상태 분석 기능', 'start': 2880, 'end': 2890, 'type': 'COM'}","{'word': '선언문', 'start': 2893, 'end': 2895, 'type': 'COM'}",no_relation
1359,타입 상태 분석 기능은 선언문 전후에 codice_8 키워드를 사용하여 해당 선언문이 의도대로 동작하는지 컴파일시에 검사할 수 있었다. 그러나 이 기능은 실질적으로 거의 사용되지 않아 제거되었다.,"{'word': '선언문', 'start': 2923, 'end': 2925, 'type': 'COM'}","{'word': '기능', 'start': 2962, 'end': 2963, 'type': 'COM'}",no_relation
1360,"이 목표에 따라 러스트는 안전성과 병행 프로그래밍, 그리고 메모리 관리의 직접 제어에 초점을 맞추고 있다. 또한 성능 면에서는 C++와 비슷한 수준을 목표로 하고 있다.","{'word': '러스트', 'start': 718, 'end': 720, 'type': 'COM'}","{'word': 'C++', 'start': 780, 'end': 782, 'type': 'COM'}",com:similar_tech
1361,"러스트의 문법은 중괄호로 코드 블록을 구분하고, codice_1, codice_2, codice_3 등의 키워드를 사용하는 등 C 및 C++와 유사한 모양을 하고 있다.","{'word': '러스트', 'start': 804, 'end': 806, 'type': 'COM'}","{'word': 'C', 'start': 875, 'end': 875, 'type': 'COM'}",com:similar_tech
1362,"러스트의 문법은 중괄호로 코드 블록을 구분하고, codice_1, codice_2, codice_3 등의 키워드를 사용하는 등 C 및 C++와 유사한 모양을 하고 있다.","{'word': '러스트', 'start': 804, 'end': 806, 'type': 'COM'}","{'word': 'C++', 'start': 879, 'end': 881, 'type': 'COM'}",com:similar_tech
1363,그러나 러스트와 C/C++는 의미상으로는 크게 다른 문법을 갖고 있다.,"{'word': '러스트', 'start': 903, 'end': 905, 'type': 'COM'}","{'word': 'C', 'start': 908, 'end': 908, 'type': 'COM'}",com:similar_tech
1364,그러나 러스트와 C/C++는 의미상으로는 크게 다른 문법을 갖고 있다.,"{'word': '러스트', 'start': 903, 'end': 905, 'type': 'COM'}","{'word': 'C++', 'start': 910, 'end': 912, 'type': 'COM'}",com:similar_tech
1365,세계 최초의 컴파일러는 1952년 그레이스 호퍼가 개발한 프로그래밍 언어 A-0를 기계어로 번역하는 컴파일러이다.,"{'word': '그레이스 호퍼', 'start': 896, 'end': 902, 'type': 'PER'}","{'word': '프로그래밍 언어 A-0를 기계어로 번역하는 컴파일러', 'start': 909, 'end': 936, 'type': 'COM'}",per:production
1366,세계 최초의 컴파일러는 1952년 그레이스 호퍼가 개발한 프로그래밍 언어 A-0를 기계어로 번역하는 컴파일러이다.,"{'word': '그레이스 호퍼', 'start': 896, 'end': 902, 'type': 'PER'}","{'word': '세계 최초의 컴파일러', 'start': 877, 'end': 887, 'type': 'COM'}",per:production
1367,컴파일러라는 용어 또한 이때 호퍼가 처음 사용하였다.,"{'word': '호퍼', 'start': 957, 'end': 958, 'type': 'PER'}","{'word': '컴파일러', 'start': 941, 'end': 944, 'type': 'COM'}",per:production
1368,"최적화 기능이 탑재된 최초의 ""완전한"" 컴파일러는 1957년 IBM의 존 배커스가 개발한 포트란 컴파일러이다.","{'word': '존 배커스', 'start': 1010, 'end': 1014, 'type': 'PER'}","{'word': '포트란 컴파일러', 'start': 1021, 'end': 1028, 'type': 'COM'}",per:production
1369,세계 최초의 컴파일러는 1952년 그레이스 호퍼가 개발한 프로그래밍 언어 A-0를 기계어로 번역하는 컴파일러이다.,"{'word': '세계 최초의 컴파일러', 'start': 877, 'end': 887, 'type': 'COM'}","{'word': '1952년', 'start': 890, 'end': 894, 'type': 'DAT'}",com:date_of_prod
1370,"최적화 기능이 탑재된 최초의 ""완전한"" 컴파일러는 1957년 IBM의 존 배커스가 개발한 포트란 컴파일러이다.","{'word': '포트란 컴파일러', 'start': 1021, 'end': 1028, 'type': 'COM'}","{'word': '1957년', 'start': 999, 'end': 1003, 'type': 'DAT'}",com:date_of_prod
1371,"그러나 현대에 들어 많은 인터프리터가 JIT 컴파일 등의 기술로 실시간 컴파일을 수행하므로, 컴파일러와 인터프리터 사이의 기술적 구분은 사라져 가는 추세이다.","{'word': '인터프리터', 'start': 409, 'end': 413, 'type': 'COM'}","{'word': 'JIT 컴파일', 'start': 416, 'end': 422, 'type': 'COM'}",com:sub_concept
1372,"좁은 의미의 컴파일러는 주로 고수준 언어로 쓰인 소스 코드를 저수준 언어(어셈블리어, 기계어 등)로 번역하는 프로그램을 가리킨다.","{'word': '저수준 언어', 'start': 593, 'end': 598, 'type': 'COM'}","{'word': '어셈블리어', 'start': 600, 'end': 604, 'type': 'COM'}",com:sub_concept
1373,"좁은 의미의 컴파일러는 주로 고수준 언어로 쓰인 소스 코드를 저수준 언어(어셈블리어, 기계어 등)로 번역하는 프로그램을 가리킨다.","{'word': '저수준 언어', 'start': 593, 'end': 598, 'type': 'COM'}","{'word': '기계어', 'start': 607, 'end': 609, 'type': 'COM'}",com:sub_concept
1374,C/C++언어와 같은 고급언어는 직접 기계어 코드로 변환한다.,"{'word': '고급언어', 'start': 1430, 'end': 1433, 'type': 'COM'}","{'word': 'C', 'start': 1418, 'end': 1418, 'type': 'COM'}",com:sub_concept
1375,C/C++언어와 같은 고급언어는 직접 기계어 코드로 변환한다.,"{'word': '고급언어', 'start': 1430, 'end': 1433, 'type': 'COM'}","{'word': 'C++', 'start': 1420, 'end': 1422, 'type': 'COM'}",com:sub_concept
1376,마이크로프로세서는 각각 다른 기계어 코드를 가지고 있기 때문에 같은 고급언어라도 다른 기계어 코드를 생성해야 한다.,"{'word': '마이크로프로세서', 'start': 1453, 'end': 1460, 'type': 'COM'}","{'word': '기계어 코드', 'start': 1469, 'end': 1474, 'type': 'COM'}",com:sub_concept
1377,그러나 자바는 다양한 마이크로프로세서에서 실행되도록 하는 철학을 가지고 개발되었기 때문에 바이트 코드를 가지고 해석을 해서 실행하는 방식이다.,"{'word': '자바', 'start': 1562, 'end': 1563, 'type': 'COM'}","{'word': '바이트 코드', 'start': 1608, 'end': 1613, 'type': 'COM'}",com:sub_concept
1378,"컴파일러(compiler, 해석기, 번역기)는 특정 프로그래밍 언어로 쓰여 있는 문서를 다른 프로그래밍 언어로 옮기는 언어 번역 프로그램을 말한다.","{'word': '컴파일러', 'start': 0, 'end': 3, 'type': 'COM'}","{'word': 'compiler', 'start': 5, 'end': 12, 'type': 'COM'}",com:alter_names
1379,"컴파일러(compiler, 해석기, 번역기)는 특정 프로그래밍 언어로 쓰여 있는 문서를 다른 프로그래밍 언어로 옮기는 언어 번역 프로그램을 말한다.","{'word': '컴파일러', 'start': 0, 'end': 3, 'type': 'COM'}","{'word': '해석기', 'start': 15, 'end': 17, 'type': 'COM'}",com:alter_names
1380,"원시 코드에서 목적 코드로 옮기는 과정을 컴파일(compile, 옮김, 번역, )이라고 한다.","{'word': '컴파일', 'start': 320, 'end': 322, 'type': 'COM'}","{'word': 'compile', 'start': 324, 'end': 330, 'type': 'COM'}",com:alter_names
1381,"원시 코드에서 목적 코드로 옮기는 과정을 컴파일(compile, 옮김, 번역, )이라고 한다.","{'word': '컴파일', 'start': 320, 'end': 322, 'type': 'COM'}","{'word': '옮김', 'start': 333, 'end': 334, 'type': 'COM'}",com:alter_names
1382,"원시 코드에서 목적 코드로 옮기는 과정을 컴파일(compile, 옮김, 번역, )이라고 한다.","{'word': '컴파일', 'start': 320, 'end': 322, 'type': 'COM'}","{'word': '번역', 'start': 337, 'end': 338, 'type': 'COM'}",com:alter_names
1383,컴파일러가 실행되는 컴퓨터나 운영체제가 컴파일러의 목적코드가 실행될 컴퓨터나 운영체제와 같은 경우 네이티브 컴파일러(native compiler 또는 hosted compiler)라고 한다.,"{'word': '네이티브 컴파일러', 'start': 1961, 'end': 1969, 'type': 'COM'}","{'word': 'native compiler', 'start': 1971, 'end': 1985, 'type': 'COM'}",com:alter_names
1384,컴파일러가 실행되는 컴퓨터나 운영체제가 컴파일러의 목적코드가 실행될 컴퓨터나 운영체제와 같은 경우 네이티브 컴파일러(native compiler 또는 hosted compiler)라고 한다.,"{'word': '네이티브 컴파일러', 'start': 1961, 'end': 1969, 'type': 'COM'}","{'word': 'hosted compiler', 'start': 1990, 'end': 2004, 'type': 'COM'}",com:alter_names
1385,반면에 크로스 컴파일러(cross compiler)는 다른 컴퓨터나 운영체제에서 실행되도록 제작된다.,"{'word': '크로스 컴파일러', 'start': 2017, 'end': 2024, 'type': 'COM'}","{'word': 'cross compiler', 'start': 2026, 'end': 2039, 'type': 'COM'}",com:alter_names
1386,초기 컴퓨터 프로그램들은 어셈블리어로 작성되었다.,"{'word': '초기 컴퓨터 프로그램', 'start': 632, 'end': 642, 'type': 'COM'}","{'word': '어셈블리어', 'start': 646, 'end': 650, 'type': 'COM'}",com:made_of
1387,소스를 한 번 읽고 번역하여 바로 출력물을 내놓는 컴파일러도 있지만 여러 가지 목적을 위해 중간 결과를 만들어 그 결과를 다시 최종 결과로 출력하는 컴파일러도 있다.,"{'word': '컴파일러', 'start': 2264, 'end': 2267, 'type': 'COM'}","{'word': '출력물', 'start': 2255, 'end': 2257, 'type': 'COM'}",com:made_of
1388,"이런 조건이 없다면 컴파일러를 사용하는 사용자가 컴파일러를 믿고 프로그램을 작성할 수도 없고, 잘못된 옮김을 인정한다면 컴파일러를 올바르게 하기 위한 노력을 들일 필요가 없을 것이다.","{'word': '사용자', 'start': 1149, 'end': 1151, 'type': 'PER'}","{'word': '컴파일러', 'start': 1154, 'end': 1157, 'type': 'COM'}",no_relation
1389,따라서 개발자는 해당 마이크로프로세서에 맞는 컴파일러를 사용해야 한다.,"{'word': '개발자', 'start': 1522, 'end': 1524, 'type': 'PER'}","{'word': '마이크로프로세서', 'start': 1530, 'end': 1537, 'type': 'COM'}",no_relation
1390,따라서 개발자는 해당 마이크로프로세서에 맞는 컴파일러를 사용해야 한다.,"{'word': '개발자', 'start': 1522, 'end': 1524, 'type': 'PER'}","{'word': '컴파일러', 'start': 1543, 'end': 1546, 'type': 'COM'}",no_relation
1391,컴파일러에서 꼭 지켜야 할 두 가지 조건이 있다.,"{'word': '컴파일러', 'start': 1033, 'end': 1036, 'type': 'COM'}","{'word': '조건', 'start': 1053, 'end': 1054, 'type': 'POH'}",no_relation
1392,"컴파일러는 를 실행 프로그램을 만들기 위한 (예, 어셈블리 언어, object 코드, machine code)로 바꾸는 데 사용된다.","{'word': '컴파일러', 'start': 83, 'end': 86, 'type': 'COM'}","{'word': '실행 프로그램', 'start': 91, 'end': 97, 'type': 'COM'}",no_relation
1393,"원래의 문서를 소스 코드 혹은 원시 코드라고 부르고, 출력된 문서를 목적 코드라고 부른다.","{'word': '소스 코드', 'start': 166, 'end': 170, 'type': 'COM'}","{'word': '목적 코드', 'start': 196, 'end': 200, 'type': 'COM'}",no_relation
1394,목적 코드는 주로 다른 프로그램이나 하드웨어가 처리하기에 용이한 형태로 출력되지만 사람이 읽을 수 있는 문서 파일이나 그림 파일 등으로 옮기는 경우도 있다.,"{'word': '목적 코드', 'start': 209, 'end': 213, 'type': 'COM'}","{'word': '하드웨어', 'start': 229, 'end': 232, 'type': 'COM'}",no_relation
1395,"원시 코드에서 목적 코드로 옮기는 과정을 컴파일(compile, 옮김, 번역, )이라고 한다.","{'word': '원시 코드', 'start': 297, 'end': 301, 'type': 'COM'}","{'word': '컴파일', 'start': 320, 'end': 322, 'type': 'COM'}",no_relation
1396,컴파일러는 소스 프로그램을 읽어서 즉시 결과를 출력하는 인터프리터와는 구분된다.,"{'word': '컴파일러', 'start': 350, 'end': 353, 'type': 'COM'}","{'word': '인터프리터', 'start': 381, 'end': 385, 'type': 'COM'}",no_relation
1397,"그러나 현대에 들어 많은 인터프리터가 JIT 컴파일 등의 기술로 실시간 컴파일을 수행하므로, 컴파일러와 인터프리터 사이의 기술적 구분은 사라져 가는 추세이다.","{'word': '컴파일러', 'start': 447, 'end': 450, 'type': 'COM'}","{'word': '인터프리터', 'start': 453, 'end': 457, 'type': 'COM'}",no_relation
1398,소스 코드를 컴파일하는 이유는 대부분 사람에게 이해하기 쉬운 형태의 고수준 언어로부터 실행가능한 기계어 프로그램을 만들기 위해서이다.,"{'word': '소스 코드', 'start': 484, 'end': 488, 'type': 'COM'}","{'word': '기계어 프로그램', 'start': 538, 'end': 545, 'type': 'COM'}",no_relation
1399,"좁은 의미의 컴파일러는 주로 고수준 언어로 쓰인 소스 코드를 저수준 언어(어셈블리어, 기계어 등)로 번역하는 프로그램을 가리킨다.","{'word': '컴파일러', 'start': 566, 'end': 569, 'type': 'COM'}","{'word': '소스 코드', 'start': 586, 'end': 590, 'type': 'COM'}",no_relation
1400,"그러나 서로 다른 CPU 아키텍처가 등장할 때마다 매번 똑같은 프로그램을 서로 다른 어셈블리어로 작성하는 비용이 커지면서, 고급 프로그래밍 언어의 필요성이 대두되었다.","{'word': '어셈블리어', 'start': 707, 'end': 711, 'type': 'COM'}","{'word': '고급 프로그래밍 언어', 'start': 729, 'end': 739, 'type': 'COM'}",no_relation
1401,"그러나 초기 컴퓨터 하드웨어의 메모리 크기가 너무 작아, 컴파일러의 등장에 기술적 장애물이 되었다.","{'word': '초기 컴퓨터 하드웨어', 'start': 758, 'end': 768, 'type': 'COM'}","{'word': '컴파일러', 'start': 786, 'end': 789, 'type': 'COM'}",no_relation
1402,"1950년대 초부터 기계어에 독립적인 최초의 고급 프로그래밍 언어가 나타났고, 실험적인 컴파일러들이 등장하기 시작했다.","{'word': '고급 프로그래밍 언어', 'start': 835, 'end': 845, 'type': 'COM'}","{'word': '컴파일러', 'start': 859, 'end': 862, 'type': 'COM'}",no_relation
1403,"첫째로, 컴파일러는 옮김의 과정에서 프로그램의 뜻을 보존하여야 한다.","{'word': '컴파일러', 'start': 1066, 'end': 1069, 'type': 'COM'}","{'word': '프로그램', 'start': 1081, 'end': 1084, 'type': 'COM'}",no_relation
1404,"첫째로, 컴파일러는 옮김의 과정에서 프로그램의 뜻을 보존하여야 한다. 입력받은 프로그램의 의미를 충실히 따라야 한다.","{'word': '컴파일러', 'start': 1066, 'end': 1069, 'type': 'COM'}","{'word': '프로그램', 'start': 1105, 'end': 1108, 'type': 'COM'}",no_relation
1405,"두 번째로, 실용적인 면에서, 컴파일러는 입력으로 들어온 프로그램을 어떤 면에서든지 개선해야 한다.","{'word': '컴파일러', 'start': 1247, 'end': 1250, 'type': 'COM'}","{'word': '프로그램', 'start': 1262, 'end': 1265, 'type': 'COM'}",no_relation
1406,"예를 들어, 소스 코드를 기계어로 옮긴다면 기계가 이해할 수 없었던 언어를 기계가 이해할 수 있게 개선한 것이 된다.","{'word': '소스 코드', 'start': 1293, 'end': 1297, 'type': 'COM'}","{'word': '기계어', 'start': 1300, 'end': 1302, 'type': 'COM'}",no_relation
1407,같은 언어로 옮긴 경우에는 성능이 개선되는 등의 장점이 있어야 한다.,"{'word': '언어', 'start': 1355, 'end': 1356, 'type': 'COM'}","{'word': '성능', 'start': 1367, 'end': 1368, 'type': 'COM'}",no_relation
1408,같은 언어로 옮긴 경우에는 성능이 개선되는 등의 장점이 있어야 한다. 그렇지 않다면 컴파일을 수행할 이유가 없어진다.,"{'word': '언어', 'start': 1355, 'end': 1356, 'type': 'COM'}","{'word': '컴파일', 'start': 1399, 'end': 1401, 'type': 'COM'}",no_relation
1409,그러나 자바는 다양한 마이크로프로세서에서 실행되도록 하는 철학을 가지고 개발되었기 때문에 바이트 코드를 가지고 해석을 해서 실행하는 방식이다.,"{'word': '자바', 'start': 1562, 'end': 1563, 'type': 'COM'}","{'word': '마이크로프로세서', 'start': 1570, 'end': 1577, 'type': 'COM'}",no_relation
1410,장점은 한번 컴파일된 바이트 코드는 다른 플랫폼에서 재컴파일없이 실행할 수 있다.,"{'word': '바이트 코드', 'start': 1650, 'end': 1655, 'type': 'COM'}","{'word': '플랫폼', 'start': 1661, 'end': 1663, 'type': 'COM'}",no_relation
1411,"그러나 단점은 바이트 코드를 해석해서 실행할 프로그램 구조가 필요하고, 직접 기계어 코드를 실행하는 것 보다 속도에서 늦다.","{'word': '바이트 코드', 'start': 1692, 'end': 1697, 'type': 'COM'}","{'word': '프로그램 구조', 'start': 1709, 'end': 1715, 'type': 'COM'}",no_relation
1412,"그러나 단점은 바이트 코드를 해석해서 실행할 프로그램 구조가 필요하고, 직접 기계어 코드를 실행하는 것 보다 속도에서 늦다.","{'word': '바이트 코드', 'start': 1692, 'end': 1697, 'type': 'COM'}","{'word': '기계어 코드', 'start': 1727, 'end': 1732, 'type': 'COM'}",no_relation
1413,많은 수의 컴파일러는 다음과 같은 순서를 거쳐 소스 코드를 번역한다.,"{'word': '컴파일러', 'start': 1760, 'end': 1763, 'type': 'COM'}","{'word': '소스 코드', 'start': 1780, 'end': 1784, 'type': 'COM'}",no_relation
1414,컴파일러나 프로그래밍 언어의 특성에 따라 일부 단계는 생략되거나 더 세부적인 단계로 나뉠 수도 있다.,"{'word': '컴파일러', 'start': 1793, 'end': 1796, 'type': 'COM'}","{'word': '프로그래밍 언어', 'start': 1799, 'end': 1806, 'type': 'COM'}",no_relation
1415,"컴파일러는 입출력되는 언어의 종류, 내부구조, 목적코드의 동작에 따라 여러 가지로 분류할 수 있다.","{'word': '컴파일러', 'start': 1850, 'end': 1853, 'type': 'COM'}","{'word': '언어의 종류', 'start': 1862, 'end': 1867, 'type': 'COM'}",no_relation
1416,"컴파일러는 입출력되는 언어의 종류, 내부구조, 목적코드의 동작에 따라 여러 가지로 분류할 수 있다.","{'word': '컴파일러', 'start': 1850, 'end': 1853, 'type': 'COM'}","{'word': '내부구조', 'start': 1870, 'end': 1873, 'type': 'COM'}",no_relation
1417,"컴파일러는 입출력되는 언어의 종류, 내부구조, 목적코드의 동작에 따라 여러 가지로 분류할 수 있다.","{'word': '컴파일러', 'start': 1850, 'end': 1853, 'type': 'COM'}","{'word': '목적코드', 'start': 1876, 'end': 1879, 'type': 'COM'}",no_relation
1418,"컴파일러는 입출력되는 언어의 종류, 내부구조, 목적코드의 동작에 따라 여러 가지로 분류할 수 있다.","{'word': '언어의 종류', 'start': 1862, 'end': 1867, 'type': 'COM'}","{'word': '내부구조', 'start': 1870, 'end': 1873, 'type': 'COM'}",no_relation
1419,"컴파일러는 입출력되는 언어의 종류, 내부구조, 목적코드의 동작에 따라 여러 가지로 분류할 수 있다.","{'word': '언어의 종류', 'start': 1862, 'end': 1867, 'type': 'COM'}","{'word': '목적코드', 'start': 1876, 'end': 1879, 'type': 'COM'}",no_relation
1420,"컴파일러는 입출력되는 언어의 종류, 내부구조, 목적코드의 동작에 따라 여러 가지로 분류할 수 있다.","{'word': '내부구조', 'start': 1870, 'end': 1873, 'type': 'COM'}","{'word': '목적코드', 'start': 1876, 'end': 1879, 'type': 'COM'}",no_relation
1421,컴파일러가 실행되는 컴퓨터나 운영체제가 컴파일러의 목적코드가 실행될 컴퓨터나 운영체제와 같은 경우 네이티브 컴파일러(native compiler 또는 hosted compiler)라고 한다.,"{'word': '컴퓨터나 운영체제', 'start': 1917, 'end': 1925, 'type': 'COM'}","{'word': '컴파일러', 'start': 1928, 'end': 1931, 'type': 'COM'}",no_relation
1422,임베디드 시스템 등 소프트웨어 개발에 충분한 환경을 갖추지 못한 환경에서 동작할 프로그램을 만들기 위해 사용된다.,"{'word': '임베디드 시스템', 'start': 2070, 'end': 2077, 'type': 'COM'}","{'word': '프로그램', 'start': 2115, 'end': 2118, 'type': 'COM'}",no_relation
1423,또한 가상 머신에서 동작할 프로그램을 만드는 컴파일러도 있다.,"{'word': '가상 머신', 'start': 2137, 'end': 2141, 'type': 'COM'}","{'word': '컴파일러', 'start': 2159, 'end': 2162, 'type': 'COM'}",no_relation
1424,이 경우 일반적으로 출력물이 가상 머신을 위해 제작된 바이트코드 형태의 기계어가 되므로 바이트코드 컴파일러라고 부른다.,"{'word': '가상 머신', 'start': 2185, 'end': 2189, 'type': 'COM'}","{'word': '바이트코드 컴파일러', 'start': 2218, 'end': 2227, 'type': 'COM'}",no_relation
1425,C/C++언어와 같은 고급언어는 직접 기계어 코드로 변환한다.,"{'word': 'C', 'start': 1418, 'end': 1418, 'type': 'COM'}","{'word': 'C++', 'start': 1420, 'end': 1422, 'type': 'COM'}",com:similar_tech
1426,"컴퓨터 과학자이자 튜링상을 받은 에츠허르 데이크스트라는 ""코볼을 이용하는 일은 마음을 무력하게 만든다.","{'word': '에츠허르 데이크스트라', 'start': 80, 'end': 90, 'type': 'PER'}","{'word': '컴퓨터 과학자', 'start': 62, 'end': 68, 'type': 'POH'}",per:title
1427,트래블러스 인슈런스(Travelers Insurance)의 CIO 조지프 T. 브로피는 막중한 프로그래밍 비용을 들이는 코볼 사용자들에게 새로운 표준의 구현을 알리는 일을 진두지휘하였다.,"{'word': '조지프 T. 브로피', 'start': 1298, 'end': 1307, 'type': 'PER'}","{'word': 'CIO', 'start': 1294, 'end': 1296, 'type': 'POH'}",per:title
1428,"단기 위원회 구성원인 진 사멧은 ""전문 프로그래머에게 제공하려는 시도는 거의 없었다.","{'word': '진 사멧', 'start': 1838, 'end': 1841, 'type': 'PER'}","{'word': '구성원', 'start': 1833, 'end': 1835, 'type': 'POH'}",per:title
1429,"CODASYL 코볼 위원회의 의장인 도널드 넬슨은 1984년에 ""학계가 ... 코볼을 싫어한다""고 말했고 컴퓨터 과학 동문들은 ""'코볼이 싫다'라는 것을 그들에게 주입시켰다""고 말했다.","{'word': '도널드 넬슨', 'start': 2572, 'end': 2577, 'type': 'PER'}","{'word': '의장', 'start': 2568, 'end': 2569, 'type': 'POH'}",per:title
1430,"설계 과정이 효과적인지에 대한 의구심이 있었다. (가끔은 코볼에 참여한 사람들까지도) 단기 위원회 구성원 호워드 브롬버그는 개발 과정에서 통제가 거의 없었으며 ""소속 인원의 지속성이 없고 ... 재능의 부족으로 홍역을 치렀다""고 말했다.","{'word': '호워드 브롬버그', 'start': 2955, 'end': 2962, 'type': 'PER'}","{'word': '구성원', 'start': 2951, 'end': 2953, 'type': 'POH'}",per:title
1431,트래블러스 인슈런스(Travelers Insurance)의 CIO 조지프 T. 브로피는 막중한 프로그래밍 비용을 들이는 코볼 사용자들에게 새로운 표준의 구현을 알리는 일을 진두지휘하였다.,"{'word': '트래블러스 인슈런스', 'start': 1261, 'end': 1270, 'type': 'ORG'}","{'word': '조지프 T. 브로피', 'start': 1298, 'end': 1307, 'type': 'ORG'}",org:members
1432,"단기 위원회 구성원인 진 사멧은 ""전문 프로그래머에게 제공하려는 시도는 거의 없었다.","{'word': '단기 위원회', 'start': 1826, 'end': 1831, 'type': 'ORG'}","{'word': '진 사멧', 'start': 1838, 'end': 1841, 'type': 'ORG'}",org:members
1433,"CODASYL 코볼 위원회의 의장인 도널드 넬슨은 1984년에 ""학계가 ... 코볼을 싫어한다""고 말했고 컴퓨터 과학 동문들은 ""'코볼이 싫다'라는 것을 그들에게 주입시켰다""고 말했다.","{'word': 'CODASYL 코볼 위원회', 'start': 2552, 'end': 2565, 'type': 'ORG'}","{'word': '도널드 넬슨', 'start': 2572, 'end': 2577, 'type': 'ORG'}",org:members
1434,"설계 과정이 효과적인지에 대한 의구심이 있었다. (가끔은 코볼에 참여한 사람들까지도) 단기 위원회 구성원 호워드 브롬버그는 개발 과정에서 통제가 거의 없었으며 ""소속 인원의 지속성이 없고 ... 재능의 부족으로 홍역을 치렀다""고 말했다.","{'word': '단기 위원회', 'start': 2944, 'end': 2949, 'type': 'ORG'}","{'word': '호워드 브롬버그', 'start': 2955, 'end': 2962, 'type': 'ORG'}",org:members
1435,"데이터와 코드의 추가적인 제어는 2002년에 도입되어 객체 지향 프로그래밍, 사용자 지정 함수, 사용자 지정 자료형이 포함되었다.","{'word': '데이터와 코드의 추가적인 제어', 'start': 1066, 'end': 1081, 'type': 'COM'}","{'word': '2002', 'start': 1084, 'end': 1087, 'type': 'DAT'}",com:date_of_prod
1436,문을 코볼 코드에서 제거하려는 시도는 그러나 난해한 프로그램들을 만들고 코드 품질을 떨어트렸다.,"{'word': '프로그램', 'start': 283, 'end': 286, 'type': 'COM'}","{'word': '코드', 'start': 260, 'end': 261, 'type': 'COM'}",com:sub_concept
1437,그러나 문은 오직 프로시저와 함께 쓰일 수 있으므로 반복문은 이들이 사용하는 곳에 위치되지 않아 프로그램을 이해하기 더 어렵게 만들게 된다.,"{'word': '프로그램', 'start': 441, 'end': 444, 'type': 'COM'}","{'word': '반복문', 'start': 416, 'end': 418, 'type': 'COM'}",com:sub_concept
1438,코볼 코드는 프로시저를 통해서만 모듈성을 이룰 수 있어 대형 시스템에서는 부적절한 것으로 알려져 있었다.,"{'word': '코볼 코드', 'start': 506, 'end': 510, 'type': 'COM'}","{'word': '프로시저', 'start': 513, 'end': 516, 'type': 'COM'}",com:sub_concept
1439,코볼 코드는 프로시저를 통해서만 모듈성을 이룰 수 있어 대형 시스템에서는 부적절한 것으로 알려져 있었다.,"{'word': '대형 시스템', 'start': 537, 'end': 542, 'type': 'COM'}","{'word': '코볼 코드', 'start': 506, 'end': 510, 'type': 'COM'}",com:sub_concept
1440,"데이터로의 접근을 제한하는 것이 불가능하였는데, 다시 말해 프로시저 하나가 어떠한 데이터 항목이라도 접근하여 수정할 수 있었다.","{'word': '데이터 항목', 'start': 611, 'end': 616, 'type': 'COM'}","{'word': '프로시저', 'start': 598, 'end': 601, 'type': 'COM'}",com:sub_concept
1441,"게다가 매개변수를 프로시저에 보내는 방법이 없었는데, 이를 빠트린 것을 두고 진 사멧은 위원회의 최대 실수로 간주하였다.","{'word': '프로시저', 'start': 647, 'end': 650, 'type': 'COM'}","{'word': '매개변수', 'start': 641, 'end': 644, 'type': 'COM'}",com:sub_concept
1442,코볼-74는 하부 프로그램들을 추가하여 프로그래머들에게 각 프로그램 부분이 접근할 수 있는 데이터를 제어하는 기능을 제공하였다.,"{'word': '코볼-74', 'start': 914, 'end': 918, 'type': 'COM'}","{'word': '하부 프로그램', 'start': 921, 'end': 927, 'type': 'COM'}",com:sub_concept
1443,코볼-74는 하부 프로그램들을 추가하여 프로그래머들에게 각 프로그램 부분이 접근할 수 있는 데이터를 제어하는 기능을 제공하였다.,"{'word': '코볼-74', 'start': 914, 'end': 918, 'type': 'COM'}","{'word': '데이터를 제어하는 기능', 'start': 965, 'end': 976, 'type': 'COM'}",com:sub_concept
1444,그 뒤로 코볼-85는 내재형 하위 프로그램(nested subprogram)을 추가하여 프로그래머들이 하위 프로그램들을 숨길 수 있게 하였다.,"{'word': '코볼-85', 'start': 991, 'end': 995, 'type': 'COM'}","{'word': '내재형 하위 프로그램', 'start': 998, 'end': 1008, 'type': 'COM'}",com:sub_concept
1445,"데이터와 코드의 추가적인 제어는 2002년에 도입되어 객체 지향 프로그래밍, 사용자 지정 함수, 사용자 지정 자료형이 포함되었다.","{'word': '데이터와 코드의 추가적인 제어', 'start': 1066, 'end': 1081, 'type': 'COM'}","{'word': '객체 지향 프로그래밍', 'start': 1096, 'end': 1106, 'type': 'COM'}",com:sub_concept
1446,"데이터와 코드의 추가적인 제어는 2002년에 도입되어 객체 지향 프로그래밍, 사용자 지정 함수, 사용자 지정 자료형이 포함되었다.","{'word': '데이터와 코드의 추가적인 제어', 'start': 1066, 'end': 1081, 'type': 'COM'}","{'word': '사용자 지정 함수', 'start': 1109, 'end': 1117, 'type': 'COM'}",com:sub_concept
1447,"데이터와 코드의 추가적인 제어는 2002년에 도입되어 객체 지향 프로그래밍, 사용자 지정 함수, 사용자 지정 자료형이 포함되었다.","{'word': '데이터와 코드의 추가적인 제어', 'start': 1066, 'end': 1081, 'type': 'COM'}","{'word': '사용자 지정 자료형', 'start': 1120, 'end': 1129, 'type': 'COM'}",com:sub_concept
1448,동일 조사에서 60%가 코볼을 가르쳐야 한다고 생각함에도 불구하고 학계의 25%만이 그들의 교육과정에 코볼 프로그래밍이 있었다.,"{'word': '교육과정', 'start': 2805, 'end': 2808, 'type': 'COM'}","{'word': '코볼 프로그래밍', 'start': 2811, 'end': 2818, 'type': 'COM'}",com:sub_concept
1449,"반면, 2003년 코볼은 미국에서 정보 시스템 교육과정의 80%에 특별히 포함되었는데 이는 C++와 자바의 비율과 동일하다.","{'word': '정보 시스템 교육과정', 'start': 2845, 'end': 2855, 'type': 'COM'}","{'word': '코볼', 'start': 2836, 'end': 2837, 'type': 'COM'}",com:sub_concept
1450,"코볼의 자료 구조는 뒤에 나온 프로그래밍 언어들에 영향을 주었다. 레코드와 파일 구조는 PL/I과 파스칼에 영향을 주었고, 절은 파스칼의 변종 레코드의 이전 것이었다.","{'word': '코볼의 자료 구조', 'start': 3271, 'end': 3279, 'type': 'COM'}","{'word': '레코드', 'start': 3308, 'end': 3310, 'type': 'COM'}",com:sub_concept
1451,"코볼의 자료 구조는 뒤에 나온 프로그래밍 언어들에 영향을 주었다. 레코드와 파일 구조는 PL/I과 파스칼에 영향을 주었고, 절은 파스칼의 변종 레코드의 이전 것이었다.","{'word': '코볼의 자료 구조', 'start': 3271, 'end': 3279, 'type': 'COM'}","{'word': '파일 구조', 'start': 3313, 'end': 3317, 'type': 'COM'}",com:sub_concept
1452,"레코드와 파일 구조는 PL/I과 파스칼에 영향을 주었고, 절은 파스칼의 변종 레코드의 이전 것이었다.","{'word': '파스칼', 'start': 3343, 'end': 3345, 'type': 'COM'}","{'word': '변종 레코드', 'start': 3348, 'end': 3353, 'type': 'COM'}",com:sub_concept
1453,게다가 잘 정의된 디비전 구조는 ENVIRONMENT DIVISION의 외부 참조 정의를 제한함으로써 특히 플랫폼 변경을 단순화하는 일에 기여하였다.,"{'word': 'ENVIRONMENT DIVISION', 'start': 3589, 'end': 3608, 'type': 'COM'}","{'word': '외부 참조 정의', 'start': 3611, 'end': 3618, 'type': 'COM'}",com:sub_concept
1454,그 뒤로 코볼-85는 내재형 하위 프로그램(nested subprogram)을 추가하여 프로그래머들이 하위 프로그램들을 숨길 수 있게 하였다.,"{'word': '내재형 하위 프로그램', 'start': 998, 'end': 1008, 'type': 'COM'}","{'word': 'nested subprogram', 'start': 1010, 'end': 1026, 'type': 'COM'}",com:alter_names
1455,코볼 표준들은 수차례 지연으로 인해 고통을 받아왔다: 코볼-85는 희망했던 날보다 5년은 더 늦었고,"{'word': '코볼-85', 'start': 3059, 'end': 3063, 'type': 'COM'}","{'word': '코볼 표준', 'start': 3029, 'end': 3033, 'type': 'COM'}",com:alter_names
1456,"코볼 표준들은 수차례 지연으로 인해 고통을 받아왔다: 코볼-85는 희망했던 날보다 5년은 더 늦었고 COBOL 2002도 5년이 늦었으며, COBOL 2014는 6년이 늦었다.","{'word': 'COBOL 2002', 'start': 3085, 'end': 3094, 'type': 'COM'}","{'word': '코볼 표준', 'start': 3029, 'end': 3033, 'type': 'COM'}",com:alter_names
1457,"코볼 표준들은 수차례 지연으로 인해 고통을 받아왔다: 코볼-85는 희망했던 날보다 5년은 더 늦었고 COBOL 2002도 5년이 늦었으며, COBOL 2014는 6년이 늦었다.","{'word': 'COBOL 2014', 'start': 3107, 'end': 3116, 'type': 'COM'}","{'word': '코볼 표준', 'start': 3029, 'end': 3033, 'type': 'COM'}",com:alter_names
1458,"코볼 사양은 새로운 배커스-나우르 표기법이 아닌, 고유한 표기법이나 메타 언어를 사용했는데 그 이유는 이를 들었던 위원회 구성원들이 얼마 없었기 때문이었다.","{'word': '코볼', 'start': 2262, 'end': 2263, 'type': 'COM'}","{'word': '메타 언어', 'start': 2300, 'end': 2304, 'type': 'COM'}",com:made_of
1459,"레코드와 파일 구조는 PL/I과 파스칼에 영향을 주었고, 절은 파스칼의 변종 레코드의 이전 것이었다.","{'word': '파스칼', 'start': 3326, 'end': 3328, 'type': 'COM'}","{'word': '파일 구조', 'start': 3313, 'end': 3317, 'type': 'COM'}",com:prior_tech
1460,"레코드와 파일 구조는 PL/I과 파스칼에 영향을 주었고, 절은 파스칼의 변종 레코드의 이전 것이었다.","{'word': 'PL/I', 'start': 3320, 'end': 3323, 'type': 'COM'}","{'word': '레코드', 'start': 3308, 'end': 3310, 'type': 'COM'}",com:prior_tech
1461,"또, 코볼은 프로그래머들이 배우고 쓰기 쉽게 하기 위해 만들어졌지만 관리자들과 같은 비기술 종사자들에게도 읽힌다.","{'word': '비기술 종사자', 'start': 1639, 'end': 1645, 'type': 'PER'}","{'word': '프로그래머', 'start': 1599, 'end': 1603, 'type': 'PER'}",no_relation
1462,"이에 대한 교리는 범죄 공격으로 여겨진다.""고 강조하면서 편집장에게 보내는 ""어떻게 우리가 상처를 줄 수 있는 진실을 이야기하는가?""라는 제목의 1975년 편지에서 동시대 코볼의 일부를 비평하였다.","{'word': '코볼', 'start': 216, 'end': 217, 'type': 'PER'}","{'word': '편집장', 'start': 152, 'end': 154, 'type': 'COM'}",no_relation
1463,"진 사멧은 우아하지 못함, 설계 과정에 참여할 영향력 있는 컴퓨터 과학자들의 부족, 사무용 데이터 처리를 업신여기는 것 때문에 코볼의 인기가 없던 것을 초기의 잘난체 반응 때문인 것으로 보았다.","{'word': '컴퓨터 과학자', 'start': 2186, 'end': 2192, 'type': 'PER'}","{'word': '사무용 데이터 처리', 'start': 2200, 'end': 2209, 'type': 'COM'}",no_relation
1464,"CODASYL 코볼 위원회의 의장인 도널드 넬슨은 1984년에 ""학계가 ... 코볼을 싫어한다""고 말했고 컴퓨터 과학 동문들은 ""'코볼이 싫다'라는 것을 그들에게 주입시켰다""고 말했다.","{'word': '컴퓨터 과학 동문', 'start': 2611, 'end': 2619, 'type': 'PER'}","{'word': '코볼', 'start': 2596, 'end': 2597, 'type': 'COM'}",no_relation
1465,코볼 공동체는 늘 컴퓨터 과학 공동체와는 분리되어 왔다.,"{'word': '컴퓨터 과학 공동체', 'start': 1984, 'end': 1993, 'type': 'ORG'}","{'word': '코볼 공동체', 'start': 1974, 'end': 1979, 'type': 'ORG'}",no_relation
1466,위원회에 속한 전원이 상업 분야나 정부 쪽 출신이었다.,"{'word': '위원회', 'start': 2041, 'end': 2043, 'type': 'ORG'}","{'word': '정부', 'start': 2060, 'end': 2061, 'type': 'ORG'}",no_relation
1467,마이크로 포커스의 2013년 조사에 따르면 대학 학계의 20%는 코볼은 구식이거나 죽었다고 생각했으며 55%는 그들의 학생들이 코볼이 구식이거나 죽었다고 생각하였다고 믿었다.,"{'word': '마이크로 포커스', 'start': 2656, 'end': 2663, 'type': 'ORG'}","{'word': '코볼', 'start': 2692, 'end': 2693, 'type': 'COM'}",no_relation
1468,1970년대에 프로그래머들은 구조적이지 않은 스파게티 코드를 구조적 프로그래밍 패러다임으로 옮기기 시작하였다.,"{'word': '구조적 프로그래밍 패러다임', 'start': 34, 'end': 47, 'type': 'COM'}","{'word': '스파게티 코드', 'start': 25, 'end': 31, 'type': 'COM'}",no_relation
1469,"문은 대체적으로 문과 프로시저로 대체되었는데 이로 말미암아 모듈식 프로그래밍을 촉진시켰고, 강력한 반복 기능으로 손쉬운 접근을 가능케 했다.","{'word': '프로시저', 'start': 320, 'end': 323, 'type': 'COM'}","{'word': '모듈식 프로그래밍', 'start': 341, 'end': 349, 'type': 'COM'}",no_relation
1470,코볼 프로그램들은 이음매가 없고 모듈성이 결여된 점으로 악명이 높았다.,"{'word': '코볼 프로그램', 'start': 466, 'end': 472, 'type': 'COM'}","{'word': '모듈성', 'start': 484, 'end': 486, 'type': 'COM'}",no_relation
1471,코볼-85는 그 이전의 버전들과 완전히 호환되지 못했고 이에 대한 개발은 논란이 있었다.,"{'word': '코볼-85', 'start': 1211, 'end': 1215, 'type': 'COM'}","{'word': '버전', 'start': 1224, 'end': 1225, 'type': 'COM'}",no_relation
1472,지지자들은 이것이 코드를 자체 문서화하여 프로그램 유지보수를 쉽게 하기 위한 것이라고 말한다.,"{'word': '코드', 'start': 1549, 'end': 1550, 'type': 'COM'}","{'word': '프로그램', 'start': 1562, 'end': 1565, 'type': 'COM'}",no_relation
1473,어떠한 학술 컴퓨터 과학자들도 코볼의 설계에 참여하지 않았다.,"{'word': '컴퓨터', 'start': 2013, 'end': 2015, 'type': 'COM'}","{'word': '코볼', 'start': 2023, 'end': 2024, 'type': 'COM'}",no_relation
1474,"당시 컴퓨터 과학자들은 코볼 개발이 씨름하던 상용 파일 처리 문제 보다 수치 분석, 물리학, 시스템 프로그래밍과 같은 분야에 더 관심이 많았다.","{'word': '코볼', 'start': 2085, 'end': 2086, 'type': 'COM'}","{'word': '상용 파일 처리 문제', 'start': 2097, 'end': 2107, 'type': 'COM'}",no_relation
1475,나중에 코볼은 코볼을 아우르는 자료의 부족으로 고통을 받았다.,"{'word': '코볼', 'start': 2373, 'end': 2374, 'type': 'COM'}","{'word': '자료', 'start': 2386, 'end': 2387, 'type': 'COM'}",no_relation
1476,분명한 파일 구조 정의들은 데이터베이스 관리 시스템의 개발보다 앞섰고 수집된 데이터는 포트란의 배열보다 훨씬 더 앞선 것이었다.,"{'word': '데이터베이스 관리 시스템', 'start': 3380, 'end': 3392, 'type': 'COM'}","{'word': '포트란', 'start': 3413, 'end': 3415, 'type': 'COM'}",no_relation
1477,이식성과 표준화에 초점을 둠에 따라 코볼로 작성된 프로그램들은 이식이 가능하였고 언어가 다양한 하드웨어 플랫폼과 운영 체제에 안착할 수 있었다.,"{'word': '하드웨어 플랫폼', 'start': 3543, 'end': 3550, 'type': 'COM'}","{'word': '운영 체제', 'start': 3553, 'end': 3557, 'type': 'COM'}",no_relation
1478,게다가 잘 정의된 디비전 구조는 ENVIRONMENT DIVISION의 외부 참조 정의를 제한함으로써 특히 플랫폼 변경을 단순화하는 일에 기여하였다.,"{'word': '플랫폼 변경', 'start': 3631, 'end': 3636, 'type': 'COM'}","{'word': '디비전 구조', 'start': 3581, 'end': 3586, 'type': 'COM'}",no_relation
1479,코볼 프로그램을 유지보수하는 사람들은 1984년까지는 이해하기 어려운 코드를 다루는데 고심해야 했으며 코볼-85의 주요 변경 사항들은 유지보수를 쉽게 할 수 있게 도와준다.,"{'word': '코볼 프로그램', 'start': 1729, 'end': 1735, 'type': 'COM'}","{'word': '코볼-85', 'start': 1786, 'end': 1790, 'type': 'COM'}",com:similar_tech
1480,"미국 의회도서관에는 포트란의 경우 코볼의 2배 분량의 서적이, 베이직의 경우 코볼의 4배 분량의 서적이 있었다.","{'word': '코볼', 'start': 2452, 'end': 2453, 'type': 'COM'}","{'word': '포트란', 'start': 2444, 'end': 2446, 'type': 'COM'}",com:similar_tech
1481,"미국 의회도서관에는 포트란의 경우 코볼의 2배 분량의 서적이, 베이직의 경우 코볼의 4배 분량의 서적이 있었다.","{'word': '코볼', 'start': 2476, 'end': 2477, 'type': 'COM'}","{'word': '베이직', 'start': 2468, 'end': 2470, 'type': 'COM'}",com:similar_tech
1482,"반면, 2003년 코볼은 미국에서 정보 시스템 교육과정의 80%에 특별히 포함되었는데 이는 C++와 자바의 비율과 동일하다.","{'word': '자바', 'start': 2882, 'end': 2883, 'type': 'COM'}","{'word': 'C++', 'start': 2877, 'end': 2879, 'type': 'COM'}",com:similar_tech
1483,"코볼 표준들은 수차례 지연으로 인해 고통을 받아왔다: 코볼-85는 희망했던 날보다 5년은 더 늦었고 COBOL 2002도 5년이 늦었으며, COBOL 2014는 6년이 늦었다.","{'word': '코볼-85', 'start': 3059, 'end': 3063, 'type': 'COM'}","{'word': 'COBOL 2002', 'start': 3085, 'end': 3094, 'type': 'COM'}",com:similar_tech
1484,"COBOL 2002도 5년이 늦었으며, COBOL 2014는 6년이 늦었다.","{'word': 'COBOL 2014', 'start': 3107, 'end': 3116, 'type': 'COM'}","{'word': 'COBOL 2002', 'start': 3085, 'end': 3094, 'type': 'COM'}",com:similar_tech
1485,"코볼 표준들은 수차례 지연으로 인해 고통을 받아왔다: 코볼-85는 희망했던 날보다 5년은 더 늦었고 COBOL 2002도 5년이 늦었으며, COBOL 2014는 6년이 늦었다.","{'word': '코볼-85', 'start': 3059, 'end': 3063, 'type': 'COM'}","{'word': 'COBOL 2014', 'start': 3107, 'end': 3116, 'type': 'COM'}",com:similar_tech
1486,그러나 일부 위원회 구성원들은 구현체와 표준의 잦은 수정 간에 따르는 비호환성에 대해 걱정을 드러냈다.,"{'word': '표준', 'start': 3235, 'end': 3236, 'type': 'COM'}","{'word': '구현체', 'start': 3230, 'end': 3232, 'type': 'COM'}",com:similar_tech
1487,"코볼(COBOL, COmmon Business-Oriented Language, 사무 지향 보통 언어)은 사무용으로 설계된, 영어와 같은 컴퓨터 프로그래밍 언어이다.","{'word': '컴퓨터 프로그래밍 언어', 'start': 77, 'end': 88, 'type': 'COM'}","{'word': '코볼', 'start': 0, 'end': 1, 'type': 'COM'}",com:sub_concept
1488,"1997년 가트너 그룹은 총 200,000,000,000줄의 코볼이 현존하며 모든 비즈니스 프로그램의 80%를 실행한 것으로 예측하였다.","{'word': '비즈니스 프로그램', 'start': 215, 'end': 223, 'type': 'COM'}","{'word': '코볼', 'start': 203, 'end': 204, 'type': 'COM'}",com:sub_concept
1489,그러나 숙련된 코볼 프로그래머가 은퇴하고 인기가 시들어가면서 프로그램들은 새로운 플랫폼으로 이관돼 현대의 언어로 다시 작성되거나 소프트웨어 패키지로 대체되는 추세이다.,"{'word': '플랫폼', 'start': 366, 'end': 368, 'type': 'COM'}","{'word': '프로그램', 'start': 355, 'end': 358, 'type': 'COM'}",com:sub_concept
1490,"확장에는 구조적, 객체 지향 프로그래밍의 지원을 포함한다.","{'word': '확장', 'start': 688, 'end': 689, 'type': 'COM'}","{'word': '구조적', 'start': 693, 'end': 695, 'type': 'COM'}",com:sub_concept
1491,"확장에는 구조적, 객체 지향 프로그래밍의 지원을 포함한다.","{'word': '확장', 'start': 688, 'end': 689, 'type': 'COM'}","{'word': '객체 지향 프로그래밍의 지원', 'start': 698, 'end': 712, 'type': 'COM'}",com:sub_concept
1492,"코볼은 영어와 비슷한 문법을 갖고 있으며, 자체 문서화 및 높은 가독성을 염두에 두고 설계되었다. 그러나 문법이 장황하고 300개가 넘는 예약어를 사용한다.","{'word': '코볼', 'start': 749, 'end': 750, 'type': 'COM'}","{'word': '예약어', 'start': 826, 'end': 828, 'type': 'COM'}",com:sub_concept
1493,"처럼 현대의 간결한 문법과 달리, 코볼은 더욱 영어와 같은 문법을 갖고 있다. (이 경우 ). 코볼 코드는 4개의 디비전(IDENTIFICATION, ENVIRONMENT, DATA, PROCEDURE)으로 나뉘며 이 안에 엄격한 계층적 섹션, 문단, 문장들을 포함한다.","{'word': '코볼 코드', 'start': 890, 'end': 894, 'type': 'COM'}","{'word': '디비전', 'start': 901, 'end': 903, 'type': 'COM'}",com:sub_concept
1494,"처럼 현대의 간결한 문법과 달리, 코볼은 더욱 영어와 같은 문법을 갖고 있다. (이 경우 ). 코볼 코드는 4개의 디비전(IDENTIFICATION, ENVIRONMENT, DATA, PROCEDURE)으로 나뉘며 이 안에 엄격한 계층적 섹션, 문단, 문장들을 포함한다.","{'word': '디비전', 'start': 901, 'end': 903, 'type': 'COM'}","{'word': 'IDENTIFICATION', 'start': 905, 'end': 918, 'type': 'COM'}",com:sub_concept
1495,"처럼 현대의 간결한 문법과 달리, 코볼은 더욱 영어와 같은 문법을 갖고 있다. (이 경우 ). 코볼 코드는 4개의 디비전(IDENTIFICATION, ENVIRONMENT, DATA, PROCEDURE)으로 나뉘며 이 안에 엄격한 계층적 섹션, 문단, 문장들을 포함한다.","{'word': '디비전', 'start': 901, 'end': 903, 'type': 'COM'}","{'word': 'ENVIRONMENT', 'start': 921, 'end': 931, 'type': 'COM'}",com:sub_concept
1496,"처럼 현대의 간결한 문법과 달리, 코볼은 더욱 영어와 같은 문법을 갖고 있다. (이 경우 ). 코볼 코드는 4개의 디비전(IDENTIFICATION, ENVIRONMENT, DATA, PROCEDURE)으로 나뉘며 이 안에 엄격한 계층적 섹션, 문단, 문장들을 포함한다.","{'word': '디비전', 'start': 901, 'end': 903, 'type': 'COM'}","{'word': 'DATA', 'start': 934, 'end': 937, 'type': 'COM'}",com:sub_concept
1497,"처럼 현대의 간결한 문법과 달리, 코볼은 더욱 영어와 같은 문법을 갖고 있다. (이 경우 ). 코볼 코드는 4개의 디비전(IDENTIFICATION, ENVIRONMENT, DATA, PROCEDURE)으로 나뉘며 이 안에 엄격한 계층적 섹션, 문단, 문장들을 포함한다.","{'word': '디비전', 'start': 901, 'end': 903, 'type': 'COM'}","{'word': 'PROCEDURE', 'start': 940, 'end': 948, 'type': 'COM'}",com:sub_concept
1498,"처럼 현대의 간결한 문법과 달리, 코볼은 더욱 영어와 같은 문법을 갖고 있다. (이 경우 ). 코볼 코드는 4개의 디비전(IDENTIFICATION, ENVIRONMENT, DATA, PROCEDURE)으로 나뉘며 이 안에 엄격한 계층적 섹션, 문단, 문장들을 포함한다.","{'word': '디비전', 'start': 901, 'end': 903, 'type': 'COM'}","{'word': '계층적 섹션', 'start': 966, 'end': 971, 'type': 'COM'}",com:sub_concept
1499,"처럼 현대의 간결한 문법과 달리, 코볼은 더욱 영어와 같은 문법을 갖고 있다. (이 경우 ). 코볼 코드는 4개의 디비전(IDENTIFICATION, ENVIRONMENT, DATA, PROCEDURE)으로 나뉘며 이 안에 엄격한 계층적 섹션, 문단, 문장들을 포함한다.","{'word': '디비전', 'start': 901, 'end': 903, 'type': 'COM'}","{'word': '문단', 'start': 974, 'end': 975, 'type': 'COM'}",com:sub_concept
1500,학계의 컴퓨터 과학자들은 코볼이 만들어졌을 때 일반적으로 사무용 응용 프로그램들에 관심이 없었으며 설계에도 참여하지 않았다.,"{'word': '사무용 응용 프로그램', 'start': 1083, 'end': 1093, 'type': 'COM'}","{'word': '코볼', 'start': 1065, 'end': 1066, 'type': 'COM'}",com:sub_concept
1501,"코볼은 문법의 장황함, 설계 과정, 구조화 프로그래밍 지원 부족으로 비판을 받아왔으며 이음매가 없고 이해하기 어려운 프로그램들을 만들어냈다.","{'word': '프로그램', 'start': 1186, 'end': 1189, 'type': 'COM'}","{'word': '코볼', 'start': 1121, 'end': 1122, 'type': 'COM'}",com:sub_concept
1502,코볼과 포트란은 프로그램밍 언어 역사에서 고급 기술언어의 원점이 되고 있다.,"{'word': '고급 기술언어의 원점', 'start': 1320, 'end': 1330, 'type': 'COM'}","{'word': '코볼', 'start': 1297, 'end': 1298, 'type': 'COM'}",com:sub_concept
1503,"코볼(COBOL, COmmon Business-Oriented Language, 사무 지향 보통 언어)은 사무용으로 설계된, 영어와 같은 컴퓨터 프로그래밍 언어이다.","{'word': '코볼', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': 'COBOL', 'start': 3, 'end': 7, 'type': 'COM'}",com:alter_names
1504,"코볼(COBOL, COmmon Business-Oriented Language, 사무 지향 보통 언어)은 사무용으로 설계된, 영어와 같은 컴퓨터 프로그래밍 언어이다.","{'word': '코볼', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': 'COmmon Business-Oriented Language', 'start': 10, 'end': 42, 'type': 'COM'}",com:alter_names
1505,"코볼(COBOL, COmmon Business-Oriented Language, 사무 지향 보통 언어)은 사무용으로 설계된, 영어와 같은 컴퓨터 프로그래밍 언어이다.","{'word': '코볼', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': '사무 지향 보통 언어', 'start': 45, 'end': 55, 'type': 'COM'}",com:alter_names
1506,코볼보다 먼저 개발된 포트란(FORTRAN)은 주로 과학기술 계산용인 반면 비슷한 시기에 탄생된 코볼은 대량 데이터 처리를 위한 업무처리 및 관리 분야용으로 자리잡게 된다.,"{'word': '포트란', 'start': 1212, 'end': 1214, 'type': 'COM'}","{'word': 'FORTRAN', 'start': 1216, 'end': 1222, 'type': 'COM'}",com:alter_names
1507,"코볼은 1959년에 CODASYL이 설계하였으며 부분적으로는, 코볼의 어머니로 불리는 그레이스 호퍼의 이전 프로그래밍 언어 디자인을 기반으로 한다.","{'word': '코볼', 'start': 460, 'end': 461, 'type': 'COM'}","{'word': '이전 프로그래밍 언어 디자인', 'start': 517, 'end': 531, 'type': 'COM'}",com:prior_tech
1508,코볼보다 먼저 개발된 포트란(FORTRAN)은 주로 과학기술 계산용인 반면 비슷한 시기에 탄생된 코볼은 대량 데이터 처리를 위한 업무처리 및 관리 분야용으로 자리잡게 된다.,"{'word': '코볼', 'start': 1200, 'end': 1201, 'type': 'COM'}","{'word': '포트란', 'start': 1212, 'end': 1214, 'type': 'COM'}",com:prior_tech
1509,임시방편으로 의도했던 미국 국방부가 발빠르게 컴퓨터 제조업체에게 그것을 제공하도록 강제한 결과 널리 채택되었다.,"{'word': '제조업체', 'start': 626, 'end': 629, 'type': 'ORG'}","{'word': '미국 국방부', 'start': 609, 'end': 614, 'type': 'ORG'}",no_relation
1510,"1997년 가트너 그룹은 총 200,000,000,000줄의 코볼이 현존하며 모든 비즈니스 프로그램의 80%를 실행한 것으로 예측하였다.","{'word': '가트너 그룹', 'start': 175, 'end': 180, 'type': 'ORG'}","{'word': '코볼', 'start': 203, 'end': 204, 'type': 'COM'}",no_relation
1511,"절차적, 명령형 언어이고, 2002년부터는 객체 지향 언어이다.","{'word': '명령형 언어', 'start': 98, 'end': 103, 'type': 'COM'}","{'word': '객체 지향 언어', 'start': 117, 'end': 124, 'type': 'COM'}",no_relation
1512,"코볼은 주로 비즈니스, 금융, 회사/정부 관리 시스템에 주로 사용된다.","{'word': '코볼', 'start': 129, 'end': 130, 'type': 'COM'}","{'word': '정부 관리 시스템', 'start': 149, 'end': 157, 'type': 'COM'}",no_relation
1513,코볼은 지금도 메인프레임 컴퓨터의 레거시 응용 프로그램들에 사용되고 있으며 대용량 일괄 처리 및 트랜잭션 처리와 같은 작업에 쓰인다.,"{'word': '트랜잭션 처리', 'start': 300, 'end': 306, 'type': 'COM'}","{'word': '대용량 일괄 처리', 'start': 288, 'end': 296, 'type': 'COM'}",no_relation
1514,그러나 숙련된 코볼 프로그래머가 은퇴하고 인기가 시들어가면서 프로그램들은 새로운 플랫폼으로 이관돼 현대의 언어로 다시 작성되거나 소프트웨어 패키지로 대체되는 추세이다.,"{'word': '코볼', 'start': 329, 'end': 330, 'type': 'COM'}","{'word': '소프트웨어', 'start': 393, 'end': 397, 'type': 'COM'}",no_relation
1515,코볼 대부분의 프로그래밍은 순수하게 기존의 응용 프로그램들을 관리하는 데 있다.,"{'word': '코볼', 'start': 415, 'end': 416, 'type': 'COM'}","{'word': '프로그램', 'start': 442, 'end': 445, 'type': 'COM'}",no_relation
1516,데이터 처리를 위해 이식 가능한 프로그래밍 언어를 만들려는 미국 국방부 노고의 일부이기도 하다.,"{'word': '프로그래밍', 'start': 561, 'end': 565, 'type': 'COM'}","{'word': '데이터', 'start': 543, 'end': 545, 'type': 'COM'}",no_relation
1517,"대형 표준 라이브러리가 부족하며 이 표준은 43개의 문들과 87개의 함수, 그리고 하나의 클래스만을 규정한다.","{'word': '라이브러리', 'start': 995, 'end': 999, 'type': 'COM'}","{'word': '클래스', 'start': 1039, 'end': 1041, 'type': 'COM'}",no_relation
1518,"코볼은 1959년에 CODASYL이 설계하였으며 부분적으로는, 코볼의 어머니로 불리는 그레이스 호퍼의 이전 프로그래밍 언어 디자인을 기반으로 한다.","{'word': 'CODASYL', 'start': 471, 'end': 477, 'type': 'PER'}","{'word': '코볼', 'start': 460, 'end': 461, 'type': 'COM'}",per:production
1519,"코볼은 1959년에 CODASYL이 설계하였으며 부분적으로는, 코볼의 어머니로 불리는 그레이스 호퍼의 이전 프로그래밍 언어 디자인을 기반으로 한다.","{'word': '그레이스 호퍼', 'start': 508, 'end': 514, 'type': 'PER'}","{'word': '코볼', 'start': 495, 'end': 496, 'type': 'COM'}",per:production
1520,코볼과 포트란은 프로그램밍 언어 역사에서 고급 기술언어의 원점이 되고 있다.,"{'word': '코볼', 'start': 1297, 'end': 1298, 'type': 'COM'}","{'word': '포트란', 'start': 1301, 'end': 1303, 'type': 'COM'}",com:similar_tech
1521,"코볼은 영어와 같은 문법을 가지고 있으며, 프로그램 안의 거의 모든 것을 기술하는데 사용된다.","{'word': '프로그램', 'start': 24, 'end': 27, 'type': 'COM'}","{'word': '코볼', 'start': 0, 'end': 1, 'type': 'COM'}",com:sub_concept
1522,영어와 같은 문법을 지닌 코볼은 300개의 예약어가 있다.,"{'word': '코볼', 'start': 170, 'end': 171, 'type': 'COM'}","{'word': '예약어', 'start': 180, 'end': 182, 'type': 'COM'}",com:sub_concept
1523,"각 코볼 프로그램은 4개의 어휘 항목을 이룬다; 워드, 리터럴, 픽처(PICTURE) 문자, 구분자(separator). 워드에는 예약어와 사용자 정의 식별자를 포함한다.","{'word': '코볼 프로그램', 'start': 313, 'end': 319, 'type': 'COM'}","{'word': '어휘 항목', 'start': 326, 'end': 330, 'type': 'COM'}",com:sub_concept
1524,"각 코볼 프로그램은 4개의 어휘 항목을 이룬다; 워드, 리터럴, 픽처(PICTURE) 문자, 구분자(separator). 워드에는 예약어와 사용자 정의 식별자를 포함한다.","{'word': '어휘 항목', 'start': 326, 'end': 330, 'type': 'COM'}","{'word': '워드', 'start': 338, 'end': 339, 'type': 'COM'}",com:sub_concept
1525,"각 코볼 프로그램은 4개의 어휘 항목을 이룬다; 워드, 리터럴, 픽처(PICTURE) 문자, 구분자(separator). 워드에는 예약어와 사용자 정의 식별자를 포함한다.","{'word': '어휘 항목', 'start': 326, 'end': 330, 'type': 'COM'}","{'word': '리터럴', 'start': 342, 'end': 344, 'type': 'COM'}",com:sub_concept
1526,"각 코볼 프로그램은 4개의 어휘 항목을 이룬다; 워드, 리터럴, 픽처(PICTURE) 문자, 구분자(separator). 워드에는 예약어와 사용자 정의 식별자를 포함한다.","{'word': '어휘 항목', 'start': 326, 'end': 330, 'type': 'COM'}","{'word': '픽처', 'start': 347, 'end': 348, 'type': 'COM'}",com:sub_concept
1527,"각 코볼 프로그램은 4개의 어휘 항목을 이룬다; 워드, 리터럴, 픽처(PICTURE) 문자, 구분자(separator). 워드에는 예약어와 사용자 정의 식별자를 포함한다.","{'word': '어휘 항목', 'start': 326, 'end': 330, 'type': 'COM'}","{'word': '구분자', 'start': 363, 'end': 365, 'type': 'COM'}",com:sub_concept
1528,"각 코볼 프로그램은 4개의 어휘 항목을 이룬다; 워드, 리터럴, 픽처(PICTURE) 문자, 구분자(separator). 워드에는 예약어와 사용자 정의 식별자를 포함한다.","{'word': '워드', 'start': 379, 'end': 380, 'type': 'COM'}","{'word': '예약어', 'start': 384, 'end': 386, 'type': 'COM'}",com:sub_concept
1529,"각 코볼 프로그램은 4개의 어휘 항목을 이룬다; 워드, 리터럴, 픽처(PICTURE) 문자, 구분자(separator). 워드에는 예약어와 사용자 정의 식별자를 포함한다.","{'word': '워드', 'start': 379, 'end': 380, 'type': 'COM'}","{'word': '식별자', 'start': 396, 'end': 398, 'type': 'COM'}",com:sub_concept
1530,"각 코볼 프로그램은 4개의 어휘 항목을 이룬다; 워드, 리터럴, 픽처(PICTURE) 문자, 구분자(separator). 워드에는 예약어와 사용자 정의 식별자를 포함한다. 이들은 최대 31개 문자 길이로 되어 있으며 문자, 숫자, 하이픈(-), 언더바(_)를 포함할 수 있다.","{'word': '워드', 'start': 379, 'end': 380, 'type': 'COM'}","{'word': '문자 길이', 'start': 418, 'end': 422, 'type': 'COM'}",com:sub_concept
1531,"각 코볼 프로그램은 4개의 어휘 항목을 이룬다; 워드, 리터럴, 픽처(PICTURE) 문자, 구분자(separator). 워드에는 예약어와 사용자 정의 식별자를 포함한다. 이들은 최대 31개 문자 길이로 되어 있으며 문자, 숫자, 하이픈(-), 언더바(_)를 포함할 수 있다.","{'word': '워드', 'start': 379, 'end': 380, 'type': 'COM'}","{'word': '문자', 'start': 432, 'end': 433, 'type': 'COM'}",com:sub_concept
1532,"각 코볼 프로그램은 4개의 어휘 항목을 이룬다; 워드, 리터럴, 픽처(PICTURE) 문자, 구분자(separator). 워드에는 예약어와 사용자 정의 식별자를 포함한다. 이들은 최대 31개 문자 길이로 되어 있으며 문자, 숫자, 하이픈(-), 언더바(_)를 포함할 수 있다.","{'word': '워드', 'start': 379, 'end': 380, 'type': 'COM'}","{'word': '숫자', 'start': 436, 'end': 437, 'type': 'COM'}",com:sub_concept
1533,"각 코볼 프로그램은 4개의 어휘 항목을 이룬다; 워드, 리터럴, 픽처(PICTURE) 문자, 구분자(separator). 워드에는 예약어와 사용자 정의 식별자를 포함한다. 이들은 최대 31개 문자 길이로 되어 있으며 문자, 숫자, 하이픈(-), 언더바(_)를 포함할 수 있다.","{'word': '워드', 'start': 379, 'end': 380, 'type': 'COM'}","{'word': '하이픈', 'start': 440, 'end': 442, 'type': 'COM'}",com:sub_concept
1534,"각 코볼 프로그램은 4개의 어휘 항목을 이룬다; 워드, 리터럴, 픽처(PICTURE) 문자, 구분자(separator). 워드에는 예약어와 사용자 정의 식별자를 포함한다. 이들은 최대 31개 문자 길이로 되어 있으며 문자, 숫자, 하이픈(-), 언더바(_)를 포함할 수 있다.","{'word': '워드', 'start': 379, 'end': 380, 'type': 'COM'}","{'word': '언더바', 'start': 448, 'end': 450, 'type': 'COM'}",com:sub_concept
1535,리터럴은 숫자(예: 12)와 문자(예: 'Hello!')를 포함한다.,"{'word': '리터럴', 'start': 466, 'end': 468, 'type': 'COM'}","{'word': '숫자', 'start': 471, 'end': 472, 'type': 'COM'}",com:sub_concept
1536,리터럴은 숫자(예: 12)와 문자(예: 'Hello!')를 포함한다.,"{'word': '리터럴', 'start': 466, 'end': 468, 'type': 'COM'}","{'word': '문자', 'start': 482, 'end': 483, 'type': 'COM'}",com:sub_concept
1537,"구분자는 공백 문자와 콤마, 세미콜론을 포함하고 그 뒤에 공백이 온다.","{'word': '구분자', 'start': 505, 'end': 507, 'type': 'COM'}","{'word': '공백 문자', 'start': 510, 'end': 514, 'type': 'COM'}",com:sub_concept
1538,"구분자는 공백 문자와 콤마, 세미콜론을 포함하고 그 뒤에 공백이 온다.","{'word': '구분자', 'start': 505, 'end': 507, 'type': 'COM'}","{'word': '콤마', 'start': 517, 'end': 518, 'type': 'COM'}",com:sub_concept
1539,"구분자는 공백 문자와 콤마, 세미콜론을 포함하고 그 뒤에 공백이 온다.","{'word': '구분자', 'start': 505, 'end': 507, 'type': 'COM'}","{'word': '세미콜론', 'start': 521, 'end': 524, 'type': 'COM'}",com:sub_concept
1540,"코볼 프로그램은 4개의 구역으로 나뉜다: IDENTIFICATION DIVISION, ENVIRONMENT DIVISION, DATA DIVISION, PROCEDURE DIVISION. IDENTIFICATION DIVISION은 소스 요소의 이름과 종류를 정의하며 여기서 클래스와 인터페이스가 지정된다.","{'word': '코볼 프로그램', 'start': 545, 'end': 551, 'type': 'COM'}","{'word': 'IDENTIFICATION DIVISION', 'start': 568, 'end': 590, 'type': 'COM'}",com:sub_concept
1541,"코볼 프로그램은 4개의 구역으로 나뉜다: IDENTIFICATION DIVISION, ENVIRONMENT DIVISION, DATA DIVISION, PROCEDURE DIVISION. IDENTIFICATION DIVISION은 소스 요소의 이름과 종류를 정의하며 여기서 클래스와 인터페이스가 지정된다.","{'word': '코볼 프로그램', 'start': 545, 'end': 551, 'type': 'COM'}","{'word': 'ENVIRONMENT DIVISION', 'start': 593, 'end': 612, 'type': 'COM'}",com:sub_concept
1542,"코볼 프로그램은 4개의 구역으로 나뉜다: IDENTIFICATION DIVISION, ENVIRONMENT DIVISION, DATA DIVISION, PROCEDURE DIVISION. IDENTIFICATION DIVISION은 소스 요소의 이름과 종류를 정의하며 여기서 클래스와 인터페이스가 지정된다.","{'word': '코볼 프로그램', 'start': 545, 'end': 551, 'type': 'COM'}","{'word': 'DATA DIVISION', 'start': 615, 'end': 627, 'type': 'COM'}",com:sub_concept
1543,"코볼 프로그램은 4개의 구역으로 나뉜다: IDENTIFICATION DIVISION, ENVIRONMENT DIVISION, DATA DIVISION, PROCEDURE DIVISION. IDENTIFICATION DIVISION은 소스 요소의 이름과 종류를 정의하며 여기서 클래스와 인터페이스가 지정된다.","{'word': '코볼 프로그램', 'start': 545, 'end': 551, 'type': 'COM'}","{'word': 'PROCEDURE DIVISION', 'start': 630, 'end': 647, 'type': 'COM'}",com:sub_concept
1544,"코볼 프로그램은 4개의 구역으로 나뉜다: IDENTIFICATION DIVISION, ENVIRONMENT DIVISION, DATA DIVISION, PROCEDURE DIVISION. IDENTIFICATION DIVISION은 소스 요소의 이름과 종류를 정의하며 여기서 클래스와 인터페이스가 지정된다.","{'word': 'IDENTIFICATION DIVISION', 'start': 650, 'end': 672, 'type': 'COM'}","{'word': '소스 요소', 'start': 675, 'end': 679, 'type': 'COM'}",com:sub_concept
1545,"코볼 프로그램은 4개의 구역으로 나뉜다: IDENTIFICATION DIVISION, ENVIRONMENT DIVISION, DATA DIVISION, PROCEDURE DIVISION. IDENTIFICATION DIVISION은 소스 요소의 이름과 종류를 정의하며 여기서 클래스와 인터페이스가 지정된다.","{'word': '소스 요소', 'start': 675, 'end': 679, 'type': 'COM'}","{'word': '이름', 'start': 682, 'end': 683, 'type': 'COM'}",com:sub_concept
1546,"코볼 프로그램은 4개의 구역으로 나뉜다: IDENTIFICATION DIVISION, ENVIRONMENT DIVISION, DATA DIVISION, PROCEDURE DIVISION. IDENTIFICATION DIVISION은 소스 요소의 이름과 종류를 정의하며 여기서 클래스와 인터페이스가 지정된다.","{'word': '소스 요소', 'start': 675, 'end': 679, 'type': 'COM'}","{'word': '종류', 'start': 686, 'end': 687, 'type': 'COM'}",com:sub_concept
1547,"코볼 프로그램은 4개의 구역으로 나뉜다: IDENTIFICATION DIVISION, ENVIRONMENT DIVISION, DATA DIVISION, PROCEDURE DIVISION. IDENTIFICATION DIVISION은 소스 요소의 이름과 종류를 정의하며 여기서 클래스와 인터페이스가 지정된다.","{'word': 'IDENTIFICATION DIVISION', 'start': 650, 'end': 672, 'type': 'COM'}","{'word': '클래스', 'start': 699, 'end': 701, 'type': 'COM'}",com:sub_concept
1548,"코볼 프로그램은 4개의 구역으로 나뉜다: IDENTIFICATION DIVISION, ENVIRONMENT DIVISION, DATA DIVISION, PROCEDURE DIVISION. IDENTIFICATION DIVISION은 소스 요소의 이름과 종류를 정의하며 여기서 클래스와 인터페이스가 지정된다.","{'word': 'IDENTIFICATION DIVISION', 'start': 650, 'end': 672, 'type': 'COM'}","{'word': '인터페이스', 'start': 704, 'end': 708, 'type': 'COM'}",com:sub_concept
1549,"ENVIRONMENT DIVISION은 이를 실행하는 시스템에 의존하는 프로그램 기능을 정의하는데, 이를테면 파일과 문자 집합을 들 수 있다.","{'word': 'ENVIRONMENT DIVISION', 'start': 717, 'end': 736, 'type': 'COM'}","{'word': '프로그램 기능', 'start': 757, 'end': 763, 'type': 'COM'}",com:sub_concept
1550,"ENVIRONMENT DIVISION은 이를 실행하는 시스템에 의존하는 프로그램 기능을 정의하는데, 이를테면 파일과 문자 집합을 들 수 있다.","{'word': 'ENVIRONMENT DIVISION', 'start': 717, 'end': 736, 'type': 'COM'}","{'word': '파일', 'start': 778, 'end': 779, 'type': 'COM'}",com:sub_concept
1551,"ENVIRONMENT DIVISION은 이를 실행하는 시스템에 의존하는 프로그램 기능을 정의하는데, 이를테면 파일과 문자 집합을 들 수 있다.","{'word': 'ENVIRONMENT DIVISION', 'start': 717, 'end': 736, 'type': 'COM'}","{'word': '문자 집합', 'start': 782, 'end': 786, 'type': 'COM'}",com:sub_concept
1552,DATA DIVISION은 변수와 매개변수를 선언하는데 쓰인다.,"{'word': 'DATA DIVISION', 'start': 797, 'end': 809, 'type': 'COM'}","{'word': '변수', 'start': 812, 'end': 813, 'type': 'COM'}",com:sub_concept
1553,DATA DIVISION은 변수와 매개변수를 선언하는데 쓰인다.,"{'word': 'DATA DIVISION', 'start': 797, 'end': 809, 'type': 'COM'}","{'word': '매개변수', 'start': 816, 'end': 819, 'type': 'COM'}",com:sub_concept
1554,PROCEDURE DIVISION은 프로그램의 문을 포함한다.,"{'word': 'PROCEDURE DIVISION', 'start': 833, 'end': 850, 'type': 'COM'}","{'word': '프로그램의 문', 'start': 853, 'end': 859, 'type': 'COM'}",com:sub_concept
1555,각 구역은 섹션으로 다시 구분되며 섹션은 여러 문단으로 이루어진다.,"{'word': '구역', 'start': 870, 'end': 871, 'type': 'COM'}","{'word': '섹션', 'start': 874, 'end': 875, 'type': 'COM'}",com:sub_concept
1556,각 구역은 섹션으로 다시 구분되며 섹션은 여러 문단으로 이루어진다.,"{'word': '구역', 'start': 870, 'end': 871, 'type': 'COM'}","{'word': '여러 문단', 'start': 891, 'end': 895, 'type': 'COM'}",com:sub_concept
1557,각 구역은 섹션으로 다시 구분되며 섹션은 여러 문단으로 이루어진다.,"{'word': '섹션', 'start': 874, 'end': 875, 'type': 'COM'}","{'word': '여러 문단', 'start': 891, 'end': 895, 'type': 'COM'}",com:sub_concept
1558,"코볼은 두 가지 포맷으로 작성할 수 있다: 고정 포맷 (기본값), 자유(free) 포맷. 고정 포맷의 경우 코드는 특정 이름에 맞추어 정렬하여야 한다.","{'word': '코볼', 'start': 906, 'end': 907, 'type': 'COM'}","{'word': '포맷', 'start': 915, 'end': 916, 'type': 'COM'}",com:sub_concept
1559,"코볼은 두 가지 포맷으로 작성할 수 있다: 고정 포맷 (기본값), 자유(free) 포맷. 고정 포맷의 경우 코드는 특정 이름에 맞추어 정렬하여야 한다.","{'word': '코볼', 'start': 906, 'end': 907, 'type': 'COM'}","{'word': '고정 포맷', 'start': 930, 'end': 934, 'type': 'COM'}",com:sub_concept
1560,"코볼은 두 가지 포맷으로 작성할 수 있다: 고정 포맷 (기본값), 자유(free) 포맷. 고정 포맷의 경우 코드는 특정 이름에 맞추어 정렬하여야 한다.","{'word': '고정 포맷', 'start': 956, 'end': 960, 'type': 'COM'}","{'word': '코드', 'start': 966, 'end': 967, 'type': 'COM'}",com:sub_concept
1561,"코볼은 두 가지 포맷으로 작성할 수 있다: 고정 포맷 (기본값), 자유(free) 포맷. 고정 포맷의 경우 코드는 특정 이름에 맞추어 정렬하여야 한다. 코볼 2002까지는 아래와 같았다: 코볼 2002에서 영역 A와 B는 컬럼 255로 병합, 확장되었으며 프로그램 이름 영역은 제거되었다. 코볼 2002는 또한 자유 포맷 코드를 도입하였다.","{'word': '코볼', 'start': 906, 'end': 907, 'type': 'COM'}","{'word': '자유 포맷', 'start': 1080, 'end': 1084, 'type': 'COM'}",com:sub_concept
1562,코볼 2002는 또한 자유 포맷 코드를 도입하였다.,"{'word': '코볼 2002', 'start': 1068, 'end': 1074, 'type': 'COM'}","{'word': '자유 포맷 코드', 'start': 1080, 'end': 1087, 'type': 'COM'}",com:sub_concept
1563,자유 포맷 코드는 마치 더 새로운 프로그래밍 언어들에서처럼 파일의 어느 열에나 위치할 수 있다.,"{'word': '파일', 'start': 1130, 'end': 1131, 'type': 'COM'}","{'word': '자유 포맷 코드', 'start': 1097, 'end': 1104, 'type': 'COM'}",com:sub_concept
1564,주석은 codice_2을 이용하여 지정하며 어느 곳에서 위치해도 되고 고정 포맷 소스 코드에도 사용할 수 있다.,"{'word': '고정 포맷 소스 코드', 'start': 1190, 'end': 1200, 'type': 'COM'}","{'word': '주석', 'start': 1151, 'end': 1152, 'type': 'COM'}",com:sub_concept
1565,"각 코볼 프로그램은 4개의 어휘 항목을 이룬다; 워드, 리터럴, 픽처(PICTURE) 문자, 구분자(separator). 워드에는 예약어와 사용자 정의 식별자를 포함한다.","{'word': '픽처', 'start': 347, 'end': 348, 'type': 'COM'}","{'word': 'PICTURE', 'start': 350, 'end': 356, 'type': 'COM'}",com:alter_names
1566,"각 코볼 프로그램은 4개의 어휘 항목을 이룬다; 워드, 리터럴, 픽처(PICTURE) 문자, 구분자(separator). 워드에는 예약어와 사용자 정의 식별자를 포함한다.","{'word': '구분자', 'start': 363, 'end': 365, 'type': 'COM'}","{'word': 'separator', 'start': 367, 'end': 375, 'type': 'COM'}",com:alter_names
1567,"이를테면 IN과 OF 키워드는 번갈아 사용할 수 있는데, 이는 IS와 ARE, VALUE와 VALUES도 그러하다.","{'word': 'OF 키워드', 'start': 255, 'end': 260, 'type': 'COM'}","{'word': 'IN', 'start': 251, 'end': 252, 'type': 'COM'}",no_relation
1568,"이를테면 IN과 OF 키워드는 번갈아 사용할 수 있는데, 이는 IS와 ARE, VALUE와 VALUES도 그러하다.","{'word': 'ARE', 'start': 285, 'end': 287, 'type': 'COM'}","{'word': 'IS', 'start': 281, 'end': 282, 'type': 'COM'}",no_relation
1569,"이를테면 IN과 OF 키워드는 번갈아 사용할 수 있는데, 이는 IS와 ARE, VALUE와 VALUES도 그러하다.","{'word': 'VALUES', 'start': 297, 'end': 302, 'type': 'COM'}","{'word': 'VALUE', 'start': 290, 'end': 294, 'type': 'COM'}",no_relation
1570,"코볼 2002에서 영역 A와 B는 컬럼 255로 병합, 확장되었으며 프로그램 이름 영역은 제거되었다.","{'word': '코볼 2002', 'start': 1011, 'end': 1017, 'type': 'COM'}","{'word': '프로그램', 'start': 1049, 'end': 1052, 'type': 'COM'}",no_relation
1571,2015년 7월에 작성된 이 JCL은 제이 무슬리(Jay Moseley)의 허큘리스 강좌와 샘플에서 가져온 것이다.,"{'word': '제이 무슬리', 'start': 5896, 'end': 5901, 'type': 'PER'}","{'word': '허큘리스 강좌', 'start': 5917, 'end': 5923, 'type': 'POH'}",per:production
1572,"지금은 유명한 《C 프로그래밍 언어》(The C Programming Language)라는 책의 Hello world 프로그램 예제가 1978년 첫 출판되었을 때, 비슷한 메인프레임 코볼 프로그램 예제가 80컬럼의 천공 카드와 천공 카드 리더를 사용할 가능성이 매우 높은 JCL을 통해 제출되었다.","{'word': 'C 프로그래밍 언어', 'start': 5637, 'end': 5646, 'type': 'COM'}","{'word': '1978년', 'start': 5703, 'end': 5707, 'type': 'DAT'}",com:date_of_prod
1573,"지금은 유명한 《C 프로그래밍 언어》(The C Programming Language)라는 책의 Hello world 프로그램 예제가 1978년 첫 출판되었을 때, 비슷한 메인프레임 코볼 프로그램 예제가 80컬럼의 천공 카드와 천공 카드 리더를 사용할 가능성이 매우 높은 JCL을 통해 제출되었다.","{'word': 'Hello world 프로그램 예제', 'start': 5682, 'end': 5700, 'type': 'COM'}","{'word': '1978년', 'start': 5703, 'end': 5707, 'type': 'DAT'}",com:date_of_prod
1574,"지금은 유명한 《C 프로그래밍 언어》(The C Programming Language)라는 책의 Hello world 프로그램 예제가 1978년 첫 출판되었을 때, 비슷한 메인프레임 코볼 프로그램 예제가 80컬럼의 천공 카드와 천공 카드 리더를 사용할 가능성이 매우 높은 JCL을 통해 제출되었다.","{'word': 'The C Programming Language', 'start': 5649, 'end': 5674, 'type': 'COM'}","{'word': '1978년', 'start': 5703, 'end': 5707, 'type': 'DAT'}",com:date_of_prod
1575,표준 코볼은 다음의 자료형을 제공한다: 자료형 안전은 코볼 안에서 변칙적이다. 수치 데이터는 각기 다른 표현들과 크기들로 조용히 변환되며 영숫자 데이터는 숫자와 그룹 데이터를 포함하여 문자열로 저장될 수 있는 어떠한 데이터 항목에라도 올 수 있다.,"{'word': '표준 코볼', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': '수치 데이터', 'start': 44, 'end': 49, 'type': 'COM'}",com:sub_concept
1576,표준 코볼은 다음의 자료형을 제공한다: 자료형 안전은 코볼 안에서 변칙적이다. 수치 데이터는 각기 다른 표현들과 크기들로 조용히 변환되며 영숫자 데이터는 숫자와 그룹 데이터를 포함하여 문자열로 저장될 수 있는 어떠한 데이터 항목에라도 올 수 있다.,"{'word': '표준 코볼', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': '영숫자 데이터', 'start': 77, 'end': 83, 'type': 'COM'}",com:sub_concept
1577,수치 데이터는 각기 다른 표현들과 크기들로 조용히 변환되며 영숫자 데이터는 숫자와 그룹 데이터를 포함하여 문자열로 저장될 수 있는 어떠한 데이터 항목에라도 올 수 있다.,"{'word': '영숫자 데이터', 'start': 77, 'end': 83, 'type': 'COM'}","{'word': '숫자', 'start': 86, 'end': 87, 'type': 'COM'}",com:sub_concept
1578,수치 데이터는 각기 다른 표현들과 크기들로 조용히 변환되며 영숫자 데이터는 숫자와 그룹 데이터를 포함하여 문자열로 저장될 수 있는 어떠한 데이터 항목에라도 올 수 있다.,"{'word': '영숫자 데이터', 'start': 77, 'end': 83, 'type': 'COM'}","{'word': '그룹 데이터', 'start': 90, 'end': 95, 'type': 'COM'}",com:sub_concept
1579,그 밖의 PICTURE 문자들(삽입 및 편집 문자)은 어떻게 항목이 형식을 가져야 하는지를 지정한다.,"{'word': 'PICTURE 문자', 'start': 379, 'end': 388, 'type': 'COM'}","{'word': '삽입', 'start': 391, 'end': 392, 'type': 'COM'}",com:sub_concept
1580,그 밖의 PICTURE 문자들(삽입 및 편집 문자)은 어떻게 항목이 형식을 가져야 하는지를 지정한다.,"{'word': 'PICTURE 문자', 'start': 379, 'end': 388, 'type': 'COM'}","{'word': '편집 문자', 'start': 396, 'end': 400, 'type': 'COM'}",com:sub_concept
1581,"이를테면 는 와 같다. ()와 부호 ()만을 포함하는 PICTURE 사양들은 순수하게 숫자 데이터 항목들만 정의하고 있지만, 영문자()나 영숫자()를 포함하는 PICTURE 사양들은 영숫자 데이터 항목을 정의한다. 그 밖의 형식의 문자로는 편집된 숫자(edited numeric)나 편집된 영숫자(edited alphanumeric) 데이터 항목들로 정의된다.","{'word': 'PICTURE 사양', 'start': 669, 'end': 678, 'type': 'COM'}","{'word': '편집된 숫자', 'start': 773, 'end': 778, 'type': 'COM'}",com:sub_concept
1582,"이를테면 는 와 같다. ()와 부호 ()만을 포함하는 PICTURE 사양들은 순수하게 숫자 데이터 항목들만 정의하고 있지만, 영문자()나 영숫자()를 포함하는 PICTURE 사양들은 영숫자 데이터 항목을 정의한다. 그 밖의 형식의 문자로는 편집된 숫자(edited numeric)나 편집된 영숫자(edited alphanumeric) 데이터 항목들로 정의된다.","{'word': 'PICTURE 사양', 'start': 669, 'end': 678, 'type': 'COM'}","{'word': '편집된 영숫자', 'start': 797, 'end': 803, 'type': 'COM'}",com:sub_concept
1583,보고서 작성기(report writer)는 보고서를 작성하기 위한 선언형 기능이다.,"{'word': '보고서', 'start': 1000, 'end': 1002, 'type': 'COM'}","{'word': '보고서 작성기', 'start': 976, 'end': 982, 'type': 'COM'}",com:sub_concept
1584,각 보고서는 DATA DIVISION의 REPORT SECTION에 정의된다.,"{'word': 'DATA DIVISION', 'start': 1227, 'end': 1239, 'type': 'COM'}","{'word': 'REPORT SECTION', 'start': 1242, 'end': 1255, 'type': 'COM'}",com:sub_concept
1585,이를테면 고객 주문이 상세히 적힌 보고서를 만들 때 프로그램이 다른 고객의 주문에 도달하게 되면 제어 차단이 일어난다.,"{'word': '프로그램', 'start': 1408, 'end': 1411, 'type': 'COM'}","{'word': '다른 고객의 주문', 'start': 1414, 'end': 1422, 'type': 'COM'}",com:sub_concept
1586,PROCEDURE DIVISION(통틀어 프로시저로 호칭)에 위치한 섹션과 문단은 레이블과 단순한 함수로 사용할 수 있다.,"{'word': 'PROCEDURE DIVISION', 'start': 2431, 'end': 2448, 'type': 'COM'}","{'word': '섹션', 'start': 2469, 'end': 2470, 'type': 'COM'}",com:sub_concept
1587,PROCEDURE DIVISION(통틀어 프로시저로 호칭)에 위치한 섹션과 문단은 레이블과 단순한 함수로 사용할 수 있다.,"{'word': 'PROCEDURE DIVISION', 'start': 2431, 'end': 2448, 'type': 'COM'}","{'word': '문단', 'start': 2473, 'end': 2474, 'type': 'COM'}",com:sub_concept
1588,PROCEDURE DIVISION(통틀어 프로시저로 호칭)에 위치한 섹션과 문단은 레이블과 단순한 함수로 사용할 수 있다.,"{'word': '섹션', 'start': 2469, 'end': 2470, 'type': 'COM'}","{'word': '레이블', 'start': 2477, 'end': 2479, 'type': 'COM'}",com:sub_concept
1589,PROCEDURE DIVISION(통틀어 프로시저로 호칭)에 위치한 섹션과 문단은 레이블과 단순한 함수로 사용할 수 있다.,"{'word': '문단', 'start': 2473, 'end': 2474, 'type': 'COM'}","{'word': '함수', 'start': 2486, 'end': 2487, 'type': 'COM'}",com:sub_concept
1590,실행은 프로그램의 프로시저를 통해 종료가 될 때까지 내려간다.,"{'word': '프로그램', 'start': 2538, 'end': 2541, 'type': 'COM'}","{'word': '프로시저', 'start': 2544, 'end': 2547, 'type': 'COM'}",com:sub_concept
1591,"특이한 제어 흐름은 지뢰를 만들어낼 수 있는데, 여기서 지뢰는 수행된 프로시저의 제어권을 예측하지 못한 시간대에 예측하지 못한 장소로 돌아오는 문제를 야기한다.","{'word': '특이한 제어 흐름', 'start': 2647, 'end': 2655, 'type': 'COM'}","{'word': '지뢰', 'start': 2658, 'end': 2659, 'type': 'COM'}",com:sub_concept
1592,"지금은 유명한 《C 프로그래밍 언어》(The C Programming Language)라는 책의 Hello world 프로그램 예제가 1978년 첫 출판되었을 때, 비슷한 메인프레임 코볼 프로그램 예제가 80컬럼의 천공 카드와 천공 카드 리더를 사용할 가능성이 매우 높은 JCL을 통해 제출되었다.","{'word': 'C 프로그래밍 언어', 'start': 5637, 'end': 5646, 'type': 'COM'}","{'word': 'Hello world 프로그램 예제', 'start': 5682, 'end': 5700, 'type': 'COM'}",com:sub_concept
1593,"지금은 유명한 《C 프로그래밍 언어》(The C Programming Language)라는 책의 Hello world 프로그램 예제가 1978년 첫 출판되었을 때, 비슷한 메인프레임 코볼 프로그램 예제가 80컬럼의 천공 카드와 천공 카드 리더를 사용할 가능성이 매우 높은 JCL을 통해 제출되었다.","{'word': 'The C Programming Language', 'start': 5649, 'end': 5674, 'type': 'COM'}","{'word': 'Hello world 프로그램 예제', 'start': 5682, 'end': 5700, 'type': 'COM'}",com:sub_concept
1594,그 밖의 형식의 문자로는 편집된 숫자(edited numeric)나 편집된 영숫자(edited alphanumeric) 데이터 항목들로 정의된다.,"{'word': '편집된 숫자', 'start': 773, 'end': 778, 'type': 'COM'}","{'word': 'edited numeric', 'start': 780, 'end': 793, 'type': 'COM'}",com:alter_names
1595,그 밖의 형식의 문자로는 편집된 숫자(edited numeric)나 편집된 영숫자(edited alphanumeric) 데이터 항목들로 정의된다.,"{'word': '편집된 영숫자', 'start': 797, 'end': 803, 'type': 'COM'}","{'word': 'edited alphanumeric', 'start': 805, 'end': 823, 'type': 'COM'}",com:alter_names
1596,보고서 작성기(report writer)는 보고서를 작성하기 위한 선언형 기능이다.,"{'word': '보고서 작성기', 'start': 976, 'end': 982, 'type': 'COM'}","{'word': 'report writer', 'start': 984, 'end': 996, 'type': 'COM'}",com:alter_names
1597,보고서들은 계층적 제어 차단(control break)을 두고 동작한다.,"{'word': '계층적 제어 차단', 'start': 1316, 'end': 1324, 'type': 'COM'}","{'word': 'control break', 'start': 1326, 'end': 1338, 'type': 'COM'}",com:alter_names
1598,PROCEDURE DIVISION(통틀어 프로시저로 호칭)에 위치한 섹션과 문단은 레이블과 단순한 함수로 사용할 수 있다.,"{'word': 'PROCEDURE DIVISION', 'start': 2431, 'end': 2448, 'type': 'COM'}","{'word': '프로시저', 'start': 2454, 'end': 2457, 'type': 'COM'}",com:alter_names
1599,아래는 DATA DIVISION이 비어있으며 MVS 3.8J이 구동되는 시스템/370 허큘리스 에뮬레이터와 GNU/리눅스를 통해 테스트되었다.,"{'word': 'MVS 3.8J', 'start': 5820, 'end': 5827, 'type': 'COM'}","{'word': '스템/370 허큘리스 에뮬레이터', 'start': 5836, 'end': 5852, 'type': 'COM'}",com:made_of
1600,아래는 DATA DIVISION이 비어있으며 MVS 3.8J이 구동되는 시스템/370 허큘리스 에뮬레이터와 GNU/리눅스를 통해 테스트되었다.,"{'word': 'MVS 3.8J', 'start': 5820, 'end': 5827, 'type': 'COM'}","{'word': 'GNU/리눅스', 'start': 5855, 'end': 5861, 'type': 'COM'}",com:made_of
1601,2015년 7월에 작성된 이 JCL은 제이 무슬리(Jay Moseley)의 허큘리스 강좌와 샘플에서 가져온 것이다.,"{'word': 'JCL', 'start': 5891, 'end': 5893, 'type': 'COM'}","{'word': '샘플', 'start': 5926, 'end': 5927, 'type': 'COM'}",com:made_of
1602,일부 PICTURE 문자들은 데이터의 종류 및 얼마나 많은 문자열이나 숫자들을 메모리에 차지하게 할 것인지를 지정한다.,"{'word': '데이터', 'start': 285, 'end': 287, 'type': 'COM'}","{'word': 'PICTURE 문자', 'start': 272, 'end': 281, 'type': 'COM'}",no_relation
1603,"포인터와 오브젝트 참조를 선언하는데 사용할 수 있지만, 대개는 수치 자료형을 지정하기 위해 존재한다.","{'word': '포인터', 'start': 899, 'end': 901, 'type': 'COM'}","{'word': '오브젝트 참조', 'start': 904, 'end': 910, 'type': 'COM'}",no_relation
1604,"프로그래머는 보고서 레이아웃 및 보고서를 만들어내는데 필요한 데이터만 지정하면 되며, 페이지 나누기, 데이터 형식 지정, 머릿말과 꼬릿말과 같은 것들을 다루기 위해 코드를 작성할 필요는 없다.","{'word': '보고서 레이아웃', 'start': 1030, 'end': 1037, 'type': 'COM'}","{'word': '데이터', 'start': 1057, 'end': 1059, 'type': 'COM'}",no_relation
1605,제어 차단은 키 변수가 값을 변경할 때 발생한다.,"{'word': '키 변수', 'start': 1358, 'end': 1361, 'type': 'COM'}","{'word': '제어 차단', 'start': 1351, 'end': 1355, 'type': 'COM'}",no_relation
1606,문은 조건이 참이 될 때까지 실행하는 반복문을 정의한다. (다른 언어들의 wihle과는 다름) 프로시저들이나 일정한 범위의 프로시저들을 호출하기 위해서도 쓰인다. (프로시저 단락 참고) 와 는 각각 하위 프로그램들과 메소드를 호출한다.,"{'word': '메소드', 'start': 3808, 'end': 3810, 'type': 'COM'}","{'word': '프로그램', 'start': 3801, 'end': 3804, 'type': 'COM'}",no_relation
1607,하위 프로그램/메소드의 이름은 리터럴이나 데이터 항목이 되는 문자열 안에 포함된다.,"{'word': '하위 프로그램', 'start': 3819, 'end': 3825, 'type': 'COM'}","{'word': '메소드', 'start': 3827, 'end': 3829, 'type': 'COM'}",no_relation
1608,매개변수들은 참조에 의해서나 내용을 통해서나(사본이 참조에 의해 전달될 때) 값에 의해(프로토타입을 이용할 수 있는 경우에만) 전달할 수 있다.,"{'word': '매개변수', 'start': 3866, 'end': 3869, 'type': 'COM'}","{'word': '프로토타입', 'start': 3915, 'end': 3919, 'type': 'COM'}",no_relation
1609,"수많은 논리적 결함들이 코볼 60에 발견되었는데, GE의 찰스 캐츠는 이에 대해 모호하게 해석되지 않는다고 경고하였다.","{'word': '찰스 캐츠', 'start': 32, 'end': 36, 'type': 'PER'}","{'word': 'GE', 'start': 28, 'end': 29, 'type': 'POH'}",per:title
1610,부사장이었던 William Rinehuls는 코볼 커뮤니티의 2/3이 위원회의 존재조차 모르고 있다고 불평하였다.,"{'word': 'William Rinehuls', 'start': 1285, 'end': 1300, 'type': 'PER'}","{'word': '부사장', 'start': 1278, 'end': 1280, 'type': 'POH'}",per:title
1611,"1981년 1월, 트래블러스 인슈런스(Travelers Insurance)의 수석 부사장 조지프 T 브로피(Joseph T. Brophy)는 표준 위원회를 고소하겠다고 위협하였는데 그 까닭은 코볼-74와 상위 호환이 되지 않았기 때문이다.","{'word': '조지프 T 브로피', 'start': 1869, 'end': 1877, 'type': 'PER'}","{'word': '수석 부사장', 'start': 1862, 'end': 1867, 'type': 'POH'}",per:title
1612,"1981년 1월, 트래블러스 인슈런스(Travelers Insurance)의 수석 부사장 조지프 T 브로피(Joseph T. Brophy)는 표준 위원회를 고소하겠다고 위협하였는데 그 까닭은 코볼-74와 상위 호환이 되지 않았기 때문이다. 브로피는 그들의 40,000,000줄이나 되는 코드의 변환을 ""비생산적""이고 ""프로그램 자원 중 완전한 쓰레기""라고 기술하였다.","{'word': '브로피', 'start': 1953, 'end': 1955, 'type': 'PER'}","{'word': '수석 부사장', 'start': 1862, 'end': 1867, 'type': 'POH'}",per:title
1613,ANSI는 1968년 8월 《USA Standard COBOL X3.23》을 만듦으로써 차기 버전들의 주춧돌이 되었다.,"{'word': 'USA Standard COBOL X3.23', 'start': 758, 'end': 781, 'type': 'COM'}","{'word': '1968년 8월', 'start': 748, 'end': 755, 'type': 'DAT'}",com:date_of_prod
1614,"1974년 ANSI는 (ANS) 코볼의 개정판을 출판하였으며, 여기에는 파일 조직, DELETE 문, 세그먼트 모듈과 같은 새로운 기능들이 포함되었다.","{'word': '코볼의 개정판', 'start': 1421, 'end': 1427, 'type': 'COM'}","{'word': '1974년', 'start': 1403, 'end': 1407, 'type': 'DAT'}",com:date_of_prod
1615,1985년 말에 ANSI는 개정된 표준을 출판하였다.,"{'word': '개정된 표준', 'start': 2638, 'end': 2643, 'type': 'COM'}","{'word': '1985년 말', 'start': 2623, 'end': 2629, 'type': 'DAT'}",com:date_of_prod
1616,초기에는 1997년에 이 리비전이 완수될 것으로 예측했으며 ISO 위원회 초안(Committee Draft)은 1997년에 이용이 가능하게 되었다.,"{'word': 'ISO 위원회 초안', 'start': 2983, 'end': 2992, 'type': 'COM'}","{'word': '1997년', 'start': 3012, 'end': 3016, 'type': 'DAT'}",com:date_of_prod
1617,마지막으로 승인된 ISO 표준은 2002년 말에 승인되어 출판되었다.,"{'word': 'ISO 표준', 'start': 3109, 'end': 3114, 'type': 'COM'}","{'word': '2002년 말', 'start': 3117, 'end': 3123, 'type': 'DAT'}",com:date_of_prod
1618,그 뒤 코볼-61 확장 사양으로 1963년에 대체되어 정렬 및 보고서 작성 기능이 도입되었다.,"{'word': '코볼-61', 'start': 481, 'end': 485, 'type': 'COM'}","{'word': '정렬', 'start': 507, 'end': 508, 'type': 'COM'}",com:sub_concept
1619,그 뒤 코볼-61 확장 사양으로 1963년에 대체되어 정렬 및 보고서 작성 기능이 도입되었다.,"{'word': '코볼-61', 'start': 481, 'end': 485, 'type': 'COM'}","{'word': '보고서 작성 기능', 'start': 512, 'end': 520, 'type': 'COM'}",com:sub_concept
1620,코볼 에디션 1965는 사양에 대해 더 명확히 하고 대용량 기억 장치의 파일들과 표를 다룰 수 있는 기능을 소개하였다.,"{'word': '코볼 에디션 1965', 'start': 583, 'end': 593, 'type': 'COM'}","{'word': '대용량 기억 장치의 파일', 'start': 612, 'end': 624, 'type': 'COM'}",com:sub_concept
1621,코볼 에디션 1965는 사양에 대해 더 명확히 하고 대용량 기억 장치의 파일들과 표를 다룰 수 있는 기능을 소개하였다.,"{'word': '코볼 에디션 1965', 'start': 583, 'end': 593, 'type': 'COM'}","{'word': '표', 'start': 628, 'end': 628, 'type': 'COM'}",com:sub_concept
1622,"1974년 ANSI는 (ANS) 코볼의 개정판을 출판하였으며, 여기에는 파일 조직, DELETE 문, 세그먼트 모듈과 같은 새로운 기능들이 포함되었다.","{'word': '코볼의 개정판', 'start': 1421, 'end': 1427, 'type': 'COM'}","{'word': '파일 조직', 'start': 1443, 'end': 1447, 'type': 'COM'}",com:sub_concept
1623,"1974년 ANSI는 (ANS) 코볼의 개정판을 출판하였으며, 여기에는 파일 조직, DELETE 문, 세그먼트 모듈과 같은 새로운 기능들이 포함되었다.","{'word': '코볼의 개정판', 'start': 1421, 'end': 1427, 'type': 'COM'}","{'word': 'DELETE 문', 'start': 1450, 'end': 1457, 'type': 'COM'}",com:sub_concept
1624,"1974년 ANSI는 (ANS) 코볼의 개정판을 출판하였으며, 여기에는 파일 조직, DELETE 문, 세그먼트 모듈과 같은 새로운 기능들이 포함되었다.","{'word': '코볼의 개정판', 'start': 1421, 'end': 1427, 'type': 'COM'}","{'word': '세그먼트 모듈', 'start': 1460, 'end': 1466, 'type': 'COM'}",com:sub_concept
1625,두 개의 개정안이 1989년(내장 함수 도입)과 1993년(기타 수정 사항 제공)에 공개되었다.,"{'word': '개정안', 'start': 2738, 'end': 2740, 'type': 'COM'}","{'word': '내장 함수 도입', 'start': 2749, 'end': 2756, 'type': 'COM'}",com:sub_concept
1626,두 개의 개정안이 1989년(내장 함수 도입)과 1993년(기타 수정 사항 제공)에 공개되었다.,"{'word': '개정안', 'start': 2738, 'end': 2740, 'type': 'COM'}","{'word': '기타 수정 사항 제공', 'start': 2766, 'end': 2776, 'type': 'COM'}",com:sub_concept
1627,"2003년과 2009년 사이에 3개의 기술 보고서가 생산되었으며, 코볼을 위한 오브젝트 완성(object finalization), XML 처리, 콜렉션 클래스를 기술하고 있다.","{'word': '기술 보고서', 'start': 3413, 'end': 3418, 'type': 'COM'}","{'word': 'object finalization', 'start': 3444, 'end': 3462, 'type': 'COM'}",com:sub_concept
1628,"2003년과 2009년 사이에 3개의 기술 보고서가 생산되었으며, 코볼을 위한 오브젝트 완성(object finalization), XML 처리, 콜렉션 클래스를 기술하고 있다.","{'word': '기술 보고서', 'start': 3413, 'end': 3418, 'type': 'COM'}","{'word': 'XML 처리', 'start': 3466, 'end': 3471, 'type': 'COM'}",com:sub_concept
1629,"2003년과 2009년 사이에 3개의 기술 보고서가 생산되었으며, 코볼을 위한 오브젝트 완성(object finalization), XML 처리, 콜렉션 클래스를 기술하고 있다.","{'word': '기술 보고서', 'start': 3413, 'end': 3418, 'type': 'COM'}","{'word': '콜렉션 클래스', 'start': 3474, 'end': 3480, 'type': 'COM'}",com:sub_concept
1630,"코볼 2002의 지원 수준은 매주 낮았다. 즉, 이 표준을 온전히 지원하는 컴파일러가 전무했다.","{'word': '코볼 2002', 'start': 3492, 'end': 3498, 'type': 'COM'}","{'word': '컴파일러', 'start': 3534, 'end': 3537, 'type': 'COM'}",com:sub_concept
1631,"코볼 프로그램들은 정부와 기업체에 고루 사용되며 z/OS, VME, 유닉스, 윈도우와 같은 다양한 운영 체제에서 구동된다.","{'word': '운영 체제', 'start': 3758, 'end': 3762, 'type': 'COM'}","{'word': 'VME', 'start': 3736, 'end': 3738, 'type': 'COM'}",com:sub_concept
1632,"코볼 프로그램들은 정부와 기업체에 고루 사용되며 z/OS, VME, 유닉스, 윈도우와 같은 다양한 운영 체제에서 구동된다.","{'word': '운영 체제', 'start': 3758, 'end': 3762, 'type': 'COM'}","{'word': '유닉스', 'start': 3741, 'end': 3743, 'type': 'COM'}",com:sub_concept
1633,"코볼 프로그램들은 정부와 기업체에 고루 사용되며 z/OS, VME, 유닉스, 윈도우와 같은 다양한 운영 체제에서 구동된다.","{'word': '운영 체제', 'start': 3758, 'end': 3762, 'type': 'COM'}","{'word': '윈도우', 'start': 3746, 'end': 3748, 'type': 'COM'}",com:sub_concept
1634,"코볼 프로그램들은 정부와 기업체에 고루 사용되며 z/OS, VME, 유닉스, 윈도우와 같은 다양한 운영 체제에서 구동된다.","{'word': '운영 체제', 'start': 3758, 'end': 3762, 'type': 'COM'}","{'word': 'z/OS', 'start': 3730, 'end': 3733, 'type': 'COM'}",com:sub_concept
1635,"2006년과 2012년에 컴퓨터월드 조사에 따르면 조직 중 60%가 코볼을 (C++, 비주얼 베이직 닷넷보다 더) 사용하였으며 코볼은 자사 내부 소프트웨어 다수에 사용되었다.","{'word': '소프트웨어', 'start': 4174, 'end': 4178, 'type': 'COM'}","{'word': '코볼', 'start': 4164, 'end': 4165, 'type': 'COM'}",com:sub_concept
1636,이 버전은 ANS(American National Standard) 코볼로 알려져 있으며 1972년에 ISO에 채택되었다.,"{'word': 'ANS', 'start': 815, 'end': 817, 'type': 'COM'}","{'word': 'American National Standard', 'start': 819, 'end': 844, 'type': 'COM'}",com:alter_names
1637,제안된 표준(일반적으로 코볼-80으로 알려져 있음)은 이전 것과는 상당히 달랐으므로 비호환성 및 변환 비용에 대한 걱정을 야기하였다.,"{'word': '표준', 'start': 1748, 'end': 1749, 'type': 'COM'}","{'word': '코볼-80', 'start': 1757, 'end': 1761, 'type': 'COM'}",com:alter_names
1638,초기에는 1997년에 이 리비전이 완수될 것으로 예측했으며 ISO 위원회 초안(Committee Draft)은 1997년에 이용이 가능하게 되었다.,"{'word': 'ISO 위원회 초안', 'start': 2983, 'end': 2992, 'type': 'COM'}","{'word': 'Committee Draft', 'start': 2994, 'end': 3008, 'type': 'COM'}",com:alter_names
1639,"2003년과 2009년 사이에 3개의 기술 보고서가 생산되었으며, 코볼을 위한 오브젝트 완성(object finalization), XML 처리, 콜렉션 클래스를 기술하고 있다.","{'word': '코볼을 위한 오브젝트', 'start': 3429, 'end': 3439, 'type': 'COM'}","{'word': 'object finalization', 'start': 3444, 'end': 3462, 'type': 'COM'}",com:alter_names
1640,"마이크로 포커스, 후지쯔, IBM을 포함한 일부 업체들은 완전한 리비전의 초안에 기반한 객체 지향 문법을 도입하였다.","{'word': '리비전의 초안', 'start': 3069, 'end': 3075, 'type': 'COM'}","{'word': '객체 지향 문법', 'start': 3082, 'end': 3089, 'type': 'COM'}",com:made_of
1641,코볼-60은 1961년에 코볼-61으로 대체되었다.,"{'word': '코볼-61', 'start': 462, 'end': 466, 'type': 'COM'}","{'word': '코볼-60', 'start': 448, 'end': 452, 'type': 'COM'}",com:prior_tech
1642,한 해 더 지나 코볼-80 컴파일러가 코볼-74 프로그램들의 변환에 일부 문제가 있었던 DEC VAX 사용자들에게 공개되었다.,"{'word': '코볼-80', 'start': 2490, 'end': 2494, 'type': 'COM'}","{'word': '코볼-74', 'start': 2502, 'end': 2506, 'type': 'COM'}",com:prior_tech
1643,객체 지향 기능들은 C++과 스몰토크로부터 가져왔다.,"{'word': '객체 지향 기능', 'start': 2920, 'end': 2927, 'type': 'COM'}","{'word': 'C++', 'start': 2931, 'end': 2933, 'type': 'COM'}",com:prior_tech
1644,객체 지향 기능들은 C++과 스몰토크로부터 가져왔다.,"{'word': '객체 지향 기능', 'start': 2920, 'end': 2927, 'type': 'COM'}","{'word': '스몰토크', 'start': 2936, 'end': 2939, 'type': 'COM'}",com:prior_tech
1645,"기타 수많은 기능들이 있었으며, 이 가운데 다수가 《CODASYL COBOL Journal of Development since 1978》에 언급되었고 코볼-85에 포함될 기회는 놓치게 되었다.","{'word': '코볼-85', 'start': 3301, 'end': 3305, 'type': 'COM'}","{'word': 'CODASYL COBOL Journal of Development since 1978', 'start': 3245, 'end': 3291, 'type': 'COM'}",com:prior_tech
1646,"수많은 논리적 결함들이 코볼 60에 발견되었는데, GE의 찰스 캐츠는 이에 대해 모호하게 해석되지 않는다고 경고하였다.","{'word': '찰스 캐츠', 'start': 32, 'end': 36, 'type': 'PER'}","{'word': '코볼 60', 'start': 13, 'end': 17, 'type': 'COM'}",no_relation
1647,1962년 말 ISO와 미국 스탠더드(현재의 ANSI)는 표준을 만드는 그룹들을 설립하였다.,"{'word': 'ISO', 'start': 698, 'end': 700, 'type': 'ORG'}","{'word': '미국 스탠더드', 'start': 703, 'end': 709, 'type': 'ORG'}",no_relation
1648,ANSI 위원회와 독립적으로 CODASYL 프로그래밍 언어 위원회는 언어 개선에 착수했다.,"{'word': 'CODASYL 프로그래밍 언어 위원회', 'start': 937, 'end': 956, 'type': 'ORG'}","{'word': 'ANSI 위원회', 'start': 921, 'end': 928, 'type': 'ORG'}",no_relation
1649,"CODASYL이 ANSI 위원회와 독립적이었으나, ANSI는 《CODASYL Journal of Development》를 사용하여 구현을 보증하는데 충분히 대중적인 기능들을 식별하게 하였다.","{'word': 'ANSI 위원회', 'start': 1105, 'end': 1112, 'type': 'ORG'}","{'word': 'CODASYL', 'start': 1096, 'end': 1102, 'type': 'ORG'}",no_relation
1650,프로그래밍 언어 위원회는 또한 ECMA와 일본 코볼 표준 위원회와도 연계하였다.,"{'word': 'ECMA', 'start': 1220, 'end': 1223, 'type': 'ORG'}","{'word': '프로그래밍 언어 위원회', 'start': 1203, 'end': 1214, 'type': 'ORG'}",no_relation
1651,프로그래밍 언어 위원회는 또한 ECMA와 일본 코볼 표준 위원회와도 연계하였다.,"{'word': '일본 코볼 표준 위원회', 'start': 1226, 'end': 1237, 'type': 'ORG'}","{'word': '프로그래밍 언어 위원회', 'start': 1203, 'end': 1214, 'type': 'ORG'}",no_relation
1652,부사장이었던 William Rinehuls는 코볼 커뮤니티의 2/3이 위원회의 존재조차 모르고 있다고 불평하였다.,"{'word': '코볼 커뮤니티', 'start': 1303, 'end': 1309, 'type': 'ORG'}","{'word': '위원회', 'start': 1317, 'end': 1319, 'type': 'ORG'}",no_relation
1653,"1981년 1월, 트래블러스 인슈런스(Travelers Insurance)의 수석 부사장 조지프 T 브로피(Joseph T. Brophy)는 표준 위원회를 고소하겠다고 위협하였는데 그 까닭은 코볼-74와 상위 호환이 되지 않았기 때문이다.","{'word': '트래블러스 인슈런스', 'start': 1829, 'end': 1838, 'type': 'ORG'}","{'word': '표준 위원회', 'start': 1898, 'end': 1903, 'type': 'ORG'}",no_relation
1654,마이크로 포커스는 그 이유를 새로운 기능에 대한 사용자 수요가 적고 컴파일러 적합성을 테스트하는데 쓰였던 미국 국립표준기술연구소(NIST) 테스트 제품군이 철폐되었기 때문으로 보았다.,"{'word': '마이크로 포커스', 'start': 3546, 'end': 3553, 'type': 'ORG'}","{'word': '미국 국립표준기술연구소', 'start': 3605, 'end': 3616, 'type': 'ORG'}",no_relation
1655,마지못한 단기 위원회는 완전한 정리를 단행하였고 1963년 3월 코볼의 문법이 알골의 것처럼 정의가 가능해졌으나 의미적인 모호성(semantic ambiguities)은 여전히 남아있다고 보고되었다.,"{'word': '단기 위원회', 'start': 72, 'end': 77, 'type': 'ORG'}","{'word': '알골', 'start': 111, 'end': 112, 'type': 'COM'}",no_relation
1656,1962년 미국 해군 평가는 분당 3-11개 문의 컴파일 속도를 지적했다.,"{'word': '미국 해군', 'start': 214, 'end': 218, 'type': 'ORG'}","{'word': '컴파일 속도', 'start': 236, 'end': 241, 'type': 'COM'}",no_relation
1657,"그 해의 나중에 DPMA(Data Processing Management Association)는 이것은 새로운 표준에 강하게 반하는 것이며, 엄두도 못 낼 정도로 높은 변환 비용과 기능 강화가 사용자에게 강제되었다고 언급하였다.","{'word': 'DPMA', 'start': 2034, 'end': 2037, 'type': 'ORG'}","{'word': '표준', 'start': 2088, 'end': 2089, 'type': 'COM'}",no_relation
1658,같은 해에 미국 국립표준국의 연구에 따르면 제안된 표준은 문제점이 거의 없을 것으로 결론을 내렸다.,"{'word': '미국 국립표준국', 'start': 2431, 'end': 2438, 'type': 'ORG'}","{'word': '표준', 'start': 2453, 'end': 2454, 'type': 'COM'}",no_relation
1659,메모리가 늘어나면서 속도가 급격하게 빨라졌고 컴파일 비용이 다양해졌다.,"{'word': '메모리', 'start': 287, 'end': 289, 'type': 'COM'}","{'word': '컴파일', 'start': 312, 'end': 314, 'type': 'COM'}",no_relation
1660,1962년 말에 IBM은 코볼이 그들의 주 개발 언어가 되고 COMTRAN의 개발은 중단할 것이라 선언하였다.,"{'word': 'COMTRAN', 'start': 390, 'end': 396, 'type': 'COM'}","{'word': '코볼', 'start': 370, 'end': 371, 'type': 'COM'}",no_relation
1661,"NOTE 문, EXAMINE 문(INSPECT 문으로 대체), 구현자 정의 랜덤 액세스 모듈(새로운 순차 및 상대 입출력 모듈로 대체)과 같은 기능들이 제거되었다.","{'word': '구현자 정의 랜덤 액세스 모듈', 'start': 1523, 'end': 1538, 'type': 'COM'}","{'word': 'EXAMINE 문', 'start': 1496, 'end': 1504, 'type': 'COM'}",no_relation
1662,보고서 작성 기능은 혹평을 받아 코볼에서 물러났지만 표준이 출판되기 전에 복귀되었다.,"{'word': '보고서 작성 기능', 'start': 1632, 'end': 1640, 'type': 'COM'}","{'word': '코볼', 'start': 1650, 'end': 1651, 'type': 'COM'}",no_relation
1663,제안된 표준(일반적으로 코볼-80으로 알려져 있음)은 이전 것과는 상당히 달랐으므로 비호환성 및 변환 비용에 대한 걱정을 야기하였다.,"{'word': '변환 비용', 'start': 1798, 'end': 1802, 'type': 'COM'}","{'word': '비호환성', 'start': 1791, 'end': 1794, 'type': 'COM'}",no_relation
1664,그 밖의 응답들은 코볼-80이 그들의 시스템에 설치할 수 있는지의 상세한 영향도 분석에 대한 것이었다.,"{'word': '시스템', 'start': 2245, 'end': 2247, 'type': 'COM'}","{'word': '코볼-80', 'start': 2234, 'end': 2238, 'type': 'COM'}",no_relation
1665,새로운 EVALUTE 문과 인라인 PERFORM이 단순해진 제어 흐름와 디버깅 덕분에 특히 잘 받아들여져 생산성이 향상되었다.,"{'word': '인라인 PERFORM', 'start': 2567, 'end': 2577, 'type': 'COM'}","{'word': 'EVALUTE 문', 'start': 2556, 'end': 2564, 'type': 'COM'}",no_relation
1666,새로운 EVALUTE 문과 인라인 PERFORM이 단순해진 제어 흐름와 디버깅 덕분에 특히 잘 받아들여져 생산성이 향상되었다.,"{'word': '디버깅', 'start': 2592, 'end': 2594, 'type': 'COM'}","{'word': '제어 흐름', 'start': 2585, 'end': 2589, 'type': 'COM'}",no_relation
1667,1990년대 초에 완전한 리비전의 차기 코볼에 객체 지향을 추가하는 작업이 시작되었다.,"{'word': '코볼', 'start': 2893, 'end': 2894, 'type': 'COM'}","{'word': '객체 지향', 'start': 2897, 'end': 2901, 'type': 'COM'}",no_relation
1668,마이크로 포커스는 그 이유를 새로운 기능에 대한 사용자 수요가 적고 컴파일러 적합성을 테스트하는데 쓰였던 미국 국립표준기술연구소(NIST) 테스트 제품군이 철폐되었기 때문으로 보았다.,"{'word': '테스트 제품군', 'start': 3624, 'end': 3630, 'type': 'COM'}","{'word': '컴파일러', 'start': 3584, 'end': 3587, 'type': 'COM'}",no_relation
1669,"20세기 말 무렵, 2000년 문제(Y2K) 해결을 위해 코볼 프로그래밍 노력이 상당 부분 집중되었으며 가끔은 10년 전에 시스템을 개발했던 동일 프로그래머들에 의해 수행되었다.","{'word': '프로그래머', 'start': 3958, 'end': 3962, 'type': 'COM'}","{'word': '코볼 프로그래밍', 'start': 3908, 'end': 3915, 'type': 'COM'}",no_relation
1670,"코볼 코드를 고치는데 필요한 일정 수준의 노력이 상당량의 비즈니스 지향 코볼에 전가되었는데, 사무 응용 프로그램들이 날짜를 사용하는 정도가 심했기 때문이다.","{'word': '코볼 코드', 'start': 3976, 'end': 3980, 'type': 'COM'}","{'word': '프로그램', 'start': 4034, 'end': 4037, 'type': 'COM'}",no_relation
1671,일부 기업체는 그들의 코볼 프로그램들을 유지보수하면서도 그들의 시스템을 값비싼 메인프레임에서 더 값싼 더 현대적인 시스템으로 이관해오고 있다.,"{'word': '코볼 프로그램', 'start': 4271, 'end': 4277, 'type': 'COM'}","{'word': '메인프레임', 'start': 4303, 'end': 4307, 'type': 'COM'}",no_relation
1672,"1974년 ANSI는 (ANS) 코볼의 개정판을 출판하였으며, 여기에는 파일 조직, DELETE 문, 세그먼트 모듈과 같은 새로운 기능들이 포함되었다.","{'word': 'ANSI', 'start': 1409, 'end': 1412, 'type': 'ORG'}","{'word': 'ANS', 'start': 1416, 'end': 1418, 'type': 'POH'}",org:production
1673,ANSI는 1968년 8월 《USA Standard COBOL X3.23》을 만듦으로써 차기 버전들의 주춧돌이 되었다.,"{'word': 'ANSI', 'start': 742, 'end': 745, 'type': 'ORG'}","{'word': 'USA Standard COBOL X3.23', 'start': 758, 'end': 781, 'type': 'COM'}",org:production
1674,"CODASYL이 ANSI 위원회와 독립적이었으나, ANSI는 《CODASYL Journal of Development》를 사용하여 구현을 보증하는데 충분히 대중적인 기능들을 식별하게 하였다.","{'word': 'ANSI', 'start': 1124, 'end': 1127, 'type': 'ORG'}","{'word': 'CODASYL Journal of Development', 'start': 1131, 'end': 1160, 'type': 'COM'}",org:production
1675,1985년 말에 ANSI는 개정된 표준을 출판하였다.,"{'word': 'ANSI', 'start': 2632, 'end': 2635, 'type': 'ORG'}","{'word': '개정된 표준', 'start': 2638, 'end': 2643, 'type': 'COM'}",org:production
1676,"마이크로 포커스, 후지쯔, IBM을 포함한 일부 업체들은 완전한 리비전의 초안에 기반한 객체 지향 문법을 도입하였다.","{'word': '마이크로 포커스', 'start': 3033, 'end': 3040, 'type': 'ORG'}","{'word': '객체 지향 문법', 'start': 3082, 'end': 3089, 'type': 'COM'}",org:production
1677,"마이크로 포커스, 후지쯔, IBM을 포함한 일부 업체들은 완전한 리비전의 초안에 기반한 객체 지향 문법을 도입하였다.","{'word': '후지쯔', 'start': 3043, 'end': 3045, 'type': 'ORG'}","{'word': '객체 지향 문법', 'start': 3082, 'end': 3089, 'type': 'COM'}",org:production
1678,"마이크로 포커스, 후지쯔, IBM을 포함한 일부 업체들은 완전한 리비전의 초안에 기반한 객체 지향 문법을 도입하였다.","{'word': 'IBM', 'start': 3048, 'end': 3050, 'type': 'ORG'}","{'word': '객체 지향 문법', 'start': 3082, 'end': 3089, 'type': 'COM'}",org:production
1679,"후지쯔/GT소프트웨어, 마이크로 포커스, 레인코드(RainCode)는 닷넷 프레임워크를 대상으로 한 객체 지향 코볼 컴파일러를 도입하였다.","{'word': '후지쯔/GT소프트웨어', 'start': 3138, 'end': 3148, 'type': 'ORG'}","{'word': '객체 지향 코볼 컴파일러', 'start': 3194, 'end': 3206, 'type': 'COM'}",org:production
1680,"후지쯔/GT소프트웨어, 마이크로 포커스, 레인코드(RainCode)는 닷넷 프레임워크를 대상으로 한 객체 지향 코볼 컴파일러를 도입하였다.","{'word': '마이크로 포커스', 'start': 3151, 'end': 3158, 'type': 'ORG'}","{'word': '객체 지향 코볼 컴파일러', 'start': 3194, 'end': 3206, 'type': 'COM'}",org:production
1681,"후지쯔/GT소프트웨어, 마이크로 포커스, 레인코드(RainCode)는 닷넷 프레임워크를 대상으로 한 객체 지향 코볼 컴파일러를 도입하였다.","{'word': '레인코드', 'start': 3161, 'end': 3164, 'type': 'ORG'}","{'word': '객체 지향 코볼 컴파일러', 'start': 3194, 'end': 3206, 'type': 'COM'}",org:production
1682,"2006년과 2012년에 컴퓨터월드 조사에 따르면 조직 중 60%가 코볼을 (C++, 비주얼 베이직 닷넷보다 더) 사용하였으며 코볼은 자사 내부 소프트웨어 다수에 사용되었다.","{'word': 'C++', 'start': 4136, 'end': 4138, 'type': 'COM'}","{'word': '비주얼 베이직 닷넷', 'start': 4141, 'end': 4150, 'type': 'COM'}",com:similar_tech
1683,41명의 사람들이 참석하였고 당시 의장은 필립스였다.,"{'word': '필립스', 'start': 118, 'end': 120, 'type': 'PER'}","{'word': '의장', 'start': 114, 'end': 115, 'type': 'POH'}",per:title
1684,이 위원회의 위원장은 미국 국립표준국의 조지프 웨그스타인(Joseph Wegstein)이었다.,"{'word': '조지프 웨그스타인', 'start': 1130, 'end': 1138, 'type': 'PER'}","{'word': '위원장', 'start': 1115, 'end': 1117, 'type': 'POH'}",per:title
1685,FLOW-MATIC의 발명가 그레이스 호퍼는 또한 그 위원회에 기술 고문 역할을 하였다.,"{'word': '그레이스 호퍼', 'start': 1393, 'end': 1399, 'type': 'PER'}","{'word': '기술 고문', 'start': 1412, 'end': 1416, 'type': 'POH'}",per:title
1686,"한 사례로 COMTRAN 설명서의 저자이자 중기 위원회 구성원이었던 로이 골드핑거가 그의 언어를 지원하고 대수식 이용을 장려하기 위해 소위원회 회의에 참석했는데, 그 뒤 그레이스 호퍼는 단기 위원회에 메모를 보내면서 영어가 기반이 되는 언어를 만들겠다는 스페리 랜드의 노력을 재차 강조했다.","{'word': '로이 골드핑거', 'start': 1744, 'end': 1750, 'type': 'PER'}","{'word': '중기 위원회 구성원', 'start': 1730, 'end': 1739, 'type': 'POH'}",per:title
1687,RCA 대표 하워드 브롬버그(Howard Bromberg) 또한 FACT를 차단함으로써 코볼 구현체에 대한 RCA의 노고가 물거품이 되지 않게 하였다.,"{'word': '하워드 브롬버그', 'start': 3198, 'end': 3205, 'type': 'PER'}","{'word': 'RCA 대표', 'start': 3191, 'end': 3196, 'type': 'POH'}",per:title
1688,"한 사례로 COMTRAN 설명서의 저자이자 중기 위원회 구성원이었던 로이 골드핑거가 그의 언어를 지원하고 대수식 이용을 장려하기 위해 소위원회 회의에 참석했는데, 그 뒤 그레이스 호퍼는 단기 위원회에 메모를 보내면서 영어가 기반이 되는 언어를 만들겠다는 스페리 랜드의 노력을 재차 강조했다.","{'word': '그레이스 호퍼', 'start': 1801, 'end': 1807, 'type': 'PER'}","{'word': '스페리 랜드', 'start': 1848, 'end': 1853, 'type': 'PER'}",per:colleagues
1689,"조지프 웨그스타인은 ""여기에 러프 스팟(rough spot)이 포함되어 있고 일부 추가가 필요하다""고 언급했고 나중에 밥 베머는 이들을 잡동사니로 기술하였다.","{'word': '조지프 웨그스타인', 'start': 2574, 'end': 2582, 'type': 'PER'}","{'word': '밥 베머', 'start': 2640, 'end': 2643, 'type': 'PER'}",per:colleagues
1690,실망감을 느낀 하워드 브롬버그는 COBOL이라 새겨진 $15의 묘비를 구매하고 찰스 필립스에게 보내 그의 불만을 드러냈다.,"{'word': '하워드 브롬버그', 'start': 3319, 'end': 3326, 'type': 'PER'}","{'word': '찰스 필립스', 'start': 3355, 'end': 3360, 'type': 'PER'}",per:colleagues
1691,"운영 위원회는 6월 4일 만나 협의회를 CODASYL(Committee on Data Systems Languages)라는 이름으로 정하고, 집행 위원회를 설립할 것을 동의하였다.","{'word': '운영 위원회', 'start': 762, 'end': 767, 'type': 'ORG'}","{'word': 'CODASYL', 'start': 784, 'end': 790, 'type': 'ORG'}",org:members
1692,"단기 위원회는 여섯 곳의 컴퓨터 제조업체와 세 군데의 정부 기관으로 이루어져 있었다. 여섯 곳의 제조업체들은 버로스(Burroughs), IBM, 미니애폴리스-하니웰 (하니웰 연구소), RCA, 스페리 랜드(Sperry Rand), 실베이니아 일렉트릭 프로덕츠였다.","{'word': '단기 위원회', 'start': 863, 'end': 868, 'type': 'ORG'}","{'word': '버로스', 'start': 924, 'end': 926, 'type': 'ORG'}",org:members
1693,"단기 위원회는 여섯 곳의 컴퓨터 제조업체와 세 군데의 정부 기관으로 이루어져 있었다. 여섯 곳의 제조업체들은 버로스(Burroughs), IBM, 미니애폴리스-하니웰 (하니웰 연구소), RCA, 스페리 랜드(Sperry Rand), 실베이니아 일렉트릭 프로덕츠였다.","{'word': '단기 위원회', 'start': 863, 'end': 868, 'type': 'ORG'}","{'word': 'IBM', 'start': 940, 'end': 942, 'type': 'ORG'}",org:members
1694,"단기 위원회는 여섯 곳의 컴퓨터 제조업체와 세 군데의 정부 기관으로 이루어져 있었다. 여섯 곳의 제조업체들은 버로스(Burroughs), IBM, 미니애폴리스-하니웰 (하니웰 연구소), RCA, 스페리 랜드(Sperry Rand), 실베이니아 일렉트릭 프로덕츠였다.","{'word': '단기 위원회', 'start': 863, 'end': 868, 'type': 'ORG'}","{'word': '미니애폴리스-하니웰', 'start': 945, 'end': 954, 'type': 'ORG'}",org:members
1695,"세 군데의 정부 기관들은 미국 공군, 해군의 데이비드 테일러 모델 베이슨(David Taylor Model Basin), 국립표준국(현재의 미국 국립표준기술연구소)이었다.","{'word': '정부 기관', 'start': 1018, 'end': 1022, 'type': 'ORG'}","{'word': '미국 공군', 'start': 1026, 'end': 1030, 'type': 'ORG'}",org:members
1696,"세 군데의 정부 기관들은 미국 공군, 해군의 데이비드 테일러 모델 베이슨(David Taylor Model Basin), 국립표준국(현재의 미국 국립표준기술연구소)이었다.","{'word': '정부 기관', 'start': 1018, 'end': 1022, 'type': 'ORG'}","{'word': '해군의 데이비드 테일러 모델 베이슨', 'start': 1033, 'end': 1051, 'type': 'ORG'}",org:members
1697,"세 군데의 정부 기관들은 미국 공군, 해군의 데이비드 테일러 모델 베이슨(David Taylor Model Basin), 국립표준국(현재의 미국 국립표준기술연구소)이었다.","{'word': '정부 기관', 'start': 1018, 'end': 1022, 'type': 'ORG'}","{'word': '국립표준국', 'start': 1080, 'end': 1084, 'type': 'ORG'}",org:members
1698,"소위원회는 사양을 만드는 일로 대부분을 보냈고, 최종 사양을 생산하기 앞서 단기 위원회가 그들의 일을 검토하고 수정하는 일을 맡았다.","{'word': '단기 위원회', 'start': 3470, 'end': 3475, 'type': 'ORG'}","{'word': '소위원회', 'start': 3428, 'end': 3431, 'type': 'ORG'}",org:members
1699,CODASYL 집행 위원회는 사용자들과 업체들로부터의 질문에 답하고 사양을 확장하고 개선할 목적으로 나중에 코볼 유지보수 위원회를 창설하였다.,"{'word': 'CODASYL 집행 위원회', 'start': 3693, 'end': 3706, 'type': 'ORG'}","{'word': '코볼 유지보수 위원회', 'start': 3753, 'end': 3763, 'type': 'ORG'}",org:members
1700,"9월까지 다섯 곳 이상의 제조업체가 CODASYL (벤딕스, 컨트롤 데이터 코퍼레이션, 제너럴 일렉트릭(GE), 내셔널 캐시 레지스터, 필코)에 참여하였고 대표되는 모든 제조업체들이 코볼 컴파일러를 발표하였다.","{'word': 'CODASYL', 'start': 3833, 'end': 3839, 'type': 'ORG'}","{'word': '벤딕스', 'start': 3842, 'end': 3844, 'type': 'ORG'}",org:members
1701,"9월까지 다섯 곳 이상의 제조업체가 CODASYL (벤딕스, 컨트롤 데이터 코퍼레이션, 제너럴 일렉트릭(GE), 내셔널 캐시 레지스터, 필코)에 참여하였고 대표되는 모든 제조업체들이 코볼 컴파일러를 발표하였다.","{'word': 'CODASYL', 'start': 3833, 'end': 3839, 'type': 'ORG'}","{'word': '컨트롤 데이터 코퍼레이션', 'start': 3847, 'end': 3859, 'type': 'ORG'}",org:members
1702,"9월까지 다섯 곳 이상의 제조업체가 CODASYL (벤딕스, 컨트롤 데이터 코퍼레이션, 제너럴 일렉트릭(GE), 내셔널 캐시 레지스터, 필코)에 참여하였고 대표되는 모든 제조업체들이 코볼 컴파일러를 발표하였다.","{'word': 'CODASYL', 'start': 3833, 'end': 3839, 'type': 'ORG'}","{'word': '제너럴 일렉트릭(GE)', 'start': 3862, 'end': 3873, 'type': 'ORG'}",org:members
1703,"9월까지 다섯 곳 이상의 제조업체가 CODASYL (벤딕스, 컨트롤 데이터 코퍼레이션, 제너럴 일렉트릭(GE), 내셔널 캐시 레지스터, 필코)에 참여하였고 대표되는 모든 제조업체들이 코볼 컴파일러를 발표하였다.","{'word': 'CODASYL', 'start': 3833, 'end': 3839, 'type': 'ORG'}","{'word': '내셔널 캐시 레지스터', 'start': 3876, 'end': 3886, 'type': 'ORG'}",org:members
1704,"9월까지 다섯 곳 이상의 제조업체가 CODASYL (벤딕스, 컨트롤 데이터 코퍼레이션, 제너럴 일렉트릭(GE), 내셔널 캐시 레지스터, 필코)에 참여하였고 대표되는 모든 제조업체들이 코볼 컴파일러를 발표하였다.","{'word': 'CODASYL', 'start': 3833, 'end': 3839, 'type': 'ORG'}","{'word': '필코', 'start': 3889, 'end': 3890, 'type': 'ORG'}",org:members
1705,미국 국방부는 각기 다른 컴퓨터에서 동일한 데이터 처리 프로그램들을 실행할 수 있는지에 대해 걱정하였다.,"{'word': '컴퓨터', 'start': 139, 'end': 141, 'type': 'COM'}","{'word': '프로그램', 'start': 156, 'end': 159, 'type': 'COM'}",com:sub_concept
1706,당시 유일한 주류 언어였던 포트란은 이러한 프로그램들 작성에 필요한 기능들이 부족했다.,"{'word': '프로그램', 'start': 208, 'end': 211, 'type': 'COM'}","{'word': '포트란', 'start': 199, 'end': 201, 'type': 'COM'}",com:sub_concept
1707,"FLOW-MATIC이 코볼에 기여한 주된 사항으로는 긴 변수 이름, 명령어를 위한 영어 낱말, 데이터 기술 및 명령의 구분이다.","{'word': 'FLOW-MATIC', 'start': 1427, 'end': 1436, 'type': 'COM'}","{'word': '긴 변수 이름', 'start': 1456, 'end': 1462, 'type': 'COM'}",com:sub_concept
1708,"FLOW-MATIC이 코볼에 기여한 주된 사항으로는 긴 변수 이름, 명령어를 위한 영어 낱말, 데이터 기술 및 명령의 구분이다.","{'word': 'FLOW-MATIC', 'start': 1427, 'end': 1436, 'type': 'COM'}","{'word': '명령어를 위한 영어 낱말', 'start': 1465, 'end': 1477, 'type': 'COM'}",com:sub_concept
1709,"FLOW-MATIC이 코볼에 기여한 주된 사항으로는 긴 변수 이름, 명령어를 위한 영어 낱말, 데이터 기술 및 명령의 구분이다.","{'word': 'FLOW-MATIC', 'start': 1427, 'end': 1436, 'type': 'COM'}","{'word': '데이터 기술 및 명령의 구분', 'start': 1480, 'end': 1494, 'type': 'COM'}",com:sub_concept
1710,"코볼에 포함된 COMTRAN의 기능들은 공식들, PICTURE 절, GO TO의 필요성을 제거하는 개선된 codice_1 문, 더 강력한 파일 관리 시스템을 포함하였다.","{'word': 'COMTRAN', 'start': 1960, 'end': 1966, 'type': 'COM'}","{'word': '공식들', 'start': 1974, 'end': 1976, 'type': 'COM'}",com:sub_concept
1711,"코볼에 포함된 COMTRAN의 기능들은 공식들, PICTURE 절, GO TO의 필요성을 제거하는 개선된 codice_1 문, 더 강력한 파일 관리 시스템을 포함하였다.","{'word': 'COMTRAN', 'start': 1960, 'end': 1966, 'type': 'COM'}","{'word': 'PICTURE 절', 'start': 1979, 'end': 1987, 'type': 'COM'}",com:sub_concept
1712,"코볼에 포함된 COMTRAN의 기능들은 공식들, PICTURE 절, GO TO의 필요성을 제거하는 개선된 codice_1 문, 더 강력한 파일 관리 시스템을 포함하였다.","{'word': 'COMTRAN', 'start': 1960, 'end': 1966, 'type': 'COM'}","{'word': '파일 관리 시스템', 'start': 2029, 'end': 2037, 'type': 'COM'}",com:sub_concept
1713,"이러한 기능들에는 불 대수, 공식, 테이블 서브스크립트(subscripts, indices)가 포함되었다.","{'word': '서브스크립트', 'start': 2304, 'end': 2309, 'type': 'COM'}","{'word': 'subscripts', 'start': 2311, 'end': 2320, 'type': 'COM'}",com:alter_names
1714,"이러한 기능들에는 불 대수, 공식, 테이블 서브스크립트(subscripts, indices)가 포함되었다.","{'word': '서브스크립트', 'start': 2304, 'end': 2309, 'type': 'COM'}","{'word': 'indices', 'start': 2323, 'end': 2329, 'type': 'COM'}",com:alter_names
1715,"조지프 웨그스타인은 ""여기에 러프 스팟(rough spot)이 포함되어 있고 일부 추가가 필요하다""고 언급했고 나중에 밥 베머는 이들을 잡동사니로 기술하였다.","{'word': 'rough spot', 'start': 2596, 'end': 2605, 'type': 'COM'}","{'word': '러프 스팟', 'start': 2590, 'end': 2594, 'type': 'COM'}",com:alter_names
1716,"제안된 이름으로는 ""BUSY"" (비즈니스 시스템: Business System), ""INFOSYL""(정보 시스템 언어: Information System Language), ""COCOSYL""(공용 컴퓨터 시스템 언어: Common Computer Systems Language)를 포함하였다 코볼(COBOL)이라는 이름은 밥 베머가 제안하였다.","{'word': 'BUSY', 'start': 2740, 'end': 2743, 'type': 'COM'}","{'word': '비즈니스 시스템', 'start': 2747, 'end': 2754, 'type': 'COM'}",com:alter_names
1717,"제안된 이름으로는 ""BUSY"" (비즈니스 시스템: Business System), ""INFOSYL""(정보 시스템 언어: Information System Language), ""COCOSYL""(공용 컴퓨터 시스템 언어: Common Computer Systems Language)를 포함하였다 코볼(COBOL)이라는 이름은 밥 베머가 제안하였다.","{'word': 'BUSY', 'start': 2740, 'end': 2743, 'type': 'COM'}","{'word': 'Business System', 'start': 2757, 'end': 2771, 'type': 'COM'}",com:alter_names
1718,"제안된 이름으로는 ""BUSY"" (비즈니스 시스템: Business System), ""INFOSYL""(정보 시스템 언어: Information System Language), ""COCOSYL""(공용 컴퓨터 시스템 언어: Common Computer Systems Language)를 포함하였다 코볼(COBOL)이라는 이름은 밥 베머가 제안하였다.","{'word': 'INFOSYL', 'start': 2776, 'end': 2782, 'type': 'COM'}","{'word': 'Information System Language', 'start': 2796, 'end': 2822, 'type': 'COM'}",com:alter_names
1719,"제안된 이름으로는 ""BUSY"" (비즈니스 시스템: Business System), ""INFOSYL""(정보 시스템 언어: Information System Language), ""COCOSYL""(공용 컴퓨터 시스템 언어: Common Computer Systems Language)를 포함하였다 코볼(COBOL)이라는 이름은 밥 베머가 제안하였다.","{'word': 'INFOSYL', 'start': 2776, 'end': 2782, 'type': 'COM'}","{'word': '정보 시스템 언어', 'start': 2785, 'end': 2793, 'type': 'COM'}",com:alter_names
1720,"제안된 이름으로는 ""BUSY"" (비즈니스 시스템: Business System), ""INFOSYL""(정보 시스템 언어: Information System Language), ""COCOSYL""(공용 컴퓨터 시스템 언어: Common Computer Systems Language)를 포함하였다 코볼(COBOL)이라는 이름은 밥 베머가 제안하였다.","{'word': 'COCOSYL', 'start': 2827, 'end': 2833, 'type': 'COM'}","{'word': 'Common Computer Systems Language', 'start': 2851, 'end': 2882, 'type': 'COM'}",com:alter_names
1721,"제안된 이름으로는 ""BUSY"" (비즈니스 시스템: Business System), ""INFOSYL""(정보 시스템 언어: Information System Language), ""COCOSYL""(공용 컴퓨터 시스템 언어: Common Computer Systems Language)를 포함하였다 코볼(COBOL)이라는 이름은 밥 베머가 제안하였다.","{'word': 'COCOSYL', 'start': 2827, 'end': 2833, 'type': 'COM'}","{'word': '공용 컴퓨터 시스템 언어', 'start': 2836, 'end': 2848, 'type': 'COM'}",com:alter_names
1722,"제안된 이름으로는 ""BUSY"" (비즈니스 시스템: Business System), ""INFOSYL""(정보 시스템 언어: Information System Language), ""COCOSYL""(공용 컴퓨터 시스템 언어: Common Computer Systems Language)를 포함하였다 코볼(COBOL)이라는 이름은 밥 베머가 제안하였다.","{'word': '코볼', 'start': 2892, 'end': 2893, 'type': 'COM'}","{'word': 'COBOL', 'start': 2895, 'end': 2899, 'type': 'COM'}",com:alter_names
1723,"FLOW-MATIC이 코볼에 기여한 주된 사항으로는 긴 변수 이름, 명령어를 위한 영어 낱말, 데이터 기술 및 명령의 구분이다.","{'word': '코볼', 'start': 1439, 'end': 1440, 'type': 'COM'}","{'word': 'FLOW-MATIC', 'start': 1427, 'end': 1436, 'type': 'COM'}",com:prior_tech
1724,1980년에 그레이스 호퍼는 코볼 60이 95% FLOW-MATIC으로 되어 있으며 COMTRAN은 매우 적은 부분에서 영향을 주었다고 언급하였다.,"{'word': '코볼 60', 'start': 1885, 'end': 1889, 'type': 'COM'}","{'word': 'FLOW-MATIC', 'start': 1896, 'end': 1905, 'type': 'COM'}",com:prior_tech
1725,"문맥에 의존적인 키워드들은 거부되었지만 이러한 접근은 나중에 PL/I에 사용되었고, 부분적으로는 2002년부터 코볼에 사용되었다.","{'word': '코볼', 'start': 2442, 'end': 2443, 'type': 'COM'}","{'word': '문맥에 의존적인 키워드', 'start': 2380, 'end': 2391, 'type': 'COM'}",com:prior_tech
1726,"증명할만한 구현체 또한 부족하였으므로, FLOW-MATIC 기반 코볼의 지지자들이 이 결의안을 뒤집을 수 있었다.","{'word': '코볼', 'start': 3163, 'end': 3164, 'type': 'COM'}","{'word': 'FLOW-MATIC', 'start': 3149, 'end': 3158, 'type': 'COM'}",com:prior_tech
1727,"취리히 알골 58 회의가 있은지 정확히 한 해 뒤인 1959년 5월 28, 29일에 펜타곤에서 회의가 열렸고 사무를 위한 공용 프로그래밍 언어를 만드는 것을 논의하였다.","{'word': '취리히 알골 58 회의', 'start': 0, 'end': 11, 'type': 'ORG'}","{'word': '펜타곤', 'start': 47, 'end': 49, 'type': 'ORG'}",no_relation
1728,이 모임을 통해 운영 위원회와 중장기 위원회들이 설립되었다.,"{'word': '중장기 위원회', 'start': 477, 'end': 483, 'type': 'ORG'}","{'word': '운영 위원회', 'start': 469, 'end': 474, 'type': 'ORG'}",no_relation
1729,RCA 대표 하워드 브롬버그(Howard Bromberg) 또한 FACT를 차단함으로써 코볼 구현체에 대한 RCA의 노고가 물거품이 되지 않게 하였다.,"{'word': 'RCA', 'start': 3251, 'end': 3253, 'type': 'ORG'}","{'word': 'FACT', 'start': 3227, 'end': 3230, 'type': 'COM'}",no_relation
1730,최초의 코볼 프로그램은 8월 17일 RCA 501에서 수행되었다.,"{'word': 'RCA', 'start': 4136, 'end': 4138, 'type': 'ORG'}","{'word': '코볼', 'start': 4120, 'end': 4121, 'type': 'COM'}",no_relation
1731,"12월 6일, 7일에 동일한 코볼 프로그램(사소한 변경사항이 있긴 하지만)이 RCA 컴퓨터, Remington-Rand 유니박 컴퓨터에서 실행되어 이들의 호환성을 입증하였다.","{'word': 'RCA 컴퓨터', 'start': 4196, 'end': 4202, 'type': 'ORG'}","{'word': '코볼 프로그램', 'start': 4169, 'end': 4175, 'type': 'COM'}",no_relation
1732,"12월 6일, 7일에 동일한 코볼 프로그램(사소한 변경사항이 있긴 하지만)이 RCA 컴퓨터, Remington-Rand 유니박 컴퓨터에서 실행되어 이들의 호환성을 입증하였다.","{'word': 'Remington-Rand 유니박 컴퓨터', 'start': 4205, 'end': 4226, 'type': 'ORG'}","{'word': '코볼 프로그램', 'start': 4169, 'end': 4175, 'type': 'COM'}",no_relation
1733,더 많은 사람들이 프로그래밍할 수 있어야 하고 새로운 언어는 동시대 기술의 제약을 받아서는 안 된다는 데 대하여 대표자 전원이 동의하였다.,"{'word': '프로그래밍', 'start': 314, 'end': 318, 'type': 'COM'}","{'word': '기술', 'start': 342, 'end': 343, 'type': 'COM'}",no_relation
1734,"데이터 설명, 문(文), 기존의 응용 프로그램, 사용자 경험을 조사하면서 작업이 개시되었다.","{'word': '데이터', 'start': 1161, 'end': 1163, 'type': 'COM'}","{'word': '응용 프로그램', 'start': 1179, 'end': 1185, 'type': 'COM'}",no_relation
1735,FLOW-MATIC의 발명가 그레이스 호퍼는 또한 그 위원회에 기술 고문 역할을 하였다.,"{'word': '그레이스 호퍼', 'start': 1393, 'end': 1399, 'type': 'PER'}","{'word': 'FLOW-MATIC', 'start': 1377, 'end': 1386, 'type': 'COM'}",per:production
1736,밥 베머가 발명한 IBM의 COMTRAN 언어는 그레이스 호퍼의 동료들이 만든 단기 위원회에 의해 FLOW-MATIC의 경쟁 언어로 간주되었다.,"{'word': '밥 베머', 'start': 1499, 'end': 1502, 'type': 'PER'}","{'word': 'COMTRAN', 'start': 1514, 'end': 1520, 'type': 'COM'}",per:production
1737,"한 사례로 COMTRAN 설명서의 저자이자 중기 위원회 구성원이었던 로이 골드핑거가 그의 언어를 지원하고 대수식 이용을 장려하기 위해 소위원회 회의에 참석했는데, 그 뒤 그레이스 호퍼는 단기 위원회에 메모를 보내면서 영어가 기반이 되는 언어를 만들겠다는 스페리 랜드의 노력을 재차 강조했다.","{'word': '로이 골드핑거', 'start': 1744, 'end': 1750, 'type': 'PER'}","{'word': 'COMTRAN 설명서', 'start': 1712, 'end': 1722, 'type': 'COM'}",per:production
1738,"제안된 이름으로는 ""BUSY"" (비즈니스 시스템: Business System), ""INFOSYL""(정보 시스템 언어: Information System Language), ""COCOSYL""(공용 컴퓨터 시스템 언어: Common Computer Systems Language)를 포함하였다 코볼(COBOL)이라는 이름은 밥 베머가 제안하였다.","{'word': '밥 베머', 'start': 2909, 'end': 2912, 'type': 'PER'}","{'word': 'COBOL', 'start': 2895, 'end': 2899, 'type': 'COM'}",per:production
1739,10월에 중기 위원회는 로이 넛이 만든 FACT 언어 사양의 사본을 받았다.,"{'word': '로이 넛', 'start': 2935, 'end': 2938, 'type': 'PER'}","{'word': 'FACT 언어', 'start': 2944, 'end': 2950, 'type': 'COM'}",per:production
1740,밥 베머가 발명한 IBM의 COMTRAN 언어는 그레이스 호퍼의 동료들이 만든 단기 위원회에 의해 FLOW-MATIC의 경쟁 언어로 간주되었다.,"{'word': 'IBM', 'start': 1509, 'end': 1511, 'type': 'ORG'}","{'word': 'COMTRAN', 'start': 1514, 'end': 1520, 'type': 'COM'}",org:production
1741,"1960년 1월 3일 집행 위원회는 이 사양을 승인하였고 정부 인쇄소에 전달되어 ""COBOL 60""으로 인쇄되었다.","{'word': '집행 위원회', 'start': 3515, 'end': 3520, 'type': 'ORG'}","{'word': 'COBOL 60', 'start': 3549, 'end': 3556, 'type': 'COM'}",org:production
1742,"9월까지 다섯 곳 이상의 제조업체가 CODASYL (벤딕스, 컨트롤 데이터 코퍼레이션, 제너럴 일렉트릭(GE), 내셔널 캐시 레지스터, 필코)에 참여하였고 대표되는 모든 제조업체들이 코볼 컴파일러를 발표하였다.","{'word': '벤딕스', 'start': 3842, 'end': 3844, 'type': 'ORG'}","{'word': '코볼 컴파일러', 'start': 3915, 'end': 3921, 'type': 'COM'}",org:production
1743,"9월까지 다섯 곳 이상의 제조업체가 CODASYL (벤딕스, 컨트롤 데이터 코퍼레이션, 제너럴 일렉트릭(GE), 내셔널 캐시 레지스터, 필코)에 참여하였고 대표되는 모든 제조업체들이 코볼 컴파일러를 발표하였다.","{'word': '컨트롤 데이터 코퍼레이션', 'start': 3847, 'end': 3859, 'type': 'ORG'}","{'word': '코볼 컴파일러', 'start': 3915, 'end': 3921, 'type': 'COM'}",org:production
1744,"9월까지 다섯 곳 이상의 제조업체가 CODASYL (벤딕스, 컨트롤 데이터 코퍼레이션, 제너럴 일렉트릭(GE), 내셔널 캐시 레지스터, 필코)에 참여하였고 대표되는 모든 제조업체들이 코볼 컴파일러를 발표하였다.","{'word': '제너럴 일렉트릭(GE)', 'start': 3862, 'end': 3873, 'type': 'ORG'}","{'word': '코볼 컴파일러', 'start': 3915, 'end': 3921, 'type': 'COM'}",org:production
1745,"9월까지 다섯 곳 이상의 제조업체가 CODASYL (벤딕스, 컨트롤 데이터 코퍼레이션, 제너럴 일렉트릭(GE), 내셔널 캐시 레지스터, 필코)에 참여하였고 대표되는 모든 제조업체들이 코볼 컴파일러를 발표하였다.","{'word': '내셔널 캐시 레지스터', 'start': 3876, 'end': 3886, 'type': 'ORG'}","{'word': '코볼 컴파일러', 'start': 3915, 'end': 3921, 'type': 'COM'}",org:production
1746,"9월까지 다섯 곳 이상의 제조업체가 CODASYL (벤딕스, 컨트롤 데이터 코퍼레이션, 제너럴 일렉트릭(GE), 내셔널 캐시 레지스터, 필코)에 참여하였고 대표되는 모든 제조업체들이 코볼 컴파일러를 발표하였다.","{'word': '필코', 'start': 3889, 'end': 3890, 'type': 'ORG'}","{'word': '코볼 컴파일러', 'start': 3915, 'end': 3921, 'type': 'COM'}",org:production
1747,GE와 IBM은 코볼을 자신들의 언어들인 GECOM과 COMTRAN에 각각 통합하였다.,"{'word': 'GE', 'start': 3931, 'end': 3932, 'type': 'ORG'}","{'word': 'GECOM', 'start': 3954, 'end': 3958, 'type': 'COM'}",org:production
1748,GE와 IBM은 코볼을 자신들의 언어들인 GECOM과 COMTRAN에 각각 통합하였다.,"{'word': 'IBM', 'start': 3935, 'end': 3937, 'type': 'ORG'}","{'word': 'COMTRAN', 'start': 3961, 'end': 3967, 'type': 'COM'}",org:production
1749,"반면, 인터내셔널 컴퓨터스 앤드 태뷸레이터스(International Computers and Tabulators)는 그들의 언어인 CODEL을 코볼로 대체할 예정이었다.","{'word': '인터내셔널 컴퓨터스 앤드 태뷸레이터스', 'start': 3984, 'end': 4003, 'type': 'ORG'}","{'word': 'CODEL', 'start': 4054, 'end': 4058, 'type': 'COM'}",org:production
1750,그 와중에 RCA와 스페리 랜드는 코볼 컴파일러를 만드는 일을 하였다.,"{'word': 'RCA', 'start': 4082, 'end': 4084, 'type': 'ORG'}","{'word': '코볼 컴파일러', 'start': 4095, 'end': 4101, 'type': 'COM'}",org:production
1751,그 와중에 RCA와 스페리 랜드는 코볼 컴파일러를 만드는 일을 하였다.,"{'word': '스페리 랜드', 'start': 4087, 'end': 4092, 'type': 'ORG'}","{'word': '코볼 컴파일러', 'start': 4095, 'end': 4101, 'type': 'COM'}",org:production
1752,"이 위원회는 주로 FLOW-MATIC, AIMACO, COMTRAN이라는 프로그래밍 언어들을 조사하였다.","{'word': 'COMTRAN', 'start': 1243, 'end': 1249, 'type': 'COM'}","{'word': 'AIMACO', 'start': 1235, 'end': 1240, 'type': 'COM'}",com:similar_tech
1753,"이 위원회는 주로 FLOW-MATIC, AIMACO, COMTRAN이라는 프로그래밍 언어들을 조사하였다.","{'word': 'FLOW-MATIC', 'start': 1223, 'end': 1232, 'type': 'COM'}","{'word': 'AIMACO', 'start': 1235, 'end': 1240, 'type': 'COM'}",com:similar_tech
1754,"이 위원회는 주로 FLOW-MATIC, AIMACO, COMTRAN이라는 프로그래밍 언어들을 조사하였다.","{'word': 'COMTRAN', 'start': 1243, 'end': 1249, 'type': 'COM'}","{'word': 'FLOW-MATIC', 'start': 1223, 'end': 1232, 'type': 'COM'}",com:similar_tech
1755,FLOW-MATIC 언어는 특히 영향력이 있었는데 그 까닭은 그것이 내부에 구현되었기 때문이기도 하지만 그 밖의 이유로는 AMIACO가 단지 사소한 변경만으로 그것을 파생시켰기 때문이다.,"{'word': 'AMIACO', 'start': 1340, 'end': 1345, 'type': 'COM'}","{'word': 'FLOW-MATIC', 'start': 1272, 'end': 1281, 'type': 'COM'}",com:similar_tech
1756,밥 베머가 발명한 IBM의 COMTRAN 언어는 그레이스 호퍼의 동료들이 만든 단기 위원회에 의해 FLOW-MATIC의 경쟁 언어로 간주되었다.,"{'word': 'COMTRAN', 'start': 1514, 'end': 1520, 'type': 'COM'}","{'word': 'FLOW-MATIC', 'start': 1554, 'end': 1563, 'type': 'COM'}",com:similar_tech
1757,IDENTIFICATION DIVISION은 다음의 코드 개체를 식별하고 클래스나 인터페이스의 정의를 포함한다.,"{'word': 'IDENTIFICATION DIVISION', 'start': 25, 'end': 47, 'type': 'COM'}","{'word': '코드 개체', 'start': 54, 'end': 58, 'type': 'COM'}",com:sub_concept
1758,IDENTIFICATION DIVISION은 다음의 코드 개체를 식별하고 클래스나 인터페이스의 정의를 포함한다.,"{'word': 'IDENTIFICATION DIVISION', 'start': 25, 'end': 47, 'type': 'COM'}","{'word': '클래스', 'start': 66, 'end': 68, 'type': 'COM'}",com:sub_concept
1759,IDENTIFICATION DIVISION은 다음의 코드 개체를 식별하고 클래스나 인터페이스의 정의를 포함한다.,"{'word': 'IDENTIFICATION DIVISION', 'start': 25, 'end': 47, 'type': 'COM'}","{'word': '인터페이스의 정의', 'start': 71, 'end': 79, 'type': 'COM'}",com:sub_concept
1760,클래스와 인터페이스라는 개념은 2002년 이후로 코볼에 포함되고 있다.,"{'word': '코볼', 'start': 115, 'end': 116, 'type': 'COM'}","{'word': '인터페이스', 'start': 93, 'end': 97, 'type': 'COM'}",com:sub_concept
1761,클래스와 인터페이스라는 개념은 2002년 이후로 코볼에 포함되고 있다.,"{'word': '코볼', 'start': 115, 'end': 116, 'type': 'COM'}","{'word': '클래스', 'start': 88, 'end': 90, 'type': 'COM'}",com:sub_concept
1762,"클래스에는 클래스 메소드와 변수, 인스턴스 오브젝트를 포함하는 팩토리 오브젝트(factory object)와 인스턴스 메소드와 변수를 포함하는 인스턴스 오브젝트(instance object)들을 갖고 있다.","{'word': '클래스', 'start': 128, 'end': 130, 'type': 'COM'}","{'word': '클래스 메소드', 'start': 134, 'end': 140, 'type': 'COM'}",com:sub_concept
1763,"클래스에는 클래스 메소드와 변수, 인스턴스 오브젝트를 포함하는 팩토리 오브젝트(factory object)와 인스턴스 메소드와 변수를 포함하는 인스턴스 오브젝트(instance object)들을 갖고 있다.","{'word': '클래스', 'start': 128, 'end': 130, 'type': 'COM'}","{'word': '변수', 'start': 143, 'end': 144, 'type': 'COM'}",com:sub_concept
1764,"클래스에는 클래스 메소드와 변수, 인스턴스 오브젝트를 포함하는 팩토리 오브젝트(factory object)와 인스턴스 메소드와 변수를 포함하는 인스턴스 오브젝트(instance object)들을 갖고 있다.","{'word': '클래스', 'start': 128, 'end': 130, 'type': 'COM'}","{'word': '인스턴스 오브젝트', 'start': 147, 'end': 155, 'type': 'COM'}",com:sub_concept
1765,"클래스에는 클래스 메소드와 변수, 인스턴스 오브젝트를 포함하는 팩토리 오브젝트(factory object)와 인스턴스 메소드와 변수를 포함하는 인스턴스 오브젝트(instance object)들을 갖고 있다.","{'word': '팩토리 오브젝트', 'start': 163, 'end': 170, 'type': 'COM'}","{'word': '클래스 메소드', 'start': 134, 'end': 140, 'type': 'COM'}",com:sub_concept
1766,"클래스에는 클래스 메소드와 변수, 인스턴스 오브젝트를 포함하는 팩토리 오브젝트(factory object)와 인스턴스 메소드와 변수를 포함하는 인스턴스 오브젝트(instance object)들을 갖고 있다.","{'word': '팩토리 오브젝트', 'start': 163, 'end': 170, 'type': 'COM'}","{'word': '인스턴스 오브젝트', 'start': 147, 'end': 155, 'type': 'COM'}",com:sub_concept
1767,"클래스에는 클래스 메소드와 변수, 인스턴스 오브젝트를 포함하는 팩토리 오브젝트(factory object)와 인스턴스 메소드와 변수를 포함하는 인스턴스 오브젝트(instance object)들을 갖고 있다.","{'word': '팩토리 오브젝트', 'start': 163, 'end': 170, 'type': 'COM'}","{'word': '변수', 'start': 143, 'end': 144, 'type': 'COM'}",com:sub_concept
1768,"클래스에는 클래스 메소드와 변수, 인스턴스 오브젝트를 포함하는 팩토리 오브젝트(factory object)와 인스턴스 메소드와 변수를 포함하는 인스턴스 오브젝트(instance object)들을 갖고 있다.","{'word': '클래스', 'start': 128, 'end': 130, 'type': 'COM'}","{'word': '팩토리 오브젝트', 'start': 163, 'end': 170, 'type': 'COM'}",com:sub_concept
1769,"클래스에는 클래스 메소드와 변수, 인스턴스 오브젝트를 포함하는 팩토리 오브젝트(factory object)와 인스턴스 메소드와 변수를 포함하는 인스턴스 오브젝트(instance object)들을 갖고 있다.","{'word': '인스턴스 오브젝트', 'start': 208, 'end': 216, 'type': 'COM'}","{'word': '인스턴스 메소드', 'start': 189, 'end': 196, 'type': 'COM'}",com:sub_concept
1770,"클래스에는 클래스 메소드와 변수, 인스턴스 오브젝트를 포함하는 팩토리 오브젝트(factory object)와 인스턴스 메소드와 변수를 포함하는 인스턴스 오브젝트(instance object)들을 갖고 있다.","{'word': '클래스', 'start': 128, 'end': 130, 'type': 'COM'}","{'word': '인스턴스 메소드', 'start': 189, 'end': 196, 'type': 'COM'}",com:sub_concept
1771,"클래스에는 클래스 메소드와 변수, 인스턴스 오브젝트를 포함하는 팩토리 오브젝트(factory object)와 인스턴스 메소드와 변수를 포함하는 인스턴스 오브젝트(instance object)들을 갖고 있다.","{'word': '인스턴스 오브젝트', 'start': 208, 'end': 216, 'type': 'COM'}","{'word': '변수', 'start': 199, 'end': 200, 'type': 'COM'}",com:sub_concept
1772,"클래스에는 클래스 메소드와 변수, 인스턴스 오브젝트를 포함하는 팩토리 오브젝트(factory object)와 인스턴스 메소드와 변수를 포함하는 인스턴스 오브젝트(instance object)들을 갖고 있다.","{'word': '클래스', 'start': 128, 'end': 130, 'type': 'COM'}","{'word': '변수', 'start': 199, 'end': 200, 'type': 'COM'}",com:sub_concept
1773,"클래스에는 클래스 메소드와 변수, 인스턴스 오브젝트를 포함하는 팩토리 오브젝트(factory object)와 인스턴스 메소드와 변수를 포함하는 인스턴스 오브젝트(instance object)들을 갖고 있다.","{'word': '클래스', 'start': 128, 'end': 130, 'type': 'COM'}","{'word': '인스턴스 오브젝트', 'start': 208, 'end': 216, 'type': 'COM'}",com:sub_concept
1774,"제네릭 프로그래밍 지원은 매개변수 방식의 클래스들을 통해 제공되며, 클래스나 인터페이스를 사용하여 예를 들 수 있다.","{'word': '제네릭 프로그래밍 지원', 'start': 267, 'end': 278, 'type': 'COM'}","{'word': '클래스', 'start': 305, 'end': 307, 'type': 'COM'}",com:sub_concept
1775,"제네릭 프로그래밍 지원은 매개변수 방식의 클래스들을 통해 제공되며, 클래스나 인터페이스를 사용하여 예를 들 수 있다.","{'word': '제네릭 프로그래밍 지원', 'start': 267, 'end': 278, 'type': 'COM'}","{'word': '인터페이스', 'start': 310, 'end': 314, 'type': 'COM'}",com:sub_concept
1776,"제네릭 프로그래밍 지원은 매개변수 방식의 클래스들을 통해 제공되며, 클래스나 인터페이스를 사용하여 예를 들 수 있다.","{'word': '제네릭 프로그래밍 지원', 'start': 267, 'end': 278, 'type': 'COM'}","{'word': '매개변수 방식의 클래스', 'start': 281, 'end': 292, 'type': 'COM'}",com:sub_concept
1777,"오브젝트들은 특정한 종류에 제한을 두기 위해 참조용으로 저장된다. 이른바 두 종류의 메소드가 있다.: 문 (과 매우 비슷하게 동작), 인라인 메소드 호출(함수를 사용하는 것과 비슷).","{'word': '오브젝트', 'start': 333, 'end': 336, 'type': 'COM'}","{'word': '인라인 메소드 호출', 'start': 408, 'end': 417, 'type': 'COM'}",com:sub_concept
1778,"이른바 두 종류의 메소드가 있다.: 문 (과 매우 비슷하게 동작), 인라인 메소드 호출(함수를 사용하는 것과 비슷).","{'word': '메소드', 'start': 380, 'end': 382, 'type': 'COM'}","{'word': '인라인 메소드 호출', 'start': 408, 'end': 417, 'type': 'COM'}",com:sub_concept
1779,"코볼은 메소드를 숨기는 방식은 제공하지 않는다. 클래스 데이터는 숨길 수 있지만, 사용자가 그것에 접근하지 못하도록 절 없이 선언한 경우에야 가능. 메소드 오버로드는 코볼 2014에 추가되었다.","{'word': '코볼', 'start': 517, 'end': 518, 'type': 'COM'}","{'word': '클래스 데이터', 'start': 544, 'end': 550, 'type': 'COM'}",com:sub_concept
1780,"클래스 데이터는 숨길 수 있지만, 사용자가 그것에 접근하지 못하도록 절 없이 선언한 경우에야 가능. 메소드 오버로드는 코볼 2014에 추가되었다.","{'word': '코볼 2014', 'start': 610, 'end': 616, 'type': 'COM'}","{'word': '메소드 오버로드', 'start': 600, 'end': 607, 'type': 'COM'}",com:sub_concept
1781,ENVIRONMENT DIVISION에는 CONFIGURATION SECTION과 INPUT-OUTPUT SECTION을 포함한다.,"{'word': 'ENVIRONMENT DIVISION', 'start': 648, 'end': 667, 'type': 'COM'}","{'word': 'CONFIGURATION SECTION', 'start': 671, 'end': 691, 'type': 'COM'}",com:sub_concept
1782,ENVIRONMENT DIVISION에는 CONFIGURATION SECTION과 INPUT-OUTPUT SECTION을 포함한다.,"{'word': 'ENVIRONMENT DIVISION', 'start': 648, 'end': 667, 'type': 'COM'}","{'word': 'INPUT-OUTPUT SECTION', 'start': 694, 'end': 713, 'type': 'COM'}",com:sub_concept
1783,"CONFIGURATION SECTION은 통화 기호, 로케일, 문자 집합과 같은 변수 기능들을 지정하는데 사용한다.","{'word': 'CONFIGURATION SECTION', 'start': 722, 'end': 742, 'type': 'COM'}","{'word': '통화 기호', 'start': 745, 'end': 749, 'type': 'COM'}",com:sub_concept
1784,"CONFIGURATION SECTION은 통화 기호, 로케일, 문자 집합과 같은 변수 기능들을 지정하는데 사용한다.","{'word': '변수 기능', 'start': 767, 'end': 771, 'type': 'COM'}","{'word': '통화 기호', 'start': 745, 'end': 749, 'type': 'COM'}",com:sub_concept
1785,"CONFIGURATION SECTION은 통화 기호, 로케일, 문자 집합과 같은 변수 기능들을 지정하는데 사용한다.","{'word': 'CONFIGURATION SECTION', 'start': 722, 'end': 742, 'type': 'COM'}","{'word': '로케일', 'start': 752, 'end': 754, 'type': 'COM'}",com:sub_concept
1786,"CONFIGURATION SECTION은 통화 기호, 로케일, 문자 집합과 같은 변수 기능들을 지정하는데 사용한다.","{'word': '변수 기능', 'start': 767, 'end': 771, 'type': 'COM'}","{'word': '로케일', 'start': 752, 'end': 754, 'type': 'COM'}",com:sub_concept
1787,"CONFIGURATION SECTION은 통화 기호, 로케일, 문자 집합과 같은 변수 기능들을 지정하는데 사용한다.","{'word': 'CONFIGURATION SECTION', 'start': 722, 'end': 742, 'type': 'COM'}","{'word': '문자 집합', 'start': 757, 'end': 761, 'type': 'COM'}",com:sub_concept
1788,"CONFIGURATION SECTION은 통화 기호, 로케일, 문자 집합과 같은 변수 기능들을 지정하는데 사용한다.","{'word': '변수 기능', 'start': 767, 'end': 771, 'type': 'COM'}","{'word': '문자 집합', 'start': 757, 'end': 761, 'type': 'COM'}",com:sub_concept
1789,"CONFIGURATION SECTION은 통화 기호, 로케일, 문자 집합과 같은 변수 기능들을 지정하는데 사용한다.","{'word': 'CONFIGURATION SECTION', 'start': 722, 'end': 742, 'type': 'COM'}","{'word': '변수 기능', 'start': 767, 'end': 771, 'type': 'COM'}",com:sub_concept
1790,"코볼은 세 개의 파일 포맷, 즉 오거나이제이션(organization)을 지원한다: 순차(sequential), 색인(indexed), 상대(relative). 순차 파일에서 레코드들은 연속적이며 순차적으로 가로질러야 하는데, 이는 마치 연결 리스트와 비슷하다.","{'word': '코볼', 'start': 825, 'end': 826, 'type': 'COM'}","{'word': '파일 포맷', 'start': 834, 'end': 838, 'type': 'COM'}",com:sub_concept
1791,"코볼은 세 개의 파일 포맷, 즉 오거나이제이션(organization)을 지원한다: 순차(sequential), 색인(indexed), 상대(relative). 순차 파일에서 레코드들은 연속적이며 순차적으로 가로질러야 하는데, 이는 마치 연결 리스트와 비슷하다.","{'word': '파일 포맷', 'start': 834, 'end': 838, 'type': 'COM'}","{'word': '오거나이제이션', 'start': 843, 'end': 849, 'type': 'COM'}",com:sub_concept
1792,"코볼은 세 개의 파일 포맷, 즉 오거나이제이션(organization)을 지원한다: 순차(sequential), 색인(indexed), 상대(relative). 순차 파일에서 레코드들은 연속적이며 순차적으로 가로질러야 하는데, 이는 마치 연결 리스트와 비슷하다.","{'word': '파일 포맷', 'start': 834, 'end': 838, 'type': 'COM'}","{'word': '순차', 'start': 872, 'end': 873, 'type': 'COM'}",com:sub_concept
1793,"코볼은 세 개의 파일 포맷, 즉 오거나이제이션(organization)을 지원한다: 순차(sequential), 색인(indexed), 상대(relative). 순차 파일에서 레코드들은 연속적이며 순차적으로 가로질러야 하는데, 이는 마치 연결 리스트와 비슷하다.","{'word': '파일 포맷', 'start': 834, 'end': 838, 'type': 'COM'}","{'word': '색인', 'start': 888, 'end': 889, 'type': 'COM'}",com:sub_concept
1794,"코볼은 세 개의 파일 포맷, 즉 오거나이제이션(organization)을 지원한다: 순차(sequential), 색인(indexed), 상대(relative). 순차 파일에서 레코드들은 연속적이며 순차적으로 가로질러야 하는데, 이는 마치 연결 리스트와 비슷하다.","{'word': '파일 포맷', 'start': 834, 'end': 838, 'type': 'COM'}","{'word': '상대', 'start': 901, 'end': 902, 'type': 'COM'}",com:sub_concept
1795,"코볼은 세 개의 파일 포맷, 즉 오거나이제이션(organization)을 지원한다: 순차(sequential), 색인(indexed), 상대(relative). 순차 파일에서 레코드들은 연속적이며 순차적으로 가로질러야 하는데, 이는 마치 연결 리스트와 비슷하다.","{'word': '순차 파일', 'start': 915, 'end': 919, 'type': 'COM'}","{'word': '레코드', 'start': 923, 'end': 925, 'type': 'COM'}",com:sub_concept
1796,색인 파일들은 하나 이상의 색인을 갖고 있어서 레코드들이 임의 접근을 가능하게 하고 이들에 저장을 가능케 한다.,"{'word': '색인 파일', 'start': 972, 'end': 976, 'type': 'COM'}","{'word': '색인', 'start': 987, 'end': 988, 'type': 'COM'}",com:sub_concept
1797,각 레코드는 고유 키를 가지고 있어야 하지만 다른 대안이 되는 레코드 키들은 꼭 고유하지 않아도 된다.,"{'word': '레코드', 'start': 1037, 'end': 1039, 'type': 'COM'}","{'word': '고유 키', 'start': 1042, 'end': 1045, 'type': 'COM'}",com:sub_concept
1798,"색인 파일들의 구현체들은 업체에 따라 다르지만, C‑ISAM와 VSAM과 같은 공통 구현체들은 IBM의 ISAM에 기반을 두고 있다.","{'word': '색인 파일', 'start': 1093, 'end': 1097, 'type': 'COM'}","{'word': '구현체', 'start': 1101, 'end': 1103, 'type': 'COM'}",com:sub_concept
1799,색인 파일들과 비슷한 상대 파일들은 고유 레코드 키를 가지고 있으나 대안 키들이 존재하지는 않는다.,"{'word': '상대 파일', 'start': 1180, 'end': 1184, 'type': 'COM'}","{'word': '고유 레코드 키', 'start': 1188, 'end': 1195, 'type': 'COM'}",com:sub_concept
1800,"상대 레코드의 키는 서열적인 위치를 지니는데, 이를테면 10번째 레코드는 10의 키를 가진다.","{'word': '10번째 레코드', 'start': 1255, 'end': 1262, 'type': 'COM'}","{'word': '10의 키', 'start': 1265, 'end': 1269, 'type': 'COM'}",com:sub_concept
1801,공통 비표준 확장으로 줄 단위의 순차 방식(line sequential organization)이 있으며 텍스트 파일을 처리하는데 쓰인다.,"{'word': '공통 비표준 확장', 'start': 1360, 'end': 1368, 'type': 'COM'}","{'word': '줄 단위의 순차 방식', 'start': 1372, 'end': 1382, 'type': 'COM'}",com:sub_concept
1802,파일 안의 레코드들은 새 줄 단위로 끝을 맺으며 그 길이는 다양하다.,"{'word': '파일', 'start': 1438, 'end': 1439, 'type': 'COM'}","{'word': '레코드', 'start': 1444, 'end': 1446, 'type': 'COM'}",com:sub_concept
1803,"DATA DIVISION은 여섯 개의 섹션으로 나뉘며 각기 다른 항목들을 선언한다. 파일 레코드의 경우 FILE SECTION, 정적 변수의 경우 WORKING-STORAGE SECTION, 매개변수와 반환값의 경우 LINKAGE SECTION, 텍스트 기반 사용자 인터페이스의 경우 REPORT SECTION과 SCREEN SECTION이 있다.","{'word': 'DATA DIVISION', 'start': 1477, 'end': 1489, 'type': 'COM'}","{'word': 'FILE SECTION', 'start': 1535, 'end': 1546, 'type': 'COM'}",com:sub_concept
1804,"DATA DIVISION은 여섯 개의 섹션으로 나뉘며 각기 다른 항목들을 선언한다. 파일 레코드의 경우 FILE SECTION, 정적 변수의 경우 WORKING-STORAGE SECTION, 매개변수와 반환값의 경우 LINKAGE SECTION, 텍스트 기반 사용자 인터페이스의 경우 REPORT SECTION과 SCREEN SECTION이 있다.","{'word': 'DATA DIVISION', 'start': 1477, 'end': 1489, 'type': 'COM'}","{'word': 'WORKING-STORAGE SECTION', 'start': 1559, 'end': 1581, 'type': 'COM'}",com:sub_concept
1805,"DATA DIVISION은 여섯 개의 섹션으로 나뉘며 각기 다른 항목들을 선언한다. 파일 레코드의 경우 FILE SECTION, 정적 변수의 경우 WORKING-STORAGE SECTION, 매개변수와 반환값의 경우 LINKAGE SECTION, 텍스트 기반 사용자 인터페이스의 경우 REPORT SECTION과 SCREEN SECTION이 있다.","{'word': 'DATA DIVISION', 'start': 1477, 'end': 1489, 'type': 'COM'}","{'word': 'LINKAGE SECTION', 'start': 1598, 'end': 1612, 'type': 'COM'}",com:sub_concept
1806,"DATA DIVISION은 여섯 개의 섹션으로 나뉘며 각기 다른 항목들을 선언한다. 파일 레코드의 경우 FILE SECTION, 정적 변수의 경우 WORKING-STORAGE SECTION, 매개변수와 반환값의 경우 LINKAGE SECTION, 텍스트 기반 사용자 인터페이스의 경우 REPORT SECTION과 SCREEN SECTION이 있다.","{'word': 'DATA DIVISION', 'start': 1477, 'end': 1489, 'type': 'COM'}","{'word': 'REPORT SECTION', 'start': 1636, 'end': 1649, 'type': 'COM'}",com:sub_concept
1807,"DATA DIVISION은 여섯 개의 섹션으로 나뉘며 각기 다른 항목들을 선언한다. 파일 레코드의 경우 FILE SECTION, 정적 변수의 경우 WORKING-STORAGE SECTION, 매개변수와 반환값의 경우 LINKAGE SECTION, 텍스트 기반 사용자 인터페이스의 경우 REPORT SECTION과 SCREEN SECTION이 있다.","{'word': 'DATA DIVISION', 'start': 1477, 'end': 1489, 'type': 'COM'}","{'word': 'SCREEN SECTION', 'start': 1652, 'end': 1665, 'type': 'COM'}",com:sub_concept
1808,코볼의 데이터 항목들은 데이터 항목이 다른 것의 일부인지를 지시하는 줄 번호를 사용하여 계층적으로 선언한다.,"{'word': '코볼', 'start': 1672, 'end': 1673, 'type': 'COM'}","{'word': '데이터 항목', 'start': 1676, 'end': 1681, 'type': 'COM'}",com:sub_concept
1809,"종속된 데이터 집합을 지닌 항목들은 그룹 항목(group item)이라고 하며, 이들을 기초 항목(elementary item)이라 부르지는 않는다.","{'word': '그룹 항목', 'start': 1833, 'end': 1837, 'type': 'COM'}","{'word': '종속된 데이터 집합', 'start': 1813, 'end': 1822, 'type': 'COM'}",com:sub_concept
1810,"위의 예에서 기초 항목 과 그룹 항목 는 레코드 에 종속되어 있지만 기초 항목 , , 은 그룹 항목 의 일부분이다.","{'word': '레코드', 'start': 2166, 'end': 2168, 'type': 'COM'}","{'word': '그룹 항목', 'start': 2158, 'end': 2162, 'type': 'COM'}",com:sub_concept
1811,"위의 예에서 기초 항목 과 그룹 항목 는 레코드 에 종속되어 있지만 기초 항목 , , 은 그룹 항목 의 일부분이다.","{'word': '레코드', 'start': 2166, 'end': 2168, 'type': 'COM'}","{'word': '기초 항목', 'start': 2150, 'end': 2154, 'type': 'COM'}",com:sub_concept
1812,"위의 예에서 기초 항목 과 그룹 항목 는 레코드 에 종속되어 있지만 기초 항목 , , 은 그룹 항목 의 일부분이다.","{'word': '그룹 항목', 'start': 2193, 'end': 2197, 'type': 'COM'}","{'word': '기초 항목', 'start': 2181, 'end': 2185, 'type': 'COM'}",com:sub_concept
1813,"클래스에는 클래스 메소드와 변수, 인스턴스 오브젝트를 포함하는 팩토리 오브젝트(factory object)와 인스턴스 메소드와 변수를 포함하는 인스턴스 오브젝트(instance object)들을 갖고 있다.","{'word': '팩토리 오브젝트', 'start': 163, 'end': 170, 'type': 'COM'}","{'word': 'factory object', 'start': 172, 'end': 185, 'type': 'COM'}",com:alter_names
1814,"클래스에는 클래스 메소드와 변수, 인스턴스 오브젝트를 포함하는 팩토리 오브젝트(factory object)와 인스턴스 메소드와 변수를 포함하는 인스턴스 오브젝트(instance object)들을 갖고 있다.","{'word': '인스턴스 오브젝트', 'start': 208, 'end': 216, 'type': 'COM'}","{'word': 'instance object', 'start': 218, 'end': 232, 'type': 'COM'}",com:alter_names
1815,"코볼은 세 개의 파일 포맷, 즉 오거나이제이션(organization)을 지원한다: 순차(sequential), 색인(indexed), 상대(relative). 순차 파일에서 레코드들은 연속적이며 순차적으로 가로질러야 하는데, 이는 마치 연결 리스트와 비슷하다.","{'word': '오거나이제이션', 'start': 843, 'end': 849, 'type': 'COM'}","{'word': 'organization)', 'start': 851, 'end': 863, 'type': 'COM'}",com:alter_names
1816,"코볼은 세 개의 파일 포맷, 즉 오거나이제이션(organization)을 지원한다: 순차(sequential), 색인(indexed), 상대(relative). 순차 파일에서 레코드들은 연속적이며 순차적으로 가로질러야 하는데, 이는 마치 연결 리스트와 비슷하다.","{'word': '순차', 'start': 872, 'end': 873, 'type': 'COM'}","{'word': 'sequential', 'start': 875, 'end': 884, 'type': 'COM'}",com:alter_names
1817,"코볼은 세 개의 파일 포맷, 즉 오거나이제이션(organization)을 지원한다: 순차(sequential), 색인(indexed), 상대(relative). 순차 파일에서 레코드들은 연속적이며 순차적으로 가로질러야 하는데, 이는 마치 연결 리스트와 비슷하다.","{'word': '색인', 'start': 888, 'end': 889, 'type': 'COM'}","{'word': 'indexed', 'start': 891, 'end': 897, 'type': 'COM'}",com:alter_names
1818,"코볼은 세 개의 파일 포맷, 즉 오거나이제이션(organization)을 지원한다: 순차(sequential), 색인(indexed), 상대(relative). 순차 파일에서 레코드들은 연속적이며 순차적으로 가로질러야 하는데, 이는 마치 연결 리스트와 비슷하다.","{'word': '상대', 'start': 901, 'end': 902, 'type': 'COM'}","{'word': 'relative', 'start': 904, 'end': 911, 'type': 'COM'}",com:alter_names
1819,공통 비표준 확장으로 줄 단위의 순차 방식(line sequential organization)이 있으며 텍스트 파일을 처리하는데 쓰인다.,"{'word': '줄 단위의 순차 방식', 'start': 1372, 'end': 1382, 'type': 'COM'}","{'word': 'line sequential organization', 'start': 1384, 'end': 1411, 'type': 'COM'}",com:alter_names
1820,번호 1을 가진 최상위 데이터 항목들은 레코드(record)라고 한다.,"{'word': '레코드', 'start': 1795, 'end': 1797, 'type': 'COM'}","{'word': 'record', 'start': 1799, 'end': 1804, 'type': 'COM'}",com:alter_names
1821,"종속된 데이터 집합을 지닌 항목들은 그룹 항목(group item)이라고 하며, 이들을 기초 항목(elementary item)이라 부르지는 않는다.","{'word': '그룹 항목', 'start': 1833, 'end': 1837, 'type': 'COM'}","{'word': 'group item', 'start': 1839, 'end': 1848, 'type': 'COM'}",com:alter_names
1822,"종속된 데이터 집합을 지닌 항목들은 그룹 항목(group item)이라고 하며, 이들을 기초 항목(elementary item)이라 부르지는 않는다.","{'word': '기초 항목', 'start': 1862, 'end': 1866, 'type': 'COM'}","{'word': 'elementary item', 'start': 1868, 'end': 1882, 'type': 'COM'}",com:alter_names
1823,"색인 파일들의 구현체들은 업체에 따라 다르지만, C‑ISAM와 VSAM과 같은 공통 구현체들은 IBM의 ISAM에 기반을 두고 있다.","{'word': 'ISAM', 'start': 1151, 'end': 1154, 'type': 'COM'}","{'word': 'C‑ISAM', 'start': 1120, 'end': 1125, 'type': 'COM'}",com:prior_tech
1824,"색인 파일들의 구현체들은 업체에 따라 다르지만, C‑ISAM와 VSAM과 같은 공통 구현체들은 IBM의 ISAM에 기반을 두고 있다.","{'word': 'ISAM', 'start': 1151, 'end': 1154, 'type': 'COM'}","{'word': 'VSAM', 'start': 1128, 'end': 1131, 'type': 'COM'}",com:prior_tech
1825,상속과 인터페이스들은 다형성을 제공한다.,"{'word': '상속', 'start': 244, 'end': 245, 'type': 'COM'}","{'word': '인터페이스', 'start': 248, 'end': 252, 'type': 'COM'}",no_relation
1826,"또, 상대 파일들은 순차 및 임의 접근이 가능하다.","{'word': '순차', 'start': 1342, 'end': 1343, 'type': 'COM'}","{'word': '임의 접근', 'start': 1347, 'end': 1351, 'type': 'COM'}",no_relation
1827,"파일 레코드의 경우 FILE SECTION, 정적 변수의 경우 WORKING-STORAGE SECTION, 매개변수와 반환값의 경우 LINKAGE SECTION, 텍스트 기반 사용자 인터페이스의 경우 REPORT SECTION과 SCREEN SECTION이 있다.","{'word': '매개변수', 'start': 1584, 'end': 1587, 'type': 'COM'}","{'word': '반환값', 'start': 1590, 'end': 1592, 'type': 'COM'}",no_relation
1828,"색인 파일들의 구현체들은 업체에 따라 다르지만, C‑ISAM와 VSAM과 같은 공통 구현체들은 IBM의 ISAM에 기반을 두고 있다.","{'word': 'IBM', 'start': 1146, 'end': 1148, 'type': 'ORG'}","{'word': 'ISAM', 'start': 1151, 'end': 1154, 'type': 'COM'}",org:production
1829,"코볼은 세 개의 파일 포맷, 즉 오거나이제이션(organization)을 지원한다: 순차(sequential), 색인(indexed), 상대(relative). 순차 파일에서 레코드들은 연속적이며 순차적으로 가로질러야 하는데, 이는 마치 연결 리스트와 비슷하다.","{'word': '오거나이제이션', 'start': 843, 'end': 849, 'type': 'COM'}","{'word': '연결 리스트', 'start': 958, 'end': 963, 'type': 'COM'}",com:similar_tech
1830,색인 파일들과 비슷한 상대 파일들은 고유 레코드 키를 가지고 있으나 대안 키들이 존재하지는 않는다.,"{'word': '색인 파일', 'start': 1168, 'end': 1172, 'type': 'COM'}","{'word': '상대 파일', 'start': 1180, 'end': 1184, 'type': 'COM'}",com:similar_tech
1831,"대표단은 미국 국방부의 데이터 시스템 연구 스태프 총괄을 맡던 찰스 A. 필립스에게 감명을 주었는데, 그는 이들이 미국 국방부의 문제들을 꼼꼼하게 이해하였다고 생각하였다.","{'word': '찰스 A. 필립스', 'start': 497, 'end': 505, 'type': 'PER'}","{'word': '데이터 시스템 연구 스태프 총괄', 'start': 475, 'end': 491, 'type': 'POH'}",per:title
1832,"대표단은 미국 국방부의 데이터 시스템 연구 스태프 총괄을 맡던 찰스 A. 필립스에게 감명을 주었는데, 그는 이들이 미국 국방부의 문제들을 꼼꼼하게 이해하였다고 생각하였다.","{'word': '미국 국방부', 'start': 526, 'end': 531, 'type': 'ORG'}","{'word': '데이터 시스템 연구 스태프', 'start': 475, 'end': 488, 'type': 'ORG'}",org:members
1833,"새로운 프로그래밍 언어들이 빠르게 확산되는 가운데, 동일 조사에서 하나로 통일된 사무 지향 언어가 사용된다면 변환은 훨씬 저렴해지고 빨라질 것이라는 결과가 나왔다.","{'word': '프로그래밍', 'start': 168, 'end': 172, 'type': 'COM'}","{'word': '사무 지향 언어', 'start': 209, 'end': 216, 'type': 'COM'}",com:sub_concept
1834,필립스는 이 회의를 지원하는데 동의하였고 대표단에게 의제의 초안을 작성하는 일을 부여하였다.,"{'word': '필립스', 'start': 691, 'end': 693, 'type': 'PER'}","{'word': '대표단', 'start': 714, 'end': 716, 'type': 'ORG'}",no_relation
1835,"1959년 4월 학계, 컴퓨터 사용자들, 제조업체들의 대표들이 펜실베니아 대학교에서 통일된 사무 언어에 대한 정식 회의를 조성하기에 이르렀다.","{'word': '펜실베니아 대학교', 'start': 291, 'end': 299, 'type': 'ORG'}","{'word': '제조업체', 'start': 279, 'end': 282, 'type': 'ORG'}",no_relation
1836,"미국 국방부는 225대의 컴퓨터를 운영했고 추가로 175대를 주문하였으며 이 컴퓨터들 상에 프로그램을 구현하는데 $200,000,000를 지출하였다.","{'word': '미국 국방부', 'start': 558, 'end': 563, 'type': 'ORG'}","{'word': '컴퓨터', 'start': 572, 'end': 574, 'type': 'COM'}",no_relation
1837,"1959년 4월 학계, 컴퓨터 사용자들, 제조업체들의 대표들이 펜실베니아 대학교에서 통일된 사무 언어에 대한 정식 회의를 조성하기에 이르렀다.","{'word': '사무 언어', 'start': 307, 'end': 311, 'type': 'COM'}","{'word': '컴퓨터 사용자', 'start': 269, 'end': 275, 'type': 'PER'}",no_relation
1838,1950년대 말 컴퓨터 사용자와 제조업체는 프로그래밍의 비용이 치솟는 것을 걱정하기 시작했다.,"{'word': '컴퓨터', 'start': 9, 'end': 11, 'type': 'COM'}","{'word': '프로그래밍', 'start': 24, 'end': 28, 'type': 'COM'}",no_relation
1839,"1959년 조사에 따르면 데이터 처리 설치에서 프로그래밍의 평균 비용은 $800,000 (미국 달러)이고 새로운 하드웨어에서 실행할 수 있도록 프로그램을 변환하는데 드는 비용은 $600,000였다.","{'word': '프로그래밍', 'start': 79, 'end': 83, 'type': 'COM'}","{'word': '데이터', 'start': 67, 'end': 69, 'type': 'COM'}",no_relation
1840,"1959년 조사에 따르면 데이터 처리 설치에서 프로그래밍의 평균 비용은 $800,000 (미국 달러)이고 새로운 하드웨어에서 실행할 수 있도록 프로그램을 변환하는데 드는 비용은 $600,000였다.","{'word': '프로그램', 'start': 133, 'end': 136, 'type': 'COM'}","{'word': '하드웨어', 'start': 116, 'end': 119, 'type': 'COM'}",no_relation
1841,"영어와 같은 데이터 처리 언어 FLOW-MATIC을 개발한 그레이스 호퍼를 포함하여 진 사멧, 솔 곤(Saul Gorn)이 대표로 참석했다.","{'word': '그레이스 호퍼', 'start': 369, 'end': 375, 'type': 'PER'}","{'word': 'FLOW-MATIC', 'start': 353, 'end': 362, 'type': 'COM'}",per:production
1842,"파스칼(Pascal)은 1969년에 스위스 ETH 취리히의 컴퓨터 과학자 니클라우스 비르트가 개발한 프로그래밍 언어로, 당대의 가장 인기있는 교육용 언어 중 하나였으며, 1980년대와 1990년대 초반에 걸쳐 널리 사용되었다.","{'word': '니클라우스 비르트', 'start': 41, 'end': 49, 'type': 'PER'}","{'word': '컴퓨터 과학자', 'start': 33, 'end': 39, 'type': 'POH'}",per:title
1843,파스칼이라는 이름은 프랑스의 수학자이자 철학자 블레즈 파스칼의 이름을 딴 것이다.,"{'word': '블레즈 파스칼', 'start': 218, 'end': 224, 'type': 'PER'}","{'word': '수학자이자 철학자', 'start': 208, 'end': 216, 'type': 'POH'}",per:title
1844,"파스칼(Pascal)은 1969년에 스위스 ETH 취리히의 컴퓨터 과학자 니클라우스 비르트가 개발한 프로그래밍 언어로, 당대의 가장 인기있는 교육용 언어 중 하나였으며, 1980년대와 1990년대 초반에 걸쳐 널리 사용되었다.","{'word': '파스칼(Pascal)', 'start': 0, 'end': 10, 'type': 'COM'}","{'word': '1969년', 'start': 13, 'end': 17, 'type': 'DAT'}",com:date_of_prod
1845,"파스칼(Pascal)은 1969년에 스위스 ETH 취리히의 컴퓨터 과학자 니클라우스 비르트가 개발한 프로그래밍 언어로, 당대의 가장 인기있는 교육용 언어 중 하나였으며, 1980년대와 1990년대 초반에 걸쳐 널리 사용되었다.","{'word': '프로그래밍 언어', 'start': 56, 'end': 63, 'type': 'COM'}","{'word': '파스칼(Pascal)', 'start': 0, 'end': 10, 'type': 'COM'}",com:sub_concept
1846,파스칼은 발표 당시에는 아주 기본적인 컴퓨터 언어의 요소만을 가지고 있었으므로 시스템을 직접 다루기에는 부족하였다.,"{'word': '파스칼', 'start': 127, 'end': 129, 'type': 'COM'}","{'word': '기본적인 컴퓨터 언어의 요소', 'start': 143, 'end': 157, 'type': 'COM'}",com:sub_concept
1847,"과학연구를 목적으로 만들어진 고급언어인 알골 60의 영향을 받은 까닭에, 같은 시기에 마찬가지 영향을 받아 제작된 C와 여러가지 면에서 유사한 점을 갖는다.","{'word': '고급언어', 'start': 312, 'end': 315, 'type': 'COM'}","{'word': '알골 60', 'start': 318, 'end': 322, 'type': 'COM'}",com:sub_concept
1848,"델파이 언어로 불리는 변종 오브젝트 파스칼은 델파이, 프리 파스칼 IDE, 라자루스 등에서 개발할 수 있다.","{'word': '변종 오브젝트 파스칼', 'start': 899, 'end': 909, 'type': 'COM'}","{'word': '델파이 언어', 'start': 887, 'end': 892, 'type': 'COM'}",com:alter_names
1849,"볼랜드 파스칼이라 불리는 델파이 이전의 오브젝트 파스칼은 터보 파스칼, 프리 파스칼 IDE에서 개발할 수 있다.","{'word': '델파이 이전의 오브젝트 파스칼', 'start': 962, 'end': 977, 'type': 'COM'}","{'word': '볼랜드 파스칼', 'start': 948, 'end': 954, 'type': 'COM'}",com:alter_names
1850,파스칼 구조는 절차와 함수로 짜여진다.,"{'word': '파스칼 구조', 'start': 2247, 'end': 2252, 'type': 'COM'}","{'word': '절차와 함수', 'start': 2255, 'end': 2260, 'type': 'COM'}",com:made_of
1851,엠바카데로 사의 델파이와 카일릭스는 파스칼의 직계 후손이라 할 수 있는 오브젝트 파스칼을 사용한다.,"{'word': '오브젝트 파스칼', 'start': 807, 'end': 814, 'type': 'COM'}","{'word': '파스칼', 'start': 787, 'end': 789, 'type': 'COM'}",com:prior_tech
1852,"많은 변종들이 존재하며, 객체 지향 프로그래밍을 위해 기능을 추가한 변종들도 다수 존재한다.","{'word': '객체 지향 프로그래밍', 'start': 729, 'end': 739, 'type': 'COM'}","{'word': '변종', 'start': 718, 'end': 719, 'type': 'POH'}",no_relation
1853,집합은 현대 수학에 있어 기본적인 개념이며 수많은 알고리즘이 집합을 사용하여 정의된다.,"{'word': '알고리즘', 'start': 1406, 'end': 1409, 'type': 'COM'}","{'word': '집합', 'start': 1378, 'end': 1379, 'type': 'POH'}",no_relation
1854,포인터를 사용한 구조적 프로그래밍과 데이터 구조화(data structuring)를 그 특징으로 한다.,"{'word': '구조적 프로그래밍', 'start': 247, 'end': 255, 'type': 'COM'}","{'word': '데이터 구조화(data structuring)', 'start': 258, 'end': 282, 'type': 'COM'}",no_relation
1855,그러나 코드를 간결하게 하고 버그를 더 쉽게 잡아내기 위한 목적으로 몇가지 기능을 제한함으로써 결과적으로 C 언어에 비해 활용도가 떨어지는 언어가 되었다.,"{'word': '코드', 'start': 388, 'end': 389, 'type': 'COM'}","{'word': '버그', 'start': 400, 'end': 401, 'type': 'COM'}",no_relation
1856,"그러나 완전히 비실용적인 언어라는 뜻은 아니며, 실제로 TeX나 초기 매킨토시 운영 체제 제작에 사용되기도 하였다.","{'word': 'TeX', 'start': 502, 'end': 504, 'type': 'COM'}","{'word': '매킨토시 운영 체제', 'start': 510, 'end': 519, 'type': 'COM'}",no_relation
1857,최근에는 파스칼 컴파일러 자체가 크게 개선되고 소프트웨어 개발 기술의 발전으로 이런 사소한 차이점은 거의 무시할 수 있는 단점이 되었다.,"{'word': '파스칼 컴파일러', 'start': 541, 'end': 548, 'type': 'COM'}","{'word': '소프트웨어 개발 기술', 'start': 562, 'end': 572, 'type': 'COM'}",no_relation
1858,"다른 프로그래밍 언어와 달리, 파스칼은 집합 유형을 지원한다:","{'word': '프로그래밍 언어', 'start': 1276, 'end': 1283, 'type': 'COM'}","{'word': '파스칼', 'start': 1290, 'end': 1292, 'type': 'COM'}",no_relation
1859,그러므로 이러한 알고리즘을 추가하는 것은 파스칼에 매우 알맞다고 볼 수 있다.,"{'word': '알고리즘', 'start': 1436, 'end': 1439, 'type': 'COM'}","{'word': '파스칼', 'start': 1450, 'end': 1452, 'type': 'COM'}",no_relation
1860,파스칼은 포인터 사용을 지원한다:,"{'word': '파스칼', 'start': 1636, 'end': 1638, 'type': 'COM'}","{'word': '포인터', 'start': 1641, 'end': 1643, 'type': 'COM'}",no_relation
1861,가변 codice_1가 자료형 codice_2 레코드의 포인터이다.,"{'word': '자료형', 'start': 1685, 'end': 1687, 'type': 'COM'}","{'word': '포인터', 'start': 1703, 'end': 1705, 'type': 'COM'}",no_relation
1862,"새로운 레코드를 만들어 값codice_3과 codice_4를 레코드 안의 필드 codice_5로 할당하려면, 다음과 같은 명령어를 사용하면 된다:","{'word': '레코드', 'start': 1736, 'end': 1738, 'type': 'COM'}","{'word': '명령어', 'start': 1800, 'end': 1802, 'type': 'COM'}",no_relation
1863,"파스칼은 구조 프로그래밍 언어이며, 제어 흐름을 goto 문 없이 표준화할 수 있다.","{'word': '파스칼', 'start': 2006, 'end': 2008, 'type': 'COM'}","{'word': '구조 프로그래밍 언어', 'start': 2011, 'end': 2021, 'type': 'COM'}",no_relation
1864,"절차와 함수는 어느 깊이로든 놓일 수 있으며, 프로그램 구조는 논리 외부 블록이다.","{'word': '절차', 'start': 2436, 'end': 2437, 'type': 'COM'}","{'word': '함수', 'start': 2440, 'end': 2441, 'type': 'COM'}",no_relation
1865,"현재는 초기의 파스칼에 비해 많은 부분이 추가, 개선되고 다른언어의 장점들을 따와 상용 파스칼 컴파일러인 델파이는 C++과 거의 기능 차이가 없다.","{'word': '델파이', 'start': 691, 'end': 693, 'type': 'COM'}","{'word': 'C++', 'start': 696, 'end': 698, 'type': 'COM'}",com:similar_tech
1866,오픈 소스로 제작된 프리 파스칼이나 GNU 파스칼도 있다.,"{'word': '프리 파스칼', 'start': 865, 'end': 870, 'type': 'COM'}","{'word': 'GNU 파스칼', 'start': 874, 'end': 880, 'type': 'COM'}",com:similar_tech
1867,엠바카데로 사의 델파이와 카일릭스는 파스칼의 직계 후손이라 할 수 있는 오브젝트 파스칼을 사용한다.,"{'word': '엠바카데로', 'start': 767, 'end': 771, 'type': 'ORG'}","{'word': '델파이와 카일릭스', 'start': 776, 'end': 784, 'type': 'COM'}",org:production
1868,"파스칼(Pascal)은 1969년에 스위스 ETH 취리히의 컴퓨터 과학자 니클라우스 비르트가 개발한 프로그래밍 언어로, 당대의 가장 인기있는 교육용 언어 중 하나였으며, 1980년대와 1990년대 초반에 걸쳐 널리 사용되었다.","{'word': '니클라우스 비르트', 'start': 41, 'end': 49, 'type': 'PER'}","{'word': '파스칼(Pascal)', 'start': 0, 'end': 10, 'type': 'COM'}",per:production
1869,"최초의 고급 프로그래밍 언어, 즉 3세대 프로그래밍 언어(3GL)는 1950년대에 작성되었다.","{'word': '최초의 고급 프로그래밍 언어', 'start': 648, 'end': 662, 'type': 'COM'}","{'word': '1950년대', 'start': 686, 'end': 691, 'type': 'DAT'}",com:date_of_prod
1870,"컴퓨터용으로 설계될 초기의 고급 프로그래밍 언어는 Plankalkül였으며, 콘라트 추제가 1943년부터 1945년까지 독일의 Z3용으로 개발될 것이었다.","{'word': 'Plankalkül', 'start': 729, 'end': 738, 'type': 'COM'}","{'word': '1943년부터 1945년', 'start': 752, 'end': 764, 'type': 'DAT'}",com:date_of_prod
1871,"컴퓨터 프로그램은 데이터(data)와 명령어(instruction), 이렇게 두 부분으로 나뉜다.","{'word': '컴퓨터 프로그램', 'start': 1070, 'end': 1077, 'type': 'COM'}","{'word': '데이터(data)와 명령어(instruction)', 'start': 1080, 'end': 1106, 'type': 'COM'}",com:sub_concept
1872,"예를 들어, C 언어는 검색, 정렬, 입출력에 관련된 다양하고 풍부한 표준 함수(standard functions)들을 제공한다.","{'word': 'C 언어', 'start': 2417, 'end': 2420, 'type': 'COM'}","{'word': '표준 함수(standard functions)', 'start': 2449, 'end': 2473, 'type': 'COM'}",com:sub_concept
1873,"연결된 함수들을 한데 묶어 놓은 것은 모듈(module)이라 하고, 모듈들의 상호 연결로 하나의 프로그램이 구성된다.","{'word': '모듈(module)', 'start': 2558, 'end': 2567, 'type': 'COM'}","{'word': '함수', 'start': 2541, 'end': 2542, 'type': 'COM'}",com:sub_concept
1874,"연결된 함수들을 한데 묶어 놓은 것은 모듈(module)이라 하고, 모듈들의 상호 연결로 하나의 프로그램이 구성된다.","{'word': '프로그램', 'start': 2591, 'end': 2594, 'type': 'COM'}","{'word': '모듈', 'start': 2575, 'end': 2576, 'type': 'COM'}",com:sub_concept
1875,그리고 이러한 모듈들을 재사용할 수 있게 모아둔 것을 라이브러리라 한다.,"{'word': '라이브러리', 'start': 2633, 'end': 2637, 'type': 'COM'}","{'word': '모듈', 'start': 2611, 'end': 2612, 'type': 'COM'}",com:sub_concept
1876,"한편 객체 지향 프로그래밍언어(OOP)인 자바스크립트에서 사용되는 기초적인 문법의 개념으로는 속성과 메쏘드를 갖는 객체(오브젝트) 개념이 있으며,","{'word': '자바스크립트에서 사용되는 기초적인 문법', 'start': 2667, 'end': 2687, 'type': 'COM'}","{'word': '객체(오브젝트)', 'start': 2708, 'end': 2715, 'type': 'COM'}",com:sub_concept
1877,"한편 객체 지향 프로그래밍언어(OOP)인 자바스크립트에서 사용되는 기초적인 문법의 개념으로는 속성과 메쏘드를 갖는 객체(오브젝트) 개념이 있으며, 변수 선언, 함수 정의, 연산자 그리고 제어문등을 주요하게 들수 있다.","{'word': '자바스크립트에서 사용되는 기초적인 문법', 'start': 2667, 'end': 2687, 'type': 'COM'}","{'word': '변수 선언, 함수 정의, 연산자 그리고 제어문', 'start': 2726, 'end': 2750, 'type': 'COM'}",com:sub_concept
1878,절대적인 기계어는 나중에 1 세대 프로그래밍 언어(1GL)로 명칭이 정해졌다.,"{'word': '절대적인 기계어', 'start': 443, 'end': 450, 'type': 'COM'}","{'word': '1 세대 프로그래밍 언어(1GL)', 'start': 457, 'end': 474, 'type': 'COM'}",com:alter_names
1879,"다음 단계로 이른바 2세대 프로그래밍 언어(2GL), 곧 어셈블리어가 개발되었으며 여전히 특정 컴퓨터의 명령어 집합 구조와 밀접하게 관계되었다.","{'word': '2세대 프로그래밍 언어(2GL)', 'start': 498, 'end': 514, 'type': 'COM'}","{'word': '어셈블리어', 'start': 519, 'end': 523, 'type': 'COM'}",com:alter_names
1880,"최초의 고급 프로그래밍 언어, 즉 3세대 프로그래밍 언어(3GL)는 1950년대에 작성되었다.","{'word': '최초의 고급 프로그래밍 언어', 'start': 648, 'end': 662, 'type': 'COM'}","{'word': '3세대 프로그래밍 언어(3GL)', 'start': 667, 'end': 683, 'type': 'COM'}",com:alter_names
1881,"4세대 프로그래밍 언어(4GL)는 3세대 프로그래밍 언어 보다 내부 컴퓨터 하드웨어의 상세한 부분을 더 고급적으로 추상화시키는 것을 목적으로 한다. 5세대 프로그래밍 언어(5GL)는 프로그래머가 작성한 알고리즘을 이용하지 않고, 프로그램에 주어지는 제약을 사용하여 문제를 해결하는 언어이다.","{'word': '4세대 프로그래밍 언어(4GL)', 'start': 817, 'end': 833, 'type': 'COM'}","{'word': '3세대 프로그래밍 언어', 'start': 836, 'end': 847, 'type': 'COM'}",com:prior_tech
1882,"통상 A언어부터 B언어, C언어 순으로 발전해 왔다고 일컬어진다.","{'word': 'B언어', 'start': 1042, 'end': 1044, 'type': 'COM'}","{'word': 'A언어', 'start': 1036, 'end': 1038, 'type': 'COM'}",com:prior_tech
1883,"통상 A언어부터 B언어, C언어 순으로 발전해 왔다고 일컬어진다.","{'word': 'C언어', 'start': 1047, 'end': 1049, 'type': 'COM'}","{'word': 'B언어', 'start': 1042, 'end': 1044, 'type': 'COM'}",com:prior_tech
1884,컴퓨터 언어는 컴퓨터의 하드웨어를 직접 제어하는 초기의 어셈블리와 같은 언어에서부터 시작하여 현재에는 C 언어와 같은 고급 언어(high-level language)로 발전되어 왔다.,"{'word': 'C 언어와 같은 고급 언어(high-level language)', 'start': 2069, 'end': 2103, 'type': 'COM'}","{'word': '컴퓨터의 하드웨어를 직접 제어하는 초기의 어셈블리', 'start': 2020, 'end': 2046, 'type': 'COM'}",com:prior_tech
1885,사용자는 필요에 따라 데이터를 다음과 같이 선언(declaration)할 수 있다.,"{'word': '사용자', 'start': 1182, 'end': 1184, 'type': 'PER'}","{'word': '데이터', 'start': 1194, 'end': 1196, 'type': 'COM'}",no_relation
1886,프로그래머는 상위 레벨의 지시문으로 프로그램을 작성하면 컴파일러가 이 지시문을 컴퓨터가 이해할 수 있는 기계어로 번역한다.,"{'word': '프로그래머', 'start': 2206, 'end': 2210, 'type': 'PER'}","{'word': '컴파일러', 'start': 2237, 'end': 2240, 'type': 'COM'}",no_relation
1887,이런 표준 함수가 제공되는 덕분에 사용자는 해당 함수를 만드는 데 드는 노력을 절약할 수 있다.,"{'word': '사용자', 'start': 2502, 'end': 2504, 'type': 'PER'}","{'word': '표준 함수', 'start': 2486, 'end': 2490, 'type': 'COM'}",no_relation
1888,고급 언어일수록 사람이 사용하는 언어에 가깝다.,"{'word': '고급 언어', 'start': 48, 'end': 52, 'type': 'COM'}","{'word': '언어', 'start': 66, 'end': 67, 'type': 'POH'}",no_relation
1889,"예를 들어, 사각형을 만드는 데 필요한 자료형을 정의한다고 하자.","{'word': '자료형', 'start': 1596, 'end': 1598, 'type': 'COM'}","{'word': '사각형', 'start': 1581, 'end': 1583, 'type': 'POH'}",no_relation
1890,프로그래밍 언어는 컴퓨터 시스템을 구동시키는 소프트웨어를 작성하기 위한 형식언어이다.,"{'word': '프로그래밍 언어', 'start': 0, 'end': 7, 'type': 'COM'}","{'word': '컴퓨터 시스템', 'start': 10, 'end': 16, 'type': 'COM'}",no_relation
1891,"일반적으로 말할 때에는 프로그래밍 언어를 지원하는 소프트웨어, 곧 소프트웨어를 작성하기 위한 소프트웨어를 가리키는 때가 많고, 이때에는 프로그래밍 언어와 소프트웨어를 구분하지 않고 소프트웨어를 프로그래밍 언어로 보기도 한다.","{'word': '프로그래밍 언어', 'start': 88, 'end': 95, 'type': 'COM'}","{'word': '소프트웨어', 'start': 103, 'end': 107, 'type': 'COM'}",no_relation
1892,"예를 들면, 델파이는 프로그래밍 언어인 오브젝트 파스칼을 지원하는 소프트웨어를 작성하기 위한 소프트웨어일 뿐이지만, 델파이를 별개의 프로그래밍 언어로 보는 때가 더 많다.","{'word': '델파이', 'start': 208, 'end': 210, 'type': 'COM'}","{'word': '프로그래밍 언어', 'start': 213, 'end': 220, 'type': 'COM'}",no_relation
1893,"최초의 컴퓨터는 종종 프로그래밍 언어의 도움 없이 프로그래밍되었는데, 이는 프로그램들을 절대적인 기계어로 작성함으로써 이루어졌다.","{'word': '컴퓨터', 'start': 301, 'end': 303, 'type': 'COM'}","{'word': '프로그래밍 언어', 'start': 309, 'end': 316, 'type': 'COM'}",no_relation
1894,10진이나 이진 형태의 프로그램들은 천공 카드나 자기 테이프로부터 읽거나 컴퓨터 프론트 패널의 스위치를 켜고 끔으로써 불러들였다.,"{'word': '프로그램', 'start': 383, 'end': 386, 'type': 'COM'}","{'word': '천공 카드', 'start': 390, 'end': 394, 'type': 'COM'}",no_relation
1895,"프로그램을 훨씬 더 인간이 읽기 쉽게 만들어주었을 뿐 아니라, 주소 계산 시 따분하고 오류가 발생할 경향이 있는 프로그래머를 안심시켜 주었다.","{'word': '프로그램', 'start': 568, 'end': 571, 'type': 'COM'}","{'word': '프로그래머', 'start': 631, 'end': 635, 'type': 'COM'}",no_relation
1896,프로그래밍 언어는 이런 바이트들을 유용한 형태로 정리한다.,"{'word': '프로그래밍 언어', 'start': 1149, 'end': 1156, 'type': 'COM'}","{'word': '바이트', 'start': 1162, 'end': 1164, 'type': 'COM'}",no_relation
1897,"이와 같이 선언하면, 컴퓨터 메모리의 한 영역을 'MyData'라는 이름의 정수(integer) 타입으로 저장한다.","{'word': '컴퓨터 메모리', 'start': 1264, 'end': 1270, 'type': 'COM'}","{'word': '정수(integer) 타입', 'start': 1294, 'end': 1307, 'type': 'COM'}",no_relation
1898,메모리의 어느 영역에 데이터를 저장할 것인가는 컴파일러가 결정한다.,"{'word': '메모리', 'start': 1317, 'end': 1319, 'type': 'COM'}","{'word': '데이터', 'start': 1329, 'end': 1331, 'type': 'COM'}",no_relation
1899,"일반적으로 사용자는 컴파일러의 내부가 어떻게 동작하는지 몰라도 프로그램을 만들 수 있다. 'MyData'는 간단한 변수(variable)이고, 한 개의 정수만 변수에 담을 수 있다.","{'word': '컴파일러', 'start': 1366, 'end': 1369, 'type': 'COM'}","{'word': '프로그램', 'start': 1390, 'end': 1393, 'type': 'COM'}",no_relation
1900,여러 개의 변수를 만들고 싶으면 아주 간단하게 배열(array)을 만들 수 있다.,"{'word': '변수', 'start': 1463, 'end': 1464, 'type': 'COM'}","{'word': '배열(array)', 'start': 1483, 'end': 1491, 'type': 'COM'}",no_relation
1901,소프트웨어 공학의 발달로 보다 복잡한 자료형들이 필요해졌다.,"{'word': '소프트웨어 공학', 'start': 1540, 'end': 1547, 'type': 'COM'}","{'word': '자료형', 'start': 1561, 'end': 1563, 'type': 'COM'}",no_relation
1902,"따라서, 위와 같은 변수나 배열의 선언만으로는 이런 정보들을 잘 정의하기가 어렵다.","{'word': '변수', 'start': 1666, 'end': 1667, 'type': 'COM'}","{'word': '배열', 'start': 1670, 'end': 1671, 'type': 'COM'}",no_relation
1903,C 언어와 같은 고급 언어(high-level language)는 보다 정교한 자료형의 선언을 지원하여 여러 가지 다른 형식의 데이터 선언들을 한데 엮은 새로운 자료형을 만들 수 있다.,"{'word': 'C 언어와 같은 고급 언어(high-level language)', 'start': 1702, 'end': 1736, 'type': 'COM'}","{'word': '자료형', 'start': 1746, 'end': 1748, 'type': 'COM'}",no_relation
1904,이러한 데이터들을 활용하기 위해서는 컴퓨터에게 지시를 내려야 한다.,"{'word': '데이터', 'start': 1931, 'end': 1933, 'type': 'COM'}","{'word': '컴퓨터', 'start': 1947, 'end': 1949, 'type': 'COM'}",no_relation
1905,프로그램 언어가 상위 레벨로 발전될수록 프로그램은 좀 더 인간의 언어에 가까운 형태가 된다.,"{'word': '프로그램 언어', 'start': 2115, 'end': 2121, 'type': 'COM'}","{'word': '프로그램', 'start': 2137, 'end': 2140, 'type': 'COM'}",no_relation
1906,이에 따라 프로그램 언어의 학습과 프로그램의 구현이 보다 수월해진다.,"{'word': '프로그램 언어', 'start': 2173, 'end': 2179, 'type': 'COM'}","{'word': '프로그램의 구현', 'start': 2186, 'end': 2193, 'type': 'COM'}",no_relation
1907,지시문들을 한데 묶어 놓은 것들을 함수(function)이라 한다.,"{'word': '지시문', 'start': 2275, 'end': 2277, 'type': 'COM'}","{'word': '함수(function)', 'start': 2294, 'end': 2305, 'type': 'COM'}",no_relation
1908,함수는 특정한 동작을 일반적인 형태로 정의해 놓은 지시문의 집합이다.,"{'word': '함수', 'start': 2313, 'end': 2314, 'type': 'COM'}","{'word': '지시문', 'start': 2341, 'end': 2343, 'type': 'COM'}",no_relation
1909,똑같은 동작이 필요하면 지시문을 다시 작성할 필요없이 함수의 매개변수를 이용하여 계속 사용할 수 있다.,"{'word': '지시문', 'start': 2365, 'end': 2367, 'type': 'COM'}","{'word': '함수의 매개변수', 'start': 2382, 'end': 2389, 'type': 'COM'}",no_relation
1910,"컴퓨터용으로 설계될 초기의 고급 프로그래밍 언어는 Plankalkül였으며, 콘라트 추제가 1943년부터 1945년까지 독일의 Z3용으로 개발될 것이었다.","{'word': '콘라트 추제', 'start': 744, 'end': 749, 'type': 'PER'}","{'word': 'Plankalkül', 'start': 729, 'end': 738, 'type': 'COM'}",per:production
1911,함수들에 경계 검사와 자동 버퍼 할당을 채택하는 것을 제안하기 위해 ISO C 윈원회는 기술 보고서 TR 24731-1를 발행하였고 TR 24731-2를 작성중에 있다.,"{'word': 'ISO C 윈원회', 'start': 2137, 'end': 2145, 'type': 'ORG'}","{'word': '기술 보고서 TR 24731-1', 'start': 2148, 'end': 2164, 'type': 'POH'}",org:production
1912,유닉스와 C는 모두 벨 연구소에서 1960년대에에서 1970년대에 만들어졌다.,"{'word': '유닉스와 C', 'start': 2791, 'end': 2796, 'type': 'COM'}","{'word': '1960년대에에서 1970년대', 'start': 2810, 'end': 2825, 'type': 'DAT'}",com:date_of_prod
1913,1983년 미국 국립 표준 협회(ANSI)는 위원회를 구성해서 C의 표준 명세를 확립하였고 이것은 ANSI C로 불린다.,"{'word': 'C의 표준 명세', 'start': 2978, 'end': 2985, 'type': 'COM'}","{'word': '1983년', 'start': 2943, 'end': 2947, 'type': 'DAT'}",com:date_of_prod
1914,이 작업은 1989년 C89라고 불리는 것이 만들어짐으로써 끝이나게 된다.,"{'word': 'C89', 'start': 3023, 'end': 3025, 'type': 'COM'}","{'word': '1989', 'start': 3017, 'end': 3020, 'type': 'DAT'}",com:date_of_prod
1915,이것은 1994년 릴리즈된 4.4BSD에서 처음 선보여졌다.,"{'word': '4.4BSD', 'start': 3422, 'end': 3427, 'type': 'COM'}","{'word': '1994년', 'start': 3411, 'end': 3415, 'type': 'DAT'}",com:date_of_prod
1916,각 헤더 파일은 하나 이상의 함수 정의와 데이터 타입 정의 그리고 매크로들을 포함한다.,"{'word': '헤더 파일', 'start': 338, 'end': 342, 'type': 'COM'}","{'word': '하나 이상의 함수 정의', 'start': 345, 'end': 356, 'type': 'COM'}",com:sub_concept
1917,각 헤더 파일은 하나 이상의 함수 정의와 데이터 타입 정의 그리고 매크로들을 포함한다.,"{'word': '헤더 파일', 'start': 338, 'end': 342, 'type': 'COM'}","{'word': '데이터 타입 정의', 'start': 359, 'end': 367, 'type': 'COM'}",com:sub_concept
1918,각 헤더 파일은 하나 이상의 함수 정의와 데이터 타입 정의 그리고 매크로들을 포함한다.,"{'word': '헤더 파일', 'start': 338, 'end': 342, 'type': 'COM'}","{'word': '매크로들', 'start': 373, 'end': 376, 'type': 'COM'}",com:sub_concept
1919,"유닉스 계열 시스템들은 일반적으로 공유 라이브러리 형태로 C 라이브러리를 가지지만, 헤더 파일들이 설치 시에 존재하지 않아서 C 개발이 불가능할 수도 있다.","{'word': '유닉스 계열 시스템', 'start': 572, 'end': 581, 'type': 'COM'}","{'word': 'C 라이브러리', 'start': 604, 'end': 610, 'type': 'COM'}",com:sub_concept
1920,C 라이브러리는 유닉스 계열 운영 체제에서 한 부분으로 여겨진다.,"{'word': '유닉스 계열 운영 체제', 'start': 669, 'end': 680, 'type': 'COM'}","{'word': 'C 라이브러리', 'start': 660, 'end': 666, 'type': 'COM'}",com:sub_concept
1921,"ISO C 표준을 포함한 C 함수들은 프로그램들에서 널리 사용되지만, 운영 체제 인터페이스의 한 부분이다.","{'word': '운영 체제 인터페이스', 'start': 736, 'end': 746, 'type': 'COM'}","{'word': 'ISO C 표준을 포함한 C 함수', 'start': 697, 'end': 714, 'type': 'COM'}",com:sub_concept
1922,"마이크로소프트 윈도우에서, 핵심 시스템 동적 라이브러리들은 C 표준 라이브러리의 구현을 제공한다.","{'word': '마이크로소프트 윈도우', 'start': 800, 'end': 810, 'type': 'COM'}","{'word': '핵심 시스템 동적 라이브러리', 'start': 815, 'end': 829, 'type': 'COM'}",com:sub_concept
1923,컴파일러의 C 라이브러리에 존재하는 함수들은 마이크로소프트 윈도우와의 인터페이스로 여겨지지 않는다.,"{'word': '컴파일러', 'start': 919, 'end': 922, 'type': 'COM'}","{'word': 'C 라이브러리에 존재하는 함수', 'start': 925, 'end': 940, 'type': 'COM'}",com:sub_concept
1924,"몇몇 컴파일러들은(예를 들면GCC) C 표준 라이브러리에서 많은 함수들의 빌트인 버전들을 제공한다; 즉, 함수들의 구현들은 컴파일된 목적 파일로 쓰여지며 프로그램은 C 라이브러리 공유 목적 파일에 있는 함수들 대신 빌트인 버전들을 호출한다.","{'word': '컴파일러', 'start': 1033, 'end': 1036, 'type': 'COM'}","{'word': 'GCC', 'start': 1045, 'end': 1047, 'type': 'COM'}",com:sub_concept
1925,호스트된 구현은 C 표준에 명시된 모든 헤더들을 갖는다.,"{'word': '호스트된 구현', 'start': 1730, 'end': 1736, 'type': 'COM'}","{'word': 'C 표준에 명시된 모든 헤더', 'start': 1739, 'end': 1753, 'type': 'COM'}",com:sub_concept
1926,"그럼에도 불구하고TR 24731-1는 마이크로소프트의 C 표준 라이브러리에 구현되었으며, 이것의 컴파일러는 오래된 불안정한 함수들을 사용할 때 경고를 발생시킨다.","{'word': '마이크로소프트의 C 표준 라이브러리', 'start': 2251, 'end': 2269, 'type': 'COM'}","{'word': 'TR 24731-1', 'start': 2239, 'end': 2248, 'type': 'COM'}",com:sub_concept
1927,"소수의 함수들은 errno를 설정하지만, 예외를 일으키지는 않는다.","{'word': '함수', 'start': 2578, 'end': 2579, 'type': 'COM'}","{'word': 'errno', 'start': 2583, 'end': 2587, 'type': 'COM'}",com:sub_concept
1928,"POSIX, 또는SUS는 기본 C 표준 라이브러리에서 사용 가능한 많은 수의 루틴들을 명시하였다.","{'word': 'POSIX', 'start': 3053, 'end': 3057, 'type': 'COM'}","{'word': '기본 C 표준 라이브러리에서 사용 가능한 많은 수의 루틴', 'start': 3067, 'end': 3097, 'type': 'COM'}",com:sub_concept
1929,"POSIX, 또는SUS는 기본 C 표준 라이브러리에서 사용 가능한 많은 수의 루틴들을 명시하였다.","{'word': 'SUS', 'start': 3062, 'end': 3064, 'type': 'COM'}","{'word': '기본 C 표준 라이브러리에서 사용 가능한 많은 수의 루틴', 'start': 3067, 'end': 3097, 'type': 'COM'}",com:sub_concept
1930,"POSIX 명세는 멀티 스레드, 네트워킹 그리고 정규 표현식에 대한 헤더 파일들을 포함한다.","{'word': 'POSIX 명세', 'start': 3108, 'end': 3115, 'type': 'COM'}","{'word': '멀티 스레드, 네트워킹 그리고 정규 표현식에 대한 헤더 파일', 'start': 3118, 'end': 3150, 'type': 'COM'}",com:sub_concept
1931,예를 들면glibc는codice_19내의 fork 같은 함수들을 구현하였다.,"{'word': 'glibc', 'start': 3203, 'end': 3207, 'type': 'COM'}","{'word': 'codice_19내의 fork 같은 함수', 'start': 3209, 'end': 3230, 'type': 'COM'}",com:sub_concept
1932,종종 POSIX 명세의 기능은 라이브러리의 한 부분으로 여겨질 수 있다; 기본 C 라이브러리는 ANSI 또는 ISO C 라이브러리로 식별된다.,"{'word': '라이브러리', 'start': 3258, 'end': 3262, 'type': 'COM'}","{'word': 'POSIX 명세의 기능', 'start': 3244, 'end': 3255, 'type': 'COM'}",com:sub_concept
1933,"BSD libc는 POSIX 표준 라이브러리의 상위 집합으로서 FreeBSD, NetBSD, OpenBSD그리고OSX같은 BSD 운영 체제에서 사용된다.","{'word': 'BSD libc', 'start': 3321, 'end': 3328, 'type': 'COM'}","{'word': 'POSIX 표준 라이브러리', 'start': 3331, 'end': 3344, 'type': 'COM'}",com:sub_concept
1934,BSD libc는 원본 표준에서 정의되지 않은 몇몇 확장들을 갖는다.,"{'word': 'BSD libc', 'start': 3441, 'end': 3448, 'type': 'COM'}","{'word': '원본 표준에서 정의되지 않은 몇몇 확장', 'start': 3451, 'end': 3471, 'type': 'COM'}",com:sub_concept
1935,몇몇 언어들은 자신의 라이브러리에 표준 C 라이브러리의 기능을 포함한다.,"{'word': '몇몇 언어', 'start': 3530, 'end': 3534, 'type': 'COM'}","{'word': '표준 C 라이브러리의 기능', 'start': 3549, 'end': 3562, 'type': 'COM'}",com:sub_concept
1936,"예를 들면 C++ 언어는 이름공간codice_33 (예를 들면codice_34, codice_35, codice_36)에서 C 표준 라이브러리의 기능을 포함하는데, 헤더 파일도 C의 것과 비슷하다(codice_37, codice_38, codice_39, 등). 다른 언어들은 D와 비슷한 접근법을 갖는데 파이썬의 경우 C파이썬이 있다.","{'word': 'C++ 언어', 'start': 3625, 'end': 3630, 'type': 'COM'}","{'word': 'C 표준 라이브러리의 기능', 'start': 3688, 'end': 3701, 'type': 'COM'}",com:sub_concept
1937,"C 라이브러리는 수학, 문자열 조작, 형 변환 그리고 파일과 콘솔 기반 입출력 함수들의 기본 집합을 제공한다.","{'word': 'C 라이브러리', 'start': 4011, 'end': 4017, 'type': 'COM'}","{'word': '수학, 문자열 조작, 형 변환 그리고 파일과 콘솔 기반 입출력 함수들의 기본 집합', 'start': 4020, 'end': 4064, 'type': 'COM'}",com:sub_concept
1938,"ANSI C가 국제 표준화 기구에 의해서 채택됨에 따라,C 표준 라이브러리는 또한 ISO C library로도 불린다.","{'word': 'C 표준 라이브러리', 'start': 142, 'end': 151, 'type': 'COM'}","{'word': 'ISO C library', 'start': 157, 'end': 169, 'type': 'COM'}",com:alter_names
1939,1983년 미국 국립 표준 협회(ANSI)는 위원회를 구성해서 C의 표준 명세를 확립하였고 이것은 ANSI C로 불린다.,"{'word': 'C의 표준 명세', 'start': 2978, 'end': 2985, 'type': 'COM'}","{'word': 'ANSI C', 'start': 2998, 'end': 3003, 'type': 'COM'}",com:alter_names
1940,종종 POSIX 명세의 기능은 라이브러리의 한 부분으로 여겨질 수 있다; 기본 C 라이브러리는 ANSI 또는 ISO C 라이브러리로 식별된다.,"{'word': '기본 C 라이브러리', 'start': 3282, 'end': 3291, 'type': 'COM'}","{'word': 'ANSI', 'start': 3294, 'end': 3297, 'type': 'COM'}",com:alter_names
1941,종종 POSIX 명세의 기능은 라이브러리의 한 부분으로 여겨질 수 있다; 기본 C 라이브러리는 ANSI 또는 ISO C 라이브러리로 식별된다.,"{'word': '기본 C 라이브러리', 'start': 3282, 'end': 3291, 'type': 'COM'}","{'word': 'ISO C 라이브러리', 'start': 3302, 'end': 3312, 'type': 'COM'}",com:alter_names
1942,"예를 들면 파이썬 2에서 빌트인 파일 객체들은 ""C의codice_40패키지를 사용해서 구현되었다""고 정의되어서, 사용 가능한 연산들(open, read, write 등)은 상응하는 C 함수들과 같은 동작을 한다고 기대할 수 있다.","{'word': '파이썬 2에서 빌트인 파일 객체', 'start': 3814, 'end': 3830, 'type': 'COM'}","{'word': 'C의codice_40패키지', 'start': 3835, 'end': 3848, 'type': 'COM'}",com:made_of
1943,1970년대 동안 C 언어는 점점 유명해 졌다.,"{'word': 'C 언어', 'start': 2845, 'end': 2848, 'type': 'COM'}","{'word': '1970년대', 'start': 2835, 'end': 2840, 'type': 'DAT'}",no_relation
1944,"C 표준 라이브러리(C standard library)는 C 언어를 위한 표준 라이브러리로서, ANSI C 표준에 의해 명시되었다.","{'word': 'C 언어', 'start': 32, 'end': 35, 'type': 'COM'}","{'word': 'ANSI C 표준', 'start': 53, 'end': 61, 'type': 'COM'}",no_relation
1945,"C 표준 라이브러리는 매크로, 타입 정의 그리고 문자열 처리나 수학적 연산, 입출력 프로세스, 메모리 할당과 다른 운영 체제 서비스 같은 작업을 위한 함수들을 제공한다.","{'word': 'C 표준 라이브러리', 'start': 178, 'end': 187, 'type': 'COM'}","{'word': '운영 체제 서비스', 'start': 242, 'end': 250, 'type': 'COM'}",no_relation
1946,C 표준 라이브러리의 API는 많은 헤더 파일들에 정의되어 있다.,"{'word': 'C 표준 라이브러리', 'start': 299, 'end': 308, 'type': 'COM'}","{'word': '헤더 파일', 'start': 319, 'end': 323, 'type': 'COM'}",no_relation
1947,"세 헤더 파일들의(codice_1, codice_2,codice_3) 구현은 필수는 아니다.","{'word': '헤더 파일', 'start': 387, 'end': 391, 'type': 'COM'}","{'word': 'codice_1', 'start': 395, 'end': 402, 'type': 'COM'}",no_relation
1948,POSIX표준은 유닉스를 위한 기능을 위해 여러 표준이 아닌 C 헤더들을 추가하였다.,"{'word': 'POSIX표준', 'start': 437, 'end': 443, 'type': 'COM'}","{'word': 'C 헤더', 'start': 471, 'end': 474, 'type': 'COM'}",no_relation
1949,예를 들면codice_4그리고codice_5가 있다.,"{'word': 'codice_4', 'start': 490, 'end': 497, 'type': 'COM'}","{'word': 'codice_5', 'start': 501, 'end': 508, 'type': 'COM'}",no_relation
1950,유닉스 계열 시스템들에서 실제 구현된 API의 권위 있는 문서화는 man page의 형태로 제공된다.,"{'word': '유닉스 계열 시스템', 'start': 515, 'end': 524, 'type': 'COM'}","{'word': 'man page', 'start': 552, 'end': 559, 'type': 'COM'}",no_relation
1951,유닉스 계열 시스템들은 일반적으로 C 라이브러리가 제거되면 동작할 수 없다.,"{'word': '유닉스 계열 시스템', 'start': 757, 'end': 766, 'type': 'COM'}","{'word': 'C 라이브러리', 'start': 776, 'end': 782, 'type': 'COM'}",no_relation
1952,C 로 쓰여진 컴파일된 애플리케이션들은 C 라이브러리와 정적으로 링크되거나 딸려온 라이브러리와 동적으로 링크된다.,"{'word': 'C 로 쓰여진 컴파일된 애플리케이션', 'start': 855, 'end': 873, 'type': 'COM'}","{'word': 'C 라이브러리', 'start': 877, 'end': 883, 'type': 'COM'}",no_relation
1953,운영 체제와 C 컴파일러에서 제공되는 많은 구현들이 존재한다.,"{'word': '운영 체제', 'start': 975, 'end': 979, 'type': 'COM'}","{'word': 'C 컴파일러', 'start': 982, 'end': 987, 'type': 'COM'}",no_relation
1954,"이것은 특히 만약 함수 호출들이 인라인 형태로 대체된다면 함수 호출 오버헤드를 감소시키며, 최적화의 다른 형태(컴파일러가 빌트인 형태의 제어 흐름 특징을 알 때)를 허용하지만 디버깅 시에 혼란을 야기할 수 있다. (예를 들면 빌트인 버전들은 인스트루멘트된 형태로 대체될 수 없다)","{'word': '함수 호출 오버헤드', 'start': 1197, 'end': 1206, 'type': 'COM'}","{'word': '디버깅', 'start': 1263, 'end': 1265, 'type': 'COM'}",no_relation
1955,그러나 빌트인 함수들은 반드시 ISO C에 따라 기본 함수들처럼 행동해야 한다.,"{'word': '빌트인 함수', 'start': 1326, 'end': 1331, 'type': 'COM'}","{'word': 'ISO C', 'start': 1339, 'end': 1343, 'type': 'COM'}",no_relation
1956,"중요한 것은 프로그램이 반드시 이러한 함수들을 가리키는 포인터를 주소를 사용해서 생성할 수 있어야 하고, 이 포인터로 함수를 발생시킬 수 있어야 한다.","{'word': '프로그램', 'start': 1374, 'end': 1377, 'type': 'COM'}","{'word': '포인터', 'start': 1398, 'end': 1400, 'type': 'COM'}",no_relation
1957,"만약 같은 함수에 대한 두 포인터들이 프로그램에서 두 다른 변환 유닛으로 만들어진다면, 이러한 두 포인터들은 반드시 같아야 한다.","{'word': '포인터', 'start': 1467, 'end': 1469, 'type': 'COM'}","{'word': '프로그램', 'start': 1473, 'end': 1476, 'type': 'COM'}",no_relation
1958,"리눅스 그리고 FreeBSD에서,수학 함수들(codice_6에 정의된)은 수학 라이브러리libm에서 따로 묶어져야 한다.","{'word': '리눅스', 'start': 1561, 'end': 1563, 'type': 'COM'}","{'word': 'FreeBSD', 'start': 1569, 'end': 1575, 'type': 'COM'}",no_relation
1959,"만약 이것들 중 어느 것이 사용된다면, 링커는 반드시 지시자codice_7을 받아야 한다.","{'word': '링커', 'start': 1651, 'end': 1652, 'type': 'COM'}","{'word': '지시자codice_7', 'start': 1659, 'end': 1669, 'type': 'COM'}",no_relation
1960,"C 표준에 따르면, 만약 구현이 호스트된다면 매크로codice_8는 1로 정의될 것이다.","{'word': 'C 표준', 'start': 1680, 'end': 1683, 'type': 'COM'}","{'word': '매크로codice_8', 'start': 1705, 'end': 1715, 'type': 'COM'}",no_relation
1961,"구현은 또한 ""freestanding""일 수 있는데 이것은 이러한 헤더들이 존재하지 않는다는 의미이다.","{'word': 'freestanding', 'start': 1770, 'end': 1781, 'type': 'COM'}","{'word': '헤더', 'start': 1799, 'end': 1800, 'type': 'COM'}",no_relation
1962,"만약 구현이""freestanding""이라면, 이것은codice_8을0으로 정의할 것이다.","{'word': 'freestanding', 'start': 1827, 'end': 1838, 'type': 'COM'}","{'word': 'codice_8', 'start': 1848, 'end': 1855, 'type': 'COM'}",no_relation
1963,C 표준 라이브러리에 있는 몇몇 함수들은 버퍼 오버플로우 취약점들과 채택 이후의 버그를 유발하는 프로그래밍을 조장하는 것으로 악명 높다.,"{'word': 'C 표준 라이브러리', 'start': 1870, 'end': 1879, 'type': 'COM'}","{'word': '버그', 'start': 1915, 'end': 1916, 'type': 'COM'}",no_relation
1964,"codice_13를 사용한 극단적인 경우를 제외하고, 모든 보안 취약점들은 보조 코드가 메모리 관리, 경계 검사, 입력 검사 등을 수행하게 함으로써 피할 수 있다.","{'word': 'codice_13', 'start': 1947, 'end': 1955, 'type': 'COM'}","{'word': '메모리 관리', 'start': 1996, 'end': 2001, 'type': 'COM'}",no_relation
1965,이것은 종종 표준 라이브러리 함수들을 사용하기 쉽고 안전하게 만들어 주는 래퍼의 형태를 통해 가능해 진다.,"{'word': '표준 라이브러리 함수', 'start': 2046, 'end': 2056, 'type': 'COM'}","{'word': '래퍼', 'start': 2080, 'end': 2081, 'type': 'COM'}",no_relation
1966,codice_16과codice_17루틴들은 스레드 안전와 경쟁 상태에 대한 취약점 때문에 비판을 받았다.,"{'word': 'codice_16', 'start': 2344, 'end': 2352, 'type': 'COM'}","{'word': 'codice_17', 'start': 2354, 'end': 2362, 'type': 'COM'}",no_relation
1967,C 표준 라이브러리에서 함수들의 오류 처리는 일관되지 않으며 가끔은 혼란스럽다.,"{'word': 'C 표준 라이브러리', 'start': 2403, 'end': 2412, 'type': 'COM'}","{'word': '함수', 'start': 2416, 'end': 2417, 'type': 'COM'}",no_relation
1968,"""glibc 하의 현재(버전 2.8) 상황은 엉망이다.","{'word': 'glibc', 'start': 2486, 'end': 2490, 'type': 'COM'}","{'word': '버전 2.8', 'start': 2498, 'end': 2503, 'type': 'COM'}",no_relation
1969,대부분의(모두는 아니지만) 함수들은 오류들에 대해 예외를 일으킨다.,"{'word': '함수', 'start': 2531, 'end': 2532, 'type': 'COM'}","{'word': '오류', 'start': 2536, 'end': 2537, 'type': 'COM'}",no_relation
1970,"다른 언어들과 달리, 원본 C 언어는 입출력 동작 같은 빌트인 함수들을 제공하지 않았다.","{'word': 'C 언어', 'start': 2653, 'end': 2656, 'type': 'COM'}","{'word': '빌트인 함수', 'start': 2669, 'end': 2674, 'type': 'COM'}",no_relation
1971,많은 대학교들과 단체들이 자신의 프로젝트를 위해 이 언어를 자신만의 형태로 만들었다.,"{'word': '프로젝트', 'start': 2880, 'end': 2883, 'type': 'COM'}","{'word': '언어', 'start': 2891, 'end': 2892, 'type': 'COM'}",no_relation
1972,C 표준 라이브러리는 다른 언어들의 표준 라이브러리들과 비교했을 때 작다고 할 수 있다.,"{'word': 'C 표준 라이브러리', 'start': 3961, 'end': 3970, 'type': 'COM'}","{'word': '다른 언어들의 표준 라이브러리', 'start': 3973, 'end': 3988, 'type': 'COM'}",no_relation
1973,이것은 C++ 표준 템플릿 라이브러리처럼 컨테이너 타입의 표준 집합을 포함하지 않는다.,"{'word': 'C++ 표준 템플릿 라이브러리', 'start': 4077, 'end': 4092, 'type': 'COM'}","{'word': '컨테이너 타입의 표준 집합', 'start': 4096, 'end': 4109, 'type': 'COM'}",no_relation
1974,"이러한 작은 표준 라이브러리의 장점은 일할 ISO C 환경을 다른 언어들 보다 더 쉽게 제공한다는 것이며, 결과적으로 C를 새로운 플랫폼에 포팅하는 것이 상대적으로 쉽게 된다.","{'word': '표준 라이브러리', 'start': 4129, 'end': 4136, 'type': 'COM'}","{'word': 'ISO C 환경', 'start': 4146, 'end': 4153, 'type': 'COM'}",no_relation
1975,"BSD libc는 POSIX 표준 라이브러리의 상위 집합으로서 FreeBSD, NetBSD, OpenBSD그리고OSX같은 BSD 운영 체제에서 사용된다.","{'word': 'BSD 운영 체제', 'start': 3389, 'end': 3397, 'type': 'COM'}","{'word': 'NetBSD', 'start': 3365, 'end': 3370, 'type': 'COM'}",com:similar_tech
1976,"BSD libc는 POSIX 표준 라이브러리의 상위 집합으로서 FreeBSD, NetBSD, OpenBSD그리고OSX같은 BSD 운영 체제에서 사용된다.","{'word': 'BSD 운영 체제', 'start': 3389, 'end': 3397, 'type': 'COM'}","{'word': 'OpenBSD', 'start': 3373, 'end': 3379, 'type': 'COM'}",com:similar_tech
1977,"BSD libc는 POSIX 표준 라이브러리의 상위 집합으로서 FreeBSD, NetBSD, OpenBSD그리고OSX같은 BSD 운영 체제에서 사용된다.","{'word': 'BSD 운영 체제', 'start': 3389, 'end': 3397, 'type': 'COM'}","{'word': 'OSX', 'start': 3383, 'end': 3385, 'type': 'COM'}",com:similar_tech
1978,"BSD libc는 POSIX 표준 라이브러리의 상위 집합으로서 FreeBSD, NetBSD, OpenBSD그리고OSX같은 BSD 운영 체제에서 사용된다.","{'word': 'BSD 운영 체제', 'start': 3389, 'end': 3397, 'type': 'COM'}","{'word': 'FreeBSD', 'start': 3356, 'end': 3362, 'type': 'COM'}",com:similar_tech
1979,"예를 들면 C++ 언어는 이름공간codice_33 (예를 들면codice_34, codice_35, codice_36)에서 C 표준 라이브러리의 기능을 포함하는데, 헤더 파일도 C의 것과 비슷하다(codice_37, codice_38, codice_39, 등). 다른 언어들은 D와 비슷한 접근법을 갖는데 파이썬의 경우 C파이썬이 있다.","{'word': 'codice_33', 'start': 3637, 'end': 3645, 'type': 'COM'}","{'word': 'codice_34', 'start': 3653, 'end': 3661, 'type': 'COM'}",com:similar_tech
1980,"예를 들면 C++ 언어는 이름공간codice_33 (예를 들면codice_34, codice_35, codice_36)에서 C 표준 라이브러리의 기능을 포함하는데, 헤더 파일도 C의 것과 비슷하다(codice_37, codice_38, codice_39, 등). 다른 언어들은 D와 비슷한 접근법을 갖는데 파이썬의 경우 C파이썬이 있다.","{'word': 'codice_33', 'start': 3637, 'end': 3645, 'type': 'COM'}","{'word': 'codice_35', 'start': 3664, 'end': 3672, 'type': 'COM'}",com:similar_tech
1981,"예를 들면 C++ 언어는 이름공간codice_33 (예를 들면codice_34, codice_35, codice_36)에서 C 표준 라이브러리의 기능을 포함하는데, 헤더 파일도 C의 것과 비슷하다(codice_37, codice_38, codice_39, 등). 다른 언어들은 D와 비슷한 접근법을 갖는데 파이썬의 경우 C파이썬이 있다.","{'word': 'codice_33', 'start': 3637, 'end': 3645, 'type': 'COM'}","{'word': 'codice_36', 'start': 3675, 'end': 3683, 'type': 'COM'}",com:similar_tech
1982,"예를 들면 파이썬 2에서 빌트인 파일 객체들은 ""C의codice_40패키지를 사용해서 구현되었다""고 정의되어서, 사용 가능한 연산들(open, read, write 등)은 상응하는 C 함수들과 같은 동작을 한다고 기대할 수 있다.","{'word': '사용 가능한 연산', 'start': 3871, 'end': 3879, 'type': 'COM'}","{'word': 'open', 'start': 3882, 'end': 3885, 'type': 'COM'}",com:similar_tech
1983,"예를 들면 파이썬 2에서 빌트인 파일 객체들은 ""C의codice_40패키지를 사용해서 구현되었다""고 정의되어서, 사용 가능한 연산들(open, read, write 등)은 상응하는 C 함수들과 같은 동작을 한다고 기대할 수 있다.","{'word': '사용 가능한 연산', 'start': 3871, 'end': 3879, 'type': 'COM'}","{'word': 'read', 'start': 3888, 'end': 3891, 'type': 'COM'}",com:similar_tech
1984,"예를 들면 파이썬 2에서 빌트인 파일 객체들은 ""C의codice_40패키지를 사용해서 구현되었다""고 정의되어서, 사용 가능한 연산들(open, read, write 등)은 상응하는 C 함수들과 같은 동작을 한다고 기대할 수 있다.","{'word': '사용 가능한 연산', 'start': 3871, 'end': 3879, 'type': 'COM'}","{'word': 'write', 'start': 3894, 'end': 3898, 'type': 'COM'}",com:similar_tech
1985,시간이 지나면서 C의 사용자 커뮤니티들은 생각을 공유하고 현재 C 표준 라이브러리라고 불리는 것을 구현하였다.,"{'word': 'C의 사용자 커뮤니티', 'start': 2697, 'end': 2707, 'type': 'ORG'}","{'word': '현재 C 표준 라이브러리', 'start': 2720, 'end': 2732, 'type': 'COM'}",org:production
1986,유닉스와 C는 모두 벨 연구소에서 1960년대에에서 1970년대에 만들어졌다.,"{'word': '벨 연구소', 'start': 2802, 'end': 2806, 'type': 'ORG'}","{'word': '유닉스와 C', 'start': 2791, 'end': 2796, 'type': 'COM'}",org:production
1987,"이반 서덜랜드가 1963년에 개발한 스케치패드는 컴퓨터 지원 설계(CAD) 소프트웨어의 조상이자 최초로 완전한 그래픽 사용자 인터페이스를 구현한 것이었으며, 비슷한 시기에 더글라스 엥겔바트를 비롯한 SRI 인터내셔널의 연구자들은 하이퍼링크를 기반으로 마우스를 사용하는 NLS(On-line System)를 개발하였다.","{'word': '스케치패드', 'start': 802, 'end': 806, 'type': 'COM'}","{'word': '1963년', 'start': 791, 'end': 795, 'type': 'DAT'}",com:date_of_prod
1988,"NLS의 하이퍼링크 개념은 제록스 파크에서 그래픽으로 확장되었으며, 1973년에 개발된 제록스 알토 컴퓨터는 그래픽 사용자 인터페이스를 사용하는 최초의 컴퓨터가 되었다.","{'word': '제록스 알토 컴퓨터', 'start': 1009, 'end': 1018, 'type': 'COM'}","{'word': '1973년', 'start': 998, 'end': 1002, 'type': 'DAT'}",com:date_of_prod
1989,1981년에 개인용 컴퓨터인 1983년에 그래픽 사용자 인터페이스에 기반한 컴퓨터 리사(LISA)를 출시했지만 값이 너무 비싼 탓에 실패하였다.,"{'word': '리사(LISA)', 'start': 1379, 'end': 1386, 'type': 'COM'}","{'word': '1983년', 'start': 1349, 'end': 1353, 'type': 'DAT'}",com:date_of_prod
1990,그러나 이후 1984년에 나온 애플의 매킨토시는 상업적인 성공을 이뤘다.,"{'word': '매킨토시', 'start': 1435, 'end': 1438, 'type': 'COM'}","{'word': '1984년', 'start': 1421, 'end': 1425, 'type': 'DAT'}",com:date_of_prod
1991,1995년 마이크로소프트사가 윈도우 95를 출시하여 성공을 거둠으로써 본격적인 그래픽 사용자 인터페이스의 대중화를 이루었다.,"{'word': '윈도우 95', 'start': 1569, 'end': 1574, 'type': 'COM'}","{'word': '1995년', 'start': 1553, 'end': 1557, 'type': 'DAT'}",com:date_of_prod
1992,그래픽 사용자 인터페이스에서 어떤 요소를 제어하려면 그 요소에 해당하는 그래픽을 직접 조작하여야 한다.,"{'word': '그래픽 사용자 인터페이스', 'start': 163, 'end': 175, 'type': 'COM'}","{'word': '요소에 해당하는 그래픽', 'start': 194, 'end': 205, 'type': 'COM'}",com:sub_concept
1993,"컴퓨터를 넘어 GUI는 MP3 플레이어 등, 포터블 미디어 플레이어, 게이밍 장치, 스마트폰, 소형 가전, 사무 및 산업 제어 등 수많은 휴대용 모바일 장치에 사용된다.","{'word': '휴대용 모바일 장치', 'start': 598, 'end': 607, 'type': 'COM'}","{'word': 'GUI', 'start': 529, 'end': 531, 'type': 'COM'}",com:sub_concept
1994,"윈도우와 리눅스, OS X을 비롯한 대부분의 현대 운영 체제들이 그래픽 사용자 인터페이스를 지원한다.","{'word': '현대 운영 체제', 'start': 641, 'end': 648, 'type': 'COM'}","{'word': '윈도우', 'start': 616, 'end': 618, 'type': 'COM'}",com:sub_concept
1995,"윈도우와 리눅스, OS X을 비롯한 대부분의 현대 운영 체제들이 그래픽 사용자 인터페이스를 지원한다.","{'word': '현대 운영 체제', 'start': 641, 'end': 648, 'type': 'COM'}","{'word': '리눅스', 'start': 621, 'end': 623, 'type': 'COM'}",com:sub_concept
1996,"윈도우와 리눅스, OS X을 비롯한 대부분의 현대 운영 체제들이 그래픽 사용자 인터페이스를 지원한다.","{'word': '현대 운영 체제', 'start': 641, 'end': 648, 'type': 'COM'}","{'word': 'OS X', 'start': 626, 'end': 629, 'type': 'COM'}",com:sub_concept
1997,"윈도우와 리눅스, OS X을 비롯한 대부분의 현대 운영 체제들이 그래픽 사용자 인터페이스를 지원한다.","{'word': '현대 운영 체제', 'start': 641, 'end': 648, 'type': 'COM'}","{'word': '그래픽 사용자 인터페이스', 'start': 652, 'end': 664, 'type': 'COM'}",com:sub_concept
1998,"리눅스 및 유닉스 계열 운영 체제에서는 X 윈도 시스템을 주로 사용하며, 모티프, Qt, GTK+ 등의 툴킷으로 확장할 수 있다.","{'word': '리눅스 및 유닉스 계열 운영 체제', 'start': 673, 'end': 690, 'type': 'COM'}","{'word': 'X 윈도 시스템', 'start': 695, 'end': 702, 'type': 'COM'}",com:sub_concept
1999,"NLS의 하이퍼링크 개념은 제록스 파크에서 그래픽으로 확장되었으며, 1973년에 개발된 제록스 알토 컴퓨터는 그래픽 사용자 인터페이스를 사용하는 최초의 컴퓨터가 되었다.","{'word': '제록스 알토 컴퓨터', 'start': 1009, 'end': 1018, 'type': 'COM'}","{'word': '그래픽 사용자 인터페이스', 'start': 1021, 'end': 1033, 'type': 'COM'}",com:sub_concept
2000,"파크 사용자 인터페이스는 윈도, 메뉴, 아이콘, 라디오 단추, 체크 상자 등의 그래픽 요소들을 사용하며, 마우스와 같은 포인팅 장치를 키보드와 함께 사용한다.","{'word': '파크 사용자 인터페이스', 'start': 1145, 'end': 1156, 'type': 'COM'}","{'word': '윈도, 메뉴, 아이콘, 라디오 단추, 체크 상자 등의 그래픽 요소', 'start': 1159, 'end': 1194, 'type': 'COM'}",com:sub_concept
2001,"파크 사용자 인터페이스는 윈도, 메뉴, 아이콘, 라디오 단추, 체크 상자 등의 그래픽 요소들을 사용하며, 마우스와 같은 포인팅 장치를 키보드와 함께 사용한다.","{'word': '포인팅 장치', 'start': 1212, 'end': 1217, 'type': 'COM'}","{'word': '마우스', 'start': 1204, 'end': 1206, 'type': 'COM'}",com:sub_concept
2002,"한편 CUI(character user interface, 명령 줄 인터페이스) OS인 유닉스(UNIX)와 그 계열의 리눅스에서는, X 윈도 시스템을 통해 그래픽 사용자 인터페이스를 구현하고 있다.","{'word': '유닉스(UNIX)와 그 계열의 리눅스', 'start': 1672, 'end': 1691, 'type': 'COM'}","{'word': '그래픽 사용자 인터페이스', 'start': 1710, 'end': 1722, 'type': 'COM'}",com:sub_concept
2003,컴퓨터 자판의 명령어 입력이 요구되는 명령 줄 인터페이스(CLI)의 가파른 학습 곡선에 대응하여 GUI가 도입되었다.,"{'word': '명령 줄 인터페이스', 'start': 437, 'end': 446, 'type': 'COM'}","{'word': 'CLI', 'start': 448, 'end': 450, 'type': 'COM'}",com:alter_names
2004,"현재 대부분의 그래픽 사용자 인터페이스들은 기본적으로 이 인터페이스로부터 유래했으며, 어떤 사람들은 이들을 ‘파크 사용자 인터페이스(PUI)’라 부르기도 한다.","{'word': '그래픽 사용자 인터페이스', 'start': 1063, 'end': 1075, 'type': 'COM'}","{'word': '파크 사용자 인터페이스(PUI)', 'start': 1116, 'end': 1132, 'type': 'COM'}",com:alter_names
2005,그래픽 사용자 인터페이스()는 사용자가 편리하게 사용할 수 있도록 입출력 등의 기능을 알기 쉬운 아이콘 따위의 그래픽으로 나타낸 것이다.,"{'word': '그래픽 사용자 인터페이스', 'start': 0, 'end': 12, 'type': 'COM'}","{'word': '아이콘 따위의 그래픽', 'start': 54, 'end': 64, 'type': 'COM'}",com:made_of
2006,"이반 서덜랜드가 1963년에 개발한 스케치패드는 컴퓨터 지원 설계(CAD) 소프트웨어의 조상이자 최초로 완전한 그래픽 사용자 인터페이스를 구현한 것이었으며, 비슷한 시기에 더글라스 엥겔바트를 비롯한 SRI 인터내셔널의 연구자들은 하이퍼링크를 기반으로 마우스를 사용하는 NLS(On-line System)를 개발하였다.","{'word': '컴퓨터 지원 설계(CAD) 소프트웨어', 'start': 809, 'end': 828, 'type': 'COM'}","{'word': '스케치패드', 'start': 802, 'end': 806, 'type': 'COM'}",com:prior_tech
2007,그래픽 사용자 인터페이스의 아이디어는 1960년대에 제안되었다.,"{'word': '그래픽 사용자 인터페이스', 'start': 746, 'end': 758, 'type': 'COM'}","{'word': '1960년대', 'start': 767, 'end': 772, 'type': 'DAT'}",no_relation
2008,"컴퓨터를 사용하면서, 화면 위의 물체나 틀, 색상과 같은 그래픽 요소들을 어떠한 기능과 용도를 나타내기 위해 고안된 사용자를 위한 컴퓨터 인터페이스이다.","{'word': '그래픽 요소', 'start': 109, 'end': 114, 'type': 'COM'}","{'word': '컴퓨터 인터페이스', 'start': 150, 'end': 158, 'type': 'COM'}",no_relation
2009,"이를테면, X자와 같은 형태의 그래픽 요소는 이를 선택하면 삭제하거나 취소하는 기능을 수행하게 되며 어떤 파일을 나타내는 아이콘을 어느 위치에서 다른 하드 디스크의 장소를 나타내는 공간으로 이동하면 복사가 된다.","{'word': '아이콘', 'start': 365, 'end': 367, 'type': 'COM'}","{'word': '하드 디스크', 'start': 381, 'end': 386, 'type': 'COM'}",no_relation
2010,GUI의 동작은 일반적으로 그래픽 요소의 직접 조작을 통해 수행된다.,"{'word': 'GUI', 'start': 482, 'end': 484, 'type': 'COM'}","{'word': '그래픽 요소', 'start': 497, 'end': 502, 'type': 'COM'}",no_relation
2011,"컴퓨터를 넘어 GUI는 MP3 플레이어 등, 포터블 미디어 플레이어, 게이밍 장치, 스마트폰, 소형 가전, 사무 및 산업 제어 등 수많은 휴대용 모바일 장치에 사용된다.","{'word': '포터블 미디어 플레이어', 'start': 546, 'end': 557, 'type': 'COM'}","{'word': '게이밍 장치', 'start': 560, 'end': 565, 'type': 'COM'}",com:similar_tech
2012,"컴퓨터를 넘어 GUI는 MP3 플레이어 등, 포터블 미디어 플레이어, 게이밍 장치, 스마트폰, 소형 가전, 사무 및 산업 제어 등 수많은 휴대용 모바일 장치에 사용된다.","{'word': '포터블 미디어 플레이어', 'start': 546, 'end': 557, 'type': 'COM'}","{'word': '스마트폰', 'start': 568, 'end': 571, 'type': 'COM'}",com:similar_tech
2013,"컴퓨터를 넘어 GUI는 MP3 플레이어 등, 포터블 미디어 플레이어, 게이밍 장치, 스마트폰, 소형 가전, 사무 및 산업 제어 등 수많은 휴대용 모바일 장치에 사용된다.","{'word': '포터블 미디어 플레이어', 'start': 546, 'end': 557, 'type': 'COM'}","{'word': '소형 가전', 'start': 574, 'end': 578, 'type': 'COM'}",com:similar_tech
2014,"컴퓨터를 넘어 GUI는 MP3 플레이어 등, 포터블 미디어 플레이어, 게이밍 장치, 스마트폰, 소형 가전, 사무 및 산업 제어 등 수많은 휴대용 모바일 장치에 사용된다.","{'word': '포터블 미디어 플레이어', 'start': 546, 'end': 557, 'type': 'COM'}","{'word': '사무 및 산업 제어', 'start': 581, 'end': 590, 'type': 'COM'}",com:similar_tech
2015,"리눅스 및 유닉스 계열 운영 체제에서는 X 윈도 시스템을 주로 사용하며, 모티프, Qt, GTK+ 등의 툴킷으로 확장할 수 있다.","{'word': '모티프', 'start': 714, 'end': 716, 'type': 'COM'}","{'word': 'Qt', 'start': 719, 'end': 720, 'type': 'COM'}",com:similar_tech
2016,"리눅스 및 유닉스 계열 운영 체제에서는 X 윈도 시스템을 주로 사용하며, 모티프, Qt, GTK+ 등의 툴킷으로 확장할 수 있다.","{'word': '모티프', 'start': 714, 'end': 716, 'type': 'COM'}","{'word': 'GTK+', 'start': 723, 'end': 726, 'type': 'COM'}",com:similar_tech
2017,"한편 CUI(character user interface, 명령 줄 인터페이스) OS인 유닉스(UNIX)와 그 계열의 리눅스에서는, X 윈도 시스템을 통해 그래픽 사용자 인터페이스를 구현하고 있다.","{'word': 'CUI(character user interface, 명령 줄 인터페이스) OS', 'start': 1626, 'end': 1669, 'type': 'COM'}","{'word': '유닉스(UNIX)', 'start': 1672, 'end': 1680, 'type': 'COM'}",com:similar_tech
2018,이후 애플 컴퓨터는 제록스 파크에서 만든 이러한 그래픽 사용자 인터페이스를 보고 당시 비상장이었던 애플의 주식 액면가 100만 달러 어치를 지불하고 기본적인 기술을 전수받았다.,"{'word': '제록스 파크', 'start': 1245, 'end': 1250, 'type': 'ORG'}","{'word': '그래픽 사용자 인터페이스', 'start': 1261, 'end': 1273, 'type': 'COM'}",org:production
2019,그러나 이후 1984년에 나온 애플의 매킨토시는 상업적인 성공을 이뤘다.,"{'word': '애플', 'start': 1431, 'end': 1432, 'type': 'ORG'}","{'word': '매킨토시', 'start': 1435, 'end': 1438, 'type': 'COM'}",org:production
2020,한편 매킨토시가 이러한 성공을 거두자 마이크로소프트사는 마이크로소프트 윈도우를 개발하였다.,"{'word': '마이크로소프트사', 'start': 1476, 'end': 1483, 'type': 'ORG'}","{'word': '마이크로소프트 윈도우', 'start': 1486, 'end': 1496, 'type': 'COM'}",org:production
2021,1995년 마이크로소프트사가 윈도우 95를 출시하여 성공을 거둠으로써 본격적인 그래픽 사용자 인터페이스의 대중화를 이루었다.,"{'word': '마이크로소프트사', 'start': 1559, 'end': 1566, 'type': 'ORG'}","{'word': '윈도우 95', 'start': 1569, 'end': 1574, 'type': 'COM'}",org:production
2022,"이반 서덜랜드가 1963년에 개발한 스케치패드는 컴퓨터 지원 설계(CAD) 소프트웨어의 조상이자 최초로 완전한 그래픽 사용자 인터페이스를 구현한 것이었으며, 비슷한 시기에 더글라스 엥겔바트를 비롯한 SRI 인터내셔널의 연구자들은 하이퍼링크를 기반으로 마우스를 사용하는 NLS(On-line System)를 개발하였다.","{'word': '이반 서덜랜드', 'start': 782, 'end': 788, 'type': 'PER'}","{'word': '스케치패드', 'start': 802, 'end': 806, 'type': 'COM'}",per:production
2023,"이반 서덜랜드가 1963년에 개발한 스케치패드는 컴퓨터 지원 설계(CAD) 소프트웨어의 조상이자 최초로 완전한 그래픽 사용자 인터페이스를 구현한 것이었으며, 비슷한 시기에 더글라스 엥겔바트를 비롯한 SRI 인터내셔널의 연구자들은 하이퍼링크를 기반으로 마우스를 사용하는 NLS(On-line System)를 개발하였다.","{'word': '더글라스 엥겔바트를 비롯한 SRI 인터내셔널의 연구자', 'start': 878, 'end': 906, 'type': 'PER'}","{'word': 'NLS(On-line System)', 'start': 932, 'end': 950, 'type': 'COM'}",per:production
2024,포트란(Fortran)은 1954년 IBM 704에서 과학적인 계산을 하기 위해 시작된 컴퓨터 프로그램 언어이다.,"{'word': 'IBM', 'start': 20, 'end': 22, 'type': 'ORG'}","{'word': '포트란(Fortran)', 'start': 0, 'end': 11, 'type': 'POH'}",org:production
2025,"현재 J3는 WG5의 지시 하에 활동하고 있으며, WG5를 구성하는 가장 큰 부분이다.","{'word': 'WG5', 'start': 1231, 'end': 1233, 'type': 'ORG'}","{'word': 'J3', 'start': 1227, 'end': 1228, 'type': 'ORG'}",org:members
2026,포트란(Fortran)은 1954년 IBM 704에서 과학적인 계산을 하기 위해 시작된 컴퓨터 프로그램 언어이다.,"{'word': '포트란(Fortran)', 'start': 0, 'end': 11, 'type': 'COM'}","{'word': '1954년', 'start': 14, 'end': 18, 'type': 'DAT'}",com:date_of_prod
2027,"이후 1956년 첫 번째 포트란 매뉴얼이 발표되었고, 1957년 대중에 첫 포트란 컴파일러가 등장한다.","{'word': '포트란 매뉴얼', 'start': 1374, 'end': 1380, 'type': 'COM'}","{'word': '1956년', 'start': 1363, 'end': 1367, 'type': 'DAT'}",com:date_of_prod
2028,"이후 1956년 첫 번째 포트란 매뉴얼이 발표되었고, 1957년 대중에 첫 포트란 컴파일러가 등장한다.","{'word': '포트란 컴파일러', 'start': 1402, 'end': 1409, 'type': 'COM'}","{'word': '1957년', 'start': 1390, 'end': 1394, 'type': 'DAT'}",com:date_of_prod
2029,"이에 Business Equipment Manufacturers Association(BEMA)은 표준화에 대한 논의를 시작하며, ANSI에 표준 문법을 제출한다. 1966년 ANSI의 승인을 얻게 되며, 첫 미국 포트란 표준이 발표된다.","{'word': '포트란 표준', 'start': 1719, 'end': 1724, 'type': 'COM'}","{'word': '1966년', 'start': 1691, 'end': 1695, 'type': 'DAT'}",com:date_of_prod
2030,위와 같이 특히 자연과학이나 공학에서의 중요한 거대한 계산문제들을 슈퍼컴퓨터들을 이용하여 해결하는 데 있어서 C언어와 같이 범용프로그래밍 언어에 속하는 프로그래밍언어들에 비해 탁월한 효율이 있는 과학계산 전문 언어이다.,"{'word': '범용프로그래밍 언어', 'start': 639, 'end': 648, 'type': 'COM'}","{'word': 'C언어', 'start': 631, 'end': 633, 'type': 'COM'}",com:sub_concept
2031,"""최초의 고급 프로그래밍 언어""가 등장하게 되자, 여러 벤더에서 다양한 문법을 가진 포트란 컴파일러를 각자의 시스템에 맞게 제작하기 시작하였으며, 1960년대에도 40여가지의 포트란 컴파일러가 존재했다고 한다.","{'word': '포트란 컴파일러', 'start': 1528, 'end': 1535, 'type': 'COM'}","{'word': '다양한 문법', 'start': 1517, 'end': 1522, 'type': 'COM'}",com:sub_concept
2032,ANSI FORTRAN 66 표준은 다음과 같은 문법을 포함하고 있다.,"{'word': 'ANSI FORTRAN 66 표준', 'start': 1931, 'end': 1948, 'type': 'COM'}","{'word': '문법', 'start': 1958, 'end': 1959, 'type': 'COM'}",com:sub_concept
2033,한편 ANSI FORTRAN 77에 몇 가지 문법이 추가된 미국 국방성(Department of Defence: DoD) 포트란 표준이 발표된다.,"{'word': '미국 국방성(Department of Defence: DoD) 포트란 표준', 'start': 2400, 'end': 2440, 'type': 'COM'}","{'word': 'ANSI FORTRAN 77', 'start': 2370, 'end': 2384, 'type': 'COM'}",com:sub_concept
2034,"FORTRAN은 수식(Formula) 변환기(Translation)의 약자이다.(IBM Mathematical ""For""mula ""Tran""slating System에서 유래.) 포트란은 알골과 함께 과학 계산용으로 주로 사용되는 언어이며, 당시 7명의 전문가가 약 2년 반 동안에 걸쳐 완성한 것이 포트란의 기본을 이루었고, 그 후 ANSI와 ISO에서 표준화하였다.","{'word': '수식(Formula) 변환기(Translation)', 'start': 73, 'end': 100, 'type': 'COM'}","{'word': 'FORTRAN', 'start': 64, 'end': 70, 'type': 'COM'}",com:alter_names
2035,"Fortran90부터 현재에 까지 ISO, ANSI 모두 포트란에 대한 명칭은 ""Fortran""을 사용한다.","{'word': '포트란', 'start': 1021, 'end': 1023, 'type': 'COM'}","{'word': 'Fortran', 'start': 1034, 'end': 1040, 'type': 'COM'}",com:alter_names
2036,"이 ANSI 표준은 FORTRAN 77 이란 이름으로 불리며, 그 공식 문서는 ANSI X3.9-1978이다.","{'word': 'ANSI 표준', 'start': 2199, 'end': 2205, 'type': 'COM'}","{'word': 'FORTRAN 77', 'start': 2208, 'end': 2217, 'type': 'COM'}",com:alter_names
2037,"공식적인 표기가 FORTRAN에서 Fortran으로 바뀐 것을 포함하여, 다음과 같은 사항을 표준에 추가하였다.","{'word': 'FORTRAN', 'start': 3067, 'end': 3073, 'type': 'COM'}","{'word': 'Fortran', 'start': 3077, 'end': 3083, 'type': 'COM'}",com:alter_names
2038,2017년 11월 12일 WG5의 투표에서 차기 포트란 표준의 이름을 Fortran 2015에서 Fortran 2018로 바꾸는 것이 가결되었다.,"{'word': 'Fortran 2015', 'start': 3990, 'end': 4001, 'type': 'COM'}","{'word': 'Fortran 2018', 'start': 4005, 'end': 4016, 'type': 'COM'}",com:alter_names
2039,"1990년대까지 널리 사용되어 왔던 FORTRAN 77에서 현재 Fortran 90/95, Fortran 2003, Fortran 2008등으로 계속 진보하고 있다.","{'word': 'Fortran 90/95, Fortran 2003, Fortran 2008', 'start': 729, 'end': 769, 'type': 'COM'}","{'word': 'FORTRAN 77', 'start': 713, 'end': 722, 'type': 'COM'}",com:prior_tech
2040,"FORTRAN77까지 초기의 버전은 그 이름에 대문자를 사용하였으나, 현재는 Fortran으로 첫 문자만을 대문자로 표기한다.","{'word': 'Fortran', 'start': 961, 'end': 967, 'type': 'COM'}","{'word': 'FORTRAN77', 'start': 918, 'end': 926, 'type': 'COM'}",com:prior_tech
2041,"포트란 표준 위원회는 10년단위의 major update 와 5년 단기의 minor update를 계획하는데, Fortran 95는 Fortran 90에 대한 minor update로 계획된다.","{'word': 'Fortran 95', 'start': 3374, 'end': 3383, 'type': 'COM'}","{'word': 'Fortran 90', 'start': 3386, 'end': 3395, 'type': 'COM'}",com:prior_tech
2042,그 이전엔 프로그래머들이 손수 어셈블리어를 이용해야 했다.,"{'word': '프로그래머', 'start': 1454, 'end': 1458, 'type': 'PER'}","{'word': '어셈블리어', 'start': 1465, 'end': 1469, 'type': 'COM'}",no_relation
2043,포트란에 대한 ANSI 표준을 담당하는 위원회는 J3로 불린다.,"{'word': 'J3', 'start': 1151, 'end': 1152, 'type': 'ORG'}","{'word': '포트란', 'start': 1124, 'end': 1126, 'type': 'COM'}",no_relation
2044,포트란에 대한 ISO 국제 표준을 담당하는 실무그룹은 ISO/IEC JTC1/SC22/WG5 로 WG5로 불린다.,"{'word': 'WG5', 'start': 1214, 'end': 1216, 'type': 'ORG'}","{'word': '포트란', 'start': 1160, 'end': 1162, 'type': 'COM'}",no_relation
2045,"IBM이 가장 영향력이 높았으므로 표준화는 FORTRAN IV 컴파일러를 바탕으로 진행되었으며, 대중에게 FORTRAN IV와 FORTRAN 66은 혼용되어 불리게 된다.","{'word': 'IBM', 'start': 1733, 'end': 1735, 'type': 'ORG'}","{'word': 'FORTRAN IV 컴파일러', 'start': 1757, 'end': 1771, 'type': 'COM'}",no_relation
2046,이후 ISO(국제 표준화 기구)에서는 1972년 이 ANSI FORTRAN 66을 그대로 받아들여 포트란 국제 표준으로 받아들인다.,"{'word': 'ISO(국제 표준화 기구', 'start': 1860, 'end': 1872, 'type': 'ORG'}","{'word': 'ANSI FORTRAN 66', 'start': 1886, 'end': 1900, 'type': 'COM'}",no_relation
2047,ISO는 이 ANSI FORTRAN 77을 수용하여 포트란 국제 표준으로 받아들인다.,"{'word': 'ISO', 'start': 2259, 'end': 2261, 'type': 'ORG'}","{'word': 'ANSI FORTRAN 77', 'start': 2266, 'end': 2280, 'type': 'COM'}",no_relation
2048,"다음은 데이터 카드(천공 카드나 천공 테이프)에서 삼각형의 세 변의 길이를 읽은 후, 헤론의 공식으로 넓이를 구하여 출력하는 예이다.","{'word': '데이터 카드(천공 카드나 천공 테이프)', 'start': 4037, 'end': 4057, 'type': 'COM'}","{'word': '헤론의 공식', 'start': 4081, 'end': 4086, 'type': 'POH'}",no_relation
2049,"Fortran 90은 1991년에 ISO에서 먼저 승인을 얻었으며, ISO/IEC 1539:1991(E) 가 ISO Fortran90 이 된다.","{'word': 'Fortran 90', 'start': 2810, 'end': 2819, 'type': 'COM'}","{'word': '1991년', 'start': 2822, 'end': 2826, 'type': 'DAT'}",no_relation
2050,"포트란은 산술 기호(+, -, *, / 등)를 그대로 사용할 수 있으며, 삼각함수·지수함수·대수함수 등과 같은 기초적인 수학 함수들을 자연스럽게 불러내어 쓸 수 있으며, 최근 첨단 과학계산에서 필수적인 벡터, 행렬계산기능 등이 내장되어 있는 과학 기술 전문언어이다.","{'word': '포트란', 'start': 271, 'end': 273, 'type': 'COM'}","{'word': '수학 함수', 'start': 338, 'end': 342, 'type': 'COM'}",no_relation
2051,"포트란은 기후 및 기상예측, 자원탐사, 우주항공, 유체 및 구조해석, 계산화학, 양자 및 분자 동역학 계산, 천문학, 인공위성을 포함한 군사과학, 자동차 선박 설계, 반도체설계, 금융계산 등 거의 모든 산업분야의 초대형 과학계산 문제의 프로그래밍에 필수적인 언어이다.","{'word': '포트란', 'start': 420, 'end': 422, 'type': 'COM'}","{'word': '프로그래밍', 'start': 552, 'end': 556, 'type': 'COM'}",no_relation
2052,다른 컴퓨터 프로그래밍 언어에서도 그렇듯이 ANSI (미국 국립 표준 협회) 와 ISO (국제 표준화 기구)의 두 표준이 통용된다.,"{'word': '컴퓨터 프로그래밍 언어', 'start': 1053, 'end': 1064, 'type': 'COM'}","{'word': 'ANSI (미국 국립 표준 협회)', 'start': 1074, 'end': 1091, 'type': 'COM'}",no_relation
2053,FORTRAN 66에 비해서 FORTRAN 77표준은 다음과 같은 몇 가지 특징적인 기능을 포함하게 된다.,"{'word': 'FORTRAN 66', 'start': 2307, 'end': 2316, 'type': 'COM'}","{'word': 'FORTRAN 77표준', 'start': 2323, 'end': 2334, 'type': 'COM'}",no_relation
2054,이 후 1980년대 이후에 전 미국에서 발표된 포트란 77 컴파일러 제품들은 대부분 ANSI 표준 뿐만 아니라 이 국방성 표준을 지원하도록 설계되었다.,"{'word': '포트란 77 컴파일러', 'start': 2475, 'end': 2485, 'type': 'COM'}","{'word': 'ANSI 표준', 'start': 2496, 'end': 2502, 'type': 'COM'}",no_relation
2055,위 사항 중에서 INCLUDE 문법을 제외한 기능들이 이후 Fortran 90 포트란 표준에 추가된다.,"{'word': 'INCLUDE 문법', 'start': 2603, 'end': 2612, 'type': 'COM'}","{'word': 'Fortran 90 포트란 표준', 'start': 2627, 'end': 2643, 'type': 'COM'}",no_relation
2056,컴퓨터 환경은 무어의 법칙이 지배하게 되면서 빠르게 변화되어가는 도중에 FORTRAN 77 표준에 대한 개정은 지지부진하게 되었다.,"{'word': '무어의 법칙', 'start': 2660, 'end': 2665, 'type': 'COM'}","{'word': 'FORTRAN 77 표준', 'start': 2692, 'end': 2704, 'type': 'COM'}",no_relation
2057,"차기 버전이 나오기에 15년의 시간이 걸렸으며, 이 길었던 기간 동안 FORTRAN 77 표준은 포트란의 역사에서도 가장 중요한 표준이 되어 버렸다.","{'word': 'FORTRAN 77 표준', 'start': 2765, 'end': 2777, 'type': 'COM'}","{'word': '포트란', 'start': 2780, 'end': 2782, 'type': 'COM'}",no_relation
2058,"이전 FORTRAN XX 표준의 의미가 ANSI를 칭하였던 것에 비해, Fortran XX 형태의 표기는 ISO 국제 표준을 의미하는 것으로 여겨지게 되었다.","{'word': 'FORTRAN XX 표준', 'start': 2894, 'end': 2906, 'type': 'COM'}","{'word': 'ISO 국제 표준', 'start': 2950, 'end': 2958, 'type': 'COM'}",no_relation
2059,"포트란의 현대화가 진행된 표준이며, Ada와 같은 여러 다른 언어에서 많은 아이디어를 가져왔다.","{'word': '포트란', 'start': 3004, 'end': 3006, 'type': 'COM'}","{'word': 'Ada', 'start': 3024, 'end': 3026, 'type': 'COM'}",no_relation
2060,Fortran 90 은 FORTRAN 77의 기존의 문법 중 몇 가지 사항을 Obsolescent로 분류하였다.,"{'word': 'Fortran 90', 'start': 3121, 'end': 3130, 'type': 'COM'}","{'word': 'FORTRAN 77', 'start': 3134, 'end': 3143, 'type': 'COM'}",no_relation
2061,"즉, 모든 FORTRAN 77 표준 코드가 Fortran 90 표준에 부합하도록 정의되었다.","{'word': 'FORTRAN 77 표준 코드', 'start': 3245, 'end': 3260, 'type': 'COM'}","{'word': 'Fortran 90 표준', 'start': 3263, 'end': 3275, 'type': 'COM'}",no_relation
2062,이는 Fortran 90에 대한 확장 기능을 제공하던 High Performance Fortran(HPFF) 프로젝트의 영향을 받아 병렬 프로그래밍에 대한 지원을 목적으로 한다.,"{'word': 'Fortran 90', 'start': 3454, 'end': 3463, 'type': 'COM'}","{'word': 'High Performance Fortran(HPFF) 프로젝트', 'start': 3481, 'end': 3515, 'type': 'COM'}",no_relation
2063,Fortran 95에서는 Fortran 90에서 Obsolescent로 분류되었던 항목 중에서 몇몇 문법이 Deleted 항목으로 변화되었다.,"{'word': 'Fortran 95', 'start': 3572, 'end': 3581, 'type': 'COM'}","{'word': 'Fortran 90', 'start': 3586, 'end': 3595, 'type': 'COM'}",no_relation
2064,"원래는 90에 대한 10년 단위 major update로 Fortran 2000이 계획되었으나, 합의가 늦어지고 Fortran 2003으로 발표된다.","{'word': 'Fortran 2000', 'start': 3684, 'end': 3695, 'type': 'COM'}","{'word': 'Fortran 2003', 'start': 3715, 'end': 3726, 'type': 'COM'}",no_relation
2065,Fortran 2003은 ISO/IEC 1539-1:2004가 공식 문서이며이다.,"{'word': 'Fortran 2003', 'start': 3736, 'end': 3747, 'type': 'COM'}","{'word': 'ISO/IEC 1539-1:2004', 'start': 3750, 'end': 3768, 'type': 'COM'}",no_relation
2066,Fortran 2008은 가장 최근에 발표된 표준으로 ISO/IEC 1539-1:2010가 공식 문서이다.,"{'word': 'Fortran 2008', 'start': 3805, 'end': 3816, 'type': 'COM'}","{'word': 'ISO/IEC 1539-1:2010', 'start': 3835, 'end': 3853, 'type': 'COM'}",no_relation
2067,다음은 대화형으로 사용자의 숫자 입력을 받아서 평균을 출력하는 프로그램이다.,"{'word': '대화형', 'start': 4983, 'end': 4985, 'type': 'COM'}","{'word': '프로그램', 'start': 5014, 'end': 5017, 'type': 'COM'}",no_relation
2068,"FORTRAN은 수식(Formula) 변환기(Translation)의 약자이다.(IBM Mathematical ""For""mula ""Tran""slating System에서 유래.) 포트란은 알골과 함께 과학 계산용으로 주로 사용되는 언어이며, 당시 7명의 전문가가 약 2년 반 동안에 걸쳐 완성한 것이 포트란의 기본을 이루었고, 그 후 ANSI와 ISO에서 표준화하였다.","{'word': '포트란', 'start': 164, 'end': 166, 'type': 'COM'}","{'word': '알골', 'start': 169, 'end': 170, 'type': 'COM'}",com:similar_tech
2069,"전문적인 과학계산 문제를 풀기 위하여 프로그래밍하는 데 있어서 C보다 포트란이 훨씬 간단 명료하고 신속하게 프로그래밍을 작성할 수 있으며, 디버깅하는 데도 시간이 현저하게 단축될 뿐만 아니라, 그 계산속도 또한 일반적으로 훨씬 빠르다.","{'word': 'C', 'start': 821, 'end': 821, 'type': 'COM'}","{'word': '포트란', 'start': 825, 'end': 827, 'type': 'COM'}",com:similar_tech
2070,"FORTRAN 66 표준이 발표된 이후에도, 각 컴파일러 벤더들은 표준에 포함되지 않는 각자의 부가적 확장 문법을 포함하는 포트란 컴파일러들을 출시하였으며, 이에 미 포트란 표준화 위원회(ANSI committee X3J3 - J3)가 1969년 결성되었으며, FORTRAN 66 표준에 대한 개정을 논의하기 시작했다.","{'word': '컴파일러 벤더', 'start': 1998, 'end': 2004, 'type': 'ORG'}","{'word': '포트란 컴파일러', 'start': 2040, 'end': 2047, 'type': 'COM'}",org:production
2071,1953년 존 배커스(John Warner Backus) 가 IBM 704 메인프레임머신에 사용할 프로그래밍 언어로 어셈블리어에 대한 대안으로 제시하였다.,"{'word': '존 배커스(John Warner Backus)', 'start': 1279, 'end': 1303, 'type': 'PER'}","{'word': 'IBM', 'start': 1307, 'end': 1309, 'type': 'ORG'}",no_relation
2072,"최종 안이 1977년에 확정되었으며, 1978년 4월 ANSI의 승인을 얻게 된다.","{'word': 'ANSI', 'start': 2180, 'end': 2183, 'type': 'ORG'}","{'word': '1977년', 'start': 2156, 'end': 2160, 'type': 'DAT'}",no_relation
2073,ANSI의 승인은 1992년에 이루어진다.,"{'word': 'ANSI', 'start': 2980, 'end': 2983, 'type': 'ORG'}","{'word': '1992년', 'start': 2990, 'end': 2994, 'type': 'DAT'}",no_relation
2074,소프트웨어와 이에 동반하는 소스 코드는 일반적으로 크게 자유 소프트웨어와 사유 소프트웨어 가운데 하나의 라이선스를 지닌다.,"{'word': '소프트웨어와 이에 동반하는 소스 코드', 'start': 184, 'end': 203, 'type': 'COM'}","{'word': '자유 소프트웨어와 사유 소프트웨어', 'start': 215, 'end': 232, 'type': 'COM'}",com:sub_concept
2075,소스는 데이터베이스(예: 저장 프로시저) 등의 다른 곳에 저장할 수도 있다.,"{'word': '데이터베이스(', 'start': 627, 'end': 633, 'type': 'COM'}","{'word': '저장 프로시저', 'start': 637, 'end': 643, 'type': 'COM'}",com:sub_concept
2076,이진 번역과 원본 플랫폼의 에뮬레이션과 같이 이용할 수 있는 포팅 옵션들이 있다.,"{'word': '포팅 옵션', 'start': 1003, 'end': 1007, 'type': 'COM'}","{'word': '원본 플랫폼의 에뮬레이션', 'start': 976, 'end': 988, 'type': 'COM'}",com:sub_concept
2077,이진 번역과 원본 플랫폼의 에뮬레이션과 같이 이용할 수 있는 포팅 옵션들이 있다.,"{'word': '포팅 옵션', 'start': 1003, 'end': 1007, 'type': 'COM'}","{'word': '이진 번역', 'start': 969, 'end': 973, 'type': 'COM'}",com:sub_concept
2078,일반적으로 이 파일들은 소스 트리(source tree)로 불리는 디렉터리 트리에 주의를 기울여 정렬된다.,"{'word': '디렉터리 트리', 'start': 600, 'end': 606, 'type': 'COM'}","{'word': '소스 트리(source tree)', 'start': 576, 'end': 593, 'type': 'COM'}",com:alter_names
2079,"현대 소프트웨어 개발에서 기계어는 극히 일부 영역에서만 쓰이며, 대부분 고급 언어로 된 소스 코드를 컴파일하여 개발한다.","{'word': '소프트웨어', 'start': 119, 'end': 123, 'type': 'COM'}","{'word': '기계어', 'start': 130, 'end': 132, 'type': 'COM'}",com:made_of
2080,"현대 소프트웨어 개발에서 기계어는 극히 일부 영역에서만 쓰이며, 대부분 고급 언어로 된 소스 코드를 컴파일하여 개발한다.","{'word': '소프트웨어', 'start': 119, 'end': 123, 'type': 'COM'}","{'word': '고급 언어로 된 소스 코드', 'start': 156, 'end': 169, 'type': 'COM'}",com:made_of
2081,프로그래머는 프로그래밍 기술을 배우려면 기존에 있던 소스 코드를 살펴보는 것이 도움이 된다.,"{'word': '프로그래머', 'start': 779, 'end': 783, 'type': 'PER'}","{'word': '소스 코드', 'start': 808, 'end': 812, 'type': 'COM'}",no_relation
2082,개발자들 사이의 소스 공유는 프로그래밍 기술의 발전에 기여하는 역할을 하며 자주 인용된다.,"{'word': '개발자', 'start': 831, 'end': 833, 'type': 'PER'}","{'word': '프로그래밍 기술', 'start': 847, 'end': 854, 'type': 'COM'}",no_relation
2083,일부 사람들은 소스 코드를 풍부한 화재(그림의 소재)로 생각한다.,"{'word': '사람', 'start': 885, 'end': 886, 'type': 'PER'}","{'word': '소스 코드', 'start': 890, 'end': 894, 'type': 'COM'}",no_relation
2084,IBM이 최초로 기계와 함께 작업할 소프트웨어를 제공했을 때 소스 코드는 무료로 제공되었다.,"{'word': 'IBM', 'start': 353, 'end': 355, 'type': 'ORG'}","{'word': '소스 코드', 'start': 387, 'end': 391, 'type': 'COM'}",no_relation
2085,IBM이 최초로 기계와 함께 작업할 소프트웨어를 제공했을 때 소스 코드는 무료로 제공되었다.,"{'word': 'IBM', 'start': 353, 'end': 355, 'type': 'ORG'}","{'word': '소프트웨어', 'start': 373, 'end': 377, 'type': 'COM'}",no_relation
2086,수십년 간 IBM은 1983년까지 소스 코드를 자사의 소프트웨어 제품 라이선스와 함께 배포하였다.,"{'word': 'IBM', 'start': 452, 'end': 454, 'type': 'ORG'}","{'word': '소스 코드', 'start': 465, 'end': 469, 'type': 'COM'}",no_relation
2087,수십년 간 IBM은 1983년까지 소스 코드를 자사의 소프트웨어 제품 라이선스와 함께 배포하였다.,"{'word': 'IBM', 'start': 452, 'end': 454, 'type': 'ORG'}","{'word': '소프트웨어', 'start': 476, 'end': 480, 'type': 'COM'}",no_relation
2088,"프로그래밍에서 설계도의 역할을 하며, 한 개, 또는 여러 개의 텍스트 파일로 구성되어 있다.","{'word': '프로그래밍', 'start': 64, 'end': 68, 'type': 'COM'}","{'word': '텍스트 파일', 'start': 99, 'end': 104, 'type': 'COM'}",no_relation
2089,프로그램 내장식 컴퓨터를 위한 최초의 프로그램들은 컴퓨터의 전면 패널 스위치를 통해 바이너리 형태로 입력되었다.,"{'word': '프로그램', 'start': 274, 'end': 277, 'type': 'COM'}","{'word': '바이너리', 'start': 300, 'end': 303, 'type': 'COM'}",no_relation
2090,1세대 프로그래밍 언어는 소스 코드와 기계어 간의 구별이 없었다.,"{'word': '소스 코드', 'start': 330, 'end': 334, 'type': 'COM'}","{'word': '기계어', 'start': 337, 'end': 339, 'type': 'COM'}",no_relation
2091,당시 소프트웨어를 개발하고 지원하는 비용이 하드웨어의 가격에 포함되었다.,"{'word': '소프트웨어', 'start': 408, 'end': 412, 'type': 'COM'}","{'word': '하드웨어', 'start': 429, 'end': 432, 'type': 'COM'}",no_relation
2092,프로그램을 구성하는 소스 코드는 일반적으로 컴퓨터의 하드 디스크에 저장된 하나 이상의 텍스트 파일에 위치한다.,"{'word': '소스 코드', 'start': 512, 'end': 516, 'type': 'COM'}","{'word': '하드 디스크', 'start': 530, 'end': 535, 'type': 'COM'}",no_relation
2093,"소스 코드는 주로 실행 프로그램을 만드는 과정을 입력하는 데 이용된다. (이를테면 컴파일이나 해석 과정) 또, 사람들 사이에 알고리즘을 주고 받는 방식으로 이용되기도 한다. (이를테면 책의 코드 조각)","{'word': '소스 코드', 'start': 666, 'end': 670, 'type': 'COM'}","{'word': '실행 프로그램', 'start': 676, 'end': 682, 'type': 'COM'}",no_relation
2094,"소스 코드는 주로 실행 프로그램을 만드는 과정을 입력하는 데 이용된다. (이를테면 컴파일이나 해석 과정) 또, 사람들 사이에 알고리즘을 주고 받는 방식으로 이용되기도 한다. (이를테면 책의 코드 조각)","{'word': '소스 코드', 'start': 666, 'end': 670, 'type': 'COM'}","{'word': '알고리즘', 'start': 736, 'end': 739, 'type': 'COM'}",no_relation
2095,소프트웨어를 다른 컴퓨터 플랫폼에 포팅하는 것은 일반적으로 소스 코드 없이는 불가능하다.,"{'word': '소프트웨어', 'start': 919, 'end': 923, 'type': 'COM'}","{'word': '포팅', 'start': 938, 'end': 939, 'type': 'COM'}",no_relation
2096,소스 코드() 또는 원시 코드란 컴퓨터 프로그램을 사람이 읽을 수 있는 프로그래밍 언어로 기술한 텍스트 파일이다.,"{'word': '소스 코드', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': '원시 코드', 'start': 11, 'end': 15, 'type': 'COM'}",com:similar_tech
2097,실행 프로그램의 디컴파일은 고급 언어에서나 어셈블리어로 소스 코드를 만들어내는 데 쓰인다.,"{'word': '고급 언어', 'start': 1030, 'end': 1034, 'type': 'COM'}","{'word': '어셈블리어', 'start': 1039, 'end': 1043, 'type': 'COM'}",com:similar_tech
2098,"C 언어, 자바, 베이직 등 대부분의 프로그래밍 언어들은 고급언어에 속한다.","{'word': '고급언어', 'start': 173, 'end': 176, 'type': 'COM'}","{'word': '베이직', 'start': 151, 'end': 153, 'type': 'COM'}",com:sub_concept
2099,"C 언어, 자바, 베이직 등 대부분의 프로그래밍 언어들은 고급언어에 속한다.","{'word': '고급언어', 'start': 173, 'end': 176, 'type': 'COM'}","{'word': '자바', 'start': 147, 'end': 148, 'type': 'COM'}",com:sub_concept
2100,"C 언어, 자바, 베이직 등 대부분의 프로그래밍 언어들은 고급언어에 속한다.","{'word': '고급언어', 'start': 173, 'end': 176, 'type': 'COM'}","{'word': 'C 언어', 'start': 141, 'end': 144, 'type': 'COM'}",com:sub_concept
2101,오토코드의 예는 코볼과 포트란이 있다.,"{'word': '오토코드', 'start': 268, 'end': 271, 'type': 'COM'}","{'word': '코볼', 'start': 277, 'end': 278, 'type': 'COM'}",com:sub_concept
2102,오토코드의 예는 코볼과 포트란이 있다.,"{'word': '오토코드', 'start': 268, 'end': 271, 'type': 'COM'}","{'word': '포트란', 'start': 281, 'end': 283, 'type': 'COM'}",com:sub_concept
2103,1960년대에 컴파일러를 이용한 고급 프로그래밍 언어들은 보통 오토코드라 불렀다.,"{'word': '고급 프로그래밍 언어', 'start': 240, 'end': 250, 'type': 'COM'}","{'word': '오토코드', 'start': 257, 'end': 260, 'type': 'COM'}",com:alter_names
2104,"고급 프로그래밍 언어 또는 하이 레벨 프로그래밍 언어()란 사람이 이해하기 쉽게 작성된 프로그래밍 언어로서, 저급 프로그래밍 언어보다 가독성이 높고 다루기 간단하다는 장점이 있다.","{'word': '저급 프로그래밍 언어', 'start': 61, 'end': 71, 'type': 'COM'}","{'word': '하이 레벨 프로그래밍 언어', 'start': 15, 'end': 28, 'type': 'COM'}",no_relation
2105,"고급 프로그래밍 언어 또는 하이 레벨 프로그래밍 언어()란 사람이 이해하기 쉽게 작성된 프로그래밍 언어로서, 저급 프로그래밍 언어보다 가독성이 높고 다루기 간단하다는 장점이 있다.","{'word': '저급 프로그래밍 언어', 'start': 61, 'end': 71, 'type': 'COM'}","{'word': '고급 프로그래밍 언어', 'start': 0, 'end': 10, 'type': 'COM'}",no_relation
2106,추상화의 정도는 얼마나 프로그래밍 언어가 높은 수준인지를 정의한다.,"{'word': '추상화', 'start': 184, 'end': 186, 'type': 'COM'}","{'word': '프로그래밍 언어', 'start': 197, 'end': 204, 'type': 'COM'}",no_relation
2107,"고급 프로그래밍 언어 또는 하이 레벨 프로그래밍 언어()란 사람이 이해하기 쉽게 작성된 프로그래밍 언어로서, 저급 프로그래밍 언어보다 가독성이 높고 다루기 간단하다는 장점이 있다.","{'word': '고급 프로그래밍 언어', 'start': 0, 'end': 10, 'type': 'COM'}","{'word': '하이 레벨 프로그래밍 언어', 'start': 15, 'end': 28, 'type': 'COM'}",com:similar_tech
2108,컴파일러나 인터프리터에 의해 저급 프로그래밍 언어로 번역되어 실행된다.,"{'word': '컴파일러', 'start': 101, 'end': 104, 'type': 'COM'}","{'word': '인터프리터', 'start': 107, 'end': 111, 'type': 'COM'}",com:similar_tech
2109,컴퓨터용으로 설계된 최초의 고급 프로그래밍 언어는 콘라트 추제가 개발한 플랑칼퀼(Plankalkül)이다.,"{'word': '콘라트 추제', 'start': 318, 'end': 323, 'type': 'PER'}","{'word': '플랑칼퀼(Plankalkül)', 'start': 330, 'end': 345, 'type': 'COM'}",per:production
2110,그러나 이 언어는 추제의 기간 동안 구현되지는 않았으며 그의 초창기 기여는 제2차 세계 대전으로 인해 다른 개발로부터 상당 부분 분리된 상태였다.,"{'word': '언어', 'start': 356, 'end': 357, 'type': 'COM'}","{'word': '추제', 'start': 360, 'end': 361, 'type': 'PER'}",no_relation
2111,영향력 있는 최초의 고급 언어는 포트란으로서 IBM의 초창기 오토코드 시스템의 기계 독립적 개발 언어였다.,"{'word': '포트란', 'start': 450, 'end': 452, 'type': 'COM'}","{'word': 'IBM', 'start': 457, 'end': 459, 'type': 'ORG'}",no_relation
2112,"알골(ALGOL, Algorithmic Language의 준말)은 1950년대 미국에서 만들어진 포트란에 대항하여 유럽의 학자들을 중심으로 개발된 프로그래밍 언어이다.","{'word': '알골', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': '1950년대', 'start': 37, 'end': 42, 'type': 'DAT'}",com:date_of_prod
2113,1960년에 제안된 ALGOL 60 은 그 문법이 BNF 표기법으로 기술되었으며 구조화된 프로그래밍의 형태를 갖고 있었다.,"{'word': 'ALGOL 60', 'start': 297, 'end': 304, 'type': 'COM'}","{'word': '1960년', 'start': 286, 'end': 290, 'type': 'DAT'}",com:date_of_prod
2114,1968년에는 ALGOL 68이 개발되었다.,"{'word': 'ALGOL 68', 'start': 641, 'end': 648, 'type': 'COM'}","{'word': '1968년', 'start': 633, 'end': 637, 'type': 'DAT'}",com:date_of_prod
2115,1960년에 제안된 ALGOL 60 은 그 문법이 BNF 표기법으로 기술되었으며 구조화된 프로그래밍의 형태를 갖고 있었다.,"{'word': 'ALGOL 60', 'start': 297, 'end': 304, 'type': 'COM'}","{'word': '구조화된 프로그래밍의 형태', 'start': 331, 'end': 344, 'type': 'COM'}",com:sub_concept
2116,ALGOL 60은 절차형 언어로는 최초로 재귀호출이 가능한 프로그래밍 언어였다.,"{'word': '절차형 언어', 'start': 365, 'end': 370, 'type': 'COM'}","{'word': 'ALGOL 60', 'start': 355, 'end': 362, 'type': 'COM'}",com:sub_concept
2117,ALGOL 60은 절차형 언어로는 최초로 재귀호출이 가능한 프로그래밍 언어였다.,"{'word': 'ALGOL 60', 'start': 355, 'end': 362, 'type': 'COM'}","{'word': '재귀호출', 'start': 378, 'end': 381, 'type': 'COM'}",com:sub_concept
2118,"인자 전달에 있어서 알골에 특징적이었던 ""이름 전달"" 방식도 이후의 언어에서는 거의 찾아볼 수 없게 되었다.","{'word': '알골', 'start': 477, 'end': 478, 'type': 'COM'}","{'word': '""이름 전달"" 방식', 'start': 488, 'end': 497, 'type': 'COM'}",com:sub_concept
2119,ALGOL 68에서는 2단계 문법 Wijngaarden 표기법으로 문법이 기술되었다.,"{'word': 'ALGOL 68', 'start': 658, 'end': 665, 'type': 'COM'}","{'word': 'Wijngaarden 표기법', 'start': 677, 'end': 691, 'type': 'COM'}",com:sub_concept
2120,"알골(ALGOL, Algorithmic Language의 준말)은 1950년대 미국에서 만들어진 포트란에 대항하여 유럽의 학자들을 중심으로 개발된 프로그래밍 언어이다.","{'word': '알골', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': 'Algorithmic Language', 'start': 10, 'end': 29, 'type': 'COM'}",com:alter_names
2121,ALGOL은 여러 ALGOL계 언어의 총칭으로 ALGOL이란 이름의 프로그래밍 언어는 존재하지 않는다.,"{'word': 'ALGOL계 언어', 'start': 150, 'end': 158, 'type': 'COM'}","{'word': 'ALGOL', 'start': 140, 'end': 144, 'type': 'COM'}",com:alter_names
2122,"1958년 취리히에서 열린 국제회의에서 제안된 것이 그 기원으로 여겨진다. (이 언어는 후에 ALGOL 58로 불리게 되지만, 당초의 이름은 IAL이었다.)","{'word': 'ALGOL 58', 'start': 250, 'end': 257, 'type': 'COM'}","{'word': 'IAL', 'start': 277, 'end': 279, 'type': 'COM'}",com:prior_tech
2123,"ALGOL 60의 후계 언어가 제정되기까지 파스칼을 설계한 Wirth의 ALGOL W를 비롯한 여러 후보자가 있었지만, 결국은 ALGOL 68이 후계로 지정되었다.","{'word': 'ALGOL 68', 'start': 777, 'end': 784, 'type': 'COM'}","{'word': 'ALGOL 60', 'start': 706, 'end': 713, 'type': 'COM'}",com:prior_tech
2124,"알골(ALGOL, Algorithmic Language의 준말)은 1950년대 미국에서 만들어진 포트란에 대항하여 유럽의 학자들을 중심으로 개발된 프로그래밍 언어이다.","{'word': '포트란', 'start': 54, 'end': 56, 'type': 'COM'}","{'word': '알골', 'start': 0, 'end': 1, 'type': 'COM'}",no_relation
2125,"알고리즘의 연구개발, 수치 계산과 논리 연산에 이용하기 위한 목적으로 만들어졌다.","{'word': '알고리즘', 'start': 94, 'end': 97, 'type': 'COM'}","{'word': '논리 연산', 'start': 113, 'end': 117, 'type': 'COM'}",no_relation
2126,ALGOL은 여러 ALGOL계 언어의 총칭으로 ALGOL이란 이름의 프로그래밍 언어는 존재하지 않는다.,"{'word': 'ALGOL', 'start': 166, 'end': 170, 'type': 'COM'}","{'word': '프로그래밍 언어', 'start': 178, 'end': 185, 'type': 'COM'}",no_relation
2127,표준으로 IFIP TC/WG2.1에서 ALGOL 60이 제정되었다.,"{'word': 'IFIP TC/WG2.1', 'start': 532, 'end': 544, 'type': 'COM'}","{'word': 'ALGOL 60', 'start': 548, 'end': 555, 'type': 'COM'}",no_relation
2128,이후에는 이어지는 표준화 작업은 진행되지 않고 1984년에야 ALGOL 60에 상당하는 것이 ISO 표준으로 지정되었다.,"{'word': 'ALGOL 60', 'start': 599, 'end': 606, 'type': 'COM'}","{'word': 'ISO 표준', 'start': 617, 'end': 622, 'type': 'COM'}",no_relation
2129,"그러나 너무 복잡하고 방대한 사양을 요구했기 때문에 ALGOL 68 컴파일러는 실제 구현이 어려웠고, Wijngaarden 표기법 또한 난해하여 실용적으로 보급되지 못했다.","{'word': 'ALGOL 68 컴파일러', 'start': 827, 'end': 839, 'type': 'COM'}","{'word': 'Wijngaarden 표기법', 'start': 855, 'end': 869, 'type': 'COM'}",no_relation
2130,"다음은 n×m의 2 차원 배열 중 절대값이 가장 큰 요소를 찾아, 그 절대 값을 y에, 첨자를 i와 k에 저장하는 함수이다.","{'word': '배열', 'start': 909, 'end': 910, 'type': 'COM'}","{'word': '함수', 'start': 959, 'end': 960, 'type': 'COM'}",no_relation
2131,"또한 PL/I, 파스칼, C 언어 등 이후 언어의 발전에 큰 영향을 주었다.","{'word': 'PL/I', 'start': 403, 'end': 406, 'type': 'COM'}","{'word': '파스칼', 'start': 409, 'end': 411, 'type': 'COM'}",com:similar_tech
2132,"또한 PL/I, 파스칼, C 언어 등 이후 언어의 발전에 큰 영향을 주었다.","{'word': 'PL/I', 'start': 403, 'end': 406, 'type': 'COM'}","{'word': 'C 언어', 'start': 414, 'end': 417, 'type': 'COM'}",com:similar_tech
2133,"알골(ALGOL, Algorithmic Language의 준말)은 1950년대 미국에서 만들어진 포트란에 대항하여 유럽의 학자들을 중심으로 개발된 프로그래밍 언어이다.","{'word': '유럽의 학자들', 'start': 64, 'end': 70, 'type': 'PER'}","{'word': '알골', 'start': 0, 'end': 1, 'type': 'COM'}",per:production
2134,"ALGOL 60의 후계 언어가 제정되기까지 파스칼을 설계한 Wirth의 ALGOL W를 비롯한 여러 후보자가 있었지만, 결국은 ALGOL 68이 후계로 지정되었다.","{'word': 'Wirth', 'start': 739, 'end': 743, 'type': 'PER'}","{'word': '파스칼', 'start': 730, 'end': 732, 'type': 'COM'}",per:production
2135,"ALGOL 60의 후계 언어가 제정되기까지 파스칼을 설계한 Wirth의 ALGOL W를 비롯한 여러 후보자가 있었지만, 결국은 ALGOL 68이 후계로 지정되었다.","{'word': 'Wirth', 'start': 739, 'end': 743, 'type': 'PER'}","{'word': 'ALGOL W', 'start': 746, 'end': 752, 'type': 'COM'}",per:production
2136,많은 프로그래밍 언어는 컴파일러와 인터프리터 양쪽 모두 구현되어 있다.,"{'word': '프로그래밍 언어', 'start': 108, 'end': 115, 'type': 'COM'}","{'word': '컴파일러', 'start': 118, 'end': 121, 'type': 'COM'}",com:sub_concept
2137,많은 프로그래밍 언어는 컴파일러와 인터프리터 양쪽 모두 구현되어 있다.,"{'word': '프로그래밍 언어', 'start': 108, 'end': 115, 'type': 'COM'}","{'word': '인터프리터', 'start': 124, 'end': 128, 'type': 'COM'}",com:sub_concept
2138,"예를 들어 자바는 가상 머신을 위한 바이트코드로 컴파일될 수 있으며, 가상 머신의 인터프리터가 이를 처리한다.","{'word': '가상 머신', 'start': 184, 'end': 188, 'type': 'COM'}","{'word': '인터프리터', 'start': 191, 'end': 195, 'type': 'COM'}",com:sub_concept
2139,인터프리트 언어()는 컴파일러를 거쳐서 기계어로 변환되지 않고 바로 실행되는 프로그래밍 언어를 말한다.,"{'word': '컴파일러', 'start': 12, 'end': 15, 'type': 'COM'}","{'word': '기계어', 'start': 22, 'end': 24, 'type': 'COM'}",no_relation
2140,반대로 반드시 기계어로 컴파일되어야만 실행시킬 수 있는 언어를 컴파일 언어라 한다.,"{'word': '기계어', 'start': 66, 'end': 68, 'type': 'COM'}","{'word': '컴파일 언어', 'start': 93, 'end': 98, 'type': 'COM'}",no_relation
2141,또한 JIT 컴파일을 통해 바이트코드가 네이티브 코드로 컴파일되기도 한다.,"{'word': 'JIT 컴파일', 'start': 210, 'end': 216, 'type': 'COM'}","{'word': '바이트코드', 'start': 222, 'end': 226, 'type': 'COM'}",no_relation
2142,또한 JIT 컴파일을 통해 바이트코드가 네이티브 코드로 컴파일되기도 한다.,"{'word': 'JIT 컴파일', 'start': 210, 'end': 216, 'type': 'COM'}","{'word': '네이티브 코드', 'start': 229, 'end': 235, 'type': 'COM'}",no_relation
2143,GCC는 리처드 스톨만이 1987년 GNU 프로젝트의 컴파일러로 작성했다.,"{'word': 'GCC', 'start': 266, 'end': 268, 'type': 'COM'}","{'word': '1987년', 'start': 280, 'end': 284, 'type': 'DAT'}",com:date_of_prod
2144,"4.6 이후의 표준 컴파일러 릴리즈에는 C (codice_1), C++ (codice_2), 오브젝티브 C, 오브젝티브 C++, 포트란 (codice_3), 자바 (codice_4), 에이다 (GNAT), 고 (codice_5)를 위한 프론트엔드가 포함되어 있다.","{'word': '표준 컴파일러 릴리즈', 'start': 641, 'end': 651, 'type': 'COM'}","{'word': 'C (codice_1), C++ (codice_2), 오브젝티브 C, 오브젝티브 C++, 포트란 (codice_3), 자바 (codice_4), 에이다 (GNAT), 고 (codice_5)를 위한 프론트엔드', 'start': 655, 'end': 769, 'type': 'COM'}",com:sub_concept
2145,새로운 버전에서 codice_9는 포트란 2003의 일부와 포트란 95를 지원하는 새로운 codice_3 프론트엔드를 선호하게 되면서 지원이 중단되었다.,"{'word': 'codice_3 프론트엔드', 'start': 1020, 'end': 1033, 'type': 'COM'}","{'word': '포트란 2003의 일부와 포트란 95', 'start': 989, 'end': 1008, 'type': 'COM'}",com:sub_concept
2146,나중의 포트란 표준이 F77 표준을 포함하면서 표준 호환 F77 코드가 표준 호환 F90/95 코드가 되어 gfortran에서 문제 없이 컴파일이 가능하다.,"{'word': '포트란 표준', 'start': 1060, 'end': 1065, 'type': 'COM'}","{'word': 'F77 표준', 'start': 1068, 'end': 1073, 'type': 'COM'}",com:sub_concept
2147,"일부 실험적인 브랜치들은 추가적인 언어들을 지원하기도 하는데, 이를테면 GCC UPC 컴파일러가 있다.","{'word': '실험적인 브랜치', 'start': 1186, 'end': 1193, 'type': 'COM'}","{'word': 'GCC UPC 컴파일러', 'start': 1223, 'end': 1234, 'type': 'COM'}",com:sub_concept
2148,"GNU 컴파일러 모음(, 줄여서 GCC)는 GNU 프로젝트의 일환으로 개발되어 널리 쓰이고 있는 컴파일러이다.","{'word': 'GNU 컴파일러 모음', 'start': 0, 'end': 10, 'type': 'COM'}","{'word': 'GCC', 'start': 18, 'end': 20, 'type': 'COM'}",com:alter_names
2149,"자유 소프트웨어 중에 가장 잘 알려진 것들 중 하나인 GCC는 원래 C만을 지원했던 컴파일러로 이름도 ""GNU C 컴파일러""였다.","{'word': 'GCC', 'start': 92, 'end': 94, 'type': 'COM'}","{'word': 'GNU C 컴파일러', 'start': 120, 'end': 129, 'type': 'COM'}",com:alter_names
2150,이러한 까닭에 현재에도 GCC는 GNU 컴파일러 모음의 일부인 GNU C 컴파일러()의 줄임말로 쓰이기도 한다.,"{'word': 'GNU C 컴파일러', 'start': 170, 'end': 179, 'type': 'COM'}","{'word': 'GCC', 'start': 148, 'end': 150, 'type': 'COM'}",com:alter_names
2151,GCC는 리처드 스톨만이 1987년 GNU 프로젝트의 컴파일러로 작성했다.,"{'word': 'GCC', 'start': 266, 'end': 268, 'type': 'COM'}","{'word': 'GNU 프로젝트의 컴파일러', 'start': 286, 'end': 299, 'type': 'COM'}",com:made_of
2152,GNU 시스템의 공식 컴파일러이므로 GCC는 많은 컴파일러와 운영 체제를 만드는 데 사용되었다.,"{'word': '컴파일러와 운영 체제', 'start': 490, 'end': 500, 'type': 'COM'}","{'word': 'GCC', 'start': 482, 'end': 484, 'type': 'COM'}",com:made_of
2153,포트란 프론트엔드는 포트란 77만 지원했던 버전 4.0 이전까지 codice_9였다.,"{'word': '버전 4.0', 'start': 946, 'end': 951, 'type': 'COM'}","{'word': 'codice_9', 'start': 958, 'end': 965, 'type': 'COM'}",com:prior_tech
2154,나중의 포트란 표준이 F77 표준을 포함하면서 표준 호환 F77 코드가 표준 호환 F90/95 코드가 되어 gfortran에서 문제 없이 컴파일이 가능하다.,"{'word': '표준 호환 F90/95 코드', 'start': 1096, 'end': 1110, 'type': 'COM'}","{'word': '표준 호환 F77 코드', 'start': 1082, 'end': 1093, 'type': 'COM'}",com:prior_tech
2155,GNU 프로젝트에 컴파일러가 없었기 때문에 이 개발은 자유 소프트웨어 재단이 후원하였다.,"{'word': 'GNU 프로젝트', 'start': 308, 'end': 315, 'type': 'COM'}","{'word': '컴파일러', 'start': 318, 'end': 321, 'type': 'COM'}",no_relation
2156,"현재 GCC는 전 세계적으로 관리되고 있으며, 다양한 중앙 처리 장치를 처리할 수 있게 되었다.","{'word': 'GCC', 'start': 411, 'end': 413, 'type': 'COM'}","{'word': '중앙 처리 장치', 'start': 438, 'end': 445, 'type': 'COM'}",no_relation
2157,"한편, 시스템 네이티브 컴파일러를 사용했을 때 비해서 GCC를 사용하면 같은 파서로 코드를 처리하므로 이식성을 향상시킬 수 있다.","{'word': '시스템 네이티브 컴파일러', 'start': 520, 'end': 532, 'type': 'COM'}","{'word': 'GCC', 'start': 546, 'end': 548, 'type': 'COM'}",no_relation
2158,GCC는 상용 컴파일러에 비해서 느린 코드를 생성했지만 최근 많이 개선되었다.,"{'word': 'GCC', 'start': 589, 'end': 591, 'type': 'COM'}","{'word': '상용 컴파일러', 'start': 594, 'end': 600, 'type': 'COM'}",no_relation
2159,CHILL을 위한 프론트엔드는 유지 보수 부족으로 개발이 중단되었다.,"{'word': 'CHILL', 'start': 1144, 'end': 1148, 'type': 'COM'}","{'word': '프론트엔드', 'start': 1154, 'end': 1158, 'type': 'COM'}",no_relation
2160,버전 4.3을 기준으로 GCC는 다음의 프로세서 계열을 대상으로 한다:,"{'word': 'GCC', 'start': 1254, 'end': 1256, 'type': 'COM'}","{'word': '프로세서', 'start': 1263, 'end': 1266, 'type': 'COM'}",no_relation
2161,"표준 릴리즈에서 지원되는, 위보다 잘 알려지지 않은 프로세서는 다음을 포함한다:","{'word': '표준 릴리즈', 'start': 1281, 'end': 1286, 'type': 'COM'}","{'word': '프로세서', 'start': 1310, 'end': 1313, 'type': 'COM'}",no_relation
2162,FSF 버전과는 별개로 GCC 버전이 지원하고 있는 추가 프로세서들은 다음과 같다:,"{'word': 'FSF 버전', 'start': 1326, 'end': 1331, 'type': 'COM'}","{'word': 'GCC 버전', 'start': 1339, 'end': 1344, 'type': 'COM'}",no_relation
2163,gcj 자바 컴파일러는 순수 기계어 아키텍처나 자바 가상 머신의 자바 바이트코드만을 대상으로 할 수 있다.,"{'word': 'gcj 자바 컴파일러', 'start': 1373, 'end': 1383, 'type': 'COM'}","{'word': '자바 가상 머신', 'start': 1399, 'end': 1406, 'type': 'COM'}",no_relation
2164,새로운 플랫폼으로 GCC의 대상으로 변경할 때에는 bootstrap이 자주 쓰인다.,"{'word': 'GCC', 'start': 1443, 'end': 1445, 'type': 'COM'}","{'word': 'bootstrap', 'start': 1461, 'end': 1469, 'type': 'COM'}",no_relation
2165,리눅스 및 일부 운영 체제용으로 개발된 대부분의 통합 개발 환경은 GCC를 지원한다.,"{'word': '통합 개발 환경', 'start': 1507, 'end': 1514, 'type': 'COM'}","{'word': 'GCC', 'start': 1517, 'end': 1519, 'type': 'COM'}",no_relation
2166,"그러나 나중에 C++, 자바, 포트란, 에이다 등 여러 언어를 컴파일할 수 있게 되면서, 현재의 이름으로 바뀌게 되었다.","{'word': '여러 언어', 'start': 226, 'end': 230, 'type': 'COM'}","{'word': 'C++', 'start': 206, 'end': 208, 'type': 'COM'}",com:similar_tech
2167,"그러나 나중에 C++, 자바, 포트란, 에이다 등 여러 언어를 컴파일할 수 있게 되면서, 현재의 이름으로 바뀌게 되었다.","{'word': '여러 언어', 'start': 226, 'end': 230, 'type': 'COM'}","{'word': '자바', 'start': 211, 'end': 212, 'type': 'COM'}",com:similar_tech
2168,"그러나 나중에 C++, 자바, 포트란, 에이다 등 여러 언어를 컴파일할 수 있게 되면서, 현재의 이름으로 바뀌게 되었다.","{'word': '여러 언어', 'start': 226, 'end': 230, 'type': 'COM'}","{'word': '포트란', 'start': 215, 'end': 217, 'type': 'COM'}",com:similar_tech
2169,"그러나 나중에 C++, 자바, 포트란, 에이다 등 여러 언어를 컴파일할 수 있게 되면서, 현재의 이름으로 바뀌게 되었다.","{'word': '여러 언어', 'start': 226, 'end': 230, 'type': 'COM'}","{'word': '에이다', 'start': 220, 'end': 222, 'type': 'COM'}",com:similar_tech
2170,"또, 이용은 가능하지만 표준에는 포함되지 않은 것으로 파스칼 (codice_6), 머큐리, Modula-2, Modula-3, PL/I, D (codice_7), VHDL (codice_8)가 있다.","{'word': '파스칼 (codice_6)', 'start': 811, 'end': 824, 'type': 'COM'}","{'word': '머큐리', 'start': 827, 'end': 829, 'type': 'COM'}",com:similar_tech
2171,"또, 이용은 가능하지만 표준에는 포함되지 않은 것으로 파스칼 (codice_6), 머큐리, Modula-2, Modula-3, PL/I, D (codice_7), VHDL (codice_8)가 있다.","{'word': '파스칼 (codice_6)', 'start': 811, 'end': 824, 'type': 'COM'}","{'word': 'Modula-2', 'start': 832, 'end': 839, 'type': 'COM'}",com:similar_tech
2172,"또, 이용은 가능하지만 표준에는 포함되지 않은 것으로 파스칼 (codice_6), 머큐리, Modula-2, Modula-3, PL/I, D (codice_7), VHDL (codice_8)가 있다.","{'word': '파스칼 (codice_6)', 'start': 811, 'end': 824, 'type': 'COM'}","{'word': 'Modula-3', 'start': 842, 'end': 849, 'type': 'COM'}",com:similar_tech
2173,"또, 이용은 가능하지만 표준에는 포함되지 않은 것으로 파스칼 (codice_6), 머큐리, Modula-2, Modula-3, PL/I, D (codice_7), VHDL (codice_8)가 있다.","{'word': '파스칼 (codice_6)', 'start': 811, 'end': 824, 'type': 'COM'}","{'word': 'PL/I', 'start': 852, 'end': 855, 'type': 'COM'}",com:similar_tech
2174,"또, 이용은 가능하지만 표준에는 포함되지 않은 것으로 파스칼 (codice_6), 머큐리, Modula-2, Modula-3, PL/I, D (codice_7), VHDL (codice_8)가 있다.","{'word': '파스칼 (codice_6)', 'start': 811, 'end': 824, 'type': 'COM'}","{'word': 'D (codice_7)', 'start': 858, 'end': 869, 'type': 'COM'}",com:similar_tech
2175,"또, 이용은 가능하지만 표준에는 포함되지 않은 것으로 파스칼 (codice_6), 머큐리, Modula-2, Modula-3, PL/I, D (codice_7), VHDL (codice_8)가 있다.","{'word': '파스칼 (codice_6)', 'start': 811, 'end': 824, 'type': 'COM'}","{'word': 'VHDL (codice_8)', 'start': 872, 'end': 886, 'type': 'COM'}",com:similar_tech
2176,GCC는 리처드 스톨만이 1987년 GNU 프로젝트의 컴파일러로 작성했다.,"{'word': '리처드 스톨만', 'start': 271, 'end': 277, 'type': 'PER'}","{'word': 'GCC', 'start': 266, 'end': 268, 'type': 'COM'}",per:production
