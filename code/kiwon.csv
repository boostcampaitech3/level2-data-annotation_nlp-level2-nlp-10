id,sentence,subject_entity,object_entity,label,worker1,worker2
0,"1967년, ""CACM""에 데이크스트라의 ""GOTO문의 해로움""(Go to statement considered harmful)라는 서한이 실렸다.","{'word': '데이크스트라', 'start': 1747, 'end': 1752, 'type': 'PER'}","{'word': '서한', 'start': 1806, 'end': 1807, 'type': 'POH'}",per:production,per:production,per:production
1,데이크스트라의 초창기 가드 명령어 언어같은 어떤 언어에서는 구조를 완전히 둘러싸는 codice_8와 같은 구문으로 구조의 단일성을 강조한다.,"{'word': '데이크스트라', 'start': 476, 'end': 481, 'type': 'PER'}","{'word': '초창기 가드 명령어 언어', 'start': 484, 'end': 496, 'type': 'COM'}",per:production,per:production,per:production
2,"하향식 설계를 할 때, 설계자는 큰 규모의 프로그램을 더 작은 공정으로 나누어 구현하고, 각각 검사한 다음에 전체 프로그램으로 합친다.","{'word': '설계자', 'start': 897, 'end': 899, 'type': 'PER'}","{'word': '하향식 설계', 'start': 884, 'end': 889, 'type': 'COM'}",per:production,per:production,per:production
3,"1967년, ""CACM""에 데이크스트라의 ""GOTO문의 해로움""(Go to statement considered harmful)라는 서한이 실렸다.","{'word': '데이크스트라', 'start': 1747, 'end': 1752, 'type': 'PER'}","{'word': 'GOTO문의 해로움', 'start': 1756, 'end': 1765, 'type': 'COM'}",per:production,per:production,per:production
4,카누스는 좀 더 완화된 구조 제한을 제안했다.,"{'word': '카누스', 'start': 2386, 'end': 2388, 'type': 'PER'}","{'word': '좀 더 완화된 구조 제한', 'start': 2391, 'end': 2403, 'type': 'COM'}",per:production,per:production,per:production
5,"프랭크 루빈은 그 해에 """"GOTO문의 해로움""의 해로움""('Go to statement considered harmful' considered harmful)이라는 글을 썼다.","{'word': '프랭크 루빈', 'start': 2872, 'end': 2877, 'type': 'PER'}","{'word': '""GOTO문의 해로움""의 해로움', 'start': 2886, 'end': 2902, 'type': 'COM'}",per:production,per:production,per:production
6,프로시저가 2개의 종료점을 갖기 때문에 데이크스트라의 구조적 프로그래밍의 규칙에 어긋난다.,"{'word': '데이크스트라', 'start': 3930, 'end': 3935, 'type': 'PER'}","{'word': '구조적 프로그래밍의 규칙', 'start': 3938, 'end': 3950, 'type': 'COM'}",per:production,per:production,per:production
7,"데이크스트라가 쓴 ""GOTO문의 해로움""이라는 논문은 이후 ""...의 해로움""이라는 유행을 낳기도 하였다.","{'word': '데이크스트라', 'start': 4876, 'end': 4881, 'type': 'PER'}","{'word': 'GOTO문의 해로움', 'start': 4887, 'end': 4896, 'type': 'COM'}",per:production,per:production,per:production
8,구조적 프로그램 이론가들은 1970년대 IBM의 연구원 밀즈가 구조적 프로그래밍 이론에 대한 그의 해석을 뉴욕타임즈의 인덱싱 시스템 개발자들에게 적용한 일이 있은 후에 대부분이 합의를 봤다.,"{'word': '밀즈', 'start': 2629, 'end': 2630, 'type': 'PER'}","{'word': 'IBM의 연구원', 'start': 2620, 'end': 2627, 'type': 'POH'}",per:title,per:title,per:title
9,"각각의 상태 변화를 분리하여 하위프로그램을 만들고 변수를 이용하여 활동중인 상태를 나타내면 가능하긴 하다. 하지만, 카누스를 포함한 일부 프로그래머들은 상태의 변화를 새로운 상태로 직접 분기하는 것을 더 좋아한다.","{'word': '카누스', 'start': 4417, 'end': 4419, 'type': 'PER'}","{'word': '프로그래머', 'start': 4429, 'end': 4433, 'type': 'POH'}",per:title,per:title,per:title
10,"이 내용들은 1960년대 후반과 1970년대 초반에 개발되었는데 주로 데이크스트라, 플로이드, 호, 그리즈가 많은 공헌을 했다.","{'word': '데이크스트라', 'start': 1633, 'end': 1638, 'type': 'PER'}","{'word': '플로이드', 'start': 1641, 'end': 1644, 'type': 'PER'}",no_relation,no_relation,no_relation
11,"이 내용들은 1960년대 후반과 1970년대 초반에 개발되었는데 주로 데이크스트라, 플로이드, 호, 그리즈가 많은 공헌을 했다.","{'word': '데이크스트라', 'start': 1633, 'end': 1638, 'type': 'PER'}","{'word': '그리즈', 'start': 1650, 'end': 1652, 'type': 'PER'}",no_relation,no_relation,no_relation
12,루빈은 물론이거니와 양보하라고 한 다른 필자들까지도 날카롭게 비판한 데이크스트라의 응답과 함께 수많은 반대 의견이 뒤따랐다.,"{'word': '루빈', 'start': 2972, 'end': 2973, 'type': 'PER'}","{'word': '다른 필자들', 'start': 2991, 'end': 2996, 'type': 'PER'}",no_relation,no_relation,no_relation
13,"그는 1969년""구조적 프로그래밍에 대한 글""에서 이렇게 썼다.:","{'word': '구조적 프로그래밍에 대한 글', 'start': 2146, 'end': 2160, 'type': 'COM'}","{'word': '1969년', 'start': 2140, 'end': 2144, 'type': 'DAT'}",com:date_of_prod,com:date_of_produced,com:date_of_produced
14,"1974년, 그의 논문, ""GOTO문이 포함된 구조적 프로그래밍""에서 직접적인 분기를 하여 입증가능성을 희생시키지 않으면서도 더 간결하고 효율적인 코드를 작성할 수 있는 몇 가지 예제를 보였다.","{'word': 'GOTO문이 포함된 구조적 프로그래밍', 'start': 2292, 'end': 2311, 'type': 'COM'}","{'word': '1974년', 'start': 2277, 'end': 2281, 'type': 'DAT'}",com:date_of_prod,com:date_of_produced,com:date_of_produced
15,구조적 프로그래밍()은 구조화 프로그래밍으로도 불리며 프로그래밍 패러다임의 일종인 절차적 프로그래밍의 하위 개념으로 볼 수 있다.,"{'word': '절차적 프로그래밍', 'start': 46, 'end': 54, 'type': 'COM'}","{'word': '구조적 프로그래밍', 'start': 0, 'end': 8, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
16,"저수준의 관점에서 구조적 프로그램은 간단하고, 계층적인 프로그램 제어 구조로 구성된다.","{'word': '구조적 프로그램', 'start': 280, 'end': 287, 'type': 'COM'}","{'word': '프로그램 제어 구조', 'start': 301, 'end': 310, 'type': 'COM'}",com:sub_concept,com:made_of,com:made_of
17,"더 간단한 구문들은 또 다른 제어 구조일 수도 있고, 할당문이나 프로시저 호출과 같은 기본 구문일 수도 있다.","{'word': '기본 구문', 'start': 419, 'end': 423, 'type': 'COM'}","{'word': '할당문', 'start': 401, 'end': 403, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
18,"더 간단한 구문들은 또 다른 제어 구조일 수도 있고, 할당문이나 프로시저 호출과 같은 기본 구문일 수도 있다.","{'word': '기본 구문', 'start': 419, 'end': 423, 'type': 'COM'}","{'word': '프로시저 호출', 'start': 407, 'end': 413, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
19,"C 같은 다른 언어들은 구조의 단일성을 강조하지 않는데, 잘못 이해하거나 잘못 수정할 수 있는 위험이 커지는 것은 아니다.","{'word': '언어', 'start': 563, 'end': 564, 'type': 'COM'}","{'word': 'C', 'start': 555, 'end': 555, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
20,"코드 작성자는 큰 조각의 코드를 이해하기 쉬운 크기의 작은 하부 프로그램(함수, 프로시저, 메서드, 블록, 등)으로 나누어야 한다.","{'word': '큰 조각의 코드', 'start': 632, 'end': 639, 'type': 'COM'}","{'word': '하부 프로그램', 'start': 657, 'end': 663, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
21,"코드 작성자는 큰 조각의 코드를 이해하기 쉬운 크기의 작은 하부 프로그램(함수, 프로시저, 메서드, 블록, 등)으로 나누어야 한다.","{'word': '하부 프로그램', 'start': 657, 'end': 663, 'type': 'COM'}","{'word': '함수, 프로시저, 메서드, 블록', 'start': 665, 'end': 681, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
22,"하향식 설계를 할 때, 설계자는 큰 규모의 프로그램을 더 작은 공정으로 나누어 구현하고, 각각 검사한 다음에 전체 프로그램으로 합친다.","{'word': '전체 프로그램', 'start': 945, 'end': 951, 'type': 'COM'}","{'word': '더 작은 공정', 'start': 914, 'end': 920, 'type': 'COM'}",com:sub_concept,com:made_of,com:made_of
23,"모든 절차적 프로그래밍 언어에서 구조적 프로그래밍을 할 수 있다. 1970년쯤부터 구조적 프로그래밍이 인기있는 기법이 되었기 때문에, 대부분의 새로 나온 절차적 프로그래밍 언어들이 구조적 프로그래밍을 고취시키기 위한 특징을 추가하였고 구조화되지 않은 프로그래밍을 쉽게 하기 위한 특징들은 남겨둔 것들도 있었다.","{'word': '절차적 프로그래밍 언어', 'start': 963, 'end': 974, 'type': 'COM'}","{'word': '구조적 프로그래밍', 'start': 978, 'end': 986, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
24,잘 알려진 구조적 프로그래밍 언어에는 파스칼(Pascal)과 에이다(Ada)가 있다.,"{'word': '구조적 프로그래밍 언어', 'start': 1140, 'end': 1151, 'type': 'COM'}","{'word': '파스칼', 'start': 1155, 'end': 1157, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
25,잘 알려진 구조적 프로그래밍 언어에는 파스칼(Pascal)과 에이다(Ada)가 있다.,"{'word': '구조적 프로그래밍 언어', 'start': 1140, 'end': 1151, 'type': 'COM'}","{'word': '에이다', 'start': 1168, 'end': 1170, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
26,"이런 점은 구조적 프로그래밍 운동에서 나온 것은 아니지만, 이런 구조들은 중앙 처리 장치의 명령 주기뿐만 아니라 튜링 기계의 동작을 설명하는 데 충분하다.","{'word': '중앙 처리 장치', 'start': 1325, 'end': 1332, 'type': 'COM'}","{'word': '명령 주기', 'start': 1335, 'end': 1339, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
27,"이 글에서 그는 뵘과 야코피니의 증명을 인용하면서, 고급언어에서 GOTO 명령을 제거하는 것이 코드의 질을 높일 수 있다고 했다.","{'word': '고급언어', 'start': 1844, 'end': 1847, 'type': 'COM'}","{'word': 'GOTO 명령', 'start': 1851, 'end': 1857, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
28,"그것은 프로그램의 순서도를 그린다면 왼쪽에는 아래쪽으로 가는 가지(branches)만, 오른쪽에는 위쪽으로 가는 가지만 그려야하며 그 가지들이 서로 교차하지 않아야 한다는 것이다.","{'word': '프로그램의 순서도', 'start': 2416, 'end': 2424, 'type': 'COM'}","{'word': '가지', 'start': 2446, 'end': 2447, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
29,"포트란, 코볼, 베이직과 같이 프로그래밍 구조가 원래 취약한 고급 프로그래밍 언어들은 이제 그런 구조를 가지고 있다.","{'word': '고급 프로그래밍 언어', 'start': 3146, 'end': 3156, 'type': 'COM'}","{'word': '포트란', 'start': 3112, 'end': 3114, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
30,"포트란, 코볼, 베이직과 같이 프로그래밍 구조가 원래 취약한 고급 프로그래밍 언어들은 이제 그런 구조를 가지고 있다.","{'word': '고급 프로그래밍 언어', 'start': 3146, 'end': 3156, 'type': 'COM'}","{'word': '코볼', 'start': 3117, 'end': 3118, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
31,"포트란, 코볼, 베이직과 같이 프로그래밍 구조가 원래 취약한 고급 프로그래밍 언어들은 이제 그런 구조를 가지고 있다.","{'word': '고급 프로그래밍 언어', 'start': 3146, 'end': 3156, 'type': 'COM'}","{'word': '베이직', 'start': 3121, 'end': 3123, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
32,"프로그래머가 경험을 쌓을수록 엄격한 의미의 구조적 프로그래밍을 침해하는 어떤 부분이 있는지를 이해하기가 쉽다는 것을 알았고, 널리 퍼진 몇몇 프로그래밍 언어들은 직접적인 분기문을 제한하고 있으며 예외처리를 이런 상황에서 사용할 수 있게 하고 있다.","{'word': '프로그래밍 언어들', 'start': 3305, 'end': 3313, 'type': 'COM'}","{'word': '예외처리', 'start': 3335, 'end': 3338, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
33,주요한 산업용 언어들은 자바와 같은 언어들을 제외하고는 프로시저 내에서의 직접 분기를 위하여 GOTO문을 여전히 유지하고 있다.,"{'word': '산업용 언어들', 'start': 3369, 'end': 3375, 'type': 'COM'}","{'word': 'GOTO문', 'start': 3417, 'end': 3421, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
34,"C는 continue, break, return과 같이 여러가지 경로로 구조에서 빠져나가는 것을 허용하고, 더 새로운 언어들은 레이블한 루프(전자와 비슷하지만 제일 안쪽 루프 뿐만 아니라 그 이상도 빠져나갈 수 있게 해 준다)와 예외처리를 지원한다.","{'word': '더 새로운 언어들', 'start': 4217, 'end': 4225, 'type': 'COM'}","{'word': '레이블한 루프', 'start': 4228, 'end': 4234, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
35,"C는 continue, break, return과 같이 여러가지 경로로 구조에서 빠져나가는 것을 허용하고, 더 새로운 언어들은 레이블한 루프(전자와 비슷하지만 제일 안쪽 루프 뿐만 아니라 그 이상도 빠져나갈 수 있게 해 준다)와 예외처리를 지원한다.","{'word': '더 새로운 언어들', 'start': 4217, 'end': 4225, 'type': 'COM'}","{'word': '예외처리', 'start': 4285, 'end': 4288, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
36,특히 구문분석기와 통신 규약 같은 프로그램들은 상태들이 있어서 기본 구조들로 줄이기가 쉽지 않다.,"{'word': '통신 규약', 'start': 4307, 'end': 4311, 'type': 'COM'}","{'word': '상태들', 'start': 4323, 'end': 4325, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
37,구조적 프로그래밍()은 구조화 프로그래밍으로도 불리며 프로그래밍 패러다임의 일종인 절차적 프로그래밍의 하위 개념으로 볼 수 있다.,"{'word': '구조적 프로그래밍', 'start': 0, 'end': 8, 'type': 'COM'}","{'word': '구조화 프로그래밍', 'start': 13, 'end': 21, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
38,잘 알려진 구조적 프로그래밍 언어에는 파스칼(Pascal)과 에이다(Ada)가 있다.,"{'word': '파스칼', 'start': 1155, 'end': 1157, 'type': 'COM'}","{'word': 'Pascal', 'start': 1159, 'end': 1164, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
39,잘 알려진 구조적 프로그래밍 언어에는 파스칼(Pascal)과 에이다(Ada)가 있다.,"{'word': '에이다', 'start': 1168, 'end': 1170, 'type': 'COM'}","{'word': 'Ada', 'start': 1172, 'end': 1174, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
40,구조적 프로그래밍의 선구적 실천가(얼리어답터)인 플로저는 구조적 프로그램 정리에 대한 그의 반응을 이렇게 설명했다.:,"{'word': '선구적 실천가', 'start': 1677, 'end': 1683, 'type': 'COM'}","{'word': '얼리어답터', 'start': 1685, 'end': 1689, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
41,"1967년, ""CACM""에 데이크스트라의 ""GOTO문의 해로움""(Go to statement considered harmful)라는 서한이 실렸다.","{'word': 'Go to statement considered harmful', 'start': 1768, 'end': 1801, 'type': 'COM'}","{'word': 'GOTO문의 해로움', 'start': 1756, 'end': 1765, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
42,컴파일러와 그래프 이론에 정통해 있는 많은 사람들이 축소 가능한 흐름도(reducible flow graphs)만을 허용해야한다고 이 생각을 옹호했다.,"{'word': '축소 가능한 흐름도', 'start': 2542, 'end': 2551, 'type': 'COM'}","{'word': 'reducible flow graphs', 'start': 2553, 'end': 2573, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
43,역사적으로 구조적 프로그램을 작성하기 위하여 몇가지 다른 구조화 기법과 방법론이 개발되어왔다.,"{'word': '구조적 프로그램', 'start': 124, 'end': 131, 'type': 'COM'}","{'word': '구조화 기법과 방법론', 'start': 150, 'end': 160, 'type': 'COM'}",com:made_of,com:prior_technology,com:prior_technology
44,구조적 프로그램 정리는 구조적 프로그래밍의 이론적 기반이 되었다.,"{'word': '구조적 프로그래밍', 'start': 1195, 'end': 1203, 'type': 'COM'}","{'word': '구조적 프로그램 정리', 'start': 1182, 'end': 1192, 'type': 'COM'}",com:made_of,com:prior_technology,com:prior_technology
45,"정리에 따르면, 프로그램을 결합하는 3가지 방법인 순차, 분기, 반복만으로 충분히 계산가능 함수를 표현할 수 있다.","{'word': '계산가능 함수', 'start': 1265, 'end': 1271, 'type': 'COM'}","{'word': '순차, 분기, 반복', 'start': 1247, 'end': 1256, 'type': 'COM'}",com:made_of,com:made_of,com:made_of
46,"구조적 프로그래밍에 대한 논의는 많은 새로운 언어를 낳았으며, 기존의 언어에 구조적인 면이 추가되는 등 언어의 발전에 도움이 되었다. 그리고 이후에 나온 프로그래밍 패러다임들에도 영향을 끼쳤다.","{'word': '프로그래밍 패러다임', 'start': 4558, 'end': 4567, 'type': 'COM'}","{'word': '구조적 프로그래밍에 대한 논의', 'start': 4472, 'end': 4487, 'type': 'COM'}",com:prior_tech,com:prior_technology,com:prior_technology
47,GOTO문을 없애거나 GOTO문에 대한 의존성을 줄여주는 것으로 가장 유명하다.,"{'word': 'GOTO문', 'start': 85, 'end': 89, 'type': 'COM'}","{'word': '의존성', 'start': 95, 'end': 97, 'type': 'COM'}",no_relation,no_relation,no_relation
48,"일반적으로 프로그램은 전역 변수는 거의 사용하지 않아야 하고 대신에 하부 프로그램은 지역 변수를 사용하거나, 값이나 참조에 의한 인자를 받아야 한다.","{'word': '지역 변수', 'start': 745, 'end': 749, 'type': 'COM'}","{'word': '전역 변수', 'start': 710, 'end': 714, 'type': 'COM'}",no_relation,no_relation,no_relation
49,"이런 기법은 전체 프로그램을 한번에 이해하지 않고, 분리된 작은 코드 조각을 쉽게 이해하는 데 도움을 준다.","{'word': '분리된 작은 코드 조각', 'start': 811, 'end': 822, 'type': 'COM'}","{'word': '기법', 'start': 785, 'end': 786, 'type': 'COM'}",no_relation,no_relation,no_relation
50,구조적 프로그래밍은 항상 그런 것은 아니지만 하향식 설계와 관련이 있다.,"{'word': '구조적 프로그래밍', 'start': 843, 'end': 851, 'type': 'COM'}","{'word': '하향식 설계', 'start': 868, 'end': 873, 'type': 'COM'}",no_relation,com:similar_technology,com:similar_technology
51,"따라서 이런 의미에서 프로세서는 항상 ""구조적 프로그램""을 실행한다.","{'word': '구조적 프로그램', 'start': 1393, 'end': 1400, 'type': 'COM'}","{'word': '프로세서', 'start': 1383, 'end': 1386, 'type': 'COM'}",no_relation,no_relation,no_relation
52,구조적 프로그램이 아닌 기억 장치의 다른 부분에서 읽는 명령을 수행해도 그러하다.,"{'word': '구조적 프로그램', 'start': 1410, 'end': 1417, 'type': 'COM'}","{'word': '기억 장치', 'start': 1423, 'end': 1427, 'type': 'COM'}",no_relation,no_relation,no_relation
53,"비록 플로저가 언급했듯이 다수의 프로그래머들이 이 정리에 익숙하지 않다고 해도, 이런 프로그래머들을 양성할 가치가 충분히 있을 정도로 몇 년간 소프트웨어 개발은 간결성, 품질, 개발 시간의 측면에서 향상되었다.","{'word': '소프트웨어 개발', 'start': 2002, 'end': 2009, 'type': 'COM'}","{'word': '프로그래머', 'start': 1970, 'end': 1974, 'type': 'COM'}",no_relation,no_relation,no_relation
54,도널드 커누스(Donald Knuth)는 프로그램이 입증가능성을 염두에 두고 작성되어야 한다는 원리는 받아들였으나 GOTO문을 없애는 것은 받아들이지 않았고 지금도 받아들이지 않는다.,"{'word': '프로그램', 'start': 2197, 'end': 2200, 'type': 'COM'}","{'word': 'GOTO문', 'start': 2238, 'end': 2242, 'type': 'COM'}",no_relation,no_relation,no_relation
55,1987년이 되어서도 여전히 컴퓨터 과학 간행물에서 구조적 프로그래밍에 대해 의문점이 제기되었다.,"{'word': '구조적 프로그래밍', 'start': 2846, 'end': 2854, 'type': 'COM'}","{'word': '컴퓨터 과학 간행물', 'start': 2833, 'end': 2842, 'type': 'COM'}",no_relation,no_relation,no_relation
56,"20세기의 막바지에 이르자, 대부분의 컴퓨터 과학자들은 구조적 프로그래밍의 개념을 배우고 적용하는 것은 유용하다고 확신했다.","{'word': '컴퓨터 과학자', 'start': 3063, 'end': 3069, 'type': 'COM'}","{'word': '구조적 프로그래밍', 'start': 3073, 'end': 3081, 'type': 'COM'}",no_relation,no_relation,no_relation
57,"대부분의 경우에 하위프로그램에 여러 개의 시작점이 있는 것은 아니지만, 여러 개의 종료점을 가지는 경우는 있다.","{'word': '시작점', 'start': 3552, 'end': 3554, 'type': 'COM'}","{'word': '종료점', 'start': 3575, 'end': 3577, 'type': 'COM'}",no_relation,no_relation,no_relation
58,다음은 파일에서 자료를 읽어서 처리하는 간단한 프로시저의 전형적인 예이다:,"{'word': '프로시저', 'start': 3667, 'end': 3670, 'type': 'COM'}","{'word': '파일', 'start': 3645, 'end': 3646, 'type': 'COM'}",no_relation,no_relation,no_relation
59,"에러 상황이 더 있다면, 청소 규칙이 서로 달라서, 오히려 goto문을 사용한 비구조적인 것보다 훨씬 읽거나 이해하기 어렵게 될 것이다.","{'word': '에러 상황', 'start': 3990, 'end': 3994, 'type': 'COM'}","{'word': '청소 규칙', 'start': 4004, 'end': 4008, 'type': 'COM'}",no_relation,no_relation,no_relation
60,반면에 그런 규칙을 따르지 않는 구조적 프로그래밍은 코드를 아주 깔끔하고 읽기 쉽게 할 것이다.,"{'word': '코드', 'start': 4096, 'end': 4097, 'type': 'COM'}","{'word': '구조적 프로그래밍', 'start': 4085, 'end': 4093, 'type': 'COM'}",no_relation,no_relation,no_relation
61,구조적 프로그래밍은 프로그래머의 습관을 바꾸었다.,"{'word': '구조적 프로그래밍', 'start': 4581, 'end': 4589, 'type': 'COM'}","{'word': '프로그래머', 'start': 4592, 'end': 4596, 'type': 'COM'}",no_relation,no_relation,no_relation
62,프로그램의 정확성을 증명하는 문제를 떠나서 데이크스트라가 그의 논문에서 말한 대로 시간에 따라 변하는 동적인 과정을 시각화하는 것은 인간에게 매우 어려운 일이다.,"{'word': '프로그램', 'start': 4609, 'end': 4612, 'type': 'COM'}","{'word': '시각화', 'start': 4674, 'end': 4676, 'type': 'COM'}",no_relation,no_relation,no_relation
63,꼭 GOTO문만의 문제가 아니라 구조화된 흐름 제어문을 사용한다고 할지라도 너무 복잡하게 중첩되어 있거나 스코프의 길이가 너무 긴 코드를 작성한다거나 너무 긴 길이의 하위프로그램을 작성하는 일을 가급적 피하게 경향이 생겼다.,"{'word': '구조화된 흐름 제어문', 'start': 4718, 'end': 4728, 'type': 'COM'}","{'word': '하위프로그램', 'start': 4793, 'end': 4798, 'type': 'COM'}",no_relation,no_relation,no_relation
64,데이크스트라가 구조적 프로그래밍을 표준 교육과정에 편입시키는 데는 성공했지만 엄격한 조건을 고수하는 데는 성공하지 못하였다.,"{'word': '데이크스트라', 'start': 3437, 'end': 3442, 'type': 'PER'}","{'word': '표준 교육과정', 'start': 3456, 'end': 3462, 'type': 'POH'}",no_relation,no_relation,no_relation
65,"에츠허르 데이크스트라가 확인한 3가지 형태의 구조는 순차, 선택, 반복이다.","{'word': '에츠허르 데이크스트라', 'start': 433, 'end': 443, 'type': 'PER'}","{'word': '구조', 'start': 458, 'end': 459, 'type': 'COM'}",no_relation,no_relation,no_relation
66,"데이크스트라는 구조의 종류를 제한하는 것이 프로그래머가 생각하는 데 집중하는 것을 돕고, 관리 가능한 절차로 분석하여 프로그램의 유효성을 더 간단히 보장할 수 있다고 했다.","{'word': '데이크스트라', 'start': 2040, 'end': 2045, 'type': 'PER'}","{'word': '프로그래머', 'start': 2064, 'end': 2068, 'type': 'COM'}",no_relation,no_relation,no_relation
67,GOTO문 제멋대로 사용하는 것을 받아들이는 프로그래밍 교육자들은 찾기가 힘들어졌다.,"{'word': '프로그래밍 교육자', 'start': 3203, 'end': 3211, 'type': 'PER'}","{'word': 'GOTO문', 'start': 3178, 'end': 3182, 'type': 'COM'}",no_relation,no_relation,no_relation
68,"데이크스트라가 밀즈의 해석이 출판된 것들과 다르다며 비판하였지만, 다른 회사의 관리자들까지도 구조적 프로그래밍의 채택을 지원하기 위하여 밀즈의 해석을 인용했다.","{'word': '데이크스트라', 'start': 2727, 'end': 2732, 'type': 'PER'}","{'word': '밀즈', 'start': 2735, 'end': 2736, 'type': 'PER'}",no_relation,no_relation,no_relation
69,"이 제어 구조들은 하나의 구문으로 간주되며, 동시에 더 간단한 구문들을 결합시키는 방법이다.","{'word': '제어 구조들', 'start': 321, 'end': 326, 'type': 'COM'}","{'word': '하나의 구문', 'start': 329, 'end': 334, 'type': 'COM'}",com:similar_tech,com:alternative_names,com:alternative_names
70,"포트란, 코볼, 베이직과 같이 프로그래밍 구조가 원래 취약한 고급 프로그래밍 언어들은 이제 그런 구조를 가지고 있다.","{'word': '포트란', 'start': 3112, 'end': 3114, 'type': 'COM'}","{'word': '코볼', 'start': 3117, 'end': 3118, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
71,"포트란, 코볼, 베이직과 같이 프로그래밍 구조가 원래 취약한 고급 프로그래밍 언어들은 이제 그런 구조를 가지고 있다.","{'word': '포트란', 'start': 3112, 'end': 3114, 'type': 'COM'}","{'word': '베이직', 'start': 3121, 'end': 3123, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
72,새로운 언어를 만들려는 의의는 박사 논문을 위한 스트롭스트룹의 프로그래밍 경험에서 비롯되었다.,"{'word': '스트롭스트룹', 'start': 170, 'end': 175, 'type': 'PER'}","{'word': '박사 논문', 'start': 160, 'end': 164, 'type': 'POH'}",per:production,per:production,per:production
73,C++는 AT&amp;T 벨 연구소의 비야네 스트롭스트룹이 C언어 기반으로 1983년 발표하여 발전한 프로그래밍 언어이다.,"{'word': '비야네 스트롭스트룹', 'start': 21, 'end': 30, 'type': 'PER'}","{'word': 'C++', 'start': 0, 'end': 2, 'type': 'COM'}",per:production,per:production,per:production
74,"1979년, 덴마크의 컴퓨터 과학자 비야네 스트롭스트룹은 C++의 선구자격 언어인 ""C with Classes"" 작업에 착수하였다.","{'word': '비야네 스트롭스트룹', 'start': 89, 'end': 98, 'type': 'PER'}","{'word': 'C with Classes', 'start': 116, 'end': 129, 'type': 'COM'}",per:production,per:production,per:production
75,"1979년, 덴마크의 컴퓨터 과학자 비야네 스트롭스트룹은 C++의 선구자격 언어인 ""C with Classes"" 작업에 착수하였다.","{'word': '비야네 스트롭스트룹', 'start': 89, 'end': 98, 'type': 'PER'}","{'word': '컴퓨터 과학자', 'start': 81, 'end': 87, 'type': 'POH'}",per:title,per:title,per:title
76,C++는 AT&amp;T 벨 연구소의 비야네 스트롭스트룹이 C언어 기반으로 1983년 발표하여 발전한 프로그래밍 언어이다.,"{'word': '벨 연구소', 'start': 14, 'end': 18, 'type': 'ORG'}","{'word': 'C++', 'start': 0, 'end': 2, 'type': 'COM'}",org:production,org:production,org:production
77,C++는 AT&amp;T 벨 연구소의 비야네 스트롭스트룹이 C언어 기반으로 1983년 발표하여 발전한 프로그래밍 언어이다.,"{'word': 'C++', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': '1983년', 'start': 42, 'end': 46, 'type': 'DAT'}",com:date_of_prod,com:date_of_produced,com:date_of_produced
78,"1979년, 덴마크의 컴퓨터 과학자 비야네 스트롭스트룹은 C++의 선구자격 언어인 ""C with Classes"" 작업에 착수하였다.","{'word': 'C with Classes', 'start': 116, 'end': 129, 'type': 'COM'}","{'word': '1979년', 'start': 69, 'end': 73, 'type': 'DAT'}",com:date_of_prod,com:date_of_produced,com:date_of_produced
79,"1983년, ""C with Classes""라는 이름은 가상 함수, 함수 이름, 연산자 오버로딩, 참조, 제약조건, type-safe free-store 메모리 할당 (new/delete), 개선된 자료형 검사, BCPL 스타일의 1줄 코멘트(//)를 포함한 새로운 기능들을 추가하면서 ""C++""로 변경되었다.","{'word': 'C++', 'start': 456, 'end': 458, 'type': 'COM'}","{'word': '1983년', 'start': 296, 'end': 300, 'type': 'DAT'}",com:date_of_prod,com:date_of_produced,com:date_of_produced
80,1985년 C++ 프로그래밍 언어 제1판이 출시되었으며 당시 공식표준이 없었기 때문에 이 언어의 절대적인 참조 문헌이 되었다.,"{'word': 'C++ 프로그래밍 언어 제1판', 'start': 475, 'end': 490, 'type': 'COM'}","{'word': '1985년', 'start': 469, 'end': 473, 'type': 'DAT'}",com:date_of_prod,com:date_of_produced,com:date_of_produced
81,최초의 C++ 상용 구현체는 같은 해 10월에 출시되었다.,"{'word': '최초의 C++ 상용 구현체', 'start': 540, 'end': 553, 'type': 'COM'}","{'word': '같은 해 10월', 'start': 556, 'end': 563, 'type': 'DAT'}",com:date_of_prod,com:date_of_produced,com:date_of_produced
82,C++는 AT&amp;T 벨 연구소의 비야네 스트롭스트룹이 C언어 기반으로 1983년 발표하여 발전한 프로그래밍 언어이다.,"{'word': '프로그래밍 언어', 'start': 57, 'end': 64, 'type': 'COM'}","{'word': 'C++', 'start': 0, 'end': 2, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
83,"처음에 스트롭스트룹의 ""C with Classes""는 C 컴파일러(Cpre)에 클래스, 상속 클래스, 스트롱 타이핑, 인라인 확장, 기본 인수를 포함한 여러 기능들을 추가하였다.","{'word': 'C with Classes', 'start': 209, 'end': 222, 'type': 'COM'}","{'word': '상속 클래스', 'start': 245, 'end': 250, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
84,"1983년, ""C with Classes""라는 이름은 가상 함수, 함수 이름, 연산자 오버로딩, 참조, 제약조건, type-safe free-store 메모리 할당 (new/delete), 개선된 자료형 검사, BCPL 스타일의 1줄 코멘트(//)를 포함한 새로운 기능들을 추가하면서 ""C++""로 변경되었다.","{'word': 'C++', 'start': 456, 'end': 458, 'type': 'COM'}","{'word': '가상 함수', 'start': 326, 'end': 330, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
85,"1983년, ""C with Classes""라는 이름은 가상 함수, 함수 이름, 연산자 오버로딩, 참조, 제약조건, type-safe free-store 메모리 할당 (new/delete), 개선된 자료형 검사, BCPL 스타일의 1줄 코멘트(//)를 포함한 새로운 기능들을 추가하면서 ""C++""로 변경되었다.","{'word': 'C++', 'start': 456, 'end': 458, 'type': 'COM'}","{'word': '오버로딩', 'start': 344, 'end': 347, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
86,"그 후, C 언어의 표준 규격이 바뀔 때 const 수식 등 C++의 기능이 C 언어에 받아들이기도 했다.","{'word': 'C++', 'start': 837, 'end': 839, 'type': 'COM'}","{'word': 'const 수식', 'start': 826, 'end': 833, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
87,"처음에 스트롭스트룹의 ""C with Classes""는 C 컴파일러(Cpre)에 클래스, 상속 클래스, 스트롱 타이핑, 인라인 확장, 기본 인수를 포함한 여러 기능들을 추가하였다.","{'word': 'C 컴파일러', 'start': 226, 'end': 231, 'type': 'COM'}","{'word': 'Cpre', 'start': 233, 'end': 236, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
88,"1983년, ""C with Classes""라는 이름은 가상 함수, 함수 이름, 연산자 오버로딩, 참조, 제약조건, type-safe free-store 메모리 할당 (new/delete), 개선된 자료형 검사, BCPL 스타일의 1줄 코멘트(//)를 포함한 새로운 기능들을 추가하면서 ""C++""로 변경되었다.","{'word': 'C with Classes', 'start': 304, 'end': 317, 'type': 'COM'}","{'word': 'C++', 'start': 456, 'end': 458, 'type': 'COM'}",com:alter_names,no_relation,no_relation
89,초기의 C++은 C 위에 놓인 트랜스레이터로 구현되었다.,"{'word': 'C++', 'start': 693, 'end': 695, 'type': 'COM'}","{'word': '트랜스레이터', 'start': 706, 'end': 711, 'type': 'COM'}",com:made_of,com:made_of,com:made_of
90,C++는 AT&amp;T 벨 연구소의 비야네 스트롭스트룹이 C언어 기반으로 1983년 발표하여 발전한 프로그래밍 언어이다.,"{'word': 'C++', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': 'C', 'start': 33, 'end': 33, 'type': 'COM'}",com:prior_tech,com:prior_technology,com:prior_technology
91,"1979년, 덴마크의 컴퓨터 과학자 비야네 스트롭스트룹은 C++의 선구자격 언어인 ""C with Classes"" 작업에 착수하였다.","{'word': 'C++', 'start': 101, 'end': 103, 'type': 'COM'}","{'word': 'C with Classes', 'start': 116, 'end': 129, 'type': 'COM'}",com:prior_tech,com:prior_technology,com:prior_technology
92,"즉, C++ 프로그램을 일단 C 프로그램으로 변환하고 나서 C 컴파일러로 컴파일하는 식이었고 따라서 C 언어에 대해 상위 호환성을 갖는 언어였다.","{'word': 'C++ 프로그램', 'start': 724, 'end': 731, 'type': 'COM'}","{'word': 'C 프로그램', 'start': 737, 'end': 742, 'type': 'COM'}",com:prior_tech,no_relation,no_relation
93,"C 언어에 객체지향 프로그래밍을 지원하기 위한 내용이 덧붙여진 것이라고 할 수도 있지만, 애초부터 객체지향을 염두에 두고 만들어진 언어와는 다르게, 단지 더 좋은 C 언어로서 수속형 언어로 취급하기도 한다.","{'word': '수속형 언어', 'start': 671, 'end': 676, 'type': 'COM'}","{'word': '객체지향', 'start': 628, 'end': 631, 'type': 'COM'}",no_relation,no_relation,no_relation
94,자바 가상 머신은 설계자인 제임스 고슬링()에 따르면 UCSD 파스칼의 p-코드()와 스몰토크 VM에 영향을 받았다고 한다.,"{'word': '제임스 고슬링', 'start': 360, 'end': 366, 'type': 'PER'}","{'word': '자바 가상 머신', 'start': 345, 'end': 352, 'type': 'COM'}",per:production,per:production,per:production
95,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '운영 체제 개발사', 'start': 2337, 'end': 2345, 'type': 'ORG'}","{'word': '자바 VM', 'start': 2385, 'end': 2389, 'type': 'COM'}",org:production,org:production,org:production
96,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': 'GNU', 'start': 2397, 'end': 2399, 'type': 'ORG'}","{'word': '오픈 소스 자바 가상 머신', 'start': 2489, 'end': 2502, 'type': 'COM'}",org:production,org:production,org:production
97,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '아파치 소프트웨어 재단', 'start': 2407, 'end': 2418, 'type': 'ORG'}","{'word': '오픈 소스 자바 가상 머신', 'start': 2489, 'end': 2502, 'type': 'COM'}",org:production,org:production,org:production
98,이러한 공개 소프트웨어 단체의 움직임에 따라 썬 마이크로시스템즈에서도 자사의 자바 가상 머신 및 개발 도구 킷을 오픈 소스 정책에 맞추어 공개한 상황이다.,"{'word': '썬 마이크로시스템즈', 'start': 2536, 'end': 2545, 'type': 'ORG'}","{'word': '자바 가상 머신', 'start': 2554, 'end': 2561, 'type': 'COM'}",org:production,org:production,org:production
99,이러한 공개 소프트웨어 단체의 움직임에 따라 썬 마이크로시스템즈에서도 자사의 자바 가상 머신 및 개발 도구 킷을 오픈 소스 정책에 맞추어 공개한 상황이다.,"{'word': '썬 마이크로시스템즈', 'start': 2536, 'end': 2545, 'type': 'ORG'}","{'word': '개발 도구 킷', 'start': 2565, 'end': 2571, 'type': 'COM'}",org:production,org:production,org:production
100,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다. 이러한 공개 소프트웨어 단체의 움직임에 따라 썬 마이크로시스템즈에서도 자사의 자바 가상 머신 및 개발 도구 킷을 오픈 소스 정책에 맞추어 공개한 상황이다.","{'word': '공개 소프트웨어 단체', 'start': 2515, 'end': 2525, 'type': 'ORG'}","{'word': 'GNU', 'start': 2397, 'end': 2399, 'type': 'ORG'}",no_relation,no_relation,no_relation
101,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다. 이러한 공개 소프트웨어 단체의 움직임에 따라 썬 마이크로시스템즈에서도 자사의 자바 가상 머신 및 개발 도구 킷을 오픈 소스 정책에 맞추어 공개한 상황이다.","{'word': '공개 소프트웨어 단체', 'start': 2515, 'end': 2525, 'type': 'ORG'}","{'word': '아파치 소프트웨어 재단', 'start': 2407, 'end': 2418, 'type': 'ORG'}",no_relation,no_relation,no_relation
102,"자바 가상 머신은 이 두 가상 머신처럼 스택 기반이어서 대다수의 명령어가 스택 선두에서 피연산자를 택하고 결과는 다시 스택에 넣는다. 스택 상의 피연산자 타입을 구분하고 명령어에 스택 상의 피연산자 타입을 기술하는 면에서는 p-코드와 유사하며 실제 구조에는 차이가 있지만 가비지 컬렉션을 사용하고 객체와 메서드 호출 개념이 있다는 점에서는 스몰토크 가상 머신과 영향을 받았다고 볼 수 있다. 하지만 p-코드가 타입 안전성을 담보하지 못해 메모리 내용을 망가뜨릴 수 있다는 점, 그리고 스몰토크 가상 머신이 동적 타입을 사용하는 스몰토크 언어 자체와 마찬가지로 타입 구분을 하지 않는다는 점에서는 자바 가상 머신과 다르다.","{'word': '자바 가상 머신', 'start': 415, 'end': 422, 'type': 'COM'}","{'word': '가비지 컬렉션', 'start': 567, 'end': 573, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
103,"자바 가상 머신은 이 두 가상 머신처럼 스택 기반이어서 대다수의 명령어가 스택 선두에서 피연산자를 택하고 결과는 다시 스택에 넣는다. 스택 상의 피연산자 타입을 구분하고 명령어에 스택 상의 피연산자 타입을 기술하는 면에서는 p-코드와 유사하며 실제 구조에는 차이가 있지만 가비지 컬렉션을 사용하고 객체와 메서드 호출 개념이 있다는 점에서는 스몰토크 가상 머신과 영향을 받았다고 볼 수 있다. 하지만 p-코드가 타입 안전성을 담보하지 못해 메모리 내용을 망가뜨릴 수 있다는 점, 그리고 스몰토크 가상 머신이 동적 타입을 사용하는 스몰토크 언어 자체와 마찬가지로 타입 구분을 하지 않는다는 점에서는 자바 가상 머신과 다르다.","{'word': '자바 가상 머신', 'start': 415, 'end': 422, 'type': 'COM'}","{'word': '메서드 호출 개념', 'start': 585, 'end': 593, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
104,특히 자바 가상 머신 위에서 동적인 스크립트 언어가 널리 쓰이게 되면서 자바(프로그래밍 언어)에서는 동적 타입 언어()를 지원하기 위한 추가 명령과 API가 추가되었다.,"{'word': '프로그래밍 언어', 'start': 1049, 'end': 1056, 'type': 'COM'}","{'word': '자바', 'start': 1046, 'end': 1047, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
105,특히 자바 가상 머신 위에서 동적인 스크립트 언어가 널리 쓰이게 되면서 자바(프로그래밍 언어)에서는 동적 타입 언어()를 지원하기 위한 추가 명령과 API가 추가되었다.,"{'word': '자바', 'start': 1046, 'end': 1047, 'type': 'COM'}","{'word': 'API', 'start': 1089, 'end': 1091, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
106,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'JVM 바이트코드 대 자바스크립트 컴파일러', 'start': 1412, 'end': 1434, 'type': 'COM'}","{'word': 'TeaVM', 'start': 1438, 'end': 1442, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
107,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'JVM 바이트코드 대 자바스크립트 컴파일러', 'start': 1412, 'end': 1434, 'type': 'COM'}","{'word': 'Dragome Web SDK에 포함된 컴파일러', 'start': 1445, 'end': 1469, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
108,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'JVM 바이트코드 대 자바스크립트 컴파일러', 'start': 1412, 'end': 1434, 'type': 'COM'}","{'word': 'Bck2Brwsr', 'start': 1472, 'end': 1480, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
109,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'JVM 바이트코드 대 자바스크립트 컴파일러', 'start': 1412, 'end': 1434, 'type': 'COM'}","{'word': 'j2js-compiler', 'start': 1483, 'end': 1495, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
110,"참고로 자바 플랫폼은 자바 SE, 자바 EE, 자바 ME, 자바 카드로 구분되나 자바 가상 머신 규격은 이 분류와 일치하지는 않는다.","{'word': '자바 플랫폼', 'start': 1544, 'end': 1549, 'type': 'COM'}","{'word': '자바 SE', 'start': 1552, 'end': 1556, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
111,"참고로 자바 플랫폼은 자바 SE, 자바 EE, 자바 ME, 자바 카드로 구분되나 자바 가상 머신 규격은 이 분류와 일치하지는 않는다.","{'word': '자바 플랫폼', 'start': 1544, 'end': 1549, 'type': 'COM'}","{'word': '자바 EE', 'start': 1559, 'end': 1563, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
112,"참고로 자바 플랫폼은 자바 SE, 자바 EE, 자바 ME, 자바 카드로 구분되나 자바 가상 머신 규격은 이 분류와 일치하지는 않는다.","{'word': '자바 플랫폼', 'start': 1544, 'end': 1549, 'type': 'COM'}","{'word': '자바 ME', 'start': 1566, 'end': 1570, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
113,"참고로 자바 플랫폼은 자바 SE, 자바 EE, 자바 ME, 자바 카드로 구분되나 자바 가상 머신 규격은 이 분류와 일치하지는 않는다.","{'word': '자바 플랫폼', 'start': 1544, 'end': 1549, 'type': 'COM'}","{'word': '자바 카드', 'start': 1573, 'end': 1577, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
114,오라클 구현의 경우 자바 SE를 위한 핫스팟 가상 머신은 사용 목적에 따라 최적화와 튜닝이 다른 서버용과 클라이언트용으로 나뉘며 서버용이 주로 자바 EE와 함께 많이 사용된다.,"{'word': '핫스팟 가상 머신', 'start': 1873, 'end': 1881, 'type': 'COM'}","{'word': '서버용', 'start': 1906, 'end': 1908, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
115,오라클 구현의 경우 자바 SE를 위한 핫스팟 가상 머신은 사용 목적에 따라 최적화와 튜닝이 다른 서버용과 클라이언트용으로 나뉘며 서버용이 주로 자바 EE와 함께 많이 사용된다.,"{'word': '핫스팟 가상 머신', 'start': 1873, 'end': 1881, 'type': 'COM'}","{'word': '클라이언트용', 'start': 1911, 'end': 1916, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
116,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '자바 플랫폼', 'start': 2019, 'end': 2024, 'type': 'COM'}","{'word': 'JVM', 'start': 2014, 'end': 2016, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
117,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '웹 브라우저', 'start': 2115, 'end': 2120, 'type': 'COM'}","{'word': '운영', 'start': 2081, 'end': 2082, 'type': 'COM'}",com:sub_concept,no_relation,no_relation
118,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '웹 브라우저', 'start': 2115, 'end': 2120, 'type': 'COM'}","{'word': '인터넷 익스플로러', 'start': 2092, 'end': 2100, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
119,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '웹 브라우저', 'start': 2115, 'end': 2120, 'type': 'COM'}","{'word': '넷스케이프', 'start': 2103, 'end': 2107, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
120,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '플랫폼', 'start': 2129, 'end': 2131, 'type': 'COM'}","{'word': '웹 브라우저', 'start': 2115, 'end': 2120, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
121,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '플랫폼', 'start': 2129, 'end': 2131, 'type': 'COM'}","{'word': '휴대전화', 'start': 2150, 'end': 2153, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
122,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '플랫폼', 'start': 2129, 'end': 2131, 'type': 'COM'}","{'word': '가전기기', 'start': 2156, 'end': 2159, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
123,따라서 자바 플랫폼은 여러 플랫폼을 지원하여 미들웨어로서의 역할과 플랫폼 스스로의 역할을 동시에 수행할 수 있다.,"{'word': '자바 플랫폼', 'start': 2177, 'end': 2182, 'type': 'COM'}","{'word': '미들웨어', 'start': 2198, 'end': 2201, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
124,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '오픈 소스 자바 가상 머신', 'start': 2489, 'end': 2502, 'type': 'COM'}","{'word': 'GCJ', 'start': 2402, 'end': 2404, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
125,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '오픈 소스 자바 가상 머신', 'start': 2489, 'end': 2502, 'type': 'COM'}","{'word': '하모니', 'start': 2454, 'end': 2456, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
126,"자바 가상 머신(, JVM)은 자바 바이트코드를 실행할 수 있는 주체이다.","{'word': '자바 가상 머신', 'start': 0, 'end': 7, 'type': 'COM'}","{'word': 'JVM', 'start': 11, 'end': 13, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
127,"자바 가상 머신은 설계자인 제임스 고슬링()에 따르면 UCSD 파스칼의 p-코드()와 스몰토크 VM에 영향을 받았다고 한다. 자바 가상 머신은 이 두 가상 머신처럼 스택 기반이어서 대다수의 명령어가 스택 선두에서 피연산자를 택하고 결과는 다시 스택에 넣는다. 스택 상의 피연산자 타입을 구분하고 명령어에 스택 상의 피연산자 타입을 기술하는 면에서는 p-코드와 유사하며 실제 구조에는 차이가 있지만 가비지 컬렉션을 사용하고 객체와 메서드 호출 개념이 있다는 점에서는 스몰토크 가상 머신과 영향을 받았다고 볼 수 있다. 하지만 p-코드가 타입 안전성을 담보하지 못해 메모리 내용을 망가뜨릴 수 있다는 점, 그리고 스몰토크 가상 머신이 동적 타입을 사용하는 스몰토크 언어 자체와 마찬가지로 타입 구분을 하지 않는다는 점에서는 자바 가상 머신과 다르다.","{'word': '스몰토크 VM', 'start': 393, 'end': 399, 'type': 'COM'}","{'word': '스몰토크 가상 머신', 'start': 605, 'end': 614, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
128,"자바 바이트코드는 주로 자바7로 작성된 소스 코드를 컴파일하여 생성하며 현재 자바 가상 머신의 구조는 자바 언어의 구조를 거의 일대일로 반영하고 있다. 하지만 스칼라 같은 다른 컴파일 언어도 자바 바이트코드를 생성할 수 있으며, 자바로 작성된 자바스크립트 엔진인 라이노() 같은 경우는 옵션에 따라 자바 가상 머신 위에서 인터프리터를 실행하기도 하고 자바 바이트코드를 동적으로 생성하기도 한다.","{'word': '라이노', 'start': 932, 'end': 934, 'type': 'COM'}","{'word': '자바스크립트 엔진', 'start': 921, 'end': 929, 'type': 'COM'}",com:alter_names,no_relation,no_relation
129,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '썬 마이크로시스템즈', 'start': 2303, 'end': 2312, 'type': 'COM'}","{'word': '오라클', 'start': 2297, 'end': 2299, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
130,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '자바 가상 머신', 'start': 2322, 'end': 2329, 'type': 'COM'}","{'word': '자바 VM', 'start': 2385, 'end': 2389, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
131,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': 'ASF', 'start': 2420, 'end': 2422, 'type': 'COM'}","{'word': '아파치 소프트웨어 재단', 'start': 2407, 'end': 2418, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
132,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': 'Apache Software Foundation', 'start': 2425, 'end': 2450, 'type': 'COM'}","{'word': '아파치 소프트웨어 재단', 'start': 2407, 'end': 2418, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
133,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': 'Apache Software Foundation', 'start': 2425, 'end': 2450, 'type': 'COM'}","{'word': 'ASF', 'start': 2420, 'end': 2422, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
134,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '아파치 소프트웨어 재단', 'start': 2407, 'end': 2418, 'type': 'COM'}","{'word': 'ASF', 'start': 2420, 'end': 2422, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
135,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': 'ASF', 'start': 2420, 'end': 2422, 'type': 'COM'}","{'word': 'Apache Software Foundation', 'start': 2425, 'end': 2450, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
136,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '아파치 소프트웨어 재단', 'start': 2407, 'end': 2418, 'type': 'COM'}","{'word': 'Apache Software Foundation', 'start': 2425, 'end': 2450, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
137,"오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다.","{'word': '하모니', 'start': 2454, 'end': 2456, 'type': 'COM'}","{'word': 'Harmony', 'start': 2458, 'end': 2464, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
138,"자바 바이트코드는 주로 자바7로 작성된 소스 코드를 컴파일하여 생성하며 현재 자바 가상 머신의 구조는 자바 언어의 구조를 거의 일대일로 반영하고 있다. 하지만 스칼라 같은 다른 컴파일 언어도 자바 바이트코드를 생성할 수 있으며, 자바로 작성된 자바스크립트 엔진인 라이노() 같은 경우는 옵션에 따라 자바 가상 머신 위에서 인터프리터를 실행하기도 하고 자바 바이트코드를 동적으로 생성하기도 한다.","{'word': '자바7', 'start': 798, 'end': 800, 'type': 'COM'}","{'word': '소스 코드', 'start': 807, 'end': 811, 'type': 'COM'}",com:made_of,no_relation,no_relation
139,"자바 바이트코드는 주로 자바7로 작성된 소스 코드를 컴파일하여 생성하며 현재 자바 가상 머신의 구조는 자바 언어의 구조를 거의 일대일로 반영하고 있다. 하지만 스칼라 같은 다른 컴파일 언어도 자바 바이트코드를 생성할 수 있으며, 자바로 작성된 자바스크립트 엔진인 라이노() 같은 경우는 옵션에 따라 자바 가상 머신 위에서 인터프리터를 실행하기도 하고 자바 바이트코드를 동적으로 생성하기도 한다.","{'word': '스칼라', 'start': 874, 'end': 876, 'type': 'COM'}","{'word': '자바 바이트코드', 'start': 892, 'end': 899, 'type': 'COM'}",com:made_of,no_relation,no_relation
140,"자바 바이트코드는 주로 자바7로 작성된 소스 코드를 컴파일하여 생성하며 현재 자바 가상 머신의 구조는 자바 언어의 구조를 거의 일대일로 반영하고 있다. 하지만 스칼라 같은 다른 컴파일 언어도 자바 바이트코드를 생성할 수 있으며, 자바로 작성된 자바스크립트 엔진인 라이노() 같은 경우는 옵션에 따라 자바 가상 머신 위에서 인터프리터를 실행하기도 하고 자바 바이트코드를 동적으로 생성하기도 한다.","{'word': '자바', 'start': 913, 'end': 914, 'type': 'COM'}","{'word': '라이노', 'start': 932, 'end': 934, 'type': 'COM'}",com:made_of,no_relation,no_relation
141,"자바 가상 머신(, JVM)은 자바 바이트코드를 실행할 수 있는 주체이다.","{'word': '자바 가상 머신', 'start': 0, 'end': 7, 'type': 'COM'}","{'word': '자바 바이트코드', 'start': 17, 'end': 24, 'type': 'COM'}",no_relation,com:sub_concept,com:sub_concept
142,일반적으로 인터프리터나 JIT 컴파일 방식으로 다른 컴퓨터 위에서 바이트코드를 실행할 수 있도록 구현되나 jop 자바 프로세서처럼 하드웨어와 소프트웨어를 혼합해 구현하는 경우도 있다. (이론적으로는 100% 하드웨어 구현도 가능하나 비효율적이다) 자바 바이트코드는 플랫폼에 독립적이며 모든 자바 가상 머신은 자바 가상 머신 규격에 정의된 대로 자바 바이트코드를 실행한다.,"{'word': '자바 바이트코드', 'start': 180, 'end': 187, 'type': 'COM'}","{'word': '플랫폼', 'start': 190, 'end': 192, 'type': 'COM'}",no_relation,no_relation,no_relation
143,따라서 표준 자바 API까지 동일한 동작을 하도록 구현한 상태에서는 이론적으로 모든 자바 프로그램은 CPU나 운영 체제의 종류와 무관하게 동일하게 동작할 것을 보장한다.,"{'word': '운영 체제', 'start': 311, 'end': 315, 'type': 'COM'}","{'word': '표준 자바 API', 'start': 254, 'end': 262, 'type': 'COM'}",no_relation,no_relation,no_relation
144,자바 가상 머신은 이 두 가상 머신처럼 스택 기반이어서 대다수의 명령어가 스택 선두에서 피연산자를 택하고 결과는 다시 스택에 넣는다.,"{'word': '명령어', 'start': 451, 'end': 453, 'type': 'COM'}","{'word': '스택', 'start': 437, 'end': 438, 'type': 'COM'}",no_relation,no_relation,no_relation
145,"자바 바이트코드는 주로 자바7로 작성된 소스 코드를 컴파일하여 생성하며 현재 자바 가상 머신의 구조는 자바 언어의 구조를 거의 일대일로 반영하고 있다. 하지만 스칼라 같은 다른 컴파일 언어도 자바 바이트코드를 생성할 수 있으며, 자바로 작성된 자바스크립트 엔진인 라이노() 같은 경우는 옵션에 따라 자바 가상 머신 위에서 인터프리터를 실행하기도 하고 자바 바이트코드를 동적으로 생성하기도 한다.","{'word': '자바 가상 머신', 'start': 952, 'end': 959, 'type': 'COM'}","{'word': '인터프리터', 'start': 965, 'end': 969, 'type': 'COM'}",no_relation,no_relation,no_relation
146,이러한 다양한 언어 구현이 가능한 것은 다음 특성 때문이라고 할 수 있다.,"{'word': '언어', 'start': 1109, 'end': 1110, 'type': 'COM'}","{'word': '특성', 'start': 1126, 'end': 1127, 'type': 'COM'}",no_relation,no_relation,no_relation
147,"2016년 5월 기준으로, 자바폴리는 사용자들이 미수정 자바 라이브러리들을 가져와서 자바스크립트로부터 직접 이들을 호출할 수 있게 하고 있다.","{'word': '자바스크립트', 'start': 1209, 'end': 1214, 'type': 'COM'}","{'word': '자바 라이브러리', 'start': 1193, 'end': 1200, 'type': 'COM'}",no_relation,no_relation,no_relation
148,"자바 가상 머신 규격에 추가로 현재 자바 ME의 ()에서 하나 부분 집합, 자바 카드의 클래식 에디션(), 커넥티드 에디션() 각기 하나 씩 부분 집합을 명시하고 있다.","{'word': '자바 카드', 'start': 1657, 'end': 1661, 'type': 'COM'}","{'word': '자바 ME', 'start': 1635, 'end': 1639, 'type': 'COM'}",no_relation,com:similar_technology,com:similar_technology
149,"단, 규격이 동일하다고 해서 모두 같은 구현을 사용하지는 않는다.","{'word': '규격', 'start': 1713, 'end': 1714, 'type': 'COM'}","{'word': '구현', 'start': 1732, 'end': 1733, 'type': 'COM'}",no_relation,no_relation,no_relation
150,"일례로 자바 SE와 자바 EE, 자바 ME의 ()는 동일한 규격을 사용하고 있으나 함께 정의된 표준 API에서 차이가 있고 사용 환경 자체의 특성에 맞게 만들어진 별도의 구현이 존재한다.","{'word': '자바 EE', 'start': 1758, 'end': 1762, 'type': 'COM'}","{'word': '자바 SE', 'start': 1751, 'end': 1755, 'type': 'COM'}",no_relation,com:similar_technology,com:similar_technology
151,"일례로 자바 SE와 자바 EE, 자바 ME의 ()는 동일한 규격을 사용하고 있으나 함께 정의된 표준 API에서 차이가 있고 사용 환경 자체의 특성에 맞게 만들어진 별도의 구현이 존재한다.","{'word': '사용 환경', 'start': 1816, 'end': 1820, 'type': 'COM'}","{'word': '표준 API', 'start': 1800, 'end': 1805, 'type': 'COM'}",no_relation,no_relation,no_relation
152,또 자바 ME CDC를 위해서도 적은 메모리와 낮은 CPU 사양에 맞춰진 ()이라고 하는 별도 구현을 제공한다.,"{'word': '메모리', 'start': 1972, 'end': 1974, 'type': 'COM'}","{'word': 'CPU', 'start': 1980, 'end': 1982, 'type': 'COM'}",no_relation,no_relation,no_relation
153,사용자는 자바 바이트코드로 컴파일된 자바 프로그램을 실행시키기 위해서 이 자바 가상 머신을 이용하면 된다.,"{'word': '자바 바이트코드', 'start': 2242, 'end': 2249, 'type': 'COM'}","{'word': '자바 가상 머신', 'start': 2278, 'end': 2285, 'type': 'COM'}",no_relation,no_relation,no_relation
154,"2016년 5월 기준으로, 자바폴리는 사용자들이 미수정 자바 라이브러리들을 가져와서 자바스크립트로부터 직접 이들을 호출할 수 있게 하고 있다.","{'word': '자바폴리', 'start': 1177, 'end': 1180, 'type': 'COM'}","{'word': '2016년 5월', 'start': 1162, 'end': 1169, 'type': 'DAT'}",no_relation,no_relation,no_relation
155,일반적으로 인터프리터나 JIT 컴파일 방식으로 다른 컴퓨터 위에서 바이트코드를 실행할 수 있도록 구현되나 jop 자바 프로세서처럼 하드웨어와 소프트웨어를 혼합해 구현하는 경우도 있다. (이론적으로는 100% 하드웨어 구현도 가능하나 비효율적이다) 자바 바이트코드는 플랫폼에 독립적이며 모든 자바 가상 머신은 자바 가상 머신 규격에 정의된 대로 자바 바이트코드를 실행한다.,"{'word': '인터프리터', 'start': 48, 'end': 52, 'type': 'COM'}","{'word': 'JIT 컴파일', 'start': 55, 'end': 61, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
156,자바 가상 머신은 설계자인 제임스 고슬링()에 따르면 UCSD 파스칼의 p-코드()와 스몰토크 VM에 영향을 받았다고 한다.,"{'word': 'p-코드', 'start': 385, 'end': 388, 'type': 'COM'}","{'word': '스몰토크 VM', 'start': 393, 'end': 399, 'type': 'COM'}",com:similar_tech,no_relation,no_relation
157,"스택 상의 피연산자 타입을 구분하고 명령어에 스택 상의 피연산자 타입을 기술하는 면에서는 p-코드와 유사하며 실제 구조에는 차이가 있지만 가비지 컬렉션을 사용하고 객체와 메서드 호출 개념이 있다는 점에서는 스몰토크 가상 머신과 영향을 받았다고 볼 수 있다. 하지만 p-코드가 타입 안전성을 담보하지 못해 메모리 내용을 망가뜨릴 수 있다는 점, 그리고 스몰토크 가상 머신이 동적 타입을 사용하는 스몰토크 언어 자체와 마찬가지로 타입 구분을 하지 않는다는 점에서는 자바 가상 머신과 다르다.","{'word': '스몰토크 가상 머신', 'start': 605, 'end': 614, 'type': 'COM'}","{'word': '자바 가상 머신', 'start': 748, 'end': 755, 'type': 'COM'}",com:similar_tech,no_relation,no_relation
158,"스택 상의 피연산자 타입을 구분하고 명령어에 스택 상의 피연산자 타입을 기술하는 면에서는 p-코드와 유사하며 실제 구조에는 차이가 있지만 가비지 컬렉션을 사용하고 객체와 메서드 호출 개념이 있다는 점에서는 스몰토크 가상 머신과 영향을 받았다고 볼 수 있다. 하지만 p-코드가 타입 안전성을 담보하지 못해 메모리 내용을 망가뜨릴 수 있다는 점, 그리고 스몰토크 가상 머신이 동적 타입을 사용하는 스몰토크 언어 자체와 마찬가지로 타입 구분을 하지 않는다는 점에서는 자바 가상 머신과 다르다.","{'word': 'p-코드', 'start': 638, 'end': 641, 'type': 'COM'}","{'word': '스몰토크 가상 머신', 'start': 686, 'end': 695, 'type': 'COM'}",com:similar_tech,no_relation,no_relation
159,"스택 상의 피연산자 타입을 구분하고 명령어에 스택 상의 피연산자 타입을 기술하는 면에서는 p-코드와 유사하며 실제 구조에는 차이가 있지만 가비지 컬렉션을 사용하고 객체와 메서드 호출 개념이 있다는 점에서는 스몰토크 가상 머신과 영향을 받았다고 볼 수 있다. 하지만 p-코드가 타입 안전성을 담보하지 못해 메모리 내용을 망가뜨릴 수 있다는 점, 그리고 스몰토크 가상 머신이 동적 타입을 사용하는 스몰토크 언어 자체와 마찬가지로 타입 구분을 하지 않는다는 점에서는 자바 가상 머신과 다르다.","{'word': 'p-코드', 'start': 638, 'end': 641, 'type': 'COM'}","{'word': '자바 가상 머신', 'start': 748, 'end': 755, 'type': 'COM'}",com:similar_tech,no_relation,no_relation
160,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'TeaVM', 'start': 1438, 'end': 1442, 'type': 'COM'}","{'word': 'j2js-compiler', 'start': 1483, 'end': 1495, 'type': 'COM'}",com:similar_tech,com:sub_concept,com:sub_concept
161,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'TeaVM', 'start': 1438, 'end': 1442, 'type': 'COM'}","{'word': 'Bck2Brwsr', 'start': 1472, 'end': 1480, 'type': 'COM'}",com:similar_tech,com:sub_concept,com:sub_concept
162,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'Bck2Brwsr', 'start': 1472, 'end': 1480, 'type': 'COM'}","{'word': 'TeaVM', 'start': 1438, 'end': 1442, 'type': 'COM'}",com:similar_tech,no_relation,no_relation
163,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'Bck2Brwsr', 'start': 1472, 'end': 1480, 'type': 'COM'}","{'word': 'j2js-compiler', 'start': 1483, 'end': 1495, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
164,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'j2js-compiler', 'start': 1483, 'end': 1495, 'type': 'COM'}","{'word': 'Bck2Brwsr', 'start': 1472, 'end': 1480, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
165,"주요 JVM 바이트코드 대 자바스크립트 컴파일러로는 TeaVM, Dragome Web SDK에 포함된 컴파일러, Bck2Brwsr, j2js-compiler가 있다.","{'word': 'j2js-compiler', 'start': 1483, 'end': 1495, 'type': 'COM'}","{'word': 'TeaVM', 'start': 1438, 'end': 1442, 'type': 'COM'}",com:similar_tech,no_relation,no_relation
166,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '마이크로소프트 윈도우', 'start': 2036, 'end': 2046, 'type': 'COM'}","{'word': '리눅스', 'start': 2059, 'end': 2061, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
167,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '마이크로소프트 윈도우', 'start': 2036, 'end': 2046, 'type': 'COM'}","{'word': '유닉스', 'start': 2064, 'end': 2066, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
168,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '마이크로소프트 윈도우', 'start': 2036, 'end': 2046, 'type': 'COM'}","{'word': 'OS X', 'start': 2069, 'end': 2072, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
169,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '리눅스', 'start': 2059, 'end': 2061, 'type': 'COM'}","{'word': '마이크로소프트 윈도우', 'start': 2036, 'end': 2046, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
170,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '리눅스', 'start': 2059, 'end': 2061, 'type': 'COM'}","{'word': '유닉스', 'start': 2064, 'end': 2066, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
171,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '리눅스', 'start': 2059, 'end': 2061, 'type': 'COM'}","{'word': 'OS X', 'start': 2069, 'end': 2072, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
172,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '유닉스', 'start': 2064, 'end': 2066, 'type': 'COM'}","{'word': '리눅스', 'start': 2059, 'end': 2061, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
173,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '유닉스', 'start': 2064, 'end': 2066, 'type': 'COM'}","{'word': '마이크로소프트 윈도우', 'start': 2036, 'end': 2046, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
174,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '유닉스', 'start': 2064, 'end': 2066, 'type': 'COM'}","{'word': 'OS X', 'start': 2069, 'end': 2072, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
175,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': 'OS X', 'start': 2069, 'end': 2072, 'type': 'COM'}","{'word': '유닉스', 'start': 2064, 'end': 2066, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
176,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': 'OS X', 'start': 2069, 'end': 2072, 'type': 'COM'}","{'word': '리눅스', 'start': 2059, 'end': 2061, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
177,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': 'OS X', 'start': 2069, 'end': 2072, 'type': 'COM'}","{'word': '마이크로소프트 윈도우', 'start': 2036, 'end': 2046, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
178,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '인터넷 익스플로러', 'start': 2092, 'end': 2100, 'type': 'COM'}","{'word': '넷스케이프', 'start': 2103, 'end': 2107, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
179,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '넷스케이프', 'start': 2103, 'end': 2107, 'type': 'COM'}","{'word': '인터넷 익스플로러', 'start': 2092, 'end': 2100, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
180,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '휴대전화', 'start': 2150, 'end': 2153, 'type': 'COM'}","{'word': '가전기기', 'start': 2156, 'end': 2159, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
181,"JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다.","{'word': '가전기기', 'start': 2156, 'end': 2159, 'type': 'COM'}","{'word': '휴대전화', 'start': 2150, 'end': 2153, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
182,1930년대 알론조 처치가 수학기초론을 연구하는 과정에서 람다 대수의 형식을 제안하였다.,"{'word': '알론조 처치', 'start': 414, 'end': 419, 'type': 'PER'}","{'word': '람다 대수', 'start': 439, 'end': 443, 'type': 'COM'}",per:production,per:production,per:production
183,"최초의 람다 대수 체계는 논리적인 오류가 있음이 증명되었으나, 처치가 1936년에 그 속에서 계산과 관련된 부분만 따로 빼내어 후에 유형 없는 람다 대수라고 불리게 된 체계를 발표하였다.","{'word': '처치', 'start': 492, 'end': 493, 'type': 'PER'}","{'word': '유형 없는 람다 대수', 'start': 531, 'end': 541, 'type': 'COM'}",per:production,per:production,per:production
184,람다 대수는 수학자 알론조 처치에 의해 수학기초론 연구의 일환으로 1930년대 소개됐다.,"{'word': '알론조 처치', 'start': 779, 'end': 784, 'type': 'PER'}","{'word': '람다 대수', 'start': 768, 'end': 772, 'type': 'COM'}",per:production,per:production,per:production
185,최초의 시스템은 스티븐 클레이니와 존 버클리 로서가 클리네-로저 역설을 제창하면서 1935년 논리적 모순을 보이기 위해 도입됐다.,"{'word': '스티븐 클레이니와 존 버클리 로서', 'start': 827, 'end': 844, 'type': 'PER'}","{'word': '클리네-로저 역설', 'start': 847, 'end': 855, 'type': 'COM'}",per:production,per:production,per:production
186,그 후인 1936년 처치는 독립적으로 현재에는 유형 없는 람다 대수라고 불리는 계산에 관련한 부분을 출판했다.,"{'word': '처치', 'start': 902, 'end': 903, 'type': 'PER'}","{'word': '유형 없는 람다 대수', 'start': 917, 'end': 927, 'type': 'COM'}",per:production,per:production,per:production
187,람다 대수는 수학자 알론조 처치에 의해 수학기초론 연구의 일환으로 1930년대 소개됐다.,"{'word': '알론조 처치', 'start': 779, 'end': 784, 'type': 'PER'}","{'word': '수학자', 'start': 775, 'end': 777, 'type': 'POH'}",per:title,per:title,per:title
188,최초의 시스템은 스티븐 클레이니와 존 버클리 로서가 클리네-로저 역설을 제창하면서 1935년 논리적 모순을 보이기 위해 도입됐다.,"{'word': '스티븐 클레이니', 'start': 827, 'end': 834, 'type': 'PER'}","{'word': '존 버클리 로서', 'start': 837, 'end': 844, 'type': 'PER'}",no_relation,no_relation,no_relation
189,"감사하게도 리처드 몬터규와 언어학자들이 λ-대수를 자연어 (natural language)의 의미론에 적용함으로써, λ-대수는 언어학과컴퓨터 과학 양쪽 분야에서 인정받는 위치를 차지했다.","{'word': '리처드 몬터규', 'start': 1101, 'end': 1107, 'type': 'PER'}","{'word': '언어학자들', 'start': 1110, 'end': 1114, 'type': 'PER'}",no_relation,no_relation,no_relation
190,1930년대 알론조 처치가 수학기초론을 연구하는 과정에서 람다 대수의 형식을 제안하였다.,"{'word': '람다 대수', 'start': 439, 'end': 443, 'type': 'COM'}","{'word': '1930년대', 'start': 407, 'end': 412, 'type': 'DAT'}",com:date_of_prod,com:date_of_produced,com:date_of_produced
191,"최초의 람다 대수 체계는 논리적인 오류가 있음이 증명되었으나, 처치가 1936년에 그 속에서 계산과 관련된 부분만 따로 빼내어 후에 유형 없는 람다 대수라고 불리게 된 체계를 발표하였다.","{'word': '유형 없는 람다 대수', 'start': 531, 'end': 541, 'type': 'COM'}","{'word': '1936년', 'start': 496, 'end': 500, 'type': 'DAT'}",com:date_of_prod,com:date_of_produced,com:date_of_produced
192,또한 1940년에는 더 약한 형태이지만 논리적 모순이 없는 단순 유형 람다 대수를 도입하였다.,"{'word': '단순 유형 람다 대수', 'start': 595, 'end': 605, 'type': 'COM'}","{'word': '1940년', 'start': 565, 'end': 569, 'type': 'DAT'}",com:date_of_prod,com:date_of_produced,com:date_of_produced
193,최초의 시스템은 스티븐 클레이니와 존 버클리 로서가 클리네-로저 역설을 제창하면서 1935년 논리적 모순을 보이기 위해 도입됐다.,"{'word': '최초의 시스템', 'start': 818, 'end': 824, 'type': 'COM'}","{'word': '1935년', 'start': 864, 'end': 868, 'type': 'DAT'}",com:date_of_prod,com:date_of_produced,com:date_of_produced
194,그 후인 1936년 처치는 독립적으로 현재에는 유형 없는 람다 대수라고 불리는 계산에 관련한 부분을 출판했다.,"{'word': '유형 없는 람다 대수', 'start': 917, 'end': 927, 'type': 'COM'}","{'word': '1936년', 'start': 896, 'end': 900, 'type': 'DAT'}",com:date_of_prod,com:date_of_produced,com:date_of_produced
195,"1940년, 그는 또한 계산적으로는 떨어지지만 논리적으로 무결한 시스템을 공개했다.","{'word': '논리적으로 무결한 시스템', 'start': 979, 'end': 991, 'type': 'COM'}","{'word': '1940년', 'start': 953, 'end': 957, 'type': 'DAT'}",com:date_of_prod,com:date_of_produced,com:date_of_produced
196,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '논리 연산', 'start': 66, 'end': 70, 'type': 'COM'}","{'word': '함수 적용', 'start': 57, 'end': 61, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
197,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '논리 연산', 'start': 66, 'end': 70, 'type': 'COM'}","{'word': '추상화', 'start': 52, 'end': 54, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
198,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '형식 체계', 'start': 77, 'end': 81, 'type': 'COM'}","{'word': '람다 대수', 'start': 0, 'end': 4, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
199,"람다 대수의 항은 변수와 추상화 및 적용 연산을 통해 구성되며 (비순수 람다 대수에서는 상수 역시 구성에 참여한다), 추상화의 기호로는 그리스 문자 람다(λ)가 사용된다.","{'word': '람다 대수의 항', 'start': 86, 'end': 93, 'type': 'COM'}","{'word': '변수', 'start': 96, 'end': 97, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
200,"람다 대수의 항은 변수와 추상화 및 적용 연산을 통해 구성되며 (비순수 람다 대수에서는 상수 역시 구성에 참여한다), 추상화의 기호로는 그리스 문자 람다(λ)가 사용된다.","{'word': '람다 대수의 항', 'start': 86, 'end': 93, 'type': 'COM'}","{'word': '추상화', 'start': 100, 'end': 102, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
201,"람다 대수의 항은 변수와 추상화 및 적용 연산을 통해 구성되며 (비순수 람다 대수에서는 상수 역시 구성에 참여한다), 추상화의 기호로는 그리스 문자 람다(λ)가 사용된다.","{'word': '람다 대수의 항', 'start': 86, 'end': 93, 'type': 'COM'}","{'word': '적용 연산', 'start': 106, 'end': 110, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
202,람다 대수의 항들에 대하여 알파 동치와 베타 축약 등의 연산을 수행할 수 있다.,"{'word': '연산', 'start': 213, 'end': 214, 'type': 'COM'}","{'word': '알파 동치와 베타 축약', 'start': 197, 'end': 208, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
203,"알파 동치는 제한 변수를 변경하는 변환으로서 이름 충돌을 방지하기 위해 사용되며, 드 브루인 첨수를 사용할 경우 이는 필요 없다.","{'word': '변환', 'start': 246, 'end': 247, 'type': 'COM'}","{'word': '알파 동치', 'start': 227, 'end': 231, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
204,"베타 축약은 함수 적용을 적절한 치환 연산 결과로 대신하는 변환이며, 베타 축약에 대한 주어진 항의 표준형이 (존재할 경우) 알파 동치 아래 유일하다는 사실은 처치-로서 정리의 따름정리이다.","{'word': '변환', 'start': 333, 'end': 334, 'type': 'COM'}","{'word': '베타 축약', 'start': 300, 'end': 304, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
205,"람다 대수는 튜링 완전성을 만족시키며, 보편 튜링 기계와 동치이다.","{'word': '람다 대수', 'start': 615, 'end': 619, 'type': 'COM'}","{'word': '튜링 완전성', 'start': 622, 'end': 627, 'type': 'COM'}",com:sub_concept,no_relation,no_relation
206,"람다 대수는 프로그래밍 언어 이론에서 중요한 역할을 하며, 리스프를 비롯한 함수형 프로그래밍 언어의 기반이 된다.","{'word': '함수형 프로그래밍 언어', 'start': 695, 'end': 706, 'type': 'COM'}","{'word': '리스프', 'start': 686, 'end': 688, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
207,함수는 컴퓨터 과학과 수학의 기초를 이루는 개념이다.,"{'word': '컴퓨터 과학', 'start': 1204, 'end': 1209, 'type': 'COM'}","{'word': '함수', 'start': 1200, 'end': 1201, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
208,함수는 컴퓨터 과학과 수학의 기초를 이루는 개념이다.,"{'word': '수학', 'start': 1212, 'end': 1213, 'type': 'COM'}","{'word': '함수', 'start': 1200, 'end': 1201, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
209,"람다 대수의 언어는 변수, 상수, 람다 기호, 괄호, 온점으로 구성된다.","{'word': '람다 대수의 언어', 'start': 1874, 'end': 1882, 'type': 'COM'}","{'word': '변수', 'start': 1885, 'end': 1886, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
210,"람다 대수의 언어는 변수, 상수, 람다 기호, 괄호, 온점으로 구성된다.","{'word': '람다 대수의 언어', 'start': 1874, 'end': 1882, 'type': 'COM'}","{'word': '괄호', 'start': 1900, 'end': 1901, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
211,"람다 대수의 언어는 변수, 상수, 람다 기호, 괄호, 온점으로 구성된다.","{'word': '람다 대수의 언어', 'start': 1874, 'end': 1882, 'type': 'COM'}","{'word': '상수', 'start': 1889, 'end': 1890, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
212,"람다 대수의 언어는 변수, 상수, 람다 기호, 괄호, 온점으로 구성된다.","{'word': '람다 대수의 언어', 'start': 1874, 'end': 1882, 'type': 'COM'}","{'word': '람다 기호', 'start': 1893, 'end': 1897, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
213,"람다 대수의 언어는 변수, 상수, 람다 기호, 괄호, 온점으로 구성된다.","{'word': '람다 대수의 언어', 'start': 1874, 'end': 1882, 'type': 'COM'}","{'word': '온점', 'start': 1904, 'end': 1905, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
214,"변수와 상수는 (후술할) 람다 항의 기초 구성원들이며, 람다 항에 등장하는 자유 변수는 (이후 정의할) 치환 연산을 통해 다른 람다 항으로 치환될 수 있다.","{'word': '람다 항', 'start': 1929, 'end': 1932, 'type': 'COM'}","{'word': '변수와 상수', 'start': 1915, 'end': 1920, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
215,람다 기호는 (후술할) 추상화 연산을 나타내는 기호이다.,"{'word': '기호', 'start': 2029, 'end': 2030, 'type': 'COM'}","{'word': '람다 기호', 'start': 2003, 'end': 2007, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
216,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '람다 대수', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': 'λ代數', 'start': 6, 'end': 8, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
217,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '람다 대수', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': '람다 계산', 'start': 24, 'end': 28, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
218,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '람다 대수', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': '람다 계산법', 'start': 38, 'end': 43, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
219,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '람다 대수', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': 'λ-대수', 'start': 16, 'end': 19, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
220,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '람다 대수', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': 'λ計算', 'start': 30, 'end': 32, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
221,"람다 대수(λ代數, ) 또는 λ-대수 또는 람다 계산(λ計算) 또는 람다 계산법(λ計算法)은 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.","{'word': '람다 대수', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': 'λ計算法', 'start': 45, 'end': 48, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
222,1960년대에 람다 대수와 프로그래밍 언어의 관계가 명확히 밝혀지기 전까지는 λ-대수는 단지 형식주의 (formalism)일 뿐이었다.,"{'word': '형식주의', 'start': 1071, 'end': 1074, 'type': 'COM'}","{'word': 'formalism', 'start': 1077, 'end': 1085, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
223,"감사하게도 리처드 몬터규와 언어학자들이 λ-대수를 자연어 (natural language)의 의미론에 적용함으로써, λ-대수는 언어학과컴퓨터 과학 양쪽 분야에서 인정받는 위치를 차지했다.","{'word': '자연어', 'start': 1123, 'end': 1125, 'type': 'COM'}","{'word': 'natural language', 'start': 1128, 'end': 1143, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
224,람다 추상화를 통해 함수를 정의한다는 것은 함수를 정의하기만 하고 함수를 수행(호출)하지는 않는다는 것을 의미한다.,"{'word': '수행', 'start': 1654, 'end': 1655, 'type': 'COM'}","{'word': '호출', 'start': 1657, 'end': 1658, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
225,"람다 항에 등장하는 변수들은 자유 변수(自由變數, )와 제한 변수(制限變數, )로 분류된다.","{'word': '자유 변수', 'start': 2551, 'end': 2555, 'type': 'COM'}","{'word': '自由變數', 'start': 2557, 'end': 2560, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
226,"람다 항에 등장하는 변수들은 자유 변수(自由變數, )와 제한 변수(制限變數, )로 분류된다.","{'word': '제한 변수', 'start': 2566, 'end': 2570, 'type': 'COM'}","{'word': '制限變數', 'start': 2572, 'end': 2575, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
227,"자유 변수를 갖지 않는 람다 항을 닫힌 람다 항(닫힌λ項, )이라고 한다.","{'word': '닫힌 람다 항', 'start': 2966, 'end': 2972, 'type': 'COM'}","{'word': '닫힌λ項', 'start': 2974, 'end': 2977, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
228,"주어진 람다 항에 등장하는 자유 변수를 또 다른 람다 항으로 치환(置換, )하는 연산을 정의할 수 있다.","{'word': '치환', 'start': 3126, 'end': 3127, 'type': 'COM'}","{'word': '置換', 'start': 3129, 'end': 3130, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
229,"치환 연산의 정의는 자연스러우며, 다만 원래 람다 항의 의미가 변질되는 경우에는 알파 변환이 선행되어야 한다 (이는 아래 네 번째 조건의 세 번째 경우에 해당한다). 구체적으로, 람다 항 formula_54, formula_55 및 변수 formula_2에 대하여, formula_2를 formula_55으로 치환한 formula_54의 치환 실례(置換實例, ) formula_113는 formula_54의 구조에 따라 다음과 같이 재귀적으로 정의된다.","{'word': '치환 실례', 'start': 3340, 'end': 3344, 'type': 'COM'}","{'word': '置換實例', 'start': 3346, 'end': 3349, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
230,"알파 동치(α同値, )는 제한 변수 변경을 통해 주어진 람다 항을 새로운 람다 항으로 변환하는 방법이다.","{'word': '알파 동치', 'start': 3405, 'end': 3409, 'type': 'COM'}","{'word': 'α同値', 'start': 3411, 'end': 3413, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
231,"베타 축약(β縮約, )은 추상화된 함수의 적용을 적절한 치환 실례로 바꾸는 것을 통해 람다 항을 변환하는 방법이다.","{'word': '베타 축약', 'start': 3695, 'end': 3699, 'type': 'COM'}","{'word': 'β縮約', 'start': 3701, 'end': 3703, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
232,"람다 항 formula_55이 formula_136와 같은 꼴의 부분 람다 항을 가지지 않는다면, formula_55을 베타 표준형(β標準型, )이라고 한다.","{'word': 'β標準型', 'start': 4189, 'end': 4192, 'type': 'COM'}","{'word': '베타 표준형', 'start': 4182, 'end': 4187, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
233,람다 추상화를 통해 함수를 정의한다는 것은 함수를 정의하기만 하고 함수를 수행(호출)하지는 않는다는 것을 의미한다.,"{'word': '함수', 'start': 1624, 'end': 1625, 'type': 'COM'}","{'word': '람다 추상화', 'start': 1613, 'end': 1618, 'type': 'COM'}",com:made_of,no_relation,no_relation
234,람다 대수의 항들에 대하여 알파 동치와 베타 축약 등의 연산을 수행할 수 있다.,"{'word': '베타 축약', 'start': 204, 'end': 208, 'type': 'COM'}","{'word': '알파 동치', 'start': 197, 'end': 201, 'type': 'COM'}",no_relation,com:similar_technology,com:similar_technology
235,"알파 동치는 제한 변수를 변경하는 변환으로서 이름 충돌을 방지하기 위해 사용되며, 드 브루인 첨수를 사용할 경우 이는 필요 없다.","{'word': '이름 충돌', 'start': 252, 'end': 256, 'type': 'COM'}","{'word': '드 브루인 첨수', 'start': 273, 'end': 280, 'type': 'COM'}",no_relation,no_relation,no_relation
236,1960년대에 람다 대수와 프로그래밍 언어의 관계가 명확히 밝혀지기 전까지는 λ-대수는 단지 형식주의 (formalism)일 뿐이었다.,"{'word': '프로그래밍 언어', 'start': 1034, 'end': 1041, 'type': 'COM'}","{'word': '람다 대수', 'start': 1027, 'end': 1031, 'type': 'COM'}",no_relation,no_relation,no_relation
237,람다 대수는 함수를 단순하게 표현할 수 있도록 하여 '함수의 계산'이라는 개념을 더 깊이 이해할 수 있게 돕는다.,"{'word': '함수', 'start': 1237, 'end': 1238, 'type': 'COM'}","{'word': '람다 대수', 'start': 1230, 'end': 1234, 'type': 'COM'}",no_relation,no_relation,no_relation
238,람다 대수의 언어를 사용하여 자연수의 페아노 산술을 다음과 같이 표현할 수 있다.,"{'word': '자연수', 'start': 4420, 'end': 4422, 'type': 'COM'}","{'word': '람다 대수', 'start': 4404, 'end': 4408, 'type': 'COM'}",no_relation,no_relation,no_relation
239,"람다 대수는 튜링 완전성을 만족시키며, 보편 튜링 기계와 동치이다.","{'word': '람다 대수', 'start': 615, 'end': 619, 'type': 'COM'}","{'word': '보편 튜링 기계', 'start': 637, 'end': 644, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
240,"람다 대수는 그 밖에도 논리학, 철학, 언어학, 컴퓨터 과학 등의 여러 분야에서 응용된다.","{'word': '논리학', 'start': 730, 'end': 732, 'type': 'COM'}","{'word': '컴퓨터 과학', 'start': 744, 'end': 749, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
241,기계어(機械語)는 CPU가 직접 해독하고 실행할 수 있는 비트 단위로 쓰인 컴퓨터 언어를 통틀어 일컫는다.,"{'word': '컴퓨터 언어', 'start': 42, 'end': 47, 'type': 'COM'}","{'word': '기계어', 'start': 0, 'end': 2, 'type': 'COM'}",com:sub_concept,no_relation,no_relation
242,기계어는 CPU의 종류에 따라서 서로 다른 코드를 갖게 된다.,"{'word': '기계어', 'start': 245, 'end': 247, 'type': 'COM'}","{'word': '코드', 'start': 269, 'end': 270, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
243,기계어는 프로그램을 나타내는 가장 낮은 단계의 개념이다.,"{'word': '기계어', 'start': 60, 'end': 62, 'type': 'COM'}","{'word': '프로그램', 'start': 65, 'end': 68, 'type': 'COM'}",no_relation,com:sub_concept,com:sub_concept
244,기계어는 어셈블리어와 1 : 1로 쓰일 수 있다.,"{'word': '기계어', 'start': 92, 'end': 94, 'type': 'COM'}","{'word': '어셈블리어', 'start': 97, 'end': 101, 'type': 'COM'}",no_relation,com:similar_technology,com:similar_technology
245,다시 말해 컴퓨터 프로그래밍에서 기계어는 대부분 어셈블리어를 거쳐 짜여지게 된다.,"{'word': '어셈블리어', 'start': 147, 'end': 151, 'type': 'COM'}","{'word': '기계어', 'start': 138, 'end': 140, 'type': 'COM'}",no_relation,no_relation,no_relation
246,"어셈블리어가 아직 만들어지기 전에는 기계어를 직접 입력하여 프로그램을 작성하기도 했으며, 오늘날에도 흔치는 않지만 그렇게 하는 사람이 있다.","{'word': '기계어', 'start': 186, 'end': 188, 'type': 'COM'}","{'word': '어셈블리어', 'start': 166, 'end': 170, 'type': 'COM'}",no_relation,com:similar_technology,com:similar_technology
247,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다.","{'word': '로버트 그리즈머, 롭 파이크, 켄 톰프슨', 'start': 19, 'end': 40, 'type': 'PER'}","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}",per:production,per:production,per:production
248,"화이트 보드에 새로운 언어에 대한 스케치를 하면서 초기 20% 파트타임 프로젝트로 시작하였다가 2008년 1월 켄 톰프슨이 C 코드를 만들어내는 컴파일러를 만들기 시작했고, 2008년 중반 풀타임 프로젝트로 승격되었다.","{'word': '켄 톰프슨', 'start': 522, 'end': 526, 'type': 'PER'}","{'word': '컴파일러', 'start': 541, 'end': 544, 'type': 'COM'}",per:production,per:production,per:production
249,"2008년 5월 이안 테일러가 Go 스펙의 초안을 이용해서 GCC 프론트엔드를 만들기 시작했고, 2008년 말 러스 콕스가 참여하면서 프로토타입에서 실질적인 언어와 라이브러리들을 만들기 시작했다.","{'word': '이안 테일러', 'start': 592, 'end': 597, 'type': 'PER'}","{'word': 'GCC 프론트엔드', 'start': 616, 'end': 624, 'type': 'COM'}",per:production,per:production,per:production
250,"2008년 5월 이안 테일러가 Go 스펙의 초안을 이용해서 GCC 프론트엔드를 만들기 시작했고, 2008년 말 러스 콕스가 참여하면서 프로토타입에서 실질적인 언어와 라이브러리들을 만들기 시작했다.","{'word': '러스 콕스', 'start': 645, 'end': 649, 'type': 'PER'}","{'word': '실질적인 언어와 라이브러리', 'start': 666, 'end': 679, 'type': 'COM'}",per:production,per:production,per:production
251,"Go를 만들고 있는 개발자들은, 제너릭 등은 급하진 않지만 어느 시점에는 기능이 도입될 것이라고 한다.","{'word': '개발자', 'start': 1787, 'end': 1789, 'type': 'PER'}","{'word': 'Go', 'start': 1776, 'end': 1777, 'type': 'COM'}",per:production,per:production,per:production
252,"Go는 다른 언어의 긍정적인 특징들을 유지하면서 공통이 되는 문제들을 해결할 새로운 프로그래밍 언어를 설계하기 위해 구글의 엔지니어 Robert Griesemer, 롭 파이크, 켄 톰프슨에 의해 실험적으로 시작되었다.","{'word': 'Robert Griesemer, 롭 파이크, 켄 톰프슨', 'start': 977, 'end': 1006, 'type': 'PER'}","{'word': '엔지니어', 'start': 972, 'end': 975, 'type': 'POH'}",per:title,per:title,per:title
253,"Go는 다른 언어의 긍정적인 특징들을 유지하면서 공통이 되는 문제들을 해결할 새로운 프로그래밍 언어를 설계하기 위해 구글의 엔지니어 Robert Griesemer, 롭 파이크, 켄 톰프슨에 의해 실험적으로 시작되었다. 이 새로운 언어는 다음의 기능을 포함할 작정이었다: 나중의 인터뷰에서, 언어 설계자 3명 모두 자신들이 C++의 복잡성을 싫어하며 이로 인해 새로운 언어를 설계하는 계기가 되었다고 언급하였다.","{'word': 'Robert Griesemer, 롭 파이크, 켄 톰프슨', 'start': 977, 'end': 1006, 'type': 'PER'}","{'word': '언어 설계자', 'start': 1065, 'end': 1070, 'type': 'POH'}",per:title,per:title,per:title
254,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다.","{'word': '로버트 그리즈머', 'start': 19, 'end': 26, 'type': 'PER'}","{'word': '롭 파이크', 'start': 29, 'end': 33, 'type': 'PER'}",no_relation,no_relation,no_relation
255,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다.","{'word': '로버트 그리즈머', 'start': 19, 'end': 26, 'type': 'PER'}","{'word': '켄 톰프슨', 'start': 36, 'end': 40, 'type': 'PER'}",no_relation,no_relation,no_relation
256,"Go의 초기 디자인은 2007년 9월 21일에 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 인페르노 분산 운영체제와 관련된 작업을 하다가 시작되었다.","{'word': '롭 파이크', 'start': 413, 'end': 417, 'type': 'PER'}","{'word': '로버트 그리즈머', 'start': 403, 'end': 410, 'type': 'PER'}",no_relation,no_relation,no_relation
257,"Go의 초기 디자인은 2007년 9월 21일에 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 인페르노 분산 운영체제와 관련된 작업을 하다가 시작되었다.","{'word': '롭 파이크', 'start': 413, 'end': 417, 'type': 'PER'}","{'word': '켄 톰프슨', 'start': 420, 'end': 424, 'type': 'PER'}",no_relation,no_relation,no_relation
258,"Go는 다른 언어의 긍정적인 특징들을 유지하면서 공통이 되는 문제들을 해결할 새로운 프로그래밍 언어를 설계하기 위해 구글의 엔지니어 Robert Griesemer, 롭 파이크, 켄 톰프슨에 의해 실험적으로 시작되었다.","{'word': '켄 톰프슨', 'start': 1002, 'end': 1006, 'type': 'PER'}","{'word': '롭 파이크', 'start': 995, 'end': 999, 'type': 'PER'}",no_relation,no_relation,no_relation
259,"Go는 다른 언어의 긍정적인 특징들을 유지하면서 공통이 되는 문제들을 해결할 새로운 프로그래밍 언어를 설계하기 위해 구글의 엔지니어 Robert Griesemer, 롭 파이크, 켄 톰프슨에 의해 실험적으로 시작되었다.","{'word': '켄 톰프슨', 'start': 1002, 'end': 1006, 'type': 'PER'}","{'word': 'Robert Griesemer', 'start': 977, 'end': 992, 'type': 'PER'}",no_relation,no_relation,no_relation
260,"하나는 구글의 셀프 호스팅 컴파일러 툴체인으로서 여러 운영 체제, 모바일 장치, 웹어셈블리를 대상으로 한다.","{'word': '구글', 'start': 234, 'end': 235, 'type': 'ORG'}","{'word': '셀프 호스팅 컴파일러 툴체인', 'start': 238, 'end': 252, 'type': 'COM'}",org:production,org:production,org:production
261,구글의 생산 시스템 중 일부 및 기타 기업들에 사용되고 있다.,"{'word': '구글', 'start': 868, 'end': 869, 'type': 'ORG'}","{'word': '생산 시스템', 'start': 872, 'end': 877, 'type': 'COM'}",org:production,org:production,org:production
262,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다.","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': '2009년', 'start': 4, 'end': 8, 'type': 'DAT'}",com:date_of_prod,com:date_of_produced,com:date_of_produced
263,"2009년 11월 10일에 리눅스와 MacOS 플랫폼을 대상으로 공식 발표되었다. Go가 처음 런칭되었을 때는 실무적인 소프트웨어를 만들기에는 준비가 좀 덜 된 상태였지만, 2010년 5월 롭 파이크는 구글에서 실제로 사용되고 있는 부분이 있다고 공개적으로 알리게 되었다.","{'word': 'Go', 'start': 739, 'end': 740, 'type': 'COM'}","{'word': '2009년 11월 10', 'start': 693, 'end': 704, 'type': 'DAT'}",com:date_of_prod,com:date_of_produced,com:date_of_produced
264,2009년 11월에 Go가 발표되었다.,"{'word': 'Go', 'start': 857, 'end': 858, 'type': 'COM'}","{'word': '2009년 11', 'start': 846, 'end': 853, 'type': 'DAT'}",com:date_of_prod,com:date_of_produced,com:date_of_produced
265,Go 1.0은 2012년 3월에 출시되었다.,"{'word': 'Go 1.0', 'start': 1133, 'end': 1138, 'type': 'COM'}","{'word': '2012년 3월', 'start': 1141, 'end': 1148, 'type': 'DAT'}",com:date_of_prod,com:date_of_produced,com:date_of_produced
266,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다. 가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다.","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': '가비지 컬렉션 기능', 'start': 59, 'end': 68, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
267,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다. 가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다.","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': '병행성', 'start': 75, 'end': 77, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
268,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다. 가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다. 구문이 C와 비슷하지만 메모리 보안, 쓰레기 수집, 구조 타이핑, CSP 스타일 병행성을 제공한다.","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': '메모리 보안', 'start': 121, 'end': 126, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
269,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다. 가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다. 구문이 C와 비슷하지만 메모리 보안, 쓰레기 수집, 구조 타이핑, CSP 스타일 병행성을 제공한다.","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': '쓰레기 수집', 'start': 129, 'end': 134, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
270,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다. 가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다. 구문이 C와 비슷하지만 메모리 보안, 쓰레기 수집, 구조 타이핑, CSP 스타일 병행성을 제공한다.","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': '구조 타이핑', 'start': 137, 'end': 142, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
271,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다. 가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다. 구문이 C와 비슷하지만 메모리 보안, 쓰레기 수집, 구조 타이핑, CSP 스타일 병행성을 제공한다.","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}","{'word': 'CSP 스타일 병행성', 'start': 145, 'end': 155, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
272,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다.","{'word': '프로그래밍 언어', 'start': 47, 'end': 54, 'type': 'COM'}","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
273,"가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다.","{'word': '컴파일 언어', 'start': 99, 'end': 104, 'type': 'COM'}","{'word': '병행성', 'start': 75, 'end': 77, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
274,"가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다.","{'word': '컴파일 언어', 'start': 99, 'end': 104, 'type': 'COM'}","{'word': '가비지 컬렉션 기능', 'start': 59, 'end': 68, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
275,"Go는 2009년 구글에서 일하는 로버트 그리즈머, 롭 파이크, 켄 톰프슨이 개발한 프로그래밍 언어이다. 가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다.","{'word': '컴파일 언어', 'start': 99, 'end': 104, 'type': 'COM'}","{'word': 'Go', 'start': 0, 'end': 1, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
276,나머지 하나는 GCC 프론트엔드인 gccgo가 있다.,"{'word': 'GCC 프론트엔드', 'start': 299, 'end': 307, 'type': 'COM'}","{'word': 'gccgo', 'start': 310, 'end': 314, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
277,서드파티 트랜스파일러 GopherJS는 프론트엔드 웹 개발을 위해 Go를 자바스크립트로 컴파일한다.,"{'word': '트랜스파일러', 'start': 326, 'end': 331, 'type': 'COM'}","{'word': 'GopherJS', 'start': 333, 'end': 340, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
278,2009년 11월 10일에 리눅스와 MacOS 플랫폼을 대상으로 공식 발표되었다.,"{'word': '플랫폼', 'start': 719, 'end': 721, 'type': 'COM'}","{'word': '리눅스', 'start': 708, 'end': 710, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
279,2009년 11월 10일에 리눅스와 MacOS 플랫폼을 대상으로 공식 발표되었다.,"{'word': '플랫폼', 'start': 719, 'end': 721, 'type': 'COM'}","{'word': 'MacOS', 'start': 713, 'end': 717, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
280,"Go는 다른 언어의 긍정적인 특징들을 유지하면서 공통이 되는 문제들을 해결할 새로운 프로그래밍 언어를 설계하기 위해 구글의 엔지니어 Robert Griesemer, 롭 파이크, 켄 톰프슨에 의해 실험적으로 시작되었다.","{'word': '프로그래밍 언어', 'start': 950, 'end': 957, 'type': 'COM'}","{'word': 'Go', 'start': 903, 'end': 904, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
281,GopherJS라는 이름의 서드파티 Go 컴파일러도 존재한다.,"{'word': '서드파티 Go 컴파일러', 'start': 1191, 'end': 1202, 'type': 'COM'}","{'word': 'GopherJS', 'start': 1176, 'end': 1183, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
282,"Go의 문법은 대체로 C와 비슷하다: 코드 블록들은 중괄호로 둘러싸고 for, switch, if를 포함한 일반적인 제어구조를 가지고 있다.","{'word': 'Go', 'start': 1272, 'end': 1273, 'type': 'COM'}","{'word': '제어구조', 'start': 1337, 'end': 1340, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
283,"Go의 문법은 대체로 C와 비슷하다: 코드 블록들은 중괄호로 둘러싸고 for, switch, if를 포함한 일반적인 제어구조를 가지고 있다. C와 다르게, 한 라인 끝의 세미콜론은 필수가 아닌 옵션이다.","{'word': 'Go', 'start': 1272, 'end': 1273, 'type': 'COM'}","{'word': '한 라인 끝의 세미콜론', 'start': 1359, 'end': 1370, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
284,"Go의 문법은 대체로 C와 비슷하다: 코드 블록들은 중괄호로 둘러싸고 for, switch, if를 포함한 일반적인 제어구조를 가지고 있다. C와 다르게, 한 라인 끝의 세미콜론은 필수가 아닌 옵션이다. 변수 선언은 다르게 작성되고 대개 옵션이다.","{'word': 'Go', 'start': 1272, 'end': 1273, 'type': 'COM'}","{'word': '변수 선언', 'start': 1386, 'end': 1390, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
285,"Go의 문법은 대체로 C와 비슷하다: 코드 블록들은 중괄호로 둘러싸고 for, switch, if를 포함한 일반적인 제어구조를 가지고 있다. C와 다르게, 한 라인 끝의 세미콜론은 필수가 아닌 옵션이다. 변수 선언은 다르게 작성되고 대개 옵션이다. 형 변환은 명시적으로 해야 한다.","{'word': 'Go', 'start': 1272, 'end': 1273, 'type': 'COM'}","{'word': '형 변환', 'start': 1411, 'end': 1414, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
286,"Go의 문법은 대체로 C와 비슷하다: 코드 블록들은 중괄호로 둘러싸고 for, switch, if를 포함한 일반적인 제어구조를 가지고 있다. C와 다르게, 한 라인 끝의 세미콜론은 필수가 아닌 옵션이다. 변수 선언은 다르게 작성되고 대개 옵션이다. 형 변환은 명시적으로 해야 한다. 병행 컴퓨팅을 다루기 위해 ""go""와 ""select"" 키워드가 사용된다.","{'word': 'Go', 'start': 1272, 'end': 1273, 'type': 'COM'}","{'word': '병행 컴퓨팅', 'start': 1430, 'end': 1435, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
287,"새로운 타입은 map, 유니코드 문자열, 배열 slice, 그리고 내부 쓰레드 통신을 위한 채널(channel)이 있다.","{'word': '새로운 타입', 'start': 1471, 'end': 1476, 'type': 'COM'}","{'word': 'map', 'start': 1479, 'end': 1481, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
288,"새로운 타입은 map, 유니코드 문자열, 배열 slice, 그리고 내부 쓰레드 통신을 위한 채널(channel)이 있다.","{'word': '새로운 타입', 'start': 1471, 'end': 1476, 'type': 'COM'}","{'word': '유니코드 문자열', 'start': 1484, 'end': 1491, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
289,"새로운 타입은 map, 유니코드 문자열, 배열 slice, 그리고 내부 쓰레드 통신을 위한 채널(channel)이 있다.","{'word': '새로운 타입', 'start': 1471, 'end': 1476, 'type': 'COM'}","{'word': '배열 slice', 'start': 1494, 'end': 1501, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
290,"새로운 타입은 map, 유니코드 문자열, 배열 slice, 그리고 내부 쓰레드 통신을 위한 채널(channel)이 있다.","{'word': '새로운 타입', 'start': 1471, 'end': 1476, 'type': 'COM'}","{'word': '내부 쓰레드 통신을 위한 채널(channel)', 'start': 1508, 'end': 1532, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
291,Go는 가비지 컬렉션이 되는 언어이다.,"{'word': '언어', 'start': 1599, 'end': 1600, 'type': 'COM'}","{'word': 'Go', 'start': 1583, 'end': 1584, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
292,병행성(concurrency)와 관련된 Go의 구조적인 규칙들(channel과 선택적인 channel input들)은 Tony Hoare의 로부터 가져온 것이다.,"{'word': 'Go', 'start': 1627, 'end': 1628, 'type': 'COM'}","{'word': 'channel과 선택적인 channel input들', 'start': 1640, 'end': 1667, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
293,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': 'C++', 'start': 1696, 'end': 1698, 'type': 'COM'}","{'word': '타입 상속', 'start': 1714, 'end': 1718, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
294,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': '자바', 'start': 1701, 'end': 1702, 'type': 'COM'}","{'word': '타입 상속', 'start': 1714, 'end': 1718, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
295,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': 'C++', 'start': 1696, 'end': 1698, 'type': 'COM'}","{'word': '제너릭', 'start': 1721, 'end': 1723, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
296,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': '자바', 'start': 1701, 'end': 1702, 'type': 'COM'}","{'word': '제너릭', 'start': 1721, 'end': 1723, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
297,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': 'C++', 'start': 1696, 'end': 1698, 'type': 'COM'}","{'word': '메서드 오버로딩', 'start': 1741, 'end': 1748, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
298,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': '자바', 'start': 1701, 'end': 1702, 'type': 'COM'}","{'word': '메서드 오버로딩', 'start': 1741, 'end': 1748, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
299,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': 'C++', 'start': 1696, 'end': 1698, 'type': 'COM'}","{'word': '포인터 연산', 'start': 1751, 'end': 1756, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
300,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': '자바', 'start': 1701, 'end': 1702, 'type': 'COM'}","{'word': '포인터 연산', 'start': 1751, 'end': 1756, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
301,"동시성이란 멀티스레딩, 병렬 컴퓨팅 뿐 아니라, 비동기성 입출력 또한 포함한다.","{'word': '동시성', 'start': 1902, 'end': 1904, 'type': 'COM'}","{'word': '멀티스레딩', 'start': 1908, 'end': 1912, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
302,"동시성이란 멀티스레딩, 병렬 컴퓨팅 뿐 아니라, 비동기성 입출력 또한 포함한다.","{'word': '동시성', 'start': 1902, 'end': 1904, 'type': 'COM'}","{'word': '병렬 컴퓨팅', 'start': 1915, 'end': 1920, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
303,"동시성이란 멀티스레딩, 병렬 컴퓨팅 뿐 아니라, 비동기성 입출력 또한 포함한다.","{'word': '동시성', 'start': 1902, 'end': 1904, 'type': 'COM'}","{'word': '비동기성 입출력', 'start': 1929, 'end': 1936, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
304,"예를 들어, 이벤트 기반 서버와 같이, 데이터베이스나 네트워크 작업과 같이 시간이 많이 걸리는 연산을 하는 동안 프로그램이 다른 일을 하는 것을 말한다.","{'word': '시간이 많이 걸리는 연산', 'start': 1989, 'end': 2001, 'type': 'COM'}","{'word': '네트워크 작업', 'start': 1977, 'end': 1983, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
305,"예를 들어, 이벤트 기반 서버와 같이, 데이터베이스나 네트워크 작업과 같이 시간이 많이 걸리는 연산을 하는 동안 프로그램이 다른 일을 하는 것을 말한다.","{'word': '시간이 많이 걸리는 연산', 'start': 1989, 'end': 2001, 'type': 'COM'}","{'word': '데이터베이스', 'start': 1969, 'end': 1974, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
306,"예를 들어, 이벤트 기반 서버와 같이, 데이터베이스나 네트워크 작업과 같이 시간이 많이 걸리는 연산을 하는 동안 프로그램이 다른 일을 하는 것을 말한다.","{'word': '프로그램이 다른 일을 하는 것', 'start': 2010, 'end': 2025, 'type': 'COM'}","{'word': '이벤트 기반 서버', 'start': 1954, 'end': 1962, 'type': 'COM'}",com:sub_concept,no_relation,no_relation
307,Go는 정적 타입 컴파일 언어의 효율성과 동적 언어처럼 쉬운 프로그래밍을 할 수 있도록 하는 것을 목표로 한다.,"{'word': '정적 타입 컴파일 언어', 'start': 2037, 'end': 2048, 'type': 'COM'}","{'word': '효율성', 'start': 2051, 'end': 2053, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
308,Go는 정적 타입 컴파일 언어의 효율성과 동적 언어처럼 쉬운 프로그래밍을 할 수 있도록 하는 것을 목표로 한다.,"{'word': '동적 언어', 'start': 2056, 'end': 2060, 'type': 'COM'}","{'word': '쉬운 프로그래밍', 'start': 2064, 'end': 2071, 'type': 'COM'}",com:sub_concept,no_relation,no_relation
309,"Go는 수많은 언어 배포판들과 동일한 종류의 디버깅, 테스트, 코드 검사 도구들을 포함하고 있다.","{'word': 'Go', 'start': 2096, 'end': 2097, 'type': 'COM'}","{'word': '디버깅', 'start': 2121, 'end': 2123, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
310,"Go는 수많은 언어 배포판들과 동일한 종류의 디버깅, 테스트, 코드 검사 도구들을 포함하고 있다.","{'word': 'Go', 'start': 2096, 'end': 2097, 'type': 'COM'}","{'word': '코드 검사 도구', 'start': 2131, 'end': 2138, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
311,"Go는 수많은 언어 배포판들과 동일한 종류의 디버깅, 테스트, 코드 검사 도구들을 포함하고 있다.","{'word': 'Go', 'start': 2096, 'end': 2097, 'type': 'COM'}","{'word': '테스트', 'start': 2126, 'end': 2128, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
312,"그 중에 Go 배포판은 다음을 포함한다: 프로파일링 및 디버깅 지원, 런타임 인스트루먼테이션(이를테면 가비지 컬렉션 일시 정지 등을 위해) 및 레이스 컨디션 테스터(race condition tester)도 포함한다.","{'word': 'Go 배포판', 'start': 2156, 'end': 2161, 'type': 'COM'}","{'word': '프로파일링 및 디버깅 지원', 'start': 2174, 'end': 2187, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
313,"그 중에 Go 배포판은 다음을 포함한다: 프로파일링 및 디버깅 지원, 런타임 인스트루먼테이션(이를테면 가비지 컬렉션 일시 정지 등을 위해) 및 레이스 컨디션 테스터(race condition tester)도 포함한다.","{'word': 'Go 배포판', 'start': 2156, 'end': 2161, 'type': 'COM'}","{'word': '레이스 컨디션 테스터', 'start': 2231, 'end': 2241, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
314,"그 중에 Go 배포판은 다음을 포함한다: 프로파일링 및 디버깅 지원, 런타임 인스트루먼테이션(이를테면 가비지 컬렉션 일시 정지 등을 위해) 및 레이스 컨디션 테스터(race condition tester)도 포함한다.","{'word': 'Go 배포판', 'start': 2156, 'end': 2161, 'type': 'COM'}","{'word': '런타임 인스트루먼테이션', 'start': 2190, 'end': 2201, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
315,"가비지 컬렉션 기능이 있고, 병행성(concurrent)을 잘 지원하는 컴파일 언어다.","{'word': '병행성', 'start': 75, 'end': 77, 'type': 'COM'}","{'word': 'concurrent', 'start': 79, 'end': 88, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
316,이 언어는 codice_1이라는 도메인 이름 때문에 종종 고랭(Golang)으로도 호칭되지만 정확한 명칭은 Go이다.,"{'word': '고랭', 'start': 196, 'end': 197, 'type': 'COM'}","{'word': 'Golang', 'start': 199, 'end': 204, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
317,병행성(concurrency)와 관련된 Go의 구조적인 규칙들(channel과 선택적인 channel input들)은 Tony Hoare의 로부터 가져온 것이다.,"{'word': '병행성', 'start': 1605, 'end': 1607, 'type': 'COM'}","{'word': 'concurrency', 'start': 1609, 'end': 1619, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
318,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': '표명', 'start': 1726, 'end': 1727, 'type': 'COM'}","{'word': 'assertion', 'start': 1729, 'end': 1737, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
319,Go를 이용해 프로그램들이 서로 소통하면서 상태를 공유하는 동시성(concurrency) 프로그램을 쉽게 만들 수 있다.,"{'word': '동시성', 'start': 1867, 'end': 1869, 'type': 'COM'}","{'word': 'concurrency', 'start': 1871, 'end': 1881, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
320,"프로파일링 및 디버깅 지원, 런타임 인스트루먼테이션(이를테면 가비지 컬렉션 일시 정지 등을 위해) 및 레이스 컨디션 테스터(race condition tester)도 포함한다.","{'word': 'race condition tester', 'start': 2243, 'end': 2263, 'type': 'COM'}","{'word': '레이스 컨디션 테스터', 'start': 2231, 'end': 2241, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
321,"아래는 Go로 만든 Hello, World 프로그램이다.","{'word': '프로그램', 'start': 2297, 'end': 2300, 'type': 'COM'}","{'word': 'Go', 'start': 2277, 'end': 2278, 'type': 'COM'}",com:made_of,com:made_of,com:made_of
322,Go로 작성된 일부 저명한 오픈 소스 소프트웨어는 다음과 같다:,"{'word': '오픈 소스 소프트웨어', 'start': 2792, 'end': 2802, 'type': 'COM'}","{'word': 'Go', 'start': 2777, 'end': 2778, 'type': 'COM'}",com:made_of,com:made_of,com:made_of
323,Go를 사용한 일부 저명한 오픈 소스 소프트웨어 프레임워크는 다음과 같다:,"{'word': '오픈 소스 소프트웨어 프레임워크', 'start': 2828, 'end': 2844, 'type': 'COM'}","{'word': 'Go', 'start': 2813, 'end': 2814, 'type': 'COM'}",com:made_of,com:made_of,com:made_of
324,이 밖에도 Go를 사용하는 저명한 기업 및 사이트는 다음과 같다(일반적으로 다른 언어와 함께 사용):,"{'word': '저명한 기업 및 사이트', 'start': 2870, 'end': 2881, 'type': 'COM'}","{'word': 'Go', 'start': 2861, 'end': 2862, 'type': 'COM'}",com:made_of,com:made_of,com:made_of
325,"Go가 처음 런칭되었을 때는 실무적인 소프트웨어를 만들기에는 준비가 좀 덜 된 상태였지만, 2010년 5월 롭 파이크는 구글에서 실제로 사용되고 있는 부분이 있다고 공개적으로 알리게 되었다.","{'word': '소프트웨어', 'start': 760, 'end': 764, 'type': 'COM'}","{'word': '구글', 'start': 806, 'end': 807, 'type': 'COM'}",no_relation,no_relation,no_relation
326,GopherJS는 Go 코드를 자바스크립트 코드로 컴파일하며 Go가 프론트엔드 개발에 사용될 수 있게 한다.,"{'word': '자바스크립트 코드', 'start': 1228, 'end': 1236, 'type': 'COM'}","{'word': 'Go 코드', 'start': 1221, 'end': 1225, 'type': 'COM'}",no_relation,com:made_of,com:made_of
327,Go는 그리 좋지 않은 하드웨어에서도 빠르게 컴파일될 수 있도록 디자인되었다.,"{'word': '하드웨어', 'start': 1552, 'end': 1555, 'type': 'COM'}","{'word': 'Go', 'start': 1539, 'end': 1540, 'type': 'COM'}",no_relation,com:made_of,com:made_of
328,2009년 11월 10일에 리눅스와 MacOS 플랫폼을 대상으로 공식 발표되었다.,"{'word': 'MacOS', 'start': 713, 'end': 717, 'type': 'COM'}","{'word': '리눅스', 'start': 708, 'end': 710, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
329,"Go의 문법은 대체로 C와 비슷하다: 코드 블록들은 중괄호로 둘러싸고 for, switch, if를 포함한 일반적인 제어구조를 가지고 있다.","{'word': 'Go', 'start': 1272, 'end': 1273, 'type': 'COM'}","{'word': 'C', 'start': 1284, 'end': 1284, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
330,"C++나 자바에 있는 기능들 중 타입 상속, 제너릭, 표명(assertion), 메서드 오버로딩, 포인터 연산은 Go에서 포함하고 있지 않다.","{'word': 'C++', 'start': 1696, 'end': 1698, 'type': 'COM'}","{'word': '자바', 'start': 1701, 'end': 1702, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
331,"예를 들어, 이벤트 기반 서버와 같이, 데이터베이스나 네트워크 작업과 같이 시간이 많이 걸리는 연산을 하는 동안 프로그램이 다른 일을 하는 것을 말한다.","{'word': '데이터베이스', 'start': 1969, 'end': 1974, 'type': 'COM'}","{'word': '네트워크 작업', 'start': 1977, 'end': 1983, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
332,"TX-0, PDP-1과 같은 컴퓨터들을 이용하여 코딩하던 과거에는 MIT 해커들이 했던 최초의 일은 어셈블러를 작성하는 일이었다.","{'word': '해커', 'start': 499, 'end': 500, 'type': 'PER'}","{'word': '어셈블러', 'start': 514, 'end': 517, 'type': 'COM'}",per:production,per:production,per:production
333,기계어는 특별한 변환 과정 없이 컴퓨터가 직접 처리할 수 있는 유일한 언어이다.,"{'word': '언어', 'start': 237, 'end': 238, 'type': 'COM'}","{'word': '기계어', 'start': 198, 'end': 200, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
334,대부분의 어셈블러는 매크로를 제공하므로 공통이 되는 일련의 명령들을 만들어낼 수 있다.,"{'word': '어셈블러', 'start': 536, 'end': 539, 'type': 'COM'}","{'word': '매크로', 'start': 542, 'end': 544, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
335,"저급 프로그래밍 언어 （低級 프로그래밍 言語）또는 로우 레벨 프로그래밍 언어()란 컴퓨터가 이해하기 쉽게 작성된 프로그래밍 언어로, 일반적으로 기계어와 어셈블리어를 일컫는다.","{'word': '저급 프로그래밍 언어', 'start': 0, 'end': 10, 'type': 'COM'}","{'word': '로우 레벨 프로그래밍 언어', 'start': 28, 'end': 41, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
336,실행속도가 매우 빠르지만 배우기가 어려우며 유지보수가 힘든 것이 단점이다.,"{'word': '실행속도', 'start': 98, 'end': 101, 'type': 'COM'}","{'word': '유지보수', 'start': 122, 'end': 125, 'type': 'COM'}",no_relation,no_relation,no_relation
337,저급언어와 반대되는 것으로 고급 프로그래밍 언어가 있다.,"{'word': '저급언어', 'start': 166, 'end': 169, 'type': 'COM'}","{'word': '고급 프로그래밍 언어', 'start': 181, 'end': 191, 'type': 'COM'}",no_relation,no_relation,no_relation
338,현재 프로그래머들은 대개 기계어로 직접 프로그램을 작성하지는 않는데 그 까닭은 고급 언어가 자동으로 다루는 수많은 세부 사항들을 신경써야 하기 때문이다.,"{'word': '고급 언어', 'start': 287, 'end': 291, 'type': 'COM'}","{'word': '기계어', 'start': 257, 'end': 259, 'type': 'COM'}",no_relation,no_relation,no_relation
339,"모든 명령마다 수많은 코드를 기억하고 찾아야 하고, 수정하기 또한 매우 어렵다.","{'word': '명령', 'start': 332, 'end': 333, 'type': 'COM'}","{'word': '코드', 'start': 341, 'end': 342, 'type': 'COM'}",no_relation,no_relation,no_relation
340,아래는 n번째 피보나치 수를 계산하는 32비트 x86 기계어를 표현한 16진 기능의 예이다:,"{'word': '기계어', 'start': 404, 'end': 406, 'type': 'COM'}","{'word': 'x86', 'start': 400, 'end': 402, 'type': 'COM'}",no_relation,no_relation,no_relation
341,2세대 언어는 기계어 최상단에 추상적인 수준을 제공한다.,"{'word': '2세대 언어', 'start': 426, 'end': 431, 'type': 'COM'}","{'word': '기계어', 'start': 434, 'end': 436, 'type': 'COM'}",no_relation,com:prior_technology,com:prior_technology
342,"아래는 상단의 피보나치 수 계산기와 동일하지만, MASM 문법을 이용하여 x86 어셈블리어로 표현한 것이다:","{'word': '어셈블리어', 'start': 625, 'end': 629, 'type': 'COM'}","{'word': '계산기', 'start': 595, 'end': 597, 'type': 'COM'}",no_relation,no_relation,no_relation
343,줄리아(Julia)는 고성능의 수치 해석 및 계산과학의 필요사항을 만족시키면서 일반 목적 프로그래밍에도 효과적으로 사용될 수 있도록 설계된 고급 동적 프로그래밍 언어이다.,"{'word': '고급 동적 프로그래밍 언어', 'start': 78, 'end': 91, 'type': 'COM'}","{'word': '줄리아', 'start': 0, 'end': 2, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
344,"줄리아 공식 배포판은 줄리아의 REPL 통신 세션 셸을 포함하고 있으며, 테스트 코드를 빠르게 실험하기 위해 사용할 수 있다.","{'word': '줄리아', 'start': 108, 'end': 110, 'type': 'COM'}","{'word': 'REPL 통신 세션 셸', 'start': 113, 'end': 124, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
345,줄리아(Julia)는 고성능의 수치 해석 및 계산과학의 필요사항을 만족시키면서 일반 목적 프로그래밍에도 효과적으로 사용될 수 있도록 설계된 고급 동적 프로그래밍 언어이다.,"{'word': '줄리아', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': 'Julia', 'start': 4, 'end': 8, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
346,"다음 부분은 샘플 세션 예제의 하나로서, 문자열들은 printLn에 의해 자동으로 이어붙여진다.","{'word': '문자열', 'start': 190, 'end': 192, 'type': 'COM'}","{'word': 'printLn', 'start': 196, 'end': 202, 'type': 'COM'}",no_relation,no_relation,no_relation
347,그런 경우에는 제조사가 만든 문서에서 쓰이는 것이 가장 자주 쓰이게 된다.,"{'word': '제조사', 'start': 348, 'end': 350, 'type': 'ORG'}","{'word': '문서', 'start': 356, 'end': 357, 'type': 'POH'}",org:production,org:production,org:production
348,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '저급 언어', 'start': 67, 'end': 71, 'type': 'COM'}","{'word': 'assembler language', 'start': 19, 'end': 36, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
349,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '저급 언어', 'start': 67, 'end': 71, 'type': 'COM'}","{'word': '어셈블러 언어', 'start': 11, 'end': 17, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
350,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '저급 언어', 'start': 67, 'end': 71, 'type': 'COM'}","{'word': '어셈블리어', 'start': 0, 'end': 4, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
351,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '컴퓨터 프로그래밍', 'start': 56, 'end': 64, 'type': 'COM'}","{'word': '저급 언어', 'start': 67, 'end': 71, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
352,어셈블러(assembler)는 어셈블리어를 기계어 형태의 오브젝트 코드로 해석해 주는 컴퓨터 언어 번역 프로그램을 말한다.,"{'word': '컴퓨터 언어 번역 프로그램', 'start': 430, 'end': 443, 'type': 'COM'}","{'word': '어셈블러', 'start': 382, 'end': 385, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
353,"어셈블러는 기본 컴퓨터 명령어들을, 컴퓨터 프로세서가 기본 연산을 수행하는데 사용할 수 있는 비트 패턴으로 변환시키는 프로그램이다.","{'word': '프로그램', 'start': 517, 'end': 520, 'type': 'COM'}","{'word': '어셈블러', 'start': 451, 'end': 454, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
354,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 어셈블러', 'start': 903, 'end': 913, 'type': 'COM'}","{'word': '고급 제어 구조', 'start': 916, 'end': 923, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
355,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 어셈블러', 'start': 903, 'end': 913, 'type': 'COM'}","{'word': '높은 수준의 프로시져', 'start': 926, 'end': 936, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
356,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 어셈블러', 'start': 903, 'end': 913, 'type': 'COM'}","{'word': '높은 수준의 자료형 추상화', 'start': 950, 'end': 963, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
357,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 어셈블러', 'start': 903, 'end': 913, 'type': 'COM'}","{'word': '함수 선언 및 호출', 'start': 938, 'end': 947, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
358,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 어셈블러', 'start': 903, 'end': 913, 'type': 'COM'}","{'word': '높은 수준의 언어 추상화 기능', 'start': 968, 'end': 983, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
359,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 언어 추상화 기능', 'start': 968, 'end': 983, 'type': 'COM'}","{'word': '높은 수준의 자료형 추상화', 'start': 950, 'end': 963, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
360,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 언어 추상화 기능', 'start': 968, 'end': 983, 'type': 'COM'}","{'word': '함수 선언 및 호출', 'start': 938, 'end': 947, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
361,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 언어 추상화 기능', 'start': 968, 'end': 983, 'type': 'COM'}","{'word': '높은 수준의 프로시져', 'start': 926, 'end': 936, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
362,"높은 수준의 어셈블러는 고급 제어 구조, 높은 수준의 프로시져/함수 선언 및 호출, 높은 수준의 자료형 추상화 같은 높은 수준의 언어 추상화 기능을 제공하기도 한다.","{'word': '높은 수준의 언어 추상화 기능', 'start': 968, 'end': 983, 'type': 'COM'}","{'word': '고급 제어 구조', 'start': 916, 'end': 923, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
363,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': 'RISC 기반 아키텍처', 'start': 1028, 'end': 1039, 'type': 'COM'}","{'word': '현대의 어셈블러', 'start': 1045, 'end': 1052, 'type': 'COM'}",com:sub_concept,no_relation,no_relation
364,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': '현대의 어셈블러', 'start': 1045, 'end': 1052, 'type': 'COM'}","{'word': 'HP PA-RISC', 'start': 1013, 'end': 1022, 'type': 'COM'}",com:sub_concept,no_relation,no_relation
365,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': '현대의 어셈블러', 'start': 1045, 'end': 1052, 'type': 'COM'}","{'word': 'Sun Sparc', 'start': 1002, 'end': 1010, 'type': 'COM'}",com:sub_concept,no_relation,no_relation
366,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': '현대의 어셈블러', 'start': 1045, 'end': 1052, 'type': 'COM'}","{'word': 'MIPS', 'start': 996, 'end': 999, 'type': 'COM'}",com:sub_concept,no_relation,no_relation
367,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': '중앙처리장치', 'start': 1075, 'end': 1080, 'type': 'COM'}","{'word': '파이프라인', 'start': 1083, 'end': 1087, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
368,그러나 현대의 컴퓨터는 납득하기 어려운 지연 없이 다중 패스 어셈블리를 수행한다.,"{'word': '현대의 컴퓨터', 'start': 1369, 'end': 1375, 'type': 'COM'}","{'word': '다중 패스 어셈블리', 'start': 1393, 'end': 1402, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
369,다중 패스 어셈블러는 링크 프로세스를 더 빠르게 한다는 장점이 있다.,"{'word': '다중 패스 어셈블러', 'start': 1411, 'end': 1420, 'type': 'COM'}","{'word': '링크 프로세스', 'start': 1423, 'end': 1429, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
370,더 복잡한 고급 어셈블러는 다음과 같은 언어 추상물을 제공한다:,"{'word': '고급 어셈블러', 'start': 1456, 'end': 1462, 'type': 'COM'}","{'word': '언어 추상물', 'start': 1472, 'end': 1477, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
371,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '어셈블리어', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': '어셈블러 언어', 'start': 11, 'end': 17, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
372,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '어셈블리어', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': 'assembler language', 'start': 19, 'end': 36, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
373,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '어셈블러 언어', 'start': 11, 'end': 17, 'type': 'COM'}","{'word': '어셈블리어', 'start': 0, 'end': 4, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
374,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '어셈블러 언어', 'start': 11, 'end': 17, 'type': 'COM'}","{'word': 'assembler language', 'start': 19, 'end': 36, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
375,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': 'assembler language', 'start': 19, 'end': 36, 'type': 'COM'}","{'word': '어셈블리어', 'start': 0, 'end': 4, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
376,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': 'assembler language', 'start': 19, 'end': 36, 'type': 'COM'}","{'word': '어셈블러 언어', 'start': 11, 'end': 17, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
377,어셈블러(assembler)는 어셈블리어를 기계어 형태의 오브젝트 코드로 해석해 주는 컴퓨터 언어 번역 프로그램을 말한다.,"{'word': '어셈블러', 'start': 382, 'end': 385, 'type': 'COM'}","{'word': 'assembler', 'start': 387, 'end': 395, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
378,"몇몇 사람들은 이러한 명령어들을 어셈블러 언어라고 부르며, 어셈블리 언어라고 부르는 사람들도 있다.","{'word': '어셈블러 언어', 'start': 543, 'end': 549, 'type': 'COM'}","{'word': '명령어', 'start': 537, 'end': 539, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
379,"몇몇 사람들은 이러한 명령어들을 어셈블러 언어라고 부르며, 어셈블리 언어라고 부르는 사람들도 있다.","{'word': '어셈블리 언어', 'start': 558, 'end': 564, 'type': 'COM'}","{'word': '명령어', 'start': 537, 'end': 539, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
380,"몇몇 사람들은 이러한 명령어들을 어셈블러 언어라고 부르며, 어셈블리 언어라고 부르는 사람들도 있다.","{'word': '명령어', 'start': 537, 'end': 539, 'type': 'COM'}","{'word': '어셈블러 언어', 'start': 543, 'end': 549, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
381,"몇몇 사람들은 이러한 명령어들을 어셈블러 언어라고 부르며, 어셈블리 언어라고 부르는 사람들도 있다.","{'word': '어셈블리 언어', 'start': 558, 'end': 564, 'type': 'COM'}","{'word': '어셈블러 언어', 'start': 543, 'end': 549, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
382,"몇몇 사람들은 이러한 명령어들을 어셈블러 언어라고 부르며, 어셈블리 언어라고 부르는 사람들도 있다.","{'word': '어셈블러 언어', 'start': 543, 'end': 549, 'type': 'COM'}","{'word': '어셈블리 언어', 'start': 558, 'end': 564, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
383,"몇몇 사람들은 이러한 명령어들을 어셈블러 언어라고 부르며, 어셈블리 언어라고 부르는 사람들도 있다.","{'word': '명령어', 'start': 537, 'end': 539, 'type': 'COM'}","{'word': '어셈블리 언어', 'start': 558, 'end': 564, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
384,니모닉 기호(mnemonics)를 opcode로 변환하고 메모리 위치와 기타 존재물에 따라 식별자를 다시 분석함으로써 목적 코드를 만들어낸다.,"{'word': '니모닉 기호', 'start': 581, 'end': 586, 'type': 'COM'}","{'word': 'mnemonics', 'start': 588, 'end': 596, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
385,거꾸로 기계어를 어셈블리어로 바꾸는 것은 “역(逆)어셈블러”(disassembler)이다.,"{'word': '역(逆)어셈블러', 'start': 685, 'end': 692, 'type': 'COM'}","{'word': 'disassembler', 'start': 695, 'end': 706, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
386,거꾸로 기계어를 어셈블리어로 바꾸는 것은 “역(逆)어셈블러”(disassembler)이다.,"{'word': 'disassembler', 'start': 695, 'end': 706, 'type': 'COM'}","{'word': '역(逆)어셈블러', 'start': 685, 'end': 692, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
387,어셈블러가 실행되는 단계를 어셈블리 타임이라고 한다.,"{'word': '어셈블리 타임', 'start': 1216, 'end': 1222, 'type': 'COM'}","{'word': '어셈블러가 실행되는 단계', 'start': 1201, 'end': 1213, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
388,기계어는 실제로 컴퓨터의 CPU가 읽어서 실행할 수 있는 0과 1로 이루어진 명령어의 조합이다.,"{'word': '기계어', 'start': 1486, 'end': 1488, 'type': 'COM'}","{'word': '명령어의 조합', 'start': 1529, 'end': 1535, 'type': 'COM'}",com:alter_names,no_relation,no_relation
389,이러한 각 명령어에 대해 사람이 알아보기 쉬운 니모닉 기호(mnemonic symbol)를 정해 사람이 좀 더 쉽게 컴퓨터의 행동을 제어할 수 있도록 한 것이 어셈블리 언어이다.,"{'word': '니모닉 기호', 'start': 1566, 'end': 1571, 'type': 'COM'}","{'word': 'mnemonic symbol', 'start': 1573, 'end': 1587, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
390,어셈블리어() 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.,"{'word': '어셈블리어', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': '기계어', 'start': 40, 'end': 42, 'type': 'COM'}",no_relation,com:similar_technology,com:similar_technology
391,"컴퓨터 구조에 따라 사용하는 기계어가 달라지며, 따라서 기계어에 대응되어 만들어지는 어셈블리어도 각각 다르게 된다.","{'word': '기계어', 'start': 107, 'end': 109, 'type': 'COM'}","{'word': '어셈블리어', 'start': 123, 'end': 127, 'type': 'COM'}",no_relation,com:similar_technology,com:similar_technology
392,"컴퓨터 CPU마다 지원하는 오퍼레이션의 타입과 개수는 제각각이며, 레지스터의 크기와 개수, 저장된 데이터 형의 표현도 각기 다르다.","{'word': '오퍼레이션', 'start': 156, 'end': 160, 'type': 'COM'}","{'word': '레지스터', 'start': 178, 'end': 181, 'type': 'COM'}",no_relation,no_relation,no_relation
393,"모든 범용 컴퓨터는 기본적으로 동일한 기능을 수행하지만, 기능을 어떤 과정을 거쳐 수행할지는 다를 수 있으며, 이런 차이는 어셈블리어에 반영되게 된다.","{'word': '범용 컴퓨터', 'start': 218, 'end': 223, 'type': 'COM'}","{'word': '어셈블리어', 'start': 284, 'end': 288, 'type': 'COM'}",no_relation,no_relation,no_relation
394,"어셈블러는 기본 컴퓨터 명령어들을, 컴퓨터 프로세서가 기본 연산을 수행하는데 사용할 수 있는 비트 패턴으로 변환시키는 프로그램이다.","{'word': '기본 컴퓨터 명령어', 'start': 457, 'end': 466, 'type': 'COM'}","{'word': '컴퓨터 프로세서', 'start': 471, 'end': 478, 'type': 'COM'}",no_relation,no_relation,no_relation
395,"고급 언어와는 달리 어셈블리어는 간단한 문장에 대해 기계어와 일대일 대응 관계가 있지만, 자주 쓰이는 몇 명령은 둘 이상의 기계어 명령을 묶어 하나의 어셈블리 명령어에 대응시키기도 한다.","{'word': '기계어', 'start': 741, 'end': 743, 'type': 'COM'}","{'word': '어셈블리어', 'start': 723, 'end': 727, 'type': 'COM'}",no_relation,com:similar_technology,com:similar_technology
396,"이것은 어셈블리 명령 부호를 오피코드로 해석할 뿐만 아니라 메모리의 위치들을 이름으로 표시하는 기능, 매크로를 통한 문장 치환 기능 등을 함께 제공한다.","{'word': '어셈블리 명령 부호', 'start': 821, 'end': 830, 'type': 'COM'}","{'word': '오피코드', 'start': 833, 'end': 836, 'type': 'COM'}",no_relation,com:alternative_names,com:alternative_names
397,"이 어셈블러는 1950년대부터 계속 쓰여 왔으며, 고급 언어를 위한 컴파일러에 견주어 보면 구조가 매우 간단하다.","{'word': '컴파일러', 'start': 1144, 'end': 1147, 'type': 'COM'}","{'word': '어셈블러', 'start': 1108, 'end': 1111, 'type': 'COM'}",no_relation,com:similar_technology,com:similar_technology
398,크로스 어셈블러는 다른 프로세서를 위한 코드를 만든다.,"{'word': '크로스 어셈블러', 'start': 1170, 'end': 1177, 'type': 'COM'}","{'word': '프로세서', 'start': 1183, 'end': 1186, 'type': 'COM'}",no_relation,no_relation,no_relation
399,"어셈블러에는 두 가지 종류가 있는데, 실행 프로그램을 만들기 위해 얼마나 많은 패스가 소스를 거치는지에 따라 다르다.","{'word': '어셈블러', 'start': 1231, 'end': 1234, 'type': 'COM'}","{'word': '실행 프로그램', 'start': 1252, 'end': 1258, 'type': 'COM'}",no_relation,no_relation,no_relation
400,게다가 단일 명령 집합에 대해 여러 니모닉과 통사론이 대응될 수 있다.,"{'word': '니모닉', 'start': 320, 'end': 322, 'type': 'COM'}","{'word': '통사론', 'start': 325, 'end': 327, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
401,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': 'MIPS', 'start': 996, 'end': 999, 'type': 'COM'}","{'word': 'Sun Sparc', 'start': 1002, 'end': 1010, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
402,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': 'MIPS', 'start': 996, 'end': 999, 'type': 'COM'}","{'word': 'HP PA-RISC', 'start': 1013, 'end': 1022, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
403,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': 'HP PA-RISC', 'start': 1013, 'end': 1022, 'type': 'COM'}","{'word': 'MIPS', 'start': 996, 'end': 999, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
404,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': 'Sun Sparc', 'start': 1002, 'end': 1010, 'type': 'COM'}","{'word': 'MIPS', 'start': 996, 'end': 999, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
405,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': 'Sun Sparc', 'start': 1002, 'end': 1010, 'type': 'COM'}","{'word': 'HP PA-RISC', 'start': 1013, 'end': 1022, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
406,"MIPS, Sun Sparc, HP PA-RISC과 같은 RISC 기반 아키텍처를 위한 현대의 어셈블러는 함수 스케줄링 기능을 가지고 있어서 중앙처리장치의 파이프라인을 효과적으로 사용할 수 있다.","{'word': 'HP PA-RISC', 'start': 1013, 'end': 1022, 'type': 'COM'}","{'word': 'Sun Sparc', 'start': 1002, 'end': 1010, 'type': 'COM'}",com:similar_tech,com:similar_technology,com:similar_technology
407,역사적으로 바이트코드는 대부분의 명령 집합이 0개 이상의 매개 변수를 갖는 1바이트 크기의 명령 코드(opcode)였기 때문에 바이트코드라 불리게 되었다.,"{'word': '명령 코드', 'start': 178, 'end': 182, 'type': 'COM'}","{'word': '바이트코드', 'start': 133, 'end': 137, 'type': 'COM'}",com:sub_concept,com:sub_concept,com:sub_concept
408,이러한 형태의 바이트코드 인터프리터는 높은 이식성을 갖는다.,"{'word': '바이트코드 인터프리터', 'start': 605, 'end': 615, 'type': 'COM'}","{'word': '이식성', 'start': 621, 'end': 623, 'type': 'POH'}",com:sub_concept,com:sub_concept,com:sub_concept
409,"바이트코드(, portable code, p-code)는 특정 하드웨어가 아닌 가상 컴퓨터에서 돌아가는 실행 프로그램을 위한 이진 표현법이다.","{'word': '바이트코드', 'start': 0, 'end': 4, 'type': 'COM'}","{'word': 'p-code', 'start': 23, 'end': 28, 'type': 'COM'}",com:alter_names,com:alternative_names,com:alternative_names
410,"하드웨어가 아닌 소프트웨어에 의해 처리되기 때문에, 보통 기계어보다 더 추상적이다.","{'word': '하드웨어', 'start': 80, 'end': 83, 'type': 'COM'}","{'word': '소프트웨어', 'start': 89, 'end': 93, 'type': 'COM'}",no_relation,no_relation,no_relation
411,"바이트코드는 특정 하드웨어에 대한 의존성을 줄이고, 인터프리팅도 쉬운 결과물을 생성하고자 하는 프로그래밍 언어에 의해, 출력 코드의 한 형태로 사용된다.","{'word': '바이트코드', 'start': 214, 'end': 218, 'type': 'COM'}","{'word': '하드웨어', 'start': 224, 'end': 227, 'type': 'COM'}",no_relation,no_relation,no_relation
412,"컴파일되어 만들어진 바이트코드는 특정 하드웨어의 기계 코드를 만드는 컴파일러의 입력으로 사용되거나, 가상 컴퓨터에서 바로 실행된다.","{'word': '바이트코드', 'start': 311, 'end': 315, 'type': 'COM'}","{'word': '컴파일러', 'start': 338, 'end': 341, 'type': 'COM'}",no_relation,no_relation,no_relation
413,"사람이 읽기 쉽도록 쓰인 소스 코드와 비교하면, 바이트 코드는 덜 추상적이며, 더 간결하고, 더 컴퓨터 중심적이다.","{'word': '소스 코드', 'start': 388, 'end': 392, 'type': 'COM'}","{'word': '바이트 코드', 'start': 401, 'end': 406, 'type': 'COM'}",no_relation,com:similar_technology,com:similar_technology
414,예를 들어 바이트코드는 변수의 접근 범위(지역변수 또는 전역변수 인지 여부) 등과 같은 의미 분석 단계의 결과를 부호화한다.,"{'word': '바이트코드', 'start': 445, 'end': 449, 'type': 'COM'}","{'word': '전역변수', 'start': 470, 'end': 473, 'type': 'COM'}",no_relation,com:sub_concept,com:sub_concept
415,바이트코드 프로그램은 보통 한 번에 하나의 명령어를 읽은 후 실행한다.,"{'word': '바이트코드 프로그램', 'start': 557, 'end': 566, 'type': 'COM'}","{'word': '명령어', 'start': 581, 'end': 583, 'type': 'COM'}",no_relation,no_relation,no_relation
416,"또 다른 형태로서 실시간 번역기 또는 저스트 인 타임(just-in-time, JIT) 컴파일러라 불리는 시스템은 실행 중에 필요에 따라서 바이트코드를 기계어로 번역한다.","{'word': '바이트코드', 'start': 709, 'end': 713, 'type': 'COM'}","{'word': '기계어', 'start': 716, 'end': 718, 'type': 'COM'}",no_relation,no_relation,no_relation
417,"이 방법은 가상 컴퓨터의 이식성을 없애지만, 바이트코드 자체에 대한 이식성을 잃지는 않는다.","{'word': '바이트코드', 'start': 752, 'end': 756, 'type': 'COM'}","{'word': '가상 컴퓨터', 'start': 733, 'end': 738, 'type': 'COM'}",no_relation,no_relation,no_relation
418,"예를 들어, 자바와 C# 코드는 보통 바이트코드 형태로 컴파일되어 저장되며, 실행 전에 JIT 컴파일러에 의해 기계 코드로 번역된다.","{'word': '자바', 'start': 786, 'end': 787, 'type': 'COM'}","{'word': 'JIT 컴파일러', 'start': 828, 'end': 835, 'type': 'COM'}",no_relation,no_relation,no_relation
419,"이 번역으로 인해 프로그램 실행 전에 지연시간이 발생하게 되지만, 보통 인터프리터보다는 훨씬 좋은 성능을 보여 준다.","{'word': '지연시간', 'start': 875, 'end': 878, 'type': 'COM'}","{'word': '프로그램', 'start': 864, 'end': 867, 'type': 'COM'}",no_relation,no_relation,no_relation
420,그래서 일반적으로 소스 코드를 직접 분석/실행하는 것보다 더 좋은 성능을 보여 준다.,"{'word': '소스 코드', 'start': 519, 'end': 523, 'type': 'COM'}","{'word': '성능', 'start': 546, 'end': 547, 'type': 'POH'}",no_relation,no_relation,no_relation
