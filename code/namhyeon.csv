id,sentence,subject_entity,object_entity,label
0,사용자는 직접 이러한 소프트웨어를 제작하고도 이를 중요하게 여기지 않을 때가 많다.,"{'word': '사용자', 'start': 835, 'end': 837, 'type': 'PER'}","{'word': '소프트웨어', 'start': 847, 'end': 851, 'type': 'COM'}",per:production
1,"발전소는 전기를 생산하지만, 전등과 같은 응용품을 이용하기 전에는 그 자체가 빛을 내는 등의 사용자가 바라는 기능을 수행하지는 않는다.","{'word': '발전소', 'start': 396, 'end': 398, 'type': 'ORG'}","{'word': '전기', 'start': 401, 'end': 402, 'type': 'POH'}",org:production
2,응용 소프트웨어() 또는 애플리케이션은 운영 체제에서 실행되는 모든 소프트웨어를 뜻한다.,"{'word': '소프트웨어', 'start': 38, 'end': 42, 'type': 'COM'}","{'word': '애플리케이션', 'start': 14, 'end': 19, 'type': 'COM'}",com:sub_concept
3,응용 소프트웨어() 또는 애플리케이션은 운영 체제에서 실행되는 모든 소프트웨어를 뜻한다.,"{'word': '소프트웨어', 'start': 38, 'end': 42, 'type': 'COM'}","{'word': '응용 소프트웨어', 'start': 0, 'end': 7, 'type': 'COM'}",com:sub_concept
4,"따라서, 워드프로세서, 스프레드시트, 웹브라우저들뿐만 아니라 컴파일러나 링커 등도 응용 소프트웨어에 속한다.","{'word': '응용 소프트웨어', 'start': 96, 'end': 103, 'type': 'COM'}","{'word': '링커', 'start': 90, 'end': 91, 'type': 'COM'}",com:sub_concept
5,"따라서, 워드프로세서, 스프레드시트, 웹브라우저들뿐만 아니라 컴파일러나 링커 등도 응용 소프트웨어에 속한다.","{'word': '응용 소프트웨어', 'start': 96, 'end': 103, 'type': 'COM'}","{'word': '컴파일러', 'start': 84, 'end': 87, 'type': 'COM'}",com:sub_concept
6,"따라서, 워드프로세서, 스프레드시트, 웹브라우저들뿐만 아니라 컴파일러나 링커 등도 응용 소프트웨어에 속한다.","{'word': '응용 소프트웨어', 'start': 96, 'end': 103, 'type': 'COM'}","{'word': '웹브라우저', 'start': 71, 'end': 75, 'type': 'COM'}",com:sub_concept
7,"따라서, 워드프로세서, 스프레드시트, 웹브라우저들뿐만 아니라 컴파일러나 링커 등도 응용 소프트웨어에 속한다.","{'word': '응용 소프트웨어', 'start': 96, 'end': 103, 'type': 'COM'}","{'word': '스프레드시트', 'start': 63, 'end': 68, 'type': 'COM'}",com:sub_concept
8,"따라서, 워드프로세서, 스프레드시트, 웹브라우저들뿐만 아니라 컴파일러나 링커 등도 응용 소프트웨어에 속한다.","{'word': '응용 소프트웨어', 'start': 96, 'end': 103, 'type': 'COM'}","{'word': '워드프로세서', 'start': 55, 'end': 60, 'type': 'COM'}",com:sub_concept
9,또는 좁은 의미에서는 OS 위에서 사용자가 직접 사용하게되는 소프트웨어들을 뜻한다.,"{'word': 'OS', 'start': 123, 'end': 124, 'type': 'COM'}","{'word': '소프트웨어', 'start': 145, 'end': 149, 'type': 'COM'}",com:sub_concept
10,이런 경우 컴파일러나 링커등 시스템소프트웨어를 제외한 워드프로세서등의 소프트웨어들만을 주로 뜻한다.,"{'word': '시스템소프트웨어', 'start': 174, 'end': 181, 'type': 'COM'}","{'word': '링커', 'start': 170, 'end': 171, 'type': 'COM'}",com:sub_concept
11,이런 경우 컴파일러나 링커등 시스템소프트웨어를 제외한 워드프로세서등의 소프트웨어들만을 주로 뜻한다.,"{'word': '시스템소프트웨어', 'start': 174, 'end': 181, 'type': 'COM'}","{'word': '컴파일러', 'start': 164, 'end': 167, 'type': 'COM'}",com:sub_concept
12,이런 경우 컴파일러나 링커등 시스템소프트웨어를 제외한 워드프로세서등의 소프트웨어들만을 주로 뜻한다.,"{'word': '소프트웨어', 'start': 197, 'end': 201, 'type': 'COM'}","{'word': '워드프로세서', 'start': 188, 'end': 193, 'type': 'COM'}",com:sub_concept
13,응용 프로그램 제품군은 하나의 꾸러미로 묶인 여러 개의 응용 프로그램을 말한다.,"{'word': '응용 프로그램 제품군', 'start': 472, 'end': 482, 'type': 'COM'}","{'word': '응용 프로그램', 'start': 503, 'end': 509, 'type': 'COM'}",com:sub_concept
14,"워드 프로세서와 스프레드시트, 그 밖에 몇몇의 응용 프로그램들이 함께 포함된 마이크로소프트 오피스가 대표적인 예이다.","{'word': '마이크로소프트 오피스', 'start': 560, 'end': 570, 'type': 'COM'}","{'word': '스프레드시트', 'start': 526, 'end': 531, 'type': 'COM'}",com:sub_concept
15,"워드 프로세서와 스프레드시트, 그 밖에 몇몇의 응용 프로그램들이 함께 포함된 마이크로소프트 오피스가 대표적인 예이다.","{'word': '마이크로소프트 오피스', 'start': 560, 'end': 570, 'type': 'COM'}","{'word': '워드 프로세서', 'start': 517, 'end': 523, 'type': 'COM'}",com:sub_concept
16,하나의 꾸러미로 묶인 응용 프로그램들은 대개 사용자가 배우거나 사용하기 쉽게 짜여진 일관된 사용자 인터페이스를 사용한다.,"{'word': '응용 프로그램', 'start': 595, 'end': 601, 'type': 'COM'}","{'word': '사용자 인터페이스', 'start': 634, 'end': 642, 'type': 'COM'}",com:sub_concept
17,"VCR, DVD 플레이어, 전자레인지와 같은 임베디드 시스템에서는 응용 소프트웨어와 운영 체제 소프트웨어를 구별하기 어려울 수도 있다.","{'word': '임베디드 시스템', 'start': 907, 'end': 914, 'type': 'COM'}","{'word': '전자레인지', 'start': 897, 'end': 901, 'type': 'COM'}",com:sub_concept
18,"VCR, DVD 플레이어, 전자레인지와 같은 임베디드 시스템에서는 응용 소프트웨어와 운영 체제 소프트웨어를 구별하기 어려울 수도 있다.","{'word': '임베디드 시스템', 'start': 907, 'end': 914, 'type': 'COM'}","{'word': 'DVD 플레이어', 'start': 887, 'end': 894, 'type': 'COM'}",com:sub_concept
19,"VCR, DVD 플레이어, 전자레인지와 같은 임베디드 시스템에서는 응용 소프트웨어와 운영 체제 소프트웨어를 구별하기 어려울 수도 있다.","{'word': '임베디드 시스템', 'start': 907, 'end': 914, 'type': 'COM'}","{'word': 'VCR', 'start': 882, 'end': 884, 'type': 'COM'}",com:sub_concept
20,간단하게 줄여서 애플리케이션이라고 하며 준말로 앱(app)이라도 부른다.,"{'word': '애플리케이션', 'start': 276, 'end': 281, 'type': 'COM'}","{'word': '앱(app)', 'start': 293, 'end': 298, 'type': 'COM'}",com:alter_names
21,이렇게 뜻을 한정할 경우 응용 소프트웨어는 시스템 소프트웨어의 여집합이라고도 생각할 수 있다.,"{'word': '응용 소프트웨어', 'start': 228, 'end': 235, 'type': 'COM'}","{'word': '시스템 소프트웨어', 'start': 238, 'end': 246, 'type': 'COM'}",no_relation
22,"쉽지만 꽤 정확하지는 않은 비유를 쓰자면, 이것은 하드웨어의 세계에서 전기 불빛을 응용 프로그램(애플리케이션)이라 하고, 발전소를 시스템이라고 할 수 있다.","{'word': '하드웨어', 'start': 336, 'end': 339, 'type': 'COM'}","{'word': '응용 프로그램', 'start': 354, 'end': 360, 'type': 'COM'}",no_relation
23,그리고 이들은 보통 사용자의 편의를 위해 응용 프로그램 사이에 상호 작용하는 기능을 가진다.,"{'word': '사용자', 'start': 662, 'end': 664, 'type': 'COM'}","{'word': '응용 프로그램', 'start': 674, 'end': 680, 'type': 'COM'}",no_relation
24,"예를 들어, 한 스프레드시트에 워드 프로세서의 문서를 포함할 수 있고, 게다가 다른 종류의 스프레드시트 응용 프로그램에서 이 스프레드시트의 문서를 만들 수도 있다.","{'word': '스프레드시트', 'start': 712, 'end': 717, 'type': 'COM'}","{'word': '워드 프로세서', 'start': 720, 'end': 726, 'type': 'COM'}",no_relation
25,사용자 소프트웨어는 시스템이 사용자에 특화된 요구에 적합하도록 만든다.,"{'word': '사용자 소프트웨어', 'start': 795, 'end': 803, 'type': 'COM'}","{'word': '시스템', 'start': 806, 'end': 808, 'type': 'COM'}",no_relation
26,"VCR, DVD 플레이어, 전자레인지와 같은 임베디드 시스템에서는 응용 소프트웨어와 운영 체제 소프트웨어를 구별하기 어려울 수도 있다.","{'word': '응용 소프트웨어', 'start': 919, 'end': 926, 'type': 'COM'}","{'word': '운영 체제 소프트웨어', 'start': 929, 'end': 939, 'type': 'COM'}",com:similar_tech
27,"마이크로소프트 파운데이션 클래스 라이브러리(, MFC)는 마이크로소프트에서 만든 윈도 API를 C++로 둘러 싼 라이브러리이다.","{'word': '마이크로소프트', 'start': 56, 'end': 62, 'type': 'ORG'}","{'word': '마이크로소프트 파운데이션 클래스 라이브러리', 'start': 24, 'end': 46, 'type': 'COM'}",org:production
28,마이크로소프트는 개발도구 시장에서 경쟁력을 얻기 위해 C++을 활용하여 MFC를 만들었다.,"{'word': '마이크로소프트', 'start': 234, 'end': 240, 'type': 'ORG'}","{'word': 'MFC', 'start': 274, 'end': 276, 'type': 'COM'}",org:production
29,MFC의 구조는 후에 시맨틱사에 매각된 매킨토시의 TCL(Think Class Library)에서 영향을 받았다.,"{'word': '매킨토시', 'start': 307, 'end': 310, 'type': 'ORG'}","{'word': 'TCL(Think Class Library)', 'start': 313, 'end': 336, 'type': 'COM'}",org:production
30,볼랜드의 터보 C++과 터보 파스칼에서는 OWL(Object Windows Library)이란 경쟁제품이 있었다.,"{'word': '볼랜드의 터보 C++과 터보 파스칼', 'start': 349, 'end': 367, 'type': 'ORG'}","{'word': 'OWL(Object Windows Library)', 'start': 372, 'end': 398, 'type': 'COM'}",org:production
31,"그 이후 볼랜드는 OWL의 개발을 중단하고, 이를 대체하는 VCL을 개발하여 델파이와 C++빌더에서 사용하고 있다.","{'word': '볼랜드', 'start': 520, 'end': 522, 'type': 'ORG'}","{'word': 'VCL', 'start': 548, 'end': 550, 'type': 'COM'}",org:production
32,"그 이후 볼랜드는 OWL의 개발을 중단하고, 이를 대체하는 VCL을 개발하여 델파이와 C++빌더에서 사용하고 있다.","{'word': '볼랜드', 'start': 520, 'end': 522, 'type': 'ORG'}","{'word': 'OWL', 'start': 525, 'end': 527, 'type': 'COM'}",org:production
33,"마이크로소프트에서 MFC가 만들어졌음에도 많은 프로그래머들에게 MFC는 너무 복잡했기 때문에, 마이크로소프트는 상용 소프트웨어 개발에 비주얼 베이직을 쓰라고 권장하였다.","{'word': '마이크로소프트', 'start': 609, 'end': 615, 'type': 'ORG'}","{'word': 'MFC', 'start': 619, 'end': 621, 'type': 'COM'}",org:production
34,"Mainsoft가 만든 유닉스용 MFC가 있으며, 1990년대 마이크로소프트는 맥 OS용 MFC를 만들기도 했지만, 계속 개발하지 않았다.","{'word': 'Mainsoft', 'start': 1306, 'end': 1313, 'type': 'ORG'}","{'word': '유닉스용 MFC', 'start': 1319, 'end': 1326, 'type': 'COM'}",org:production
35,"Mainsoft가 만든 유닉스용 MFC가 있으며, 1990년대 마이크로소프트는 맥 OS용 MFC를 만들기도 했지만, 계속 개발하지 않았다.","{'word': '마이크로소프트', 'start': 1341, 'end': 1347, 'type': 'ORG'}","{'word': '맥 OS용 MFC', 'start': 1350, 'end': 1358, 'type': 'COM'}",org:production
36,MFC는 1992년 16비트 윈도용 마이크로소프트 C/C++ 7.0 컴파일러에서 처음 도입되었다.,"{'word': '윈도용 마이크로소프트 C/C++ 7.0 컴파일러', 'start': 152, 'end': 177, 'type': 'COM'}","{'word': 'MFC', 'start': 136, 'end': 138, 'type': 'COM'}",com:sub_concept
37,그 당시에는 C++이 소프트웨어 제품 개발 언어로 활용되기 시작하던 때였다.,"{'word': '소프트웨어 제품 개발 언어', 'start': 203, 'end': 216, 'type': 'COM'}","{'word': 'C++', 'start': 198, 'end': 200, 'type': 'COM'}",com:sub_concept
38,C++빌더는 MFC를 라이선스 받아 포함하고 있다.,"{'word': 'C++빌더', 'start': 580, 'end': 584, 'type': 'COM'}","{'word': 'MFC', 'start': 587, 'end': 589, 'type': 'COM'}",com:sub_concept
39,비주얼 베이직을 강조하면서도 새 버전의 비주얼 스튜디오에는 항상 MFC가 공급되었다.,"{'word': '비주얼 스튜디오', 'start': 849, 'end': 856, 'type': 'COM'}","{'word': 'MFC', 'start': 863, 'end': 865, 'type': 'COM'}",com:sub_concept
40,"MFC가 처음 도입되었을 때 마이크로소프트는 기본적인 C++ 문법에 메시지 처리, 예외 처리, 런타임 처리, 동적 클래스 객체 생성을 위한 매크로를 추가해 C++ 언어를 확장하려 했다.","{'word': 'C++ 문법', 'start': 935, 'end': 940, 'type': 'COM'}","{'word': '메시지 처리', 'start': 943, 'end': 948, 'type': 'COM'}",com:sub_concept
41,"MFC가 처음 도입되었을 때 마이크로소프트는 기본적인 C++ 문법에 메시지 처리, 예외 처리, 런타임 처리, 동적 클래스 객체 생성을 위한 매크로를 추가해 C++ 언어를 확장하려 했다.","{'word': 'C++ 문법', 'start': 935, 'end': 940, 'type': 'COM'}","{'word': '예외 처리', 'start': 951, 'end': 955, 'type': 'COM'}",com:sub_concept
42,"MFC가 처음 도입되었을 때 마이크로소프트는 기본적인 C++ 문법에 메시지 처리, 예외 처리, 런타임 처리, 동적 클래스 객체 생성을 위한 매크로를 추가해 C++ 언어를 확장하려 했다.","{'word': 'C++ 문법', 'start': 935, 'end': 940, 'type': 'COM'}","{'word': '런타임 처리', 'start': 958, 'end': 963, 'type': 'COM'}",com:sub_concept
43,"MFC가 처음 도입되었을 때 마이크로소프트는 기본적인 C++ 문법에 메시지 처리, 예외 처리, 런타임 처리, 동적 클래스 객체 생성을 위한 매크로를 추가해 C++ 언어를 확장하려 했다.","{'word': 'C++ 문법', 'start': 935, 'end': 940, 'type': 'COM'}","{'word': '동적 클래스 객체 생성', 'start': 966, 'end': 977, 'type': 'COM'}",com:sub_concept
44,이런 매크로를 활용한 시스템은 컴파일러의 타입 검사를 무시하므로 버그를 가져올 수 있었다.,"{'word': '컴파일러', 'start': 1026, 'end': 1029, 'type': 'COM'}","{'word': '타입 검사', 'start': 1032, 'end': 1036, 'type': 'COM'}",com:sub_concept
45,"게다가 MFC의 문서/뷰 프레임워크는 데이터 모델과 유저 인터페이스, 제어 로직을 분리한다는 MVC 디자인을 자연스럽게 만들어준다.","{'word': 'MFC', 'start': 1200, 'end': 1202, 'type': 'COM'}","{'word': '문서/뷰 프레임워크', 'start': 1205, 'end': 1214, 'type': 'COM'}",com:sub_concept
46,"게다가 MFC의 문서/뷰 프레임워크는 데이터 모델과 유저 인터페이스, 제어 로직을 분리한다는 MVC 디자인을 자연스럽게 만들어준다.","{'word': 'MVC 디자인', 'start': 1248, 'end': 1254, 'type': 'COM'}","{'word': '데이터 모델', 'start': 1217, 'end': 1222, 'type': 'COM'}",com:sub_concept
47,"게다가 MFC의 문서/뷰 프레임워크는 데이터 모델과 유저 인터페이스, 제어 로직을 분리한다는 MVC 디자인을 자연스럽게 만들어준다.","{'word': 'MVC 디자인', 'start': 1248, 'end': 1254, 'type': 'COM'}","{'word': '유저 인터페이스', 'start': 1225, 'end': 1232, 'type': 'COM'}",com:sub_concept
48,"게다가 MFC의 문서/뷰 프레임워크는 데이터 모델과 유저 인터페이스, 제어 로직을 분리한다는 MVC 디자인을 자연스럽게 만들어준다.","{'word': 'MVC 디자인', 'start': 1248, 'end': 1254, 'type': 'COM'}","{'word': '제어 로직', 'start': 1235, 'end': 1239, 'type': 'COM'}",com:sub_concept
49,"MFC Feature Pack을 지원하여, 리본 메뉴 등의 UI를 IDE에서 자동으로 작성해준다.","{'word': 'UI', 'start': 1417, 'end': 1418, 'type': 'COM'}","{'word': '리본 메뉴', 'start': 1408, 'end': 1412, 'type': 'COM'}",com:sub_concept
50,"마이크로소프트 파운데이션 클래스 라이브러리 마이크로소프트 파운데이션 클래스 라이브러리(, MFC)는 마이크로소프트에서 만든 윈도 API를 C++로 둘러 싼 라이브러리이다.","{'word': '마이크로소프트 파운데이션 클래스 라이브러리', 'start': 0, 'end': 22, 'type': 'COM'}","{'word': 'MFC', 'start': 50, 'end': 52, 'type': 'COM'}",com:alter_names
51,"마이크로소프트 파운데이션 클래스 라이브러리(, MFC)는 마이크로소프트에서 만든 윈도 API를 C++로 둘러 싼 라이브러리이다.","{'word': '마이크로소프트 파운데이션 클래스 라이브러리', 'start': 24, 'end': 46, 'type': 'COM'}","{'word': 'MFC', 'start': 50, 'end': 52, 'type': 'COM'}",com:alter_names
52,마이크로소프트는 개발도구 시장에서 경쟁력을 얻기 위해 C++을 활용하여 MFC를 만들었다.,"{'word': 'MFC', 'start': 274, 'end': 276, 'type': 'COM'}","{'word': 'C++', 'start': 264, 'end': 266, 'type': 'COM'}",com:made_of
53,MFC와 비주얼 베이직의 후속작으로 Windows Forms가 출시되었으며 C++ 관리 모드 확장으로 쓸 수 있다.,"{'word': 'MFC와 비주얼 베이직', 'start': 704, 'end': 715, 'type': 'COM'}","{'word': 'Windows Forms', 'start': 724, 'end': 736, 'type': 'COM'}",com:prior_tech
54,"마이크로소프트에서 MFC가 만들어졌음에도 많은 프로그래머들에게 MFC는 너무 복잡했기 때문에, 마이크로소프트는 상용 소프트웨어 개발에 비주얼 베이직을 쓰라고 권장하였다.","{'word': '프로그래머', 'start': 635, 'end': 639, 'type': 'PER'}","{'word': 'MFC', 'start': 644, 'end': 646, 'type': 'COM'}",no_relation
55,그래서 많은 프로그래머들이 MFC를 사용하게 되었다.,"{'word': '프로그래머', 'start': 882, 'end': 886, 'type': 'PER'}","{'word': 'MFC', 'start': 890, 'end': 892, 'type': 'COM'}",no_relation
56,"객체 지향 모델을 더 엄격하게 따르고 있었기 때문에, OWL은 한때 MFC보다 인기 있었다. 하지만 윈도의 새로운 기능에 대한 업데이트가 늦어지게 되면서, 시장 지배력을 잃어버렸다.","{'word': 'OWL', 'start': 443, 'end': 445, 'type': 'COM'}","{'word': 'MFC', 'start': 451, 'end': 453, 'type': 'COM'}",no_relation
57,비주얼 스튜디오 2005 출시와 함께 닷넷 프레임워크의 기능들을 더 쉬운 문법으로 쓸 수 있게 되었다.,"{'word': '비주얼 스튜디오 2005', 'start': 769, 'end': 781, 'type': 'COM'}","{'word': '닷넷 프레임워크', 'start': 790, 'end': 797, 'type': 'COM'}",no_relation
58,32비트 버전의 MFC부터 이것이 개선되었다.,"{'word': 'MFC', 'start': 1069, 'end': 1071, 'type': 'COM'}","{'word': '32비트', 'start': 1060, 'end': 1063, 'type': 'COM'}",no_relation
59,MFC의 가장 큰 장점은 윈도 API를 객체지향적으로 프로그래밍할 수 있다는 것이다.,"{'word': 'MFC', 'start': 1086, 'end': 1088, 'type': 'COM'}","{'word': '윈도 API', 'start': 1100, 'end': 1105, 'type': 'COM'}",no_relation
60,또한 윈도의 자원과 연관된 형들은 그들을 생성한 객체가 죽게 되면 자동으로 핸들을 해제해 준다는 장점도 있다.,"{'word': '윈도', 'start': 1137, 'end': 1138, 'type': 'COM'}","{'word': '객체', 'start': 1161, 'end': 1162, 'type': 'COM'}",no_relation
61,하지만 MFC는 다중 운영체제를 지원하지 않는다는 약점이 있다.,"{'word': 'MFC', 'start': 1274, 'end': 1276, 'type': 'COM'}","{'word': '다중 운영체제', 'start': 1279, 'end': 1285, 'type': 'COM'}",no_relation
62,"Eisler (development lead), St. John, and Engstrom (program manager)은 함께 이 문제를 해결하여 솔루션을 내놓았는데 이 이름이 DirectX이다.","{'word': 'Engstrom', 'start': 1349, 'end': 1356, 'type': 'PER'}","{'word': 'program manager', 'start': 1359, 'end': 1373, 'type': 'POH'}",per:title
63,"마이크로소프트의 3명의 직원 Craig Eisler, Alex St. John, Eric Engstrom은 프로그래머들이 마이크로소프트의 이전 운영 체제인 MS-DOS를 더 나은 플랫폼으로 보는 경향이 있었기 때문에 걱정이 있었다.","{'word': 'Craig Eisler', 'start': 865, 'end': 876, 'type': 'PER'}","{'word': 'Alex St. John', 'start': 879, 'end': 891, 'type': 'PER'}",per:colleagues
64,"마이크로소프트의 3명의 직원 Craig Eisler, Alex St. John, Eric Engstrom은 프로그래머들이 마이크로소프트의 이전 운영 체제인 MS-DOS를 더 나은 플랫폼으로 보는 경향이 있었기 때문에 걱정이 있었다.","{'word': 'Craig Eisler', 'start': 865, 'end': 876, 'type': 'PER'}","{'word': 'Eric Engstrom', 'start': 894, 'end': 906, 'type': 'PER'}",per:colleagues
65,"마이크로소프트의 3명의 직원 Craig Eisler, Alex St. John, Eric Engstrom은 프로그래머들이 마이크로소프트의 이전 운영 체제인 MS-DOS를 더 나은 플랫폼으로 보는 경향이 있었기 때문에 걱정이 있었다.","{'word': 'Alex St. John', 'start': 879, 'end': 891, 'type': 'PER'}","{'word': 'Eric Engstrom', 'start': 894, 'end': 906, 'type': 'PER'}",per:colleagues
66,"Eisler (development lead), St. John, and Engstrom (program manager)은 함께 이 문제를 해결하여 솔루션을 내놓았는데 이 이름이 DirectX이다.","{'word': 'Eisler', 'start': 1308, 'end': 1313, 'type': 'PER'}","{'word': 'St. John', 'start': 1335, 'end': 1342, 'type': 'PER'}",per:colleagues
67,"Eisler (development lead), St. John, and Engstrom (program manager)은 함께 이 문제를 해결하여 솔루션을 내놓았는데 이 이름이 DirectX이다.","{'word': 'Eisler', 'start': 1308, 'end': 1313, 'type': 'PER'}","{'word': 'Engstrom', 'start': 1349, 'end': 1356, 'type': 'PER'}",per:colleagues
68,"Eisler (development lead), St. John, and Engstrom (program manager)은 함께 이 문제를 해결하여 솔루션을 내놓았는데 이 이름이 DirectX이다.","{'word': 'St. John', 'start': 1335, 'end': 1342, 'type': 'PER'}","{'word': 'Engstrom', 'start': 1349, 'end': 1356, 'type': 'PER'}",per:colleagues
69,"1994년 말, 마이크로소프트는 다음 운영 체제인 윈도우 95를 출시할 준비가 되었다.","{'word': '마이크로소프트', 'start': 809, 'end': 815, 'type': 'ORG'}","{'word': '윈도우 95', 'start': 828, 'end': 833, 'type': 'COM'}",org:production
70,"Microsoft DirectX()는 멀티미디어, 특히 게임 프로그래밍에서 마이크로소프트 플랫폼에서 작업을 위한 API의 집합이다.","{'word': 'API', 'start': 63, 'end': 65, 'type': 'COM'}","{'word': 'Microsoft DirectX', 'start': 0, 'end': 16, 'type': 'COM'}",com:sub_concept
71,다이렉트엑스는 또한 게임뿐 아니라 최근에 나온 3차원 그래픽 하드웨어를 사용하여 높은 품질의 3차원 그래픽을 빠르게 렌더링할 수 있기 때문에 소프트웨어 업계 전반에서 사용되기도 한다.,"{'word': '다이렉트엑스', 'start': 153, 'end': 158, 'type': 'COM'}","{'word': '3차원 그래픽 하드웨어', 'start': 179, 'end': 190, 'type': 'COM'}",com:sub_concept
72,다이렉트엑스 런타임과 소프트웨어 개발킷은 무료이지만 개조는 할 수 없는 클로즈드 소스(오픈 소스의 반대 개념) 소프트웨어이다.,"{'word': '클로즈드 소스', 'start': 296, 'end': 302, 'type': 'COM'}","{'word': '다이렉트엑스 런타임과 소프트웨어 개발킷', 'start': 256, 'end': 276, 'type': 'COM'}",com:sub_concept
73,"다이렉트엑스 런타임은 원래 컴퓨터 게임 개발자들에게만 공개되었으나, 최근에는 기본적으로 윈도우에 포함되어 있다.","{'word': '윈도우', 'start': 376, 'end': 378, 'type': 'COM'}","{'word': '다이렉트엑스 런타임', 'start': 327, 'end': 336, 'type': 'COM'}",com:sub_concept
74,그 까닭은 이러한 새로운 버전들은 윈도우 비스타에 도입되었던 새로운 윈도우 디스플레이 드라이버 모델이 있어야 동작하기 때문이다.,"{'word': '윈도우 비스타', 'start': 571, 'end': 577, 'type': 'COM'}","{'word': '윈도우 디스플레이 드라이버 모델', 'start': 590, 'end': 606, 'type': 'COM'}",com:sub_concept
75,"새로운 비스타/WDDM 그래픽스 구조에는 데스크톱 창 관리자와 같이, 그래픽 하드웨어를 여러 개의 응용 프로그램과 서비스에 가상화할 수 있게 도와 주는 새로운 비디오 메모리 관리자를 포함하고 있다.","{'word': '비스타/WDDM 그래픽스 구조', 'start': 693, 'end': 708, 'type': 'COM'}","{'word': '비디오 메모리 관리자', 'start': 778, 'end': 788, 'type': 'COM'}",com:sub_concept
76,"1994년 말, 마이크로소프트는 다음 운영 체제인 윈도우 95를 출시할 준비가 되었다.","{'word': '운영 체제', 'start': 821, 'end': 825, 'type': 'COM'}","{'word': '윈도우 95', 'start': 828, 'end': 833, 'type': 'COM'}",com:sub_concept
77,"마이크로소프트의 3명의 직원 Craig Eisler, Alex St. John, Eric Engstrom은 프로그래머들이 마이크로소프트의 이전 운영 체제인 MS-DOS를 더 나은 플랫폼으로 보는 경향이 있었기 때문에 걱정이 있었다.","{'word': '운영 체제', 'start': 929, 'end': 933, 'type': 'COM'}","{'word': 'MS-DOS', 'start': 936, 'end': 941, 'type': 'COM'}",com:sub_concept
78,라이온킹 비디오 게임의 윈도우 포팅에 관한 부정적인 반응이 함께했다.,"{'word': '라이온킹 비디오 게임', 'start': 1085, 'end': 1095, 'type': 'COM'}","{'word': '윈도우 포팅', 'start': 1098, 'end': 1103, 'type': 'COM'}",com:sub_concept
79,"도스는 비디오 카드, 키보드, 마우스, 사운드 장치, 그리고 시스템의 나머지 모든 부분들에 직접 접근을 허용하였던 반면에 윈도우 95는 보호 메모리 모델이 포함되어 이 모든 것들에 대한 접근을 제한하였다.","{'word': '도스', 'start': 1124, 'end': 1125, 'type': 'COM'}","{'word': '비디오 카드', 'start': 1128, 'end': 1133, 'type': 'COM'}",com:sub_concept
80,"도스는 비디오 카드, 키보드, 마우스, 사운드 장치, 그리고 시스템의 나머지 모든 부분들에 직접 접근을 허용하였던 반면에 윈도우 95는 보호 메모리 모델이 포함되어 이 모든 것들에 대한 접근을 제한하였다.","{'word': '도스', 'start': 1124, 'end': 1125, 'type': 'COM'}","{'word': '키보드', 'start': 1136, 'end': 1138, 'type': 'COM'}",com:sub_concept
81,"도스는 비디오 카드, 키보드, 마우스, 사운드 장치, 그리고 시스템의 나머지 모든 부분들에 직접 접근을 허용하였던 반면에 윈도우 95는 보호 메모리 모델이 포함되어 이 모든 것들에 대한 접근을 제한하였다.","{'word': '도스', 'start': 1124, 'end': 1125, 'type': 'COM'}","{'word': '마우스', 'start': 1141, 'end': 1143, 'type': 'COM'}",com:sub_concept
82,"도스는 비디오 카드, 키보드, 마우스, 사운드 장치, 그리고 시스템의 나머지 모든 부분들에 직접 접근을 허용하였던 반면에 윈도우 95는 보호 메모리 모델이 포함되어 이 모든 것들에 대한 접근을 제한하였다.","{'word': '도스', 'start': 1124, 'end': 1125, 'type': 'COM'}","{'word': '사운드 장치', 'start': 1146, 'end': 1151, 'type': 'COM'}",com:sub_concept
83,"도스는 비디오 카드, 키보드, 마우스, 사운드 장치, 그리고 시스템의 나머지 모든 부분들에 직접 접근을 허용하였던 반면에 윈도우 95는 보호 메모리 모델이 포함되어 이 모든 것들에 대한 접근을 제한하였다.","{'word': '윈도우 95', 'start': 1192, 'end': 1197, 'type': 'COM'}","{'word': '보호 메모리 모델', 'start': 1200, 'end': 1208, 'type': 'COM'}",com:sub_concept
84,"Microsoft DirectX()는 멀티미디어, 특히 게임 프로그래밍에서 마이크로소프트 플랫폼에서 작업을 위한 API의 집합이다.","{'word': 'Microsoft DirectX', 'start': 0, 'end': 16, 'type': 'COM'}","{'word': '게임 프로그래밍', 'start': 31, 'end': 38, 'type': 'COM'}",no_relation
85,"다이렉트엑스는 마이크로소프트 윈도우, 세가, 드림캐스트, 마이크로소프트 엑스박스 및 엑스박스 360을 위한 비디오 게임 개발에 널리 쓰인다.","{'word': '다이렉트엑스', 'start': 74, 'end': 79, 'type': 'COM'}","{'word': '마이크로소프트 윈도우', 'start': 82, 'end': 92, 'type': 'COM'}",no_relation
86,"다이렉트엑스는 마이크로소프트 윈도우, 세가, 드림캐스트, 마이크로소프트 엑스박스 및 엑스박스 360을 위한 비디오 게임 개발에 널리 쓰인다.","{'word': '다이렉트엑스', 'start': 74, 'end': 79, 'type': 'COM'}","{'word': '마이크로소프트 엑스박스 및 엑스박스 360', 'start': 106, 'end': 128, 'type': 'COM'}",no_relation
87,"다이렉트엑스는 마이크로소프트 윈도우, 세가, 드림캐스트, 마이크로소프트 엑스박스 및 엑스박스 360을 위한 비디오 게임 개발에 널리 쓰인다.","{'word': '다이렉트엑스', 'start': 74, 'end': 79, 'type': 'COM'}","{'word': '세가', 'start': 95, 'end': 96, 'type': 'COM'}",no_relation
88,"다이렉트엑스는 마이크로소프트 윈도우, 세가, 드림캐스트, 마이크로소프트 엑스박스 및 엑스박스 360을 위한 비디오 게임 개발에 널리 쓰인다.","{'word': '다이렉트엑스', 'start': 74, 'end': 79, 'type': 'COM'}","{'word': '드림캐스트', 'start': 99, 'end': 103, 'type': 'COM'}",no_relation
89,상위 버전으로 업데이트하고 싶을 경우 마이크로소프트의 공식 홈페이지를 통해 설치할 수 있다.,"{'word': '마이크로소프트', 'start': 411, 'end': 417, 'type': 'COM'}","{'word': '버전', 'start': 393, 'end': 394, 'type': 'COM'}",no_relation
90,그래서 DirectX 조건에 맞더라도 드라이버가 윈도우 디스플레이 드라이버 모델을 지원하지 않으면 사용할 수 없다.,"{'word': 'DirectX', 'start': 628, 'end': 634, 'type': 'COM'}","{'word': '윈도우 디스플레이 드라이버 모델', 'start': 651, 'end': 667, 'type': 'COM'}",no_relation
91,"마이크로소프트는 프로그래머들을 위한 조속한 솔루션이 필요했는데, 이 운영 체제가 출시되기 수개월 밖에 안 남았기 때문이다.","{'word': '마이크로소프트', 'start': 1239, 'end': 1245, 'type': 'COM'}","{'word': '운영 체제', 'start': 1277, 'end': 1281, 'type': 'COM'}",no_relation
92,이 라이브러리들 가운데 대다수가 크로스플랫폼이거나 오픈 코드에 기반을 두고 있다.,"{'word': '크로스플랫폼', 'start': 1543, 'end': 1548, 'type': 'COM'}","{'word': '오픈 코드', 'start': 1553, 'end': 1557, 'type': 'COM'}",no_relation
93,"Direct3D 9Ex, Direct3D 10은 윈도우 비스타 이상, Direct3D 11은 윈도우 비스타 SP2 또는 윈도우 7 이상, Direct3D 12는 윈도우 10에서만 사용할 수 있다.","{'word': 'Direct3D 9Ex', 'start': 442, 'end': 453, 'type': 'COM'}","{'word': 'Direct3D 10', 'start': 456, 'end': 466, 'type': 'COM'}",com:similar_tech
94,"Direct3D 9Ex, Direct3D 10은 윈도우 비스타 이상, Direct3D 11은 윈도우 비스타 SP2 또는 윈도우 7 이상, Direct3D 12는 윈도우 10에서만 사용할 수 있다.","{'word': 'Direct3D 9Ex', 'start': 442, 'end': 453, 'type': 'COM'}","{'word': 'Direct3D 11', 'start': 481, 'end': 491, 'type': 'COM'}",com:similar_tech
95,"Direct3D 9Ex, Direct3D 10은 윈도우 비스타 이상, Direct3D 11은 윈도우 비스타 SP2 또는 윈도우 7 이상, Direct3D 12는 윈도우 10에서만 사용할 수 있다.","{'word': 'Direct3D 9Ex', 'start': 442, 'end': 453, 'type': 'COM'}","{'word': 'Direct3D 12', 'start': 519, 'end': 529, 'type': 'COM'}",com:similar_tech
96,"Direct3D 9Ex, Direct3D 10은 윈도우 비스타 이상, Direct3D 11은 윈도우 비스타 SP2 또는 윈도우 7 이상, Direct3D 12는 윈도우 10에서만 사용할 수 있다.","{'word': '윈도우 비스타', 'start': 469, 'end': 475, 'type': 'COM'}","{'word': '윈도우 비스타 SP2', 'start': 494, 'end': 504, 'type': 'COM'}",com:similar_tech
97,"Direct3D 9Ex, Direct3D 10은 윈도우 비스타 이상, Direct3D 11은 윈도우 비스타 SP2 또는 윈도우 7 이상, Direct3D 12는 윈도우 10에서만 사용할 수 있다.","{'word': '윈도우 비스타', 'start': 469, 'end': 475, 'type': 'COM'}","{'word': '윈도우 7', 'start': 509, 'end': 513, 'type': 'COM'}",com:similar_tech
98,"Direct3D 9Ex, Direct3D 10은 윈도우 비스타 이상, Direct3D 11은 윈도우 비스타 SP2 또는 윈도우 7 이상, Direct3D 12는 윈도우 10에서만 사용할 수 있다.","{'word': '윈도우 비스타', 'start': 469, 'end': 475, 'type': 'COM'}","{'word': '윈도우 10', 'start': 532, 'end': 537, 'type': 'COM'}",com:similar_tech
99,"MS-DOS가 게임 프로그래밍을 위한 더 나은 플랫폼으로 비쳐졌는데, 그 이유는 윈도우 95용으로 개발된 게임이 거의 없어서 운영 체제가 큰 성공을 거두지 못할 것으로 생각되었기 때문이다.","{'word': 'MS-DOS', 'start': 979, 'end': 984, 'type': 'COM'}","{'word': '윈도우 95', 'start': 1024, 'end': 1029, 'type': 'COM'}",com:similar_tech
100,DirectX 계열의 응용 프로그램 프로그래밍 인터페이스에 대한 대안으로 대부분의 기능이 있는 OpenGL이 있다.,"{'word': 'DirectX', 'start': 1419, 'end': 1425, 'type': 'COM'}","{'word': 'OpenGL', 'start': 1472, 'end': 1477, 'type': 'COM'}",com:similar_tech
101,"이 밖에도 SDL, 알레그로, 오픈맥스, OpenAL, FMOD가 있다.","{'word': 'SDL', 'start': 1490, 'end': 1492, 'type': 'COM'}","{'word': '알레그로', 'start': 1495, 'end': 1498, 'type': 'COM'}",com:similar_tech
102,"이 밖에도 SDL, 알레그로, 오픈맥스, OpenAL, FMOD가 있다.","{'word': 'SDL', 'start': 1490, 'end': 1492, 'type': 'COM'}","{'word': '오픈맥스', 'start': 1501, 'end': 1504, 'type': 'COM'}",com:similar_tech
103,"이 밖에도 SDL, 알레그로, 오픈맥스, OpenAL, FMOD가 있다.","{'word': 'SDL', 'start': 1490, 'end': 1492, 'type': 'COM'}","{'word': 'OpenAL', 'start': 1507, 'end': 1512, 'type': 'COM'}",com:similar_tech
104,"이 밖에도 SDL, 알레그로, 오픈맥스, OpenAL, FMOD가 있다.","{'word': 'SDL', 'start': 1490, 'end': 1492, 'type': 'COM'}","{'word': 'FMOD', 'start': 1515, 'end': 1518, 'type': 'COM'}",com:similar_tech
105,"또, DirectX와 똑같은 API를 둔 다른 대안으로 와인을 들 수 있다.","{'word': 'DirectX', 'start': 1574, 'end': 1580, 'type': 'COM'}","{'word': '와인', 'start': 1602, 'end': 1603, 'type': 'COM'}",com:similar_tech
106,"소프트웨어 개발()은 애플리케이션, 프레임워크, 기타 소프트웨어 구성 요소의 개발과 유지보수에 수반되는 구상, 디자인, 프로그래밍, 문서화, 테스트, 버그 수정의 과정이다.","{'word': '소프트웨어 개발', 'start': 0, 'end': 7, 'type': 'COM'}","{'word': '애플리케이션, 프레임워크, 기타 소프트웨어 구성 요소의 개발', 'start': 12, 'end': 44, 'type': 'COM'}",com:sub_concept
107,"소프트웨어 개발()은 애플리케이션, 프레임워크, 기타 소프트웨어 구성 요소의 개발과 유지보수에 수반되는 구상, 디자인, 프로그래밍, 문서화, 테스트, 버그 수정의 과정이다.","{'word': '소프트웨어 개발', 'start': 0, 'end': 7, 'type': 'COM'}","{'word': '구상, 디자인, 프로그래밍, 문서화, 테스트, 버그 수정', 'start': 58, 'end': 88, 'type': 'COM'}",com:sub_concept
108,소프트웨어 개발은 소스 코드의 작성과 유지보수를 수반하지만 더 넓은 의미에서 보면 일반적으로 계획되고 구조화된 과정 속에서 소프트웨어의 마지막 표명을 통해 원하는 소프트웨어의 개념으로부터 발생하는 모든 과정을 포괄한다.,"{'word': '소프트웨어 개발', 'start': 97, 'end': 104, 'type': 'COM'}","{'word': '소스 코드의 작성과 유지보수', 'start': 107, 'end': 121, 'type': 'COM'}",com:sub_concept
109,"또, 소프트웨어 개발은 소프트웨어 제품이 탄생하는데 수반되는 연구, 신개발, 프로토타입, 수정, 재사용, 리엔지니어링, 유지보수 등의 기타 활동도 포함한다.","{'word': '소프트웨어 개발', 'start': 223, 'end': 230, 'type': 'COM'}","{'word': '연구, 신개발, 프로토타입, 수정, 재사용, 리엔지니어링, 유지보수', 'start': 254, 'end': 290, 'type': 'COM'}",com:sub_concept
110,소프트웨어 개발에 다음과 같은 단계들을 공유한다:,"{'word': '소프트웨어 개발', 'start': 308, 'end': 315, 'type': 'COM'}","{'word': '단계', 'start': 325, 'end': 326, 'type': 'POH'}",no_relation
111,프로토타입 기반 언어의 가장 원조격인 프로그래밍 언어인 셀프는 데이비드 엉거와 랜덜 스미스가 개발했다.,"{'word': '데이비드 엉거', 'start': 273, 'end': 279, 'type': 'PER'}","{'word': '랜덜 스미스', 'start': 282, 'end': 287, 'type': 'PER'}",per:colleagues
112,"프로토타입 기반 프로그래밍은 객체지향 프로그래밍의 한 형태의 갈래로 클래스가 없고, 클래스 기반 언어에서 상속을 사용하는 것과는 다르게, 객체를 원형(프로토타입)으로 하여 복제의 과정을 통하여 객체의 동작 방식을 다시 사용할 수 있다.","{'word': '객체지향 프로그래밍', 'start': 16, 'end': 25, 'type': 'COM'}","{'word': '프로토타입 기반 프로그래밍', 'start': 0, 'end': 13, 'type': 'COM'}",com:sub_concept
113,"클래스기반 언어에서 '클래스'는 동작 방식인 메소드의 모임으로 동작하고, 모든 인스턴스의 구조는 동일하고, 인스턴스는 객체의 자료를 가지고 있다.","{'word': '클래스기반 언어', 'start': 533, 'end': 540, 'type': 'COM'}","{'word': '클래스', 'start': 545, 'end': 547, 'type': 'COM'}",com:sub_concept
114,"클래스기반 언어에서 '클래스'는 동작 방식인 메소드의 모임으로 동작하고, 모든 인스턴스의 구조는 동일하고, 인스턴스는 객체의 자료를 가지고 있다.","{'word': '클래스기반 언어', 'start': 533, 'end': 540, 'type': 'COM'}","{'word': '인스턴스', 'start': 593, 'end': 596, 'type': 'COM'}",com:sub_concept
115,"클래스기반 언어에서, 클래스의 생성자를 통하거나 필요하다면 생성자와 생성자의 매개변수를 통하여 인스턴스를 새로 만든다.","{'word': '클래스기반 언어', 'start': 1148, 'end': 1155, 'type': 'COM'}","{'word': '인스턴스', 'start': 1201, 'end': 1204, 'type': 'COM'}",com:sub_concept
116,"클래스기반 언어에서, 클래스의 생성자를 통하거나 필요하다면 생성자와 생성자의 매개변수를 통하여 인스턴스를 새로 만든다. 결과로 만들어진 인스턴스는 선택된 클래스의 설계와 행동을 따르게 된다.","{'word': '클래스기반 언어', 'start': 1148, 'end': 1155, 'type': 'COM'}","{'word': '인스턴스', 'start': 1224, 'end': 1227, 'type': 'COM'}",com:sub_concept
117,'복제'는 원래 있던 객체의 프로토타입의 행동을 복제하여 새 객체를 생성하는 과정을 거친다.,"{'word': '객체', 'start': 1822, 'end': 1823, 'type': 'COM'}","{'word': '프로토타입', 'start': 1826, 'end': 1830, 'type': 'COM'}",com:sub_concept
118,이런 이유로 대부분의 프로토타입기반 언어들은 자료와 메서드 두가지 모두 슬롯으로 관리한다.,"{'word': '프로토타입기반 언어', 'start': 2527, 'end': 2536, 'type': 'COM'}","{'word': '자료', 'start': 2540, 'end': 2541, 'type': 'COM'}",com:sub_concept
119,이런 이유로 대부분의 프로토타입기반 언어들은 자료와 메서드 두가지 모두 슬롯으로 관리한다.,"{'word': '프로토타입기반 언어', 'start': 2527, 'end': 2536, 'type': 'COM'}","{'word': '메서드', 'start': 2544, 'end': 2546, 'type': 'COM'}",com:sub_concept
120,"프로토타입 객체는 정확히 복사되지만, 다른 이름이나 참조값을 갖는다.","{'word': '프로토타입 객체', 'start': 2640, 'end': 2647, 'type': 'COM'}","{'word': '참조값', 'start': 2669, 'end': 2671, 'type': 'COM'}",com:sub_concept
121,이렇게 접근하면 객체 작성자가 한 부모 객체의 자식 객체들간에 부수효과를 신경쓰지 않고 복제할 수 있다는 이점이 있다.,"{'word': '부모 객체', 'start': 2750, 'end': 2754, 'type': 'COM'}","{'word': '자식 객체', 'start': 2757, 'end': 2761, 'type': 'COM'}",com:sub_concept
122,"프로토타입기반 시스템을 비판하고 클래스기반 객체 모델을 지지하는 사람들은 프로그래밍 언어의 정적 타입 시스템을 지지하는 사람들이 동적 타입 시스템에 대하여 우려하는 것과 비슷한 점을 우려하고 있다(자료형 참조). 특히, 프로그램의 정확성, 안전성, 예측성, 효율을 떨어뜨린다고 우려한다.","{'word': '프로그래밍 언어', 'start': 3326, 'end': 3333, 'type': 'COM'}","{'word': '정적 타입 시스템', 'start': 3336, 'end': 3344, 'type': 'COM'}",com:sub_concept
123,"프로토타입기반 시스템을 비판하고 클래스기반 객체 모델을 지지하는 사람들은 프로그래밍 언어의 정적 타입 시스템을 지지하는 사람들이 동적 타입 시스템에 대하여 우려하는 것과 비슷한 점을 우려하고 있다(자료형 참조). 특히, 프로그램의 정확성, 안전성, 예측성, 효율을 떨어뜨린다고 우려한다.","{'word': '프로그램', 'start': 3408, 'end': 3411, 'type': 'COM'}","{'word': '정확성', 'start': 3414, 'end': 3416, 'type': 'COM'}",com:sub_concept
124,"프로토타입기반 시스템을 비판하고 클래스기반 객체 모델을 지지하는 사람들은 프로그래밍 언어의 정적 타입 시스템을 지지하는 사람들이 동적 타입 시스템에 대하여 우려하는 것과 비슷한 점을 우려하고 있다(자료형 참조). 특히, 프로그램의 정확성, 안전성, 예측성, 효율을 떨어뜨린다고 우려한다.","{'word': '프로그램', 'start': 3408, 'end': 3411, 'type': 'COM'}","{'word': '안전성', 'start': 3419, 'end': 3421, 'type': 'COM'}",com:sub_concept
125,"프로토타입기반 시스템을 비판하고 클래스기반 객체 모델을 지지하는 사람들은 프로그래밍 언어의 정적 타입 시스템을 지지하는 사람들이 동적 타입 시스템에 대하여 우려하는 것과 비슷한 점을 우려하고 있다(자료형 참조). 특히, 프로그램의 정확성, 안전성, 예측성, 효율을 떨어뜨린다고 우려한다.","{'word': '프로그램', 'start': 3408, 'end': 3411, 'type': 'COM'}","{'word': '예측성', 'start': 3424, 'end': 3426, 'type': 'COM'}",com:sub_concept
126,"프로토타입기반 시스템을 비판하고 클래스기반 객체 모델을 지지하는 사람들은 프로그래밍 언어의 정적 타입 시스템을 지지하는 사람들이 동적 타입 시스템에 대하여 우려하는 것과 비슷한 점을 우려하고 있다(자료형 참조). 특히, 프로그램의 정확성, 안전성, 예측성, 효율을 떨어뜨린다고 우려한다.","{'word': '프로그램', 'start': 3408, 'end': 3411, 'type': 'COM'}","{'word': '효율', 'start': 3429, 'end': 3430, 'type': 'COM'}",com:sub_concept
127,"정확성, 안전성, 예측성의 관점에서 보면, 클래스는 타입과 비슷하며, 실제로 대부분의 정적 타입 객체지향 언어에서 클래스는 타입의 역할을 한다.","{'word': '정적 타입 객체지향 언어', 'start': 3494, 'end': 3506, 'type': 'COM'}","{'word': '클래스', 'start': 3510, 'end': 3512, 'type': 'COM'}",com:sub_concept
128,그리고 클래스의 인스턴스는 주어진 방식대로 동작하리라는 확실한 보장이 된다.,"{'word': '클래스', 'start': 3531, 'end': 3533, 'type': 'COM'}","{'word': '인스턴스', 'start': 3536, 'end': 3539, 'type': 'COM'}",com:sub_concept
129,"프로토타입기반 프로그래밍은 클래스리스(""class-less""), 프로토타입 지향(prototype-oriented) 혹은 인스턴스 기반(instance-based) 프로그래밍이라고도 한다.","{'word': '프로토타입기반', 'start': 132, 'end': 138, 'type': 'COM'}","{'word': '클래스리스', 'start': 147, 'end': 151, 'type': 'COM'}",com:alter_names
130,"프로토타입기반 프로그래밍은 클래스리스(""class-less""), 프로토타입 지향(prototype-oriented) 혹은 인스턴스 기반(instance-based) 프로그래밍이라고도 한다.","{'word': '프로토타입기반', 'start': 132, 'end': 138, 'type': 'COM'}","{'word': '프로토타입 지향', 'start': 168, 'end': 175, 'type': 'COM'}",com:alter_names
131,"프로토타입기반 프로그래밍은 클래스리스(""class-less""), 프로토타입 지향(prototype-oriented) 혹은 인스턴스 기반(instance-based) 프로그래밍이라고도 한다.","{'word': '프로토타입기반', 'start': 132, 'end': 138, 'type': 'COM'}","{'word': '인스턴스 기반', 'start': 200, 'end': 206, 'type': 'COM'}",com:alter_names
132,"프로토타입기반 프로그래밍은 클래스리스(""class-less""), 프로토타입 지향(prototype-oriented) 혹은 인스턴스 기반(instance-based) 프로그래밍이라고도 한다.","{'word': '클래스리스', 'start': 147, 'end': 151, 'type': 'COM'}","{'word': 'class-less', 'start': 154, 'end': 163, 'type': 'COM'}",com:alter_names
133,"프로토타입기반 프로그래밍은 클래스리스(""class-less""), 프로토타입 지향(prototype-oriented) 혹은 인스턴스 기반(instance-based) 프로그래밍이라고도 한다.","{'word': '프로토타입 지향', 'start': 168, 'end': 175, 'type': 'COM'}","{'word': 'prototype-oriented', 'start': 177, 'end': 194, 'type': 'COM'}",com:alter_names
134,"프로토타입기반 프로그래밍은 클래스리스(""class-less""), 프로토타입 지향(prototype-oriented) 혹은 인스턴스 기반(instance-based) 프로그래밍이라고도 한다.","{'word': '인스턴스 기반', 'start': 200, 'end': 206, 'type': 'COM'}","{'word': 'instance-based', 'start': 208, 'end': 221, 'type': 'COM'}",com:alter_names
135,순수 프로토타입은 '연쇄적' 프로토타입이라고도 하는데 케보가 그 예이다.,"{'word': '순수 프로토타입', 'start': 2566, 'end': 2573, 'type': 'COM'}","{'word': ""'연쇄적' 프로토타입"", 'start': 2576, 'end': 2586, 'type': 'COM'}",com:alter_names
136,"그러나 케보는 위임 방식에서 주로 쓰는 분류상의 원형을 사용하지 않고, 추가적인 기본형을 제공하여 '가족 닮음'(family reseemblances)라고 하는 유사한 객체들을 모아서 변화를 적용한다.","{'word': '가족 닮음', 'start': 3068, 'end': 3072, 'type': 'COM'}","{'word': 'family reseemblances', 'start': 3075, 'end': 3094, 'type': 'COM'}",com:alter_names
137,테스트는 C 버전에서 복사한 리삭으로 작성된 MPEG-2 코덱으로 하였다.,"{'word': 'MPEG-2 코덱', 'start': 3799, 'end': 3807, 'type': 'COM'}","{'word': '리삭', 'start': 3790, 'end': 3791, 'type': 'COM'}",com:made_of
138,"프로토타입 기반 프로그래밍은, 학습의 과정의 주요한 특징으로 프로토타입이나 이그젬플러를 강조하는, 인지 심리학과 같은 특정 학문과 관련되어 있는 경우가 많다.","{'word': '프로토타입 기반 프로그래밍', 'start': 960, 'end': 973, 'type': 'COM'}","{'word': '인지 심리학', 'start': 1015, 'end': 1020, 'type': 'POH'}",no_relation
139,"하나는 원래 있던 객체를 '복제(cloning)'하는 방법이고, 다른 하나는 '무(無)에서(""ex nihilo"")' 객체를 생성하는 방법이다.","{'word': '객체', 'start': 1302, 'end': 1303, 'type': 'COM'}","{'word': '복제', 'start': 1307, 'end': 1308, 'type': 'POH'}",no_relation
140,"클래스리스 프로그래밍은 최근에 와서 많이 유명해졌는데, 자바스크립트와 모픽 프레임워크를 사용하는 스퀵에 적용되었고, 그 외에 세실, 뉴튼스크립트, 아이오, 무, 리볼, 케보 등에 적용되었다.(#프로토타입 기반 언어 목록 참고.)","{'word': '자바스크립트', 'start': 327, 'end': 332, 'type': 'COM'}","{'word': '모픽 프레임워크', 'start': 335, 'end': 342, 'type': 'COM'}",no_relation
141,"클래스기반 언어에서 객체는 일반적으로 두 가지 형태가 있다. '클래스'는 객체의 기본적인 만듦새와 기능을 정의하고, '인스턴스'는 ""사용할 수 있는"" 객체로 특정 클래스의 양식을 기반으로 한다.","{'word': '클래스', 'start': 459, 'end': 461, 'type': 'COM'}","{'word': '인스턴스', 'start': 490, 'end': 493, 'type': 'COM'}",no_relation
142,프로토타입기반 프로그래밍을 지지하는 사람들은 클래스기반 언어에서는 개발자가 클래스들 사이의 분류와 관계에 먼저 초점을 맞추기 쉽다고 한다.,"{'word': '프로토타입기반 프로그래밍', 'start': 649, 'end': 661, 'type': 'COM'}","{'word': '클래스기반 언어', 'start': 674, 'end': 681, 'type': 'COM'}",no_relation
143,"이와는 달리, 프로토타입기반 프로그래밍은 프로그래머가 여러 가지 표본의 동작 방식에 초점을 맞추고, 이 객체들을 나중에 클래스와 비슷한 방식의 ""객체의 원형""으로 분류하는 것은 나중에 걱정해도 된다.","{'word': '프로토타입기반 프로그래밍', 'start': 735, 'end': 747, 'type': 'COM'}","{'word': '프로그래머', 'start': 750, 'end': 754, 'type': 'COM'}",no_relation
144,"많은 프로토타입기반 체계가 실행시간에 프로토타입을 대체하기 쉬우나, 클래스기반 객체지향 체계에서는 최초의 동적 객체지향 체계인 스몰토크와 같이 프로그램의 실행 중에 클래스를 바꿀 수 있는 것은 몇 가지 되지 않는다.","{'word': '프로토타입기반 체계', 'start': 842, 'end': 851, 'type': 'COM'}","{'word': '클래스기반 객체지향 체계', 'start': 877, 'end': 889, 'type': 'COM'}",no_relation
145,"많은 프로토타입기반 체계가 실행시간에 프로토타입을 대체하기 쉬우나, 클래스기반 객체지향 체계에서는 최초의 동적 객체지향 체계인 스몰토크와 같이 프로그램의 실행 중에 클래스를 바꿀 수 있는 것은 몇 가지 되지 않는다.","{'word': '프로토타입기반 체계', 'start': 842, 'end': 851, 'type': 'COM'}","{'word': '동적 객체지향 체계', 'start': 898, 'end': 907, 'type': 'COM'}",no_relation
146,프로토타입 기반 체계의 대부분은 인터프리터이고 동적 타입 프로그래밍 언어이다. 하지만 프로토타입기반의 정적 타입의 체계가 기술적으로 가능하다.,"{'word': '프로토타입 기반 체계', 'start': 1049, 'end': 1059, 'type': 'COM'}","{'word': '동적 타입 프로그래밍 언어', 'start': 1075, 'end': 1088, 'type': 'COM'}",no_relation
147,"""무에서"" 객체를 생성할 수 있는 체계는 이미 있던 프로토타입을 복제하지 않고 아무것도 없는 상태에서 새로운 객체를 생성할 수 있게 해 준다.","{'word': '프로토타입', 'start': 1452, 'end': 1456, 'type': 'COM'}","{'word': '객체', 'start': 1484, 'end': 1485, 'type': 'COM'}",no_relation
148,"많은 프로토타입기반 언어에서 기본 객체 프로토타입인 ""codice_1"" 프로토타입이 있는데, 여기에 공통적으로 필요한 메서드가 들어있고, 모든 객체의 마스터 프로토타입으로 사용된다. ""무에서"" 객체를 창조하는 방식의 유용한 한 가지는 새 객체의 슬롯 이름이 최상위의 ""codice_1"" 객체와 네임스페이스 충돌이 일어나지 않는다는 것이다.","{'word': '프로토타입기반 언어', 'start': 1556, 'end': 1565, 'type': 'COM'}","{'word': '메서드', 'start': 1619, 'end': 1621, 'type': 'COM'}",no_relation
149,"모질라 자바스크립트는 객체의 ""codice_3"" 프로퍼티를 codice_4로 지정하면 이것이 가능하도록 구현되어 있다.","{'word': '모질라 자바스크립트', 'start': 1743, 'end': 1752, 'type': 'COM'}","{'word': '객체', 'start': 1755, 'end': 1756, 'type': 'COM'}",no_relation
150,어떤 체계에서 복제된 자식 객체는 명시적으로 프로토타입과 '위임'(delegation)이나 '닮음'(resemblance)으로 연관되어 있다.,"{'word': '자식 객체', 'start': 1919, 'end': 1923, 'type': 'COM'}","{'word': '프로토타입', 'start': 1932, 'end': 1936, 'type': 'COM'}",no_relation
151,그래서 프로토타입을 변경하면 복제품에 영향을 끼친다.,"{'word': '프로토타입', 'start': 1991, 'end': 1995, 'type': 'COM'}","{'word': '복제품', 'start': 2003, 'end': 2005, 'type': 'COM'}",no_relation
152,"포스와 케보 같은 다른 체계에서는 프로토타입을 번식시키는 이런 방식을 따르지 않고, 대신에 프로토타입을 수정하더라도 복제품에는 영향을 끼치지 않는 ""연쇄된"" 형태를 사용하여 원본 객체를 수정하더라도 그 자손으로 자동 번식되지 않는다.","{'word': '포스와 케보', 'start': 2017, 'end': 2022, 'type': 'COM'}","{'word': '프로토타입', 'start': 2036, 'end': 2040, 'type': 'COM'}",no_relation
153,"실행시간에 '위임'하는 프로토타입기반의 언어들은 올바른 메서드로 동적 디스패치를 할 수 있거나, 맞는 자료 조각에 이를 때까지 객체에서 프로토타입으로 간단히 위임 포인터를 연속적으로 따라가서 찾을 수 있다.","{'word': '프로토타입기반의 언어', 'start': 2161, 'end': 2171, 'type': 'COM'}","{'word': '위임 포인터', 'start': 2236, 'end': 2241, 'type': 'COM'}",no_relation
154,객체들 사이에서 동작을 공유하는 것을 확립하기 위해 필요한 것들은 위임 포인터뿐이다.,"{'word': '객체', 'start': 2264, 'end': 2265, 'type': 'COM'}","{'word': '위임 포인터', 'start': 2301, 'end': 2306, 'type': 'COM'}",no_relation
155,클래스기반 객체지향 언어에서 클래스와 인스턴스의 관계와 달리 프로토타입과 파생된 객체는 이 연결을 통하여 프로토타입과 자식 객체가 메모리나 구조적인 유사성을 가질 필요가 없다.,"{'word': '클래스', 'start': 2328, 'end': 2330, 'type': 'COM'}","{'word': '인스턴스', 'start': 2333, 'end': 2336, 'type': 'COM'}",no_relation
156,"마찬가지로, 자식 객체는 클래스 기반의 연관된 클래스의 구조를 재배치하지 않고 계속해서 수정할 수 있다.","{'word': '자식 객체', 'start': 2418, 'end': 2422, 'type': 'COM'}","{'word': '클래스의 구조', 'start': 2437, 'end': 2443, 'type': 'COM'}",no_relation
157,"또 중요한 점은, 자료뿐만 아니라 메서드도 추가되거나 변경될 수 있다는 것이다.","{'word': '자료', 'start': 2480, 'end': 2481, 'type': 'COM'}","{'word': '메서드', 'start': 2489, 'end': 2491, 'type': 'COM'}",no_relation
158,원본 프로토타입에서 복제된 객체로 포인터는 보이지 않는다.,"{'word': '원본 프로토타입', 'start': 2607, 'end': 2614, 'type': 'COM'}","{'word': '포인터', 'start': 2626, 'end': 2628, 'type': 'COM'}",no_relation
159,메서드와 속성은 대응되는 것으로 중복된다.,"{'word': '메서드', 'start': 2707, 'end': 2709, 'type': 'COM'}","{'word': '속성', 'start': 2712, 'end': 2713, 'type': 'COM'}",no_relation
160,"또 다른 이점은, 디스패치 중 메서드 미리보기의 계산 비용이 위임에 비해서 급격히 줄어든다는 것이다.","{'word': '디스패치', 'start': 2808, 'end': 2811, 'type': 'COM'}","{'word': '메서드 미리보기', 'start': 2815, 'end': 2822, 'type': 'COM'}",no_relation
161,위임을 하면 적합한 메서드나 슬롯을 찾는 것을 실패한다면 전체 위임 사슬에서 찾아봐야 하기 때문이다.,"{'word': '메서드', 'start': 2866, 'end': 2868, 'type': 'COM'}","{'word': '슬롯', 'start': 2871, 'end': 2872, 'type': 'COM'}",no_relation
162,연쇄 접근 방식의 단점은 시스템을 통해 바뀌는 것을 번식시키는 데에 조직적으로 어렵다는 것이다.,"{'word': '연쇄 접근 방식', 'start': 2912, 'end': 2919, 'type': 'COM'}","{'word': '시스템', 'start': 2926, 'end': 2928, 'type': 'COM'}",no_relation
163,프로토타입에 변화가 생기면 이것은 복제품에 즉시 혹은 자동적으로 적용되지 않는다.,"{'word': '프로토타입', 'start': 2966, 'end': 2970, 'type': 'COM'}","{'word': '복제품', 'start': 2985, 'end': 2987, 'type': 'COM'}",no_relation
164,다른 단점은 이 형태를 세련되게 구현하지 못하면 원형과 복제품이 같은 부분에서 복제품들이 위임 형태에 비해서 메모리가 더 많이 낭비된다는 것이다.,"{'word': '원형', 'start': 3152, 'end': 3153, 'type': 'COM'}","{'word': '복제품', 'start': 3156, 'end': 3158, 'type': 'COM'}",no_relation
165,그러나 케보에서 실제로 하고 있는 접근 방식처럼 공유하도록 구현하고 자료는 배후에 두는 방식으로 프로그래밍에 대한 연쇄적 행동이 가능하다.,"{'word': '케보', 'start': 3211, 'end': 3212, 'type': 'COM'}","{'word': '프로그래밍', 'start': 3261, 'end': 3265, 'type': 'COM'}",no_relation
166,"프로토타입기반 시스템을 비판하고 클래스기반 객체 모델을 지지하는 사람들은 프로그래밍 언어의 정적 타입 시스템을 지지하는 사람들이 동적 타입 시스템에 대하여 우려하는 것과 비슷한 점을 우려하고 있다(자료형 참조). 특히, 프로그램의 정확성, 안전성, 예측성, 효율을 떨어뜨린다고 우려한다.","{'word': '프로토타입기반 시스템', 'start': 3285, 'end': 3295, 'type': 'COM'}","{'word': '클래스기반 객체 모델', 'start': 3303, 'end': 3313, 'type': 'COM'}",no_relation
167,"프로토타입기반 시스템을 비판하고 클래스기반 객체 모델을 지지하는 사람들은 프로그래밍 언어의 정적 타입 시스템을 지지하는 사람들이 동적 타입 시스템에 대하여 우려하는 것과 비슷한 점을 우려하고 있다(자료형 참조). 특히, 프로그램의 정확성, 안전성, 예측성, 효율을 떨어뜨린다고 우려한다.","{'word': '정적 타입 시스템', 'start': 3336, 'end': 3344, 'type': 'COM'}","{'word': '동적 타입 시스템', 'start': 3357, 'end': 3365, 'type': 'COM'}",no_relation
168,"효율성의 관점에서 보면, 클래스를 선언하면 대부분의 컴파일러는 더 효율적인 메서드와 인스턴스 변수 미리보기가 가능하여 최적화하기 쉽게 된다.","{'word': '클래스', 'start': 3584, 'end': 3586, 'type': 'COM'}","{'word': '컴파일러', 'start': 3599, 'end': 3602, 'type': 'COM'}",no_relation
169,"효율성의 관점에서 보면, 클래스를 선언하면 대부분의 컴파일러는 더 효율적인 메서드와 인스턴스 변수 미리보기가 가능하여 최적화하기 쉽게 된다.","{'word': '클래스', 'start': 3584, 'end': 3586, 'type': 'COM'}","{'word': '메서드', 'start': 3612, 'end': 3614, 'type': 'COM'}",no_relation
170,"효율성의 관점에서 보면, 클래스를 선언하면 대부분의 컴파일러는 더 효율적인 메서드와 인스턴스 변수 미리보기가 가능하여 최적화하기 쉽게 된다.","{'word': '클래스', 'start': 3584, 'end': 3586, 'type': 'COM'}","{'word': '인스턴스 변수', 'start': 3617, 'end': 3623, 'type': 'COM'}",no_relation
171,"셀프 (프로그래밍 언어)에서 보면, 클래스기반에 비해서 프로토타입 기반 체계는 수행 속도를 빠르게 하는 컴파일과 인터프리트 기술을 개발하는 데 많은 시간이 걸린다.","{'word': '클래스기반', 'start': 3669, 'end': 3673, 'type': 'COM'}","{'word': '프로토타입 기반 체계', 'start': 3680, 'end': 3690, 'type': 'COM'}",no_relation
172,"셀프 (프로그래밍 언어)에서 보면, 클래스기반에 비해서 프로토타입 기반 체계는 수행 속도를 빠르게 하는 컴파일과 인터프리트 기술을 개발하는 데 많은 시간이 걸린다.","{'word': '컴파일', 'start': 3707, 'end': 3709, 'type': 'COM'}","{'word': '인터프리트 기술', 'start': 3712, 'end': 3719, 'type': 'COM'}",no_relation
173,예를 들어 리삭 컴파일러는 C만큼이나 빨리 코드를 만든다.,"{'word': '리삭 컴파일러', 'start': 3747, 'end': 3753, 'type': 'COM'}","{'word': 'C', 'start': 3756, 'end': 3756, 'type': 'COM'}",no_relation
174,이 테스트 결과로 리삭 버전이 C 버전보다 1.9% 속도가 느리지만 37%만큼 줄 수가 적었다.,"{'word': '리삭 버전', 'start': 3826, 'end': 3830, 'type': 'COM'}","{'word': 'C 버전', 'start': 3833, 'end': 3836, 'type': 'COM'}",no_relation
175,"마지막으로, 비록 자바스크립트와 같은 언어들이 유명세를 떨치고, 시장에 침투하고 있지만 프로토타입기반 언어가 소프트웨어 개발자들 사이에서 익숙하지 않아서 때문에 많은 비판을 받는다.","{'word': '자바스크립트', 'start': 3880, 'end': 3885, 'type': 'COM'}","{'word': '프로토타입기반 언어', 'start': 3919, 'end': 3928, 'type': 'COM'}",no_relation
176,그래서 ECMA스크립트 표준의 4번째판이 자바스크립트를 클래스기반 언어로 만들려고 하고 있다.,"{'word': 'ECMA스크립트 표준', 'start': 3976, 'end': 3986, 'type': 'COM'}","{'word': '자바스크립트', 'start': 3995, 'end': 4000, 'type': 'COM'}",no_relation
177,"게다가 프로토타입기반 체계가 상대적으로 기발하고 별로 사용되지 않고 있으며, 소프트웨어를 개발할 때 널리 퍼지지 못하여 최고관행과 멀기 때문이다.","{'word': '프로토타입기반 체계', 'start': 4029, 'end': 4038, 'type': 'COM'}","{'word': '소프트웨어', 'start': 4068, 'end': 4072, 'type': 'COM'}",no_relation
178,비구조적 프로그래밍은 하나의 연속된 덩어리에 모든 코드를 넣는 프로그래밍 패러다임이다.,"{'word': '프로그래밍 패러다임', 'start': 35, 'end': 44, 'type': 'COM'}","{'word': '비구조적 프로그래밍', 'start': 0, 'end': 9, 'type': 'COM'}",com:sub_concept
179,비구조적 프로그래밍 언어는 코드의 특정부분으로 건너뛰는 GOTO문과 같은 흐름 제어문에 의존할 수밖에 없다.,"{'word': '비구조적 프로그래밍 언어', 'start': 138, 'end': 150, 'type': 'COM'}","{'word': 'GOTO문', 'start': 169, 'end': 173, 'type': 'COM'}",com:sub_concept
180,그러나 프로그램 구조는 항상 조건문과 GOTO문을 조합하여 구현할 수 있기 때문에 구조가 모든 언어에서 필요한 것은 아니다.,"{'word': '프로그램 구조', 'start': 273, 'end': 279, 'type': 'COM'}","{'word': '조건문', 'start': 285, 'end': 287, 'type': 'COM'}",com:sub_concept
181,그러나 프로그램 구조는 항상 조건문과 GOTO문을 조합하여 구현할 수 있기 때문에 구조가 모든 언어에서 필요한 것은 아니다.,"{'word': '프로그램 구조', 'start': 273, 'end': 279, 'type': 'COM'}","{'word': 'GOTO문', 'start': 290, 'end': 294, 'type': 'COM'}",com:sub_concept
182,"어셈블리어는 대체로 비구조적 언어인데, 기본이 되는 기계어 코드가 구조적이지 않기 때문이다.","{'word': '비구조적 언어', 'start': 497, 'end': 503, 'type': 'COM'}","{'word': '어셈블리어', 'start': 486, 'end': 490, 'type': 'COM'}",com:sub_concept
183,"구조화되지 않은 원시 코드는 읽고 디버그하기가 매우 어렵고, 구조적인 작성을 지원하는 프로그래밍 언어에서는 추천하지 않는다.","{'word': '원시 코드', 'start': 208, 'end': 212, 'type': 'COM'}","{'word': '프로그래밍 언어', 'start': 247, 'end': 254, 'type': 'COM'}",no_relation
184,"GOTO문을 쓰는 것에 수행 속도상의 이점은 없다. (실제로, 컴파일러가 최적화 할 수 있는 것들을 혼란시켜 오히려 불이익이 될 수도 있다.)","{'word': 'GOTO문', 'start': 406, 'end': 410, 'type': 'COM'}","{'word': '컴파일러', 'start': 441, 'end': 444, 'type': 'COM'}",no_relation
185,어셈블리 언어에 있는 유일한 구조는 함수의 시작과 끝 같이 컴파일 도구에서 쓰는 것들이다.,"{'word': '어셈블리 언어', 'start': 538, 'end': 544, 'type': 'COM'}","{'word': '컴파일 도구', 'start': 571, 'end': 576, 'type': 'COM'}",no_relation
186,"비구조적 프로그래밍은 하나의 연속된 덩어리에 모든 코드를 넣는 프로그래밍 패러다임이다. 대비되는 개념으로는 구조적 프로그래밍이 있는데, 이는 프로그램의 작업이 (함수나 서브루틴으로 알려진) 더 작은 부분으로 나누어 필요할 때마다 호출하는 것이다.","{'word': '비구조적 프로그래밍', 'start': 0, 'end': 9, 'type': 'COM'}","{'word': '구조적 프로그래밍', 'start': 60, 'end': 68, 'type': 'COM'}",com:similar_tech
187,MS-DOS의 배치 파일과 같은 많은 스크립트 언어나 베이직이나 포트란 같이 오래된 언어에서는 여전히 사용되기도 한다.,"{'word': '베이직', 'start': 369, 'end': 371, 'type': 'COM'}","{'word': '포트란', 'start': 375, 'end': 377, 'type': 'COM'}",com:similar_tech
188,2002년 2월 마이크로소프트는 3년 8개월간의 침묵을 깨고 비주얼 스튜디오 닷넷의 베타를 내놓았다.,"{'word': '마이크로소프트', 'start': 1458, 'end': 1464, 'type': 'ORG'}","{'word': '비주얼 스튜디오 닷넷의 베타', 'start': 1483, 'end': 1497, 'type': 'COM'}",org:production
189,1997년 2월에 출시된 마이크로소프트의 첫 비주얼 스튜디오이다.,"{'word': '마이크로소프트의 첫 비주얼 스튜디오', 'start': 356, 'end': 374, 'type': 'COM'}","{'word': '1997년 2월', 'start': 342, 'end': 349, 'type': 'DAT'}",com:date_of_prod
190,다음 버전 6.0은 1998년 6월에 출시되었다.,"{'word': '다음 버전 6.0', 'start': 528, 'end': 536, 'type': 'COM'}","{'word': '1998년 6월', 'start': 539, 'end': 546, 'type': 'DAT'}",com:date_of_prod
191,2002년 2월 마이크로소프트는 3년 8개월간의 침묵을 깨고 비주얼 스튜디오 닷넷의 베타를 내놓았다.,"{'word': '비주얼 스튜디오 닷넷의 베타', 'start': 1483, 'end': 1497, 'type': 'COM'}","{'word': '2002년 2월', 'start': 1449, 'end': 1456, 'type': 'DAT'}",com:date_of_prod
192,2003년 4월 출시된 비주얼 스튜디오 닷넷 2003은 마이너 업그레이드이다.,"{'word': '비주얼 스튜디오 닷넷 2003', 'start': 2111, 'end': 2126, 'type': 'COM'}","{'word': '2003년 4월', 'start': 2098, 'end': 2105, 'type': 'DAT'}",com:date_of_prod
193,2006년 9월 13일에 서비스 팩 1이 발표되었다.,"{'word': '서비스 팩 1', 'start': 2454, 'end': 2460, 'type': 'COM'}","{'word': '2006년 9월 13일', 'start': 2440, 'end': 2451, 'type': 'DAT'}",com:date_of_prod
194,"2005년 11월 17일 비주얼 스튜디오 2005가 출시되었으며, 이 버전부터 닷넷이라는 꼬리표를 뗐지만 업그레이드된 닷넷 프레임워크를 사용한다.","{'word': '비주얼 스튜디오 2005', 'start': 2484, 'end': 2496, 'type': 'COM'}","{'word': '2005년 11월 17일', 'start': 2470, 'end': 2482, 'type': 'DAT'}",com:date_of_prod
195,비주얼 스튜디오 2012는 2012년 8월 2일 출시되었다.,"{'word': '비주얼 스튜디오 2012', 'start': 4159, 'end': 4171, 'type': 'COM'}","{'word': '2012년 8월 2일', 'start': 4174, 'end': 4184, 'type': 'DAT'}",com:date_of_prod
196,비주얼 스튜디오 2013 RC는 2013년 9월 9일 MSDN을 통해 개발자들에게 제공되었다.,"{'word': '비주얼 스튜디오 2013 RC', 'start': 4316, 'end': 4331, 'type': 'COM'}","{'word': '2013년 9월 9일', 'start': 4334, 'end': 4344, 'type': 'DAT'}",com:date_of_prod
197,비주얼 스튜디오 2013 업데이트 1 (2013.1)이 2014년 1월 20일 공개되었다.,"{'word': '비주얼 스튜디오 2013 업데이트 1', 'start': 4369, 'end': 4388, 'type': 'COM'}","{'word': '2014년 1월 20일', 'start': 4400, 'end': 4411, 'type': 'DAT'}",com:date_of_prod
198,"2017년 3월 7일, 비주얼 스튜디오 2017이 최종 이름으로 공식 발표되었다.","{'word': '비주얼 스튜디오 2017', 'start': 4767, 'end': 4779, 'type': 'COM'}","{'word': '2017년 3월 7일', 'start': 4754, 'end': 4764, 'type': 'DAT'}",com:date_of_prod
199,"이후 2019년 2월 27일 RC 버전이 공개되었고, 2019년 4월 2일 정식 버전이 출시되었다.","{'word': 'RC 버전', 'start': 4880, 'end': 4884, 'type': 'COM'}","{'word': '2019년 2월 27일', 'start': 4867, 'end': 4878, 'type': 'DAT'}",com:date_of_prod
200,"이후 2019년 2월 27일 RC 버전이 공개되었고, 2019년 4월 2일 정식 버전이 출시되었다.","{'word': '정식 버전', 'start': 4906, 'end': 4910, 'type': 'COM'}","{'word': '2019년 4월 2일', 'start': 4894, 'end': 4904, 'type': 'DAT'}",com:date_of_prod
201,모든 구성 요소는 버전 6.0을 달고 나왔다.,"{'word': '버전 6.0', 'start': 566, 'end': 571, 'type': 'COM'}","{'word': '모든 구성 요소', 'start': 556, 'end': 563, 'type': 'COM'}",com:sub_concept
202,비주얼 스튜디오 6.0의 비주얼 베이직 6.0이 대부분의 비주얼 베이직 프로그래머가 알고 있는 것이다.,"{'word': '비주얼 스튜디오 6.0', 'start': 625, 'end': 636, 'type': 'COM'}","{'word': '비주얼 베이직 6.0', 'start': 639, 'end': 649, 'type': 'COM'}",com:sub_concept
203,비주얼 베이직 닷넷은 이전 버전의 비주얼 베이직과는 달랐다. 또한 비주얼 J++를 포함하는 마지막 버전이 되었다.,"{'word': '비주얼 베이직 닷넷', 'start': 683, 'end': 692, 'type': 'COM'}","{'word': '비주얼 J++', 'start': 720, 'end': 726, 'type': 'COM'}",com:sub_concept
204,"비주얼 J++의 마이크로소프트 자바 확장 때문에 선과 마이크로소프트 사이에 분쟁이 있었으며, 자바 VM 기반의 개발 환경을 더 이상 출시하지 못하게 되었다.","{'word': '비주얼 J++', 'start': 747, 'end': 753, 'type': 'COM'}","{'word': '마이크로소프트 자바 확장', 'start': 756, 'end': 768, 'type': 'COM'}",com:sub_concept
205,비주얼 베이직은 버전 6.0과 버전 7.0 사이의 차이가 매우 크기 때문에 완전히 다른 프로그래밍 언어로 보는 견해가 강하다.,"{'word': '프로그래밍 언어', 'start': 970, 'end': 977, 'type': 'COM'}","{'word': '비주얼 베이직', 'start': 921, 'end': 927, 'type': 'COM'}",com:sub_concept
206,MSIL이라는 간접 언어로 컴파일된 다음 실행 시간에 플랫폼에 맞게 컴파일되는 것이다.,"{'word': '간접 언어', 'start': 1588, 'end': 1592, 'type': 'COM'}","{'word': 'MSIL', 'start': 1580, 'end': 1583, 'type': 'COM'}",com:sub_concept
207,비주얼 J#은 자바 문법을 사용하지만 닷넷 프레임워크 용으로 컴파일된다.,"{'word': '비주얼 J#', 'start': 1726, 'end': 1731, 'type': 'COM'}","{'word': '자바 문법', 'start': 1734, 'end': 1738, 'type': 'COM'}",com:sub_concept
208,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '비주얼 스튜디오 2003', 'start': 2277, 'end': 2289, 'type': 'COM'}","{'word': '아카데믹', 'start': 2302, 'end': 2305, 'type': 'COM'}",com:sub_concept
209,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '비주얼 스튜디오 2003', 'start': 2277, 'end': 2289, 'type': 'COM'}","{'word': '프로페셔널', 'start': 2308, 'end': 2312, 'type': 'COM'}",com:sub_concept
210,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '비주얼 스튜디오 2003', 'start': 2277, 'end': 2289, 'type': 'COM'}","{'word': '엔터프라이즈 디벨로퍼', 'start': 2315, 'end': 2325, 'type': 'COM'}",com:sub_concept
211,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '비주얼 스튜디오 2003', 'start': 2277, 'end': 2289, 'type': 'COM'}","{'word': '엔터프라이즈 아키텍트', 'start': 2328, 'end': 2338, 'type': 'COM'}",com:sub_concept
212,"제네릭 프로그래밍 기능이 C#, Visual Basic .NET, Visual C++ CLR, Visual J#에 추가되었다.","{'word': 'C#', 'start': 2632, 'end': 2633, 'type': 'COM'}","{'word': '제네릭 프로그래밍', 'start': 2618, 'end': 2626, 'type': 'COM'}",com:sub_concept
213,"제네릭 프로그래밍 기능이 C#, Visual Basic .NET, Visual C++ CLR, Visual J#에 추가되었다.","{'word': 'Visual Basic .NET', 'start': 2636, 'end': 2652, 'type': 'COM'}","{'word': '제네릭 프로그래밍', 'start': 2618, 'end': 2626, 'type': 'COM'}",com:sub_concept
214,"제네릭 프로그래밍 기능이 C#, Visual Basic .NET, Visual C++ CLR, Visual J#에 추가되었다.","{'word': 'Visual C++ CLR', 'start': 2655, 'end': 2668, 'type': 'COM'}","{'word': '제네릭 프로그래밍', 'start': 2618, 'end': 2626, 'type': 'COM'}",com:sub_concept
215,"제네릭 프로그래밍 기능이 C#, Visual Basic .NET, Visual C++ CLR, Visual J#에 추가되었다.","{'word': 'Visual J#', 'start': 2671, 'end': 2679, 'type': 'COM'}","{'word': '제네릭 프로그래밍', 'start': 2618, 'end': 2626, 'type': 'COM'}",com:sub_concept
216,비주얼 스튜디오 2005는 64비트 지원도 하게 되었다.,"{'word': '비주얼 스튜디오 2005', 'start': 2725, 'end': 2737, 'type': 'COM'}","{'word': '64비트', 'start': 2740, 'end': 2743, 'type': 'COM'}",com:sub_concept
217,플랫폼 SDK에만 64비트 컴파일러 및 라이브러리가 있었으며 비주얼 C++ 닷넷 2003의 경우는 마이크로소프트에 전자 우편을 보내야 했다.,"{'word': '플랫폼 SDK', 'start': 2832, 'end': 2838, 'type': 'COM'}","{'word': '64비트 컴파일러 및 라이브러리', 'start': 2842, 'end': 2858, 'type': 'COM'}",com:sub_concept
218,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '비주얼 스튜디오 2005', 'start': 2911, 'end': 2923, 'type': 'COM'}","{'word': '익스프레스', 'start': 2931, 'end': 2935, 'type': 'COM'}",com:sub_concept
219,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '비주얼 스튜디오 2005', 'start': 2911, 'end': 2923, 'type': 'COM'}","{'word': '스탠더드', 'start': 2938, 'end': 2941, 'type': 'COM'}",com:sub_concept
220,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '비주얼 스튜디오 2005', 'start': 2911, 'end': 2923, 'type': 'COM'}","{'word': '프로페셔널', 'start': 2944, 'end': 2948, 'type': 'COM'}",com:sub_concept
221,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '비주얼 스튜디오 2005', 'start': 2911, 'end': 2923, 'type': 'COM'}","{'word': '툴즈 포 오피스', 'start': 2951, 'end': 2958, 'type': 'COM'}",com:sub_concept
222,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '비주얼 스튜디오 2005', 'start': 2911, 'end': 2923, 'type': 'COM'}","{'word': '팀 시스템', 'start': 2961, 'end': 2965, 'type': 'COM'}",com:sub_concept
223,비주얼 스튜디오 2005 때와 마찬가지로 익스프레스 에디션을 제공하고 있다.,"{'word': '비주얼 스튜디오 2005', 'start': 3769, 'end': 3781, 'type': 'COM'}","{'word': '익스프레스 에디션', 'start': 3792, 'end': 3800, 'type': 'COM'}",com:sub_concept
224,비주얼 스튜디오 2005에서 제공되었던 Visual J# 개발 환경은 익스프레스 에디션을 포함하여 이 버전에서는 제공되지 않고 있다.,"{'word': '비주얼 스튜디오 2005', 'start': 3812, 'end': 3824, 'type': 'COM'}","{'word': 'Visual J# 개발 환경', 'start': 3834, 'end': 3848, 'type': 'COM'}",com:sub_concept
225,또한 새 버전의 Visual C++ 컴파일러에서는 최근 활발한 논의 및 개정이 진행 중인 C++0x 사양을 지원한다.,"{'word': 'Visual C++ 컴파일러', 'start': 4037, 'end': 4051, 'type': 'COM'}","{'word': 'C++0x 사양', 'start': 4078, 'end': 4085, 'type': 'COM'}",com:sub_concept
226,또한 새 버전의 Visual C++ 컴파일러에서는 최근 활발한 논의 및 개정이 진행 중인 C++14/17 사양을 일부 지원한다.,"{'word': 'Visual C++ 컴파일러', 'start': 4520, 'end': 4534, 'type': 'COM'}","{'word': 'C++14/17 사양', 'start': 4561, 'end': 4571, 'type': 'COM'}",com:sub_concept
227,64비트만 지원하는 최초의 비주얼 스튜디오 버전이다.,"{'word': '비주얼 스튜디오', 'start': 5056, 'end': 5063, 'type': 'COM'}","{'word': '64비트', 'start': 5041, 'end': 5044, 'type': 'COM'}",com:sub_concept
228,"비주얼 스튜디오 팀 서비스(vsts)는 소스 코드 관리(팀 파운데이션 버전 제어 또는 깃), 보고, 요구 사항 관리, 프로젝트 관리 (애자일 소프트웨어 개발), 테스트 및 출시 관리 기능을 제공하는 마이크로소프트의 제품이다.","{'word': '비주얼 스튜디오 팀 서비스', 'start': 5185, 'end': 5198, 'type': 'COM'}","{'word': '소스 코드 관리', 'start': 5207, 'end': 5214, 'type': 'COM'}",com:sub_concept
229,"비주얼 스튜디오 팀 서비스(vsts)는 소스 코드 관리(팀 파운데이션 버전 제어 또는 깃), 보고, 요구 사항 관리, 프로젝트 관리 (애자일 소프트웨어 개발), 테스트 및 출시 관리 기능을 제공하는 마이크로소프트의 제품이다.","{'word': '비주얼 스튜디오 팀 서비스', 'start': 5185, 'end': 5198, 'type': 'COM'}","{'word': '보고', 'start': 5237, 'end': 5238, 'type': 'COM'}",com:sub_concept
230,"비주얼 스튜디오 팀 서비스(vsts)는 소스 코드 관리(팀 파운데이션 버전 제어 또는 깃), 보고, 요구 사항 관리, 프로젝트 관리 (애자일 소프트웨어 개발), 테스트 및 출시 관리 기능을 제공하는 마이크로소프트의 제품이다.","{'word': '비주얼 스튜디오 팀 서비스', 'start': 5185, 'end': 5198, 'type': 'COM'}","{'word': '요구 사항 관리', 'start': 5241, 'end': 5248, 'type': 'COM'}",com:sub_concept
231,"비주얼 스튜디오 팀 서비스(vsts)는 소스 코드 관리(팀 파운데이션 버전 제어 또는 깃), 보고, 요구 사항 관리, 프로젝트 관리 (애자일 소프트웨어 개발), 테스트 및 출시 관리 기능을 제공하는 마이크로소프트의 제품이다.","{'word': '비주얼 스튜디오 팀 서비스', 'start': 5185, 'end': 5198, 'type': 'COM'}","{'word': '프로젝트 관리', 'start': 5251, 'end': 5257, 'type': 'COM'}",com:sub_concept
232,"비주얼 스튜디오 팀 서비스(vsts)는 소스 코드 관리(팀 파운데이션 버전 제어 또는 깃), 보고, 요구 사항 관리, 프로젝트 관리 (애자일 소프트웨어 개발), 테스트 및 출시 관리 기능을 제공하는 마이크로소프트의 제품이다.","{'word': '비주얼 스튜디오 팀 서비스', 'start': 5185, 'end': 5198, 'type': 'COM'}","{'word': '테스트 및 출시 관리 기능', 'start': 5275, 'end': 5288, 'type': 'COM'}",com:sub_concept
233,"마이크로소프트 비주얼 스튜디오(Microsoft Visual Studio)는 마이크로소프트 윈도우, macOS에서 작동하며, 다양한 언어로 프로그래밍할 수 있는 마이크로소프트의 통합 개발 환경이다.","{'word': '마이크로소프트 비주얼 스튜디오', 'start': 17, 'end': 32, 'type': 'COM'}","{'word': 'Microsoft Visual Studio', 'start': 34, 'end': 56, 'type': 'COM'}",com:alter_names
234,RC(Release Cantidate)를 거쳐 베타 버전을 지나 새로운 제품이 나오고 Express 버전이 나왔다.,"{'word': 'RC', 'start': 4094, 'end': 4095, 'type': 'COM'}","{'word': 'Release Cantidate', 'start': 4097, 'end': 4113, 'type': 'COM'}",com:alter_names
235,"버전은 15.0으로, 2016년 11월 16일 RC(Release Candidate)버전이 공개되었다.","{'word': 'RC', 'start': 4633, 'end': 4634, 'type': 'COM'}","{'word': 'Release Candidate', 'start': 4636, 'end': 4652, 'type': 'COM'}",com:alter_names
236,"비주얼 스튜디오 팀 서비스(vsts)는 소스 코드 관리(팀 파운데이션 버전 제어 또는 깃), 보고, 요구 사항 관리, 프로젝트 관리 (애자일 소프트웨어 개발), 테스트 및 출시 관리 기능을 제공하는 마이크로소프트의 제품이다.","{'word': '비주얼 스튜디오 팀 서비스', 'start': 5185, 'end': 5198, 'type': 'COM'}","{'word': 'vsts', 'start': 5200, 'end': 5203, 'type': 'COM'}",com:alter_names
237,C++ 관리되는 확장이라는 새로운 도구를 통해서 C++ 언어로 닷넷 프로그램을 짤 수 있게 되었다.,"{'word': '닷넷 프로그램', 'start': 1902, 'end': 1908, 'type': 'COM'}","{'word': 'C++ 언어', 'start': 1894, 'end': 1899, 'type': 'COM'}",com:made_of
238,"비주얼 스튜디오 버전 4.0 이전에, 비주얼 베이직 3, 비주얼 C++, 비주얼 폭스프로, 비주얼 소스세이프가 별도의 제품으로 있었다.","{'word': '비주얼 스튜디오 버전 4.0', 'start': 266, 'end': 280, 'type': 'COM'}","{'word': '비주얼 베이직 3', 'start': 287, 'end': 295, 'type': 'COM'}",com:prior_tech
239,"비주얼 스튜디오 버전 4.0 이전에, 비주얼 베이직 3, 비주얼 C++, 비주얼 폭스프로, 비주얼 소스세이프가 별도의 제품으로 있었다.","{'word': '비주얼 스튜디오 버전 4.0', 'start': 266, 'end': 280, 'type': 'COM'}","{'word': '비주얼 C++', 'start': 298, 'end': 304, 'type': 'COM'}",com:prior_tech
240,"비주얼 스튜디오 버전 4.0 이전에, 비주얼 베이직 3, 비주얼 C++, 비주얼 폭스프로, 비주얼 소스세이프가 별도의 제품으로 있었다.","{'word': '비주얼 스튜디오 버전 4.0', 'start': 266, 'end': 280, 'type': 'COM'}","{'word': '비주얼 폭스프로', 'start': 307, 'end': 314, 'type': 'COM'}",com:prior_tech
241,"비주얼 스튜디오 버전 4.0 이전에, 비주얼 베이직 3, 비주얼 C++, 비주얼 폭스프로, 비주얼 소스세이프가 별도의 제품으로 있었다.","{'word': '비주얼 스튜디오 버전 4.0', 'start': 266, 'end': 280, 'type': 'COM'}","{'word': '비주얼 소스세이프', 'start': 317, 'end': 325, 'type': 'COM'}",com:prior_tech
242,비주얼 베이직 닷넷은 이전 버전의 비주얼 베이직과는 달랐다.,"{'word': '비주얼 베이직 닷넷', 'start': 683, 'end': 692, 'type': 'COM'}","{'word': '이전 버전의 비주얼 베이직', 'start': 695, 'end': 708, 'type': 'COM'}",com:prior_tech
243,실제 명칭에서도 비주얼 베이직이라는 정식 명칭은 6.0 및 그 이전 버전에 대해서 사용할 수 있으며 7.0 이후부터는 비주얼 베이직 닷넷 이라고 부르게 되었다.,"{'word': '비주얼 베이직 닷넷', 'start': 1058, 'end': 1067, 'type': 'COM'}","{'word': '비주얼 베이직', 'start': 1001, 'end': 1007, 'type': 'COM'}",com:prior_tech
244,비주얼 J++는 더 이상 새 버전이 나오지 않고 있으며 대신 비주얼 J#이 새롭게 소개되었다. 하지만 비주얼 J#에 대한 비판의 목소리가 매우 높으며 실제 프로젝트에서 채택되어 이용되는 사례는 거의 없는 것으로 보인다.,"{'word': '비주얼 J#', 'start': 1205, 'end': 1210, 'type': 'COM'}","{'word': '비주얼 J++', 'start': 1171, 'end': 1177, 'type': 'COM'}",com:prior_tech
245,"또한 C#라는 새로운 언어를 소개하였으며, 비주얼 J++의 후속작 비주얼 J#을 소개하였다.","{'word': '비주얼 J#', 'start': 1711, 'end': 1716, 'type': 'COM'}","{'word': '비주얼 J++', 'start': 1698, 'end': 1704, 'type': 'COM'}",com:prior_tech
246,비주얼 스튜디오 2013 업데이트 1 (2013.1)이 2014년 1월 20일 공개되었다. 이 버전은 고객의 일부 주요 의 - 비주얼 스튜디오 2013의 차기 버전이다.,"{'word': '비주얼 스튜디오 2013 업데이트 1', 'start': 4369, 'end': 4388, 'type': 'COM'}","{'word': '비주얼 스튜디오 2013', 'start': 4440, 'end': 4452, 'type': 'COM'}",com:prior_tech
247,비주얼 스튜디오 2019의 차기작인 비주얼 스튜디오 2022는 매우 큰 것부터 바뀌었다.,"{'word': '비주얼 스튜디오 2022', 'start': 4940, 'end': 4952, 'type': 'COM'}","{'word': '비주얼 스튜디오 2019', 'start': 4920, 'end': 4932, 'type': 'COM'}",com:prior_tech
248,"인터페이스가 더 단정해졌으며, 사용자 정의할 수 있는 부분도 많아졌다.","{'word': '사용자', 'start': 1983, 'end': 1985, 'type': 'PER'}","{'word': '인터페이스', 'start': 1966, 'end': 1970, 'type': 'COM'}",no_relation
249,비주얼 스튜디오 닷넷 2002의 경우 무료로 60일 평가판을 사용할 수 있다.,"{'word': '비주얼 스튜디오 닷넷 2002', 'start': 2036, 'end': 2051, 'type': 'COM'}","{'word': '60일 평가판', 'start': 2061, 'end': 2067, 'type': 'POH'}",no_relation
250,익스프레스 에디션의 등장으로 기존과 같은 개별 언어에 대한 제품의 분리 판매는 더 이상 시행하지 않게 되었다.,"{'word': '익스프레스 에디션', 'start': 3452, 'end': 3460, 'type': 'COM'}","{'word': '제품', 'start': 3485, 'end': 3486, 'type': 'POH'}",no_relation
251,비주얼 스튜디오의 미리보기판은 빌드 2013 콘퍼런스에서 발표되어 2013년 7월 26일부터 사용이 가능했다.,"{'word': '비주얼 스튜디오의 미리보기판', 'start': 4254, 'end': 4268, 'type': 'COM'}","{'word': '빌드 2013 콘퍼런스', 'start': 4271, 'end': 4282, 'type': 'POH'}",no_relation
252,C++ 버전이 올라갔으며 현재는 프리뷰 상태인데 배경색이 검은색에서 하얀색으로 바뀌었다.,"{'word': 'C++ 버전', 'start': 4970, 'end': 4975, 'type': 'COM'}","{'word': '프리뷰 상태', 'start': 4988, 'end': 4993, 'type': 'POH'}",no_relation
253,"마이크로소프트 비주얼 스튜디오(Microsoft Visual Studio)는 마이크로소프트 윈도우, macOS에서 작동하며, 다양한 언어로 프로그래밍할 수 있는 마이크로소프트의 통합 개발 환경이다.","{'word': '마이크로소프트 비주얼 스튜디오', 'start': 17, 'end': 32, 'type': 'COM'}","{'word': '마이크로소프트 윈도우', 'start': 60, 'end': 70, 'type': 'COM'}",no_relation
254,"마이크로소프트 비주얼 스튜디오(Microsoft Visual Studio)는 마이크로소프트 윈도우, macOS에서 작동하며, 다양한 언어로 프로그래밍할 수 있는 마이크로소프트의 통합 개발 환경이다.","{'word': '마이크로소프트 비주얼 스튜디오', 'start': 17, 'end': 32, 'type': 'COM'}","{'word': 'macOS', 'start': 73, 'end': 77, 'type': 'COM'}",no_relation
255,"프로그램, 웹 사이트, 웹 프로그램 등을 개발할 수 있다.","{'word': '프로그램', 'start': 128, 'end': 131, 'type': 'COM'}","{'word': '웹 사이트', 'start': 134, 'end': 138, 'type': 'COM'}",no_relation
256,"프로그램, 웹 사이트, 웹 프로그램 등을 개발할 수 있다.","{'word': '프로그램', 'start': 128, 'end': 131, 'type': 'COM'}","{'word': '웹 프로그램', 'start': 141, 'end': 146, 'type': 'COM'}",no_relation
257,"프로그램, 웹 사이트, 웹 프로그램 등을 개발할 수 있다.","{'word': '웹 사이트', 'start': 134, 'end': 138, 'type': 'COM'}","{'word': '웹 프로그램', 'start': 141, 'end': 146, 'type': 'COM'}",no_relation
258,"비주얼 인터데브와 마이크로소프트 개발자 네트워크의 일부분이 들어 있었다. ""마이크로소프트의 첫 통합 개발 환경이다"".","{'word': '비주얼 인터데브', 'start': 462, 'end': 469, 'type': 'COM'}","{'word': '마이크로소프트 개발자 네트워크', 'start': 472, 'end': 487, 'type': 'COM'}",no_relation
259,마이크로소프트가 닷넷 프레임워크에 신경을 쓰는 4년간 핵심 개발자 도구였다.,"{'word': '마이크로소프트', 'start': 582, 'end': 588, 'type': 'COM'}","{'word': '닷넷 프레임워크', 'start': 591, 'end': 598, 'type': 'COM'}",no_relation
260,"역시 비주얼 베이직과 비주얼 폭스프로는 독립된 도구로 남아 있었고, 비주얼 J++과 비주얼 인터데브도 더 이상 통합된 개발 환경을 이루지 못하게 되었다.","{'word': '비주얼 베이직', 'start': 838, 'end': 844, 'type': 'COM'}","{'word': '비주얼 폭스프로', 'start': 847, 'end': 854, 'type': 'COM'}",no_relation
261,"역시 비주얼 베이직과 비주얼 폭스프로는 독립된 도구로 남아 있었고, 비주얼 J++과 비주얼 인터데브도 더 이상 통합된 개발 환경을 이루지 못하게 되었다.","{'word': '비주얼 J++', 'start': 873, 'end': 879, 'type': 'COM'}","{'word': '비주얼 인터데브', 'start': 882, 'end': 889, 'type': 'COM'}",no_relation
262,비주얼 폭스프로는 한 차례 닷넷 프레임워크 기반의 개발 도구로 독립 발매된 적이 있으며 최근에는 CodePlex를 통하여 오픈 소스 제품으로 론칭할 예정이다.,"{'word': '비주얼 폭스프로', 'start': 1082, 'end': 1089, 'type': 'COM'}","{'word': 'CodePlex', 'start': 1136, 'end': 1143, 'type': 'COM'}",no_relation
263,비주얼 인터데브 역시 더 이상 새 버전은 나오지 않고 있다. 하지만 비주얼 스튜디오 닷넷 2002 이후부터 지원되는 ASP 닷넷 기반의 통합 웹 개발 환경을 통하여 비주얼 인터데브의 기존 기능과 함께 업그레이드된 기능을 사용할 수 있게 되었다.,"{'word': '비주얼 인터데브', 'start': 1294, 'end': 1301, 'type': 'COM'}","{'word': '비주얼 스튜디오 닷넷 2002', 'start': 1332, 'end': 1347, 'type': 'COM'}",no_relation
264,자바 바이트코드처럼 닷넷 프레임워크의 관리되는 코드는 기계어로 컴파일되지 않는다.,"{'word': '자바 바이트코드', 'start': 1534, 'end': 1541, 'type': 'COM'}","{'word': '닷넷 프레임워크', 'start': 1545, 'end': 1552, 'type': 'COM'}",no_relation
265,모노나 DotGNU 같은 도구로 MSIL 언어의 프로그램을 실행시킬 수도 있다.,"{'word': '모노', 'start': 1629, 'end': 1630, 'type': 'COM'}","{'word': 'DotGNU', 'start': 1633, 'end': 1638, 'type': 'COM'}",no_relation
266,"비주얼 베이직은 비주얼 베이직 닷넷으로 바뀌었고, 기존의 비주얼 베이직의 문법적인 사양을 닷넷에 맞게 개선한 점 이외에는 완전히 다른 프로그래밍 언어와 개발 환경으로 자리잡았다.","{'word': '비주얼 베이직', 'start': 1767, 'end': 1773, 'type': 'COM'}","{'word': '비주얼 베이직 닷넷', 'start': 1776, 'end': 1785, 'type': 'COM'}",no_relation
267,비주얼 스튜디오 닷넷 환경은 비주얼 폭스프로를 제외한 모든 언어를 통합한다.,"{'word': '비주얼 스튜디오 닷넷 환경', 'start': 1923, 'end': 1936, 'type': 'COM'}","{'word': '비주얼 폭스프로', 'start': 1939, 'end': 1946, 'type': 'COM'}",no_relation
268,"내부 버전은 7.1이며, 닷넷 프레임워크가 업그레이드되었고 모바일 장치를 위한 프로그래밍이 가능해졌다.","{'word': '닷넷 프레임워크', 'start': 2156, 'end': 2163, 'type': 'COM'}","{'word': '모바일 장치', 'start': 2175, 'end': 2180, 'type': 'COM'}",no_relation
269,"C++ 컴파일러가 더욱 더 표준을 준수하게 되었고, 무료 버전도 사용할 수 있게 되었다.","{'word': 'C++ 컴파일러', 'start': 2200, 'end': 2207, 'type': 'COM'}","{'word': '무료 버전', 'start': 2229, 'end': 2233, 'type': 'COM'}",no_relation
270,"C++ 컴파일러가 더욱 더 표준을 준수하게 되었고, 무료 버전도 사용할 수 있게 되었다. 이 무료 버전은 후에 익스프레스 에디션이 된다.","{'word': 'C++ 컴파일러', 'start': 2200, 'end': 2207, 'type': 'COM'}","{'word': '익스프레스 에디션', 'start': 2262, 'end': 2270, 'type': 'COM'}",no_relation
271,또한 엔터프라이즈 템플릿이란 기능으로 거대한 개발 팀의 코딩 스타일이나 정책을 쉽게 조정할 수 있게 되었다.,"{'word': '엔터프라이즈 템플릿', 'start': 2382, 'end': 2391, 'type': 'COM'}","{'word': '코딩 스타일', 'start': 2410, 'end': 2415, 'type': 'COM'}",no_relation
272,현재 윈도우 비스타를 위한 특별 업데이트와 함께 공식적으로 비주얼 스튜디오 2005 서비스 팩 1을 사용할 수 있다.,"{'word': '윈도우 비스타', 'start': 2555, 'end': 2561, 'type': 'COM'}","{'word': '비주얼 스튜디오 2005 서비스 팩 1', 'start': 2585, 'end': 2605, 'type': 'COM'}",no_relation
273,비주얼 C++ 2005는 AMD64용 바이너리를 컴파일할 수 있게 되었다.,"{'word': '비주얼 C++ 2005', 'start': 2757, 'end': 2768, 'type': 'COM'}","{'word': 'AMD64용 바이너리', 'start': 2771, 'end': 2781, 'type': 'COM'}",no_relation
274,이전 버전의 비주얼 스튜디오는 64비트를 지원하지 않았다.,"{'word': '비주얼 스튜디오', 'start': 2806, 'end': 2813, 'type': 'COM'}","{'word': '64비트', 'start': 2816, 'end': 2819, 'type': 'COM'}",no_relation
275,플랫폼 SDK에만 64비트 컴파일러 및 라이브러리가 있었으며 비주얼 C++ 닷넷 2003의 경우는 마이크로소프트에 전자 우편을 보내야 했다.,"{'word': '비주얼 C++ 닷넷 2003', 'start': 2866, 'end': 2880, 'type': 'COM'}","{'word': '마이크로소프트', 'start': 2887, 'end': 2893, 'type': 'COM'}",no_relation
276,또한 팀 시스템은 MSDN 가입 여부에 따라서 4개의 버전으로 나뉜다.,"{'word': '팀 시스템', 'start': 3000, 'end': 3004, 'type': 'COM'}","{'word': 'MSDN', 'start': 3007, 'end': 3010, 'type': 'COM'}",no_relation
277,"익스프레스 에디션은 개인 및 교육 목적으로 사용하는 데 제한이 없으며, 인터넷을 통하여 무료로 다운로드할 수 있다.","{'word': '익스프레스 에디션', 'start': 3037, 'end': 3045, 'type': 'COM'}","{'word': '인터넷', 'start': 3077, 'end': 3079, 'type': 'COM'}",no_relation
278,"각각의 언어별로 익스프레스 에디션이 있으며 웹 전문 개발 도구인 웹 디벨로퍼 익스프레스, SQL 서버 2005 익스프레스 에디션, MSDN 라이브러리 익스프레스 에디션을 다운로드할 수 있다.","{'word': '웹 디벨로퍼 익스프레스', 'start': 3138, 'end': 3149, 'type': 'COM'}","{'word': 'SQL 서버 2005 익스프레스 에디션', 'start': 3152, 'end': 3172, 'type': 'COM'}",no_relation
279,"각각의 언어별로 익스프레스 에디션이 있으며 웹 전문 개발 도구인 웹 디벨로퍼 익스프레스, SQL 서버 2005 익스프레스 에디션, MSDN 라이브러리 익스프레스 에디션을 다운로드할 수 있다.","{'word': '웹 디벨로퍼 익스프레스', 'start': 3138, 'end': 3149, 'type': 'COM'}","{'word': 'MSDN 라이브러리 익스프레스 에디션', 'start': 3175, 'end': 3194, 'type': 'COM'}",no_relation
280,최근에는 윈도우 및 XBOX 360을 위한 게임 전문 개발 도구인 XNA 게임 스튜디오 익스프레스와 하드웨어 제어를 위한 로보틱스 스튜디오 익스프레스 에디션도 함께 배포하고 있다.,"{'word': '윈도우', 'start': 3214, 'end': 3216, 'type': 'COM'}","{'word': 'XBOX 360', 'start': 3220, 'end': 3227, 'type': 'COM'}",no_relation
281,최근에는 윈도우 및 XBOX 360을 위한 게임 전문 개발 도구인 XNA 게임 스튜디오 익스프레스와 하드웨어 제어를 위한 로보틱스 스튜디오 익스프레스 에디션도 함께 배포하고 있다.,"{'word': 'XNA 게임 스튜디오 익스프레스', 'start': 3246, 'end': 3262, 'type': 'COM'}","{'word': '로보틱스 스튜디오 익스프레스 에디션', 'start': 3277, 'end': 3295, 'type': 'COM'}",no_relation
282,전체 비주얼 스튜디오에서 누릴 수 있는 이점의 상당수가 누락되어 있지만 익스프레스 에디션 고유의 특혜가 있다.,"{'word': '비주얼 스튜디오', 'start': 3313, 'end': 3320, 'type': 'COM'}","{'word': '익스프레스 에디션', 'start': 3350, 'end': 3358, 'type': 'COM'}",no_relation
283,익스프레스 에디션 개발 도구는 설치 후 30일 이내에 개인 사용자 등록을 통하여 받을 수 있는 제품 키를 프로그램에 지정하여 인증하여야 한다.,"{'word': '익스프레스 에디션 개발 도구', 'start': 3372, 'end': 3386, 'type': 'COM'}","{'word': '프로그램', 'start': 3431, 'end': 3434, 'type': 'COM'}",no_relation
284,"비주얼 스튜디오 2005는 Professional은 90일, Team Suite는 180일간 평가할 수 있다.","{'word': 'Professional', 'start': 3529, 'end': 3540, 'type': 'COM'}","{'word': 'Team Suite', 'start': 3548, 'end': 3557, 'type': 'COM'}",no_relation
285,"윈도우 비스타, 닷넷 프레임워크 3.5 대응 및 LINQ, C# 3.0, 비주얼 베이직 9.0 등의 기능이 포함되었다.","{'word': '윈도우 비스타', 'start': 3647, 'end': 3653, 'type': 'COM'}","{'word': '닷넷 프레임워크 3.5 대응 및 LINQ', 'start': 3656, 'end': 3677, 'type': 'COM'}",no_relation
286,"윈도우 비스타, 닷넷 프레임워크 3.5 대응 및 LINQ, C# 3.0, 비주얼 베이직 9.0 등의 기능이 포함되었다.","{'word': '윈도우 비스타', 'start': 3647, 'end': 3653, 'type': 'COM'}","{'word': 'C# 3.0', 'start': 3680, 'end': 3685, 'type': 'COM'}",no_relation
287,"윈도우 비스타, 닷넷 프레임워크 3.5 대응 및 LINQ, C# 3.0, 비주얼 베이직 9.0 등의 기능이 포함되었다.","{'word': '윈도우 비스타', 'start': 3647, 'end': 3653, 'type': 'COM'}","{'word': '비주얼 베이직 9.0', 'start': 3688, 'end': 3698, 'type': 'COM'}",no_relation
288,웹 개발 환경에서는 프로젝트 내에 포함된 소스 코드에 대해서도 인텔리센스 기능을 지원하게 되었다.,"{'word': '웹 개발 환경', 'start': 3714, 'end': 3720, 'type': 'COM'}","{'word': '프로젝트', 'start': 3725, 'end': 3728, 'type': 'COM'}",no_relation
289,"윈도우 7, 윈도우 서버 2008 R2 운영 체제를 위한 기술을 제공하며, 닷넷 프레임워크 4.0 대응 및 C# 4.0, 비주얼 베이직 10.0 등의 기능이 새로 포함되어 2010년 4월 12일에 출시하였다.","{'word': '윈도우 7', 'start': 3911, 'end': 3915, 'type': 'COM'}","{'word': '윈도우 서버 2008 R2 운영 체제', 'start': 3918, 'end': 3937, 'type': 'COM'}",no_relation
290,"윈도우 7, 윈도우 서버 2008 R2 운영 체제를 위한 기술을 제공하며, 닷넷 프레임워크 4.0 대응 및 C# 4.0, 비주얼 베이직 10.0 등의 기능이 새로 포함되어 2010년 4월 12일에 출시하였다.","{'word': '윈도우 7', 'start': 3911, 'end': 3915, 'type': 'COM'}","{'word': '닷넷 프레임워크 4.0 대응 및 C# 4.0', 'start': 3953, 'end': 3976, 'type': 'COM'}",no_relation
291,"윈도우 7, 윈도우 서버 2008 R2 운영 체제를 위한 기술을 제공하며, 닷넷 프레임워크 4.0 대응 및 C# 4.0, 비주얼 베이직 10.0 등의 기능이 새로 포함되어 2010년 4월 12일에 출시하였다.","{'word': '윈도우 7', 'start': 3911, 'end': 3915, 'type': 'COM'}","{'word': '비주얼 베이직 10.0', 'start': 3979, 'end': 3990, 'type': 'COM'}",no_relation
292,비주얼 스튜디오 2013 최종판은 닷넷 4.5.1과 더불어 2013년 10월 17일부터 다운로드가 가능하다.,"{'word': '비주얼 스튜디오 2013 최종판', 'start': 4193, 'end': 4209, 'type': 'COM'}","{'word': '닷넷 4.5.1', 'start': 4212, 'end': 4219, 'type': 'COM'}",no_relation
293,"윈도우 10 운영 체제를 위한 기술을 제공하며, 닷넷 프레임워크 4.6에 대응한다.","{'word': '윈도우 10 운영 체제', 'start': 4464, 'end': 4475, 'type': 'COM'}","{'word': '닷넷 프레임워크 4.6', 'start': 4491, 'end': 4502, 'type': 'COM'}",no_relation
294,"이 버전에서는 그간 속도 문제가 제기되었던 인스톨러가 교체되었고, 리눅스로의 원격 C++ 빌드 지원, 개발자 도우미에 C++ 언어 추가 등의 기능을 지원한다.","{'word': '리눅스', 'start': 4702, 'end': 4704, 'type': 'COM'}","{'word': '원격 C++ 빌드 지원', 'start': 4708, 'end': 4719, 'type': 'COM'}",no_relation
295,Vsts는 수많은 통합 개발 환경의 백엔드로 쓸 수 있으나 마이크로소프트 비주얼 스튜디오의 백엔드로 사용할 때 최상의 이점을 제공하도록 설계되어 있다.,"{'word': 'Vsts', 'start': 5311, 'end': 5314, 'type': 'COM'}","{'word': '마이크로소프트 비주얼 스튜디오', 'start': 5344, 'end': 5359, 'type': 'COM'}",no_relation
296,비주얼 스튜디오에 추가기능이 없을때 비주얼 스튜디오 인스톨러를 쓴다.,"{'word': '비주얼 스튜디오', 'start': 5396, 'end': 5403, 'type': 'COM'}","{'word': '비주얼 스튜디오 인스톨러', 'start': 5416, 'end': 5428, 'type': 'COM'}",no_relation
297,"마이크로소프트에서는 비주얼 베이직, 비주얼 C#, 비주얼 J# 등 특정한 언어로만 프로그래밍할 수 있는 언어별 버전도 제공하고 있다.","{'word': '비주얼 베이직', 'start': 172, 'end': 178, 'type': 'COM'}","{'word': '비주얼 C#', 'start': 181, 'end': 186, 'type': 'COM'}",com:similar_tech
298,"마이크로소프트에서는 비주얼 베이직, 비주얼 C#, 비주얼 J# 등 특정한 언어로만 프로그래밍할 수 있는 언어별 버전도 제공하고 있다.","{'word': '비주얼 베이직', 'start': 172, 'end': 178, 'type': 'COM'}","{'word': '비주얼 J#', 'start': 189, 'end': 194, 'type': 'COM'}",com:similar_tech
299,"마이크로소프트에서는 비주얼 베이직, 비주얼 C#, 비주얼 J# 등 특정한 언어로만 프로그래밍할 수 있는 언어별 버전도 제공하고 있다.","{'word': '비주얼 C#', 'start': 181, 'end': 186, 'type': 'COM'}","{'word': '비주얼 J#', 'start': 189, 'end': 194, 'type': 'COM'}",com:similar_tech
300,"프로페셔널, 엔터프라이즈 에디션이 존재했으며 비주얼 베이직 5.0, 비주얼 C++ 5.0, 비주얼 J++ 1.1, 비주얼 폭스프로 5.0이 있었다.","{'word': '프로페셔널', 'start': 379, 'end': 383, 'type': 'COM'}","{'word': '엔터프라이즈 에디션', 'start': 386, 'end': 395, 'type': 'COM'}",com:similar_tech
301,"프로페셔널, 엔터프라이즈 에디션이 존재했으며 비주얼 베이직 5.0, 비주얼 C++ 5.0, 비주얼 J++ 1.1, 비주얼 폭스프로 5.0이 있었다.","{'word': '비주얼 베이직 5.0', 'start': 404, 'end': 414, 'type': 'COM'}","{'word': '비주얼 C++ 5.0', 'start': 417, 'end': 427, 'type': 'COM'}",com:similar_tech
302,"프로페셔널, 엔터프라이즈 에디션이 존재했으며 비주얼 베이직 5.0, 비주얼 C++ 5.0, 비주얼 J++ 1.1, 비주얼 폭스프로 5.0이 있었다.","{'word': '비주얼 베이직 5.0', 'start': 404, 'end': 414, 'type': 'COM'}","{'word': '비주얼 J++ 1.1', 'start': 430, 'end': 440, 'type': 'COM'}",com:similar_tech
303,"프로페셔널, 엔터프라이즈 에디션이 존재했으며 비주얼 베이직 5.0, 비주얼 C++ 5.0, 비주얼 J++ 1.1, 비주얼 폭스프로 5.0이 있었다.","{'word': '비주얼 베이직 5.0', 'start': 404, 'end': 414, 'type': 'COM'}","{'word': '비주얼 폭스프로 5.0', 'start': 443, 'end': 454, 'type': 'COM'}",com:similar_tech
304,"프로페셔널, 엔터프라이즈 에디션이 존재했으며 비주얼 베이직 5.0, 비주얼 C++ 5.0, 비주얼 J++ 1.1, 비주얼 폭스프로 5.0이 있었다.","{'word': '비주얼 C++ 5.0', 'start': 417, 'end': 427, 'type': 'COM'}","{'word': '비주얼 J++ 1.1', 'start': 430, 'end': 440, 'type': 'COM'}",com:similar_tech
305,"프로페셔널, 엔터프라이즈 에디션이 존재했으며 비주얼 베이직 5.0, 비주얼 C++ 5.0, 비주얼 J++ 1.1, 비주얼 폭스프로 5.0이 있었다.","{'word': '비주얼 C++ 5.0', 'start': 417, 'end': 427, 'type': 'COM'}","{'word': '비주얼 폭스프로 5.0', 'start': 443, 'end': 454, 'type': 'COM'}",com:similar_tech
306,"프로페셔널, 엔터프라이즈 에디션이 존재했으며 비주얼 베이직 5.0, 비주얼 C++ 5.0, 비주얼 J++ 1.1, 비주얼 폭스프로 5.0이 있었다.","{'word': '비주얼 J++ 1.1', 'start': 430, 'end': 440, 'type': 'COM'}","{'word': '비주얼 폭스프로 5.0', 'start': 443, 'end': 454, 'type': 'COM'}",com:similar_tech
307,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '아카데믹', 'start': 2302, 'end': 2305, 'type': 'COM'}","{'word': '프로페셔널', 'start': 2308, 'end': 2312, 'type': 'COM'}",com:similar_tech
308,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '아카데믹', 'start': 2302, 'end': 2305, 'type': 'COM'}","{'word': '엔터프라이즈 디벨로퍼', 'start': 2315, 'end': 2325, 'type': 'COM'}",com:similar_tech
309,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '아카데믹', 'start': 2302, 'end': 2305, 'type': 'COM'}","{'word': '엔터프라이즈 아키텍트', 'start': 2328, 'end': 2338, 'type': 'COM'}",com:similar_tech
310,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '프로페셔널', 'start': 2308, 'end': 2312, 'type': 'COM'}","{'word': '엔터프라이즈 디벨로퍼', 'start': 2315, 'end': 2325, 'type': 'COM'}",com:similar_tech
311,"비주얼 스튜디오 2003의 네 가지 에디션은 아카데믹, 프로페셔널, 엔터프라이즈 디벨로퍼, 엔터프라이즈 아키텍트가 있다.","{'word': '엔터프라이즈 디벨로퍼', 'start': 2315, 'end': 2325, 'type': 'COM'}","{'word': '엔터프라이즈 아키텍트', 'start': 2328, 'end': 2338, 'type': 'COM'}",com:similar_tech
312,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '익스프레스', 'start': 2931, 'end': 2935, 'type': 'COM'}","{'word': '스탠더드', 'start': 2938, 'end': 2941, 'type': 'COM'}",com:similar_tech
313,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '익스프레스', 'start': 2931, 'end': 2935, 'type': 'COM'}","{'word': '프로페셔널', 'start': 2944, 'end': 2948, 'type': 'COM'}",com:similar_tech
314,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '스탠더드', 'start': 2938, 'end': 2941, 'type': 'COM'}","{'word': '프로페셔널', 'start': 2944, 'end': 2948, 'type': 'COM'}",com:similar_tech
315,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '익스프레스', 'start': 2931, 'end': 2935, 'type': 'COM'}","{'word': '툴즈 포 오피스', 'start': 2951, 'end': 2958, 'type': 'COM'}",com:similar_tech
316,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '스탠더드', 'start': 2938, 'end': 2941, 'type': 'COM'}","{'word': '툴즈 포 오피스', 'start': 2951, 'end': 2958, 'type': 'COM'}",com:similar_tech
317,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '프로페셔널', 'start': 2944, 'end': 2948, 'type': 'COM'}","{'word': '툴즈 포 오피스', 'start': 2951, 'end': 2958, 'type': 'COM'}",com:similar_tech
318,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '익스프레스', 'start': 2931, 'end': 2935, 'type': 'COM'}","{'word': '팀 시스템', 'start': 2961, 'end': 2965, 'type': 'COM'}",com:similar_tech
319,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '스탠더드', 'start': 2938, 'end': 2941, 'type': 'COM'}","{'word': '팀 시스템', 'start': 2961, 'end': 2965, 'type': 'COM'}",com:similar_tech
320,"비주얼 스튜디오 2005의 에디션은 익스프레스, 스탠더드, 프로페셔널, 툴즈 포 오피스, 팀 시스템으로 나뉜다.","{'word': '툴즈 포 오피스', 'start': 2951, 'end': 2958, 'type': 'COM'}","{'word': '팀 시스템', 'start': 2961, 'end': 2965, 'type': 'COM'}",com:similar_tech
321,"버전은 16.0으로, 2018년 6월 6일 마이크로소프트에서 발표했다.","{'word': '마이크로소프트', 'start': 4848, 'end': 4854, 'type': 'ORG'}","{'word': '2018년 6월 6일', 'start': 4836, 'end': 4846, 'type': 'DAT'}",no_relation
322,절차형 언어로 1964년 다트머스 대학교의 존 케메니(John Kemeny)와 토머스 커츠(Thomas Kurtz)가 개발했다.,"{'word': '존 케메니(John Kemeny)', 'start': 140, 'end': 157, 'type': 'PER'}","{'word': '토머스 커츠(Thomas Kurtz)', 'start': 160, 'end': 179, 'type': 'PER'}",per:colleagues
323,"초심자용 다목적 기호명령부호(初心者用 多目的 記號命令符號，Beginner's All-purpose Symbolic Instruction Code), 약자 베이직(BASIC, )은 프로그래밍 언어의 하나이다.","{'word': '프로그래밍 언어', 'start': 100, 'end': 107, 'type': 'COM'}","{'word': '베이직', 'start': 86, 'end': 88, 'type': 'COM'}",com:sub_concept
324,이후의 베이직은 구조화 프로그래밍을 지원하며 코드에서 줄번호가 사라졌다.,"{'word': '베이직', 'start': 547, 'end': 549, 'type': 'COM'}","{'word': '구조화 프로그래밍', 'start': 552, 'end': 560, 'type': 'COM'}",com:sub_concept
325,다음 예는 현대적인 베이직의 거의 대부분에서 RUN 명령으로 실행할 수 있다.,"{'word': '베이직', 'start': 595, 'end': 597, 'type': 'COM'}","{'word': 'RUN 명령', 'start': 609, 'end': 614, 'type': 'COM'}",com:sub_concept
326,많은 베이직에서 End 선언문은 빼도 된다.,"{'word': '베이직', 'start': 653, 'end': 655, 'type': 'COM'}","{'word': 'End 선언문', 'start': 659, 'end': 665, 'type': 'COM'}",com:sub_concept
327,"초심자용 다목적 기호명령부호(初心者用 多目的 記號命令符號，Beginner's All-purpose Symbolic Instruction Code), 약자 베이직(BASIC, )은 프로그래밍 언어의 하나이다.","{'word': '초심자용 다목적 기호명령부호', 'start': 0, 'end': 14, 'type': 'COM'}","{'word': '初心者用 多目的 記號命令符號', 'start': 16, 'end': 30, 'type': 'COM'}",com:alter_names
328,"초심자용 다목적 기호명령부호(初心者用 多目的 記號命令符號，Beginner's All-purpose Symbolic Instruction Code), 약자 베이직(BASIC, )은 프로그래밍 언어의 하나이다.","{'word': '초심자용 다목적 기호명령부호', 'start': 0, 'end': 14, 'type': 'COM'}","{'word': ""Beginner's All-purpose Symbolic Instruction Code"", 'start': 32, 'end': 79, 'type': 'COM'}",com:alter_names
329,"초심자용 다목적 기호명령부호(初心者用 多目的 記號命令符號，Beginner's All-purpose Symbolic Instruction Code), 약자 베이직(BASIC, )은 프로그래밍 언어의 하나이다.","{'word': '베이직', 'start': 86, 'end': 88, 'type': 'COM'}","{'word': 'BASIC', 'start': 90, 'end': 94, 'type': 'COM'}",com:alter_names
330,"교육용으로 개발되어 언어의 문법이 쉬우며, 다트머스의 최초 제품 이래로 인터프리터 방식이 많았으나 최근에는 컴파일러 방식도 많다.","{'word': '인터프리터 방식', 'start': 228, 'end': 235, 'type': 'COM'}","{'word': '컴파일러 방식', 'start': 248, 'end': 254, 'type': 'COM'}",no_relation
331,현재는 다양한 종류의 베이직이 존재하며 서로 문법도 많이 차이가 난다.,"{'word': '베이직', 'start': 273, 'end': 275, 'type': 'COM'}","{'word': '문법', 'start': 286, 'end': 287, 'type': 'COM'}",no_relation
332,서로 다른 종류 사이의 소스 코드는 호환되지 않는다.,"{'word': '종류', 'start': 307, 'end': 308, 'type': 'COM'}","{'word': '소스 코드', 'start': 314, 'end': 318, 'type': 'COM'}",no_relation
333,아래 예는 모든 ANSI/ISO 호환 베이직과 1970년대에서 1980년대에 마이크로 컴퓨터에 설치된 대부분의 베이직에서 동작한다.,"{'word': 'ANSI/ISO', 'start': 340, 'end': 347, 'type': 'COM'}","{'word': '베이직', 'start': 352, 'end': 354, 'type': 'COM'}",no_relation
334,이러한 기종에 설치된 베이직은 줄번호가 생략된 즉각 모드로 실행할 수도 있다.,"{'word': '베이직', 'start': 442, 'end': 444, 'type': 'COM'}","{'word': '즉각 모드', 'start': 456, 'end': 460, 'type': 'COM'}",no_relation
335,다음 예를 실행할 때에는 RUN 명령어가 필요없다.,"{'word': '예', 'start': 477, 'end': 477, 'type': 'COM'}","{'word': 'RUN 명령어', 'start': 488, 'end': 494, 'type': 'COM'}",no_relation
336,사용자 입력 개수 만큼 별 출력.,"{'word': '사용자 입력', 'start': 675, 'end': 680, 'type': 'COM'}","{'word': '출력', 'start': 690, 'end': 691, 'type': 'COM'}",no_relation
337,"2006년 개발자 그레이든 호아레의 개인 프로젝트로 시작되었으며, 2009년 호아레의 고용주인 모질라가 2010년 처음으로 일반에 공개되었으며, 같은 해 Objective Caml로 작성된 초기 컴파일러에서 Rust로 작성된 컴파일러로 전환되었다. ""rustc""는 2011년 처음으로 자기 자신을 컴파일하는데 성공했다.","{'word': '그레이든 호아레', 'start': 143, 'end': 150, 'type': 'PER'}","{'word': 'Rust', 'start': 249, 'end': 252, 'type': 'COM'}",per:production
338,"러스트()는 모질라 리서치에서 개발한 범용 프로그래밍 언어이다. ""안전하고, 병렬적이며, 실용적인"" 언어로 디자인되었으며, 순수 함수형 프로그래밍, 액터 기반 병렬 프로그래밍, 명령형 프로그래밍, 객체 지향 프로그래밍 스타일을 지원한다.","{'word': '모질라 리서치', 'start': 7, 'end': 13, 'type': 'ORG'}","{'word': '러스트', 'start': 0, 'end': 2, 'type': 'COM'}",org:production
339,"모질라의 정책에 따라, 러스트는 전적으로 오픈 소스로 개발되고 있으며, 커뮤니티로부터 피드백을 받고 있다.","{'word': '모질라', 'start': 345, 'end': 347, 'type': 'ORG'}","{'word': '러스트', 'start': 358, 'end': 360, 'type': 'COM'}",org:production
340,모질라 재단이 러스트의 개발을 후원하고 있다.,"{'word': '모질라 재단', 'start': 405, 'end': 410, 'type': 'ORG'}","{'word': '러스트', 'start': 413, 'end': 415, 'type': 'COM'}",org:production
341,러스트의 설계에는 모질라의 렌더링 엔진인 서보와 rustc 컴파일러를 개발하면서 쌓인 경험들이 반영되어 있다.,"{'word': '모질라', 'start': 441, 'end': 443, 'type': 'ORG'}","{'word': '서보', 'start': 454, 'end': 455, 'type': 'COM'}",org:production
342,"러스트()는 모질라 리서치에서 개발한 범용 프로그래밍 언어이다. ""안전하고, 병렬적이며, 실용적인"" 언어로 디자인되었으며, 순수 함수형 프로그래밍, 액터 기반 병렬 프로그래밍, 명령형 프로그래밍, 객체 지향 프로그래밍 스타일을 지원한다.","{'word': '러스트', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': '순수 함수형 프로그래밍', 'start': 69, 'end': 80, 'type': 'COM'}",com:sub_concept
343,"러스트()는 모질라 리서치에서 개발한 범용 프로그래밍 언어이다. ""안전하고, 병렬적이며, 실용적인"" 언어로 디자인되었으며, 순수 함수형 프로그래밍, 액터 기반 병렬 프로그래밍, 명령형 프로그래밍, 객체 지향 프로그래밍 스타일을 지원한다.","{'word': '러스트', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': '액터 기반 병렬 프로그래밍', 'start': 83, 'end': 96, 'type': 'COM'}",com:sub_concept
344,"러스트()는 모질라 리서치에서 개발한 범용 프로그래밍 언어이다. ""안전하고, 병렬적이며, 실용적인"" 언어로 디자인되었으며, 순수 함수형 프로그래밍, 액터 기반 병렬 프로그래밍, 명령형 프로그래밍, 객체 지향 프로그래밍 스타일을 지원한다.","{'word': '프로그래밍 언어', 'start': 24, 'end': 31, 'type': 'COM'}","{'word': '러스트', 'start': 0, 'end': 2, 'type': 'COM'}",com:sub_concept
345,"러스트()는 모질라 리서치에서 개발한 범용 프로그래밍 언어이다. ""안전하고, 병렬적이며, 실용적인"" 언어로 디자인되었으며, 순수 함수형 프로그래밍, 액터 기반 병렬 프로그래밍, 명령형 프로그래밍, 객체 지향 프로그래밍 스타일을 지원한다.","{'word': '러스트', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': '명령형 프로그래밍', 'start': 99, 'end': 107, 'type': 'COM'}",com:sub_concept
346,"러스트()는 모질라 리서치에서 개발한 범용 프로그래밍 언어이다. ""안전하고, 병렬적이며, 실용적인"" 언어로 디자인되었으며, 순수 함수형 프로그래밍, 액터 기반 병렬 프로그래밍, 명령형 프로그래밍, 객체 지향 프로그래밍 스타일을 지원한다.","{'word': '러스트', 'start': 0, 'end': 2, 'type': 'COM'}","{'word': '객체 지향 프로그래밍 스타일', 'start': 110, 'end': 124, 'type': 'COM'}",com:sub_concept
347,카고(cargo)는 러스트의 빌드 시스템이다.,"{'word': '러스트', 'start': 504, 'end': 506, 'type': 'COM'}","{'word': '카고(cargo)', 'start': 493, 'end': 501, 'type': 'COM'}",com:sub_concept
348,러스트는 CPU 병행처리 및 메모리 자원 누수 방지등의 언어 철학 바탕위에 설계된 취지에 맞게 안전성으로 제작된 프로그램은 빌드 과정에서 사전에 불안정한 결과를 방지할 수 있다는 빌드시스템으로까지 이어지는 완전한 안정성을 실현하고 있다,"{'word': '러스트', 'start': 519, 'end': 521, 'type': 'COM'}","{'word': 'CPU 병행처리', 'start': 524, 'end': 531, 'type': 'COM'}",com:sub_concept
349,러스트는 CPU 병행처리 및 메모리 자원 누수 방지등의 언어 철학 바탕위에 설계된 취지에 맞게 안전성으로 제작된 프로그램은 빌드 과정에서 사전에 불안정한 결과를 방지할 수 있다는 빌드시스템으로까지 이어지는 완전한 안정성을 실현하고 있다,"{'word': '러스트', 'start': 519, 'end': 521, 'type': 'COM'}","{'word': '메모리 자원 누수 방지', 'start': 535, 'end': 546, 'type': 'COM'}",com:sub_concept
350,타입 시스템은 하스켈의 영향을 받아 타입 클래스를 지원한다.,"{'word': '타입 시스템', 'start': 1081, 'end': 1086, 'type': 'COM'}","{'word': '타입 클래스', 'start': 1101, 'end': 1106, 'type': 'COM'}",com:sub_concept
351,반면 함수의 인자나 반환값에서는 타입 정보를 빼놓을 수 없다.,"{'word': '함수', 'start': 1180, 'end': 1181, 'type': 'COM'}","{'word': '인자', 'start': 1184, 'end': 1185, 'type': 'COM'}",com:sub_concept
352,반면 함수의 인자나 반환값에서는 타입 정보를 빼놓을 수 없다.,"{'word': '함수', 'start': 1180, 'end': 1181, 'type': 'COM'}","{'word': '반환값', 'start': 1188, 'end': 1190, 'type': 'COM'}",com:sub_concept
353,"객체 시스템은 implementation, trait, struct 또는 enum으로 이루어져 있다.","{'word': '객체 시스템', 'start': 1444, 'end': 1449, 'type': 'COM'}","{'word': 'implementation', 'start': 1452, 'end': 1465, 'type': 'COM'}",com:sub_concept
354,"객체 시스템은 implementation, trait, struct 또는 enum으로 이루어져 있다.","{'word': '객체 시스템', 'start': 1444, 'end': 1449, 'type': 'COM'}","{'word': 'trait', 'start': 1468, 'end': 1472, 'type': 'COM'}",com:sub_concept
355,"객체 시스템은 implementation, trait, struct 또는 enum으로 이루어져 있다.","{'word': '객체 시스템', 'start': 1444, 'end': 1449, 'type': 'COM'}","{'word': 'struct', 'start': 1475, 'end': 1480, 'type': 'COM'}",com:sub_concept
356,"객체 시스템은 implementation, trait, struct 또는 enum으로 이루어져 있다.","{'word': '객체 시스템', 'start': 1444, 'end': 1449, 'type': 'COM'}","{'word': 'enum', 'start': 1485, 'end': 1488, 'type': 'COM'}",com:sub_concept
357,"codice_4 또는 codice_5은 객체의 데이터를 정의하는데 사용되며, codice_6 키워드로 정의하는 implementation은 객체의 멤버 함수를 정의하는데 사용된다.","{'word': '객체', 'start': 1523, 'end': 1524, 'type': 'COM'}","{'word': '데이터', 'start': 1527, 'end': 1529, 'type': 'COM'}",com:sub_concept
358,"codice_4 또는 codice_5은 객체의 데이터를 정의하는데 사용되며, codice_6 키워드로 정의하는 implementation은 객체의 멤버 함수를 정의하는데 사용된다.","{'word': '객체', 'start': 1579, 'end': 1580, 'type': 'COM'}","{'word': '멤버 함수', 'start': 1583, 'end': 1587, 'type': 'COM'}",com:sub_concept
359,"객체의 상속은 codice_7을 통해 이루어지며, C++의 다형 상속 문제를 회피하기 위해 trait은 객체의 멤버를 정의할 수 없도록 만들어져 있다.","{'word': 'C++', 'start': 1630, 'end': 1632, 'type': 'COM'}","{'word': '다형 상속 문제', 'start': 1635, 'end': 1642, 'type': 'COM'}",com:sub_concept
360,"아래 코드는 러스트 1.0 기준이며, 러스트의 문법은 향후 변경될 수 있다.","{'word': '러스트', 'start': 1708, 'end': 1710, 'type': 'COM'}","{'word': '러스트 1.0', 'start': 1694, 'end': 1700, 'type': 'COM'}",com:sub_concept
361,/* 이 함수는 러스트의 암묵적 반환문을 이용해 작성되었다.,"{'word': '러스트', 'start': 1800, 'end': 1802, 'type': 'COM'}","{'word': '암묵적 반환문', 'start': 1805, 'end': 1811, 'type': 'COM'}",com:sub_concept
362,"러스트의 `if` 문은 선언문이 아닌 표현식이므로, `if` 문에도 반환값이 존재한다.","{'word': '러스트', 'start': 1825, 'end': 1827, 'type': 'COM'}","{'word': '`if` 문', 'start': 1830, 'end': 1835, 'type': 'COM'}",com:sub_concept
363,"러스트의 `if` 문은 선언문이 아닌 표현식이므로, `if` 문에도 반환값이 존재한다.","{'word': '`if` 문', 'start': 1854, 'end': 1859, 'type': 'COM'}","{'word': '반환값', 'start': 1863, 'end': 1865, 'type': 'COM'}",com:sub_concept
364,다음은 러스트의 병행 프로그래밍 기능을 보여주는 예제이다.,"{'word': '러스트', 'start': 2219, 'end': 2221, 'type': 'COM'}","{'word': '병행 프로그래밍', 'start': 2224, 'end': 2231, 'type': 'COM'}",com:sub_concept
365,"// C나 C++의 단순한 코드 치환 매크로와 달리, 러스트의 매크로는 Scheme과 유사한 구조적 매크로이다.","{'word': 'C', 'start': 2655, 'end': 2655, 'type': 'COM'}","{'word': '코드 치환 매크로', 'start': 2667, 'end': 2675, 'type': 'COM'}",com:sub_concept
366,"// C나 C++의 단순한 코드 치환 매크로와 달리, 러스트의 매크로는 Scheme과 유사한 구조적 매크로이다.","{'word': 'C++', 'start': 2658, 'end': 2660, 'type': 'COM'}","{'word': '코드 치환 매크로', 'start': 2667, 'end': 2675, 'type': 'COM'}",com:sub_concept
367,"// C나 C++의 단순한 코드 치환 매크로와 달리, 러스트의 매크로는 Scheme과 유사한 구조적 매크로이다.","{'word': '러스트', 'start': 2682, 'end': 2684, 'type': 'COM'}","{'word': '매크로', 'start': 2687, 'end': 2689, 'type': 'COM'}",com:sub_concept
368,러스트 0.4 이전 버전은 정적 타입 검사에 더해 타입 상태 분석 기능을 지원하였다.,"{'word': '러스트 0.4 이전 버전', 'start': 2832, 'end': 2844, 'type': 'COM'}","{'word': '정적 타입 검사', 'start': 2847, 'end': 2854, 'type': 'COM'}",com:sub_concept
369,러스트 0.4 이전 버전은 정적 타입 검사에 더해 타입 상태 분석 기능을 지원하였다.,"{'word': '러스트 0.4 이전 버전', 'start': 2832, 'end': 2844, 'type': 'COM'}","{'word': '타입 상태 분석 기능', 'start': 2860, 'end': 2870, 'type': 'COM'}",com:sub_concept
370,"러스트 0.2는 처음으로 클래스를 도입하였고, 0.3에는 소멸자와 인터페이스가 도입되었다.","{'word': '러스트 0.2', 'start': 3028, 'end': 3034, 'type': 'COM'}","{'word': '클래스', 'start': 3042, 'end': 3044, 'type': 'COM'}",com:sub_concept
371,"러스트 0.2는 처음으로 클래스를 도입하였고, 0.3에는 소멸자와 인터페이스가 도입되었다.","{'word': '0.3', 'start': 3054, 'end': 3056, 'type': 'COM'}","{'word': '소멸자', 'start': 3060, 'end': 3062, 'type': 'COM'}",com:sub_concept
372,"러스트 0.2는 처음으로 클래스를 도입하였고, 0.3에는 소멸자와 인터페이스가 도입되었다.","{'word': '0.3', 'start': 3054, 'end': 3056, 'type': 'COM'}","{'word': '인터페이스', 'start': 3065, 'end': 3069, 'type': 'COM'}",com:sub_concept
373,"그러나 0.4에 trait 기능이 도입되면서 인터페이스는 trait와 통합되었고, class는 제거되었다.","{'word': '0.4', 'start': 3083, 'end': 3085, 'type': 'COM'}","{'word': 'trait 기능', 'start': 3088, 'end': 3095, 'type': 'COM'}",com:sub_concept
374,"러스트 파운데이션(Rust Foundation)은 참여형 대규모 오픈 소스 생태계를 유지하고 성장시키는 새로운 접근 방식으로 ""좋은 소프트웨어는 행복하고 잘 지원되는 사람들에 의해 만들어집니다.""라는 모토를 갖고서 러스트(Rust) 프로그래밍 언어와 생태계를 관리하는 독립적인 비영리 조직으로, 프로젝트를 관리하고 개발하는 유지 관리자를 지원하는 데 중점을 두고 있다.","{'word': '러스트 파운데이션', 'start': 3212, 'end': 3220, 'type': 'COM'}","{'word': 'Rust Foundation', 'start': 3222, 'end': 3236, 'type': 'COM'}",com:alter_names
375,"러스트 파운데이션(Rust Foundation)은 참여형 대규모 오픈 소스 생태계를 유지하고 성장시키는 새로운 접근 방식으로 ""좋은 소프트웨어는 행복하고 잘 지원되는 사람들에 의해 만들어집니다.""라는 모토를 갖고서 러스트(Rust) 프로그래밍 언어와 생태계를 관리하는 독립적인 비영리 조직으로, 프로젝트를 관리하고 개발하는 유지 관리자를 지원하는 데 중점을 두고 있다.","{'word': '러스트', 'start': 3332, 'end': 3334, 'type': 'COM'}","{'word': 'Rust', 'start': 3336, 'end': 3339, 'type': 'COM'}",com:alter_names
376,러스트 공식홈페이지에서는 '플레이그라운드'(playground) 페이지를 통해서 실시간 빌드 및 실행 테스트 공간을 제공하고있다.,"{'word': ""'플레이그라운드'"", 'start': 3153, 'end': 3161, 'type': 'COM'}","{'word': 'playground', 'start': 3163, 'end': 3172, 'type': 'POH'}",com:alter_names
377,러스트는 인터넷에서 실행되는 서버 및 클라이언트 프로그램을 개발하는데 적합한 언어를 목표로 설계되었다.,"{'word': '서버 및 클라이언트 프로그램', 'start': 667, 'end': 681, 'type': 'COM'}","{'word': '러스트', 'start': 651, 'end': 653, 'type': 'COM'}",com:made_of
378,아래는 각각 재귀함수와 반복문을 사용해 작성된 계승 함수이다:,"{'word': '재귀함수', 'start': 1763, 'end': 1766, 'type': 'COM'}","{'word': '계승 함수', 'start': 1782, 'end': 1786, 'type': 'COM'}",com:made_of
379,아래는 각각 재귀함수와 반복문을 사용해 작성된 계승 함수이다:,"{'word': '반복문', 'start': 1769, 'end': 1771, 'type': 'COM'}","{'word': '계승 함수', 'start': 1782, 'end': 1786, 'type': 'COM'}",com:made_of
380,// `thread::spawn`을 통해 스레드를 생성한다.,"{'word': '`thread::spawn`', 'start': 2538, 'end': 2552, 'type': 'COM'}","{'word': '스레드', 'start': 2558, 'end': 2560, 'type': 'COM'}",com:made_of
381,객체 시스템은 러스트 0.2에서 0.4에 거쳐 많은 변화를 겪었다.,"{'word': '0.4', 'start': 3008, 'end': 3010, 'type': 'COM'}","{'word': '러스트 0.2', 'start': 2998, 'end': 3004, 'type': 'COM'}",com:prior_tech
382,"러스트 0.2는 처음으로 클래스를 도입하였고, 0.3에는 소멸자와 인터페이스가 도입되었다.","{'word': '0.3', 'start': 3054, 'end': 3056, 'type': 'COM'}","{'word': '러스트 0.2', 'start': 3028, 'end': 3034, 'type': 'COM'}",com:prior_tech
383,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '구글', 'start': 3427, 'end': 3428, 'type': 'ORG'}","{'word': '마이크로소프트', 'start': 3431, 'end': 3437, 'type': 'ORG'}",no_relation
384,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '구글', 'start': 3427, 'end': 3428, 'type': 'ORG'}","{'word': '모질라 재단', 'start': 3440, 'end': 3445, 'type': 'ORG'}",no_relation
385,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '구글', 'start': 3427, 'end': 3428, 'type': 'ORG'}","{'word': '아마존 웹 서비스', 'start': 3448, 'end': 3456, 'type': 'ORG'}",no_relation
386,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '구글', 'start': 3427, 'end': 3428, 'type': 'ORG'}","{'word': '화웨이', 'start': 3459, 'end': 3461, 'type': 'ORG'}",no_relation
387,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '마이크로소프트', 'start': 3431, 'end': 3437, 'type': 'ORG'}","{'word': '모질라 재단', 'start': 3440, 'end': 3445, 'type': 'ORG'}",no_relation
388,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '마이크로소프트', 'start': 3431, 'end': 3437, 'type': 'ORG'}","{'word': '아마존 웹 서비스', 'start': 3448, 'end': 3456, 'type': 'ORG'}",no_relation
389,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '마이크로소프트', 'start': 3431, 'end': 3437, 'type': 'ORG'}","{'word': '화웨이', 'start': 3459, 'end': 3461, 'type': 'ORG'}",no_relation
390,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '모질라 재단', 'start': 3440, 'end': 3445, 'type': 'ORG'}","{'word': '아마존 웹 서비스', 'start': 3448, 'end': 3456, 'type': 'ORG'}",no_relation
391,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '모질라 재단', 'start': 3440, 'end': 3445, 'type': 'ORG'}","{'word': '화웨이', 'start': 3459, 'end': 3461, 'type': 'ORG'}",no_relation
392,"창립 멤버로는 구글, 마이크로소프트, 모질라 재단, 아마존 웹 서비스, 화웨이이다.","{'word': '아마존 웹 서비스', 'start': 3448, 'end': 3456, 'type': 'ORG'}","{'word': '화웨이', 'start': 3459, 'end': 3461, 'type': 'ORG'}",no_relation
393,"2010년 처음으로 일반에 공개되었으며, 같은 해 Objective Caml로 작성된 초기 컴파일러에서 Rust로 작성된 컴파일러로 전환되었다. ""rustc""는 2011년 처음으로 자기 자신을 컴파일하는데 성공했다.","{'word': '""rustc""', 'start': 272, 'end': 278, 'type': 'COM'}","{'word': '2011년', 'start': 281, 'end': 285, 'type': 'DAT'}",no_relation
394,2012년 1월 첫 번째 알파 버전인 0.1이 발표되었다.,"{'word': '알파 버전', 'start': 326, 'end': 330, 'type': 'COM'}","{'word': '2012년 1월', 'start': 312, 'end': 319, 'type': 'DAT'}",no_relation
395,"이 목표에 따라 러스트는 안전성과 병행 프로그래밍, 그리고 메모리 관리의 직접 제어에 초점을 맞추고 있다.","{'word': '병행 프로그래밍', 'start': 728, 'end': 735, 'type': 'COM'}","{'word': '메모리 관리', 'start': 742, 'end': 747, 'type': 'COM'}",no_relation
396,러스트는 메모리 오류를 발생시키지 않도록 설계되었다.,"{'word': '러스트', 'start': 939, 'end': 941, 'type': 'COM'}","{'word': '메모리 오류', 'start': 944, 'end': 949, 'type': 'COM'}",no_relation
397,러스트는 널 포인터나 초기화되지 않은 포인터가 존재하지 않도록 강제하고 있다.,"{'word': '러스트', 'start': 969, 'end': 971, 'type': 'COM'}","{'word': '널 포인터', 'start': 974, 'end': 978, 'type': 'COM'}",no_relation
398,러스트는 널 포인터나 초기화되지 않은 포인터가 존재하지 않도록 강제하고 있다.,"{'word': '러스트', 'start': 969, 'end': 971, 'type': 'COM'}","{'word': '포인터', 'start': 990, 'end': 992, 'type': 'COM'}",no_relation
399,"모든 변수는 초기값을 가지고 할당되며, 해제된 포인터에 접근하는 코드는 컴파일러가 미리 감지하여 컴파일 오류를 일으킨다.","{'word': '포인터', 'start': 1039, 'end': 1041, 'type': 'COM'}","{'word': '컴파일러', 'start': 1053, 'end': 1056, 'type': 'COM'}",no_relation
400,"또한, 변수 선언 시 타입을 지정하지 않아도 컴파일러가 타입 추론을 통해 해당 변수의 타입을 지정할 수 있다.","{'word': '컴파일러', 'start': 1140, 'end': 1143, 'type': 'COM'}","{'word': '변수', 'start': 1159, 'end': 1160, 'type': 'COM'}",no_relation
401,병행 프로그래밍은 얼랭과 유사한 actor 기반의 모델을 사용하고 있다.,"{'word': '병행 프로그래밍', 'start': 1212, 'end': 1219, 'type': 'COM'}","{'word': '얼랭', 'start': 1222, 'end': 1223, 'type': 'COM'}",no_relation
402,각각의 태스크는 데이터를 직접 공유하지 않고 메시지 전달을 통해서만 데이터를 교환할 수 있다.,"{'word': '태스크', 'start': 1257, 'end': 1259, 'type': 'COM'}","{'word': '데이터', 'start': 1262, 'end': 1264, 'type': 'COM'}",no_relation
403,"메시지를 복사할 때 생기는 성능 저하를 막기 위해, unique box의 경우 데이터 복사 없이 메시지를 전달할 수 있다.","{'word': 'unique box', 'start': 1335, 'end': 1344, 'type': 'COM'}","{'word': '데이터 복사', 'start': 1350, 'end': 1355, 'type': 'COM'}",no_relation
404,"unique box는 하나의 객체만이 소유할 수 있고, 다른 태스크로 전달될 경우 데이터 복사 없이 소유권만 바뀌게 된다.","{'word': 'unique box', 'start': 1375, 'end': 1384, 'type': 'COM'}","{'word': '태스크', 'start': 1409, 'end': 1411, 'type': 'COM'}",no_relation
405,아래는 각각 재귀함수와 반복문을 사용해 작성된 계승 함수이다:,"{'word': '재귀함수', 'start': 1763, 'end': 1766, 'type': 'COM'}","{'word': '반복문', 'start': 1769, 'end': 1771, 'type': 'COM'}",no_relation
406,// `mut` 키워드는 값이 바뀔 수 있는 변수를 가리킨다.,"{'word': '`mut` 키워드', 'start': 1971, 'end': 1979, 'type': 'COM'}","{'word': '변수', 'start': 1993, 'end': 1994, 'type': 'COM'}",no_relation
407,return result; // 위의 예제와 달리 명시적 반환문을 사용한다,"{'word': '예제', 'start': 2062, 'end': 2063, 'type': 'COM'}","{'word': '반환문', 'start': 2073, 'end': 2075, 'type': 'COM'}",no_relation
408,// 1.21 버전부터는 for_each가 가능해졌다.,"{'word': '1.21 버전', 'start': 2131, 'end': 2137, 'type': 'COM'}","{'word': 'for_each', 'start': 2142, 'end': 2149, 'type': 'COM'}",no_relation
409,/* 이 함수는 각각 병렬적으로 실행되는 10개의 스레드를 만든다.,"{'word': '함수', 'start': 2253, 'end': 2254, 'type': 'COM'}","{'word': '스레드', 'start': 2276, 'end': 2278, 'type': 'COM'}",no_relation
410,"각각의 스레드가 stdout에 접근을 시도함에 따라, 한 행에 여러 문자열이 섞여서","{'word': '스레드', 'start': 2290, 'end': 2292, 'type': 'COM'}","{'word': 'stdout', 'start': 2295, 'end': 2300, 'type': 'COM'}",no_relation
411,"// 변수 message는 변경이 불가능하므로, 여러 개의 태스크에서 동시에 접근해도 안전하다.","{'word': '변수 message', 'start': 2353, 'end': 2362, 'type': 'COM'}","{'word': '태스크', 'start': 2383, 'end': 2385, 'type': 'COM'}",no_relation
412,// `for` 반복문은 `Iterator` trait을 구현하는 어떤 객체에 대해서나 사용할 수 있다.,"{'word': '`for` 반복문', 'start': 2460, 'end': 2468, 'type': 'COM'}","{'word': '`Iterator` trait', 'start': 2471, 'end': 2486, 'type': 'COM'}",no_relation
413,"// println! 은 매크로이며, 컴파일 시간에 변수의 형 검사가 이루어진다.","{'word': '매크로', 'start': 2620, 'end': 2622, 'type': 'COM'}","{'word': '컴파일', 'start': 2627, 'end': 2629, 'type': 'COM'}",no_relation
414,타입 상태 분석 기능은 선언문 전후에 codice_8 키워드를 사용하여 해당 선언문이 의도대로 동작하는지 컴파일시에 검사할 수 있었다.,"{'word': '타입 상태 분석 기능', 'start': 2880, 'end': 2890, 'type': 'COM'}","{'word': '선언문', 'start': 2893, 'end': 2895, 'type': 'COM'}",no_relation
415,타입 상태 분석 기능은 선언문 전후에 codice_8 키워드를 사용하여 해당 선언문이 의도대로 동작하는지 컴파일시에 검사할 수 있었다. 그러나 이 기능은 실질적으로 거의 사용되지 않아 제거되었다.,"{'word': '선언문', 'start': 2923, 'end': 2925, 'type': 'COM'}","{'word': '기능', 'start': 2962, 'end': 2963, 'type': 'COM'}",no_relation
416,"이 목표에 따라 러스트는 안전성과 병행 프로그래밍, 그리고 메모리 관리의 직접 제어에 초점을 맞추고 있다. 또한 성능 면에서는 C++와 비슷한 수준을 목표로 하고 있다.","{'word': '러스트', 'start': 718, 'end': 720, 'type': 'COM'}","{'word': 'C++', 'start': 780, 'end': 782, 'type': 'COM'}",com:similar_tech
417,"러스트의 문법은 중괄호로 코드 블록을 구분하고, codice_1, codice_2, codice_3 등의 키워드를 사용하는 등 C 및 C++와 유사한 모양을 하고 있다.","{'word': '러스트', 'start': 804, 'end': 806, 'type': 'COM'}","{'word': 'C', 'start': 875, 'end': 875, 'type': 'COM'}",com:similar_tech
418,"러스트의 문법은 중괄호로 코드 블록을 구분하고, codice_1, codice_2, codice_3 등의 키워드를 사용하는 등 C 및 C++와 유사한 모양을 하고 있다.","{'word': '러스트', 'start': 804, 'end': 806, 'type': 'COM'}","{'word': 'C++', 'start': 879, 'end': 881, 'type': 'COM'}",com:similar_tech
419,그러나 러스트와 C/C++는 의미상으로는 크게 다른 문법을 갖고 있다.,"{'word': '러스트', 'start': 903, 'end': 905, 'type': 'COM'}","{'word': 'C', 'start': 908, 'end': 908, 'type': 'COM'}",com:similar_tech
420,그러나 러스트와 C/C++는 의미상으로는 크게 다른 문법을 갖고 있다.,"{'word': '러스트', 'start': 903, 'end': 905, 'type': 'COM'}","{'word': 'C++', 'start': 910, 'end': 912, 'type': 'COM'}",com:similar_tech
421,세계 최초의 컴파일러는 1952년 그레이스 호퍼가 개발한 프로그래밍 언어 A-0를 기계어로 번역하는 컴파일러이다.,"{'word': '그레이스 호퍼', 'start': 896, 'end': 902, 'type': 'PER'}","{'word': '프로그래밍 언어 A-0를 기계어로 번역하는 컴파일러', 'start': 909, 'end': 936, 'type': 'COM'}",per:production
422,세계 최초의 컴파일러는 1952년 그레이스 호퍼가 개발한 프로그래밍 언어 A-0를 기계어로 번역하는 컴파일러이다.,"{'word': '그레이스 호퍼', 'start': 896, 'end': 902, 'type': 'PER'}","{'word': '세계 최초의 컴파일러', 'start': 877, 'end': 887, 'type': 'COM'}",per:production
423,컴파일러라는 용어 또한 이때 호퍼가 처음 사용하였다.,"{'word': '호퍼', 'start': 957, 'end': 958, 'type': 'PER'}","{'word': '컴파일러', 'start': 941, 'end': 944, 'type': 'COM'}",per:production
424,"최적화 기능이 탑재된 최초의 ""완전한"" 컴파일러는 1957년 IBM의 존 배커스가 개발한 포트란 컴파일러이다.","{'word': '존 배커스', 'start': 1010, 'end': 1014, 'type': 'PER'}","{'word': '포트란 컴파일러', 'start': 1021, 'end': 1028, 'type': 'COM'}",per:production
425,세계 최초의 컴파일러는 1952년 그레이스 호퍼가 개발한 프로그래밍 언어 A-0를 기계어로 번역하는 컴파일러이다.,"{'word': '세계 최초의 컴파일러', 'start': 877, 'end': 887, 'type': 'COM'}","{'word': '1952년', 'start': 890, 'end': 894, 'type': 'DAT'}",com:date_of_prod
426,"최적화 기능이 탑재된 최초의 ""완전한"" 컴파일러는 1957년 IBM의 존 배커스가 개발한 포트란 컴파일러이다.","{'word': '포트란 컴파일러', 'start': 1021, 'end': 1028, 'type': 'COM'}","{'word': '1957년', 'start': 999, 'end': 1003, 'type': 'DAT'}",com:date_of_prod
427,"그러나 현대에 들어 많은 인터프리터가 JIT 컴파일 등의 기술로 실시간 컴파일을 수행하므로, 컴파일러와 인터프리터 사이의 기술적 구분은 사라져 가는 추세이다.","{'word': '인터프리터', 'start': 409, 'end': 413, 'type': 'COM'}","{'word': 'JIT 컴파일', 'start': 416, 'end': 422, 'type': 'COM'}",com:sub_concept
428,"좁은 의미의 컴파일러는 주로 고수준 언어로 쓰인 소스 코드를 저수준 언어(어셈블리어, 기계어 등)로 번역하는 프로그램을 가리킨다.","{'word': '저수준 언어', 'start': 593, 'end': 598, 'type': 'COM'}","{'word': '어셈블리어', 'start': 600, 'end': 604, 'type': 'COM'}",com:sub_concept
429,"좁은 의미의 컴파일러는 주로 고수준 언어로 쓰인 소스 코드를 저수준 언어(어셈블리어, 기계어 등)로 번역하는 프로그램을 가리킨다.","{'word': '저수준 언어', 'start': 593, 'end': 598, 'type': 'COM'}","{'word': '기계어', 'start': 607, 'end': 609, 'type': 'COM'}",com:sub_concept
430,C/C++언어와 같은 고급언어는 직접 기계어 코드로 변환한다.,"{'word': '고급언어', 'start': 1430, 'end': 1433, 'type': 'COM'}","{'word': 'C', 'start': 1418, 'end': 1418, 'type': 'COM'}",com:sub_concept
431,C/C++언어와 같은 고급언어는 직접 기계어 코드로 변환한다.,"{'word': '고급언어', 'start': 1430, 'end': 1433, 'type': 'COM'}","{'word': 'C++', 'start': 1420, 'end': 1422, 'type': 'COM'}",com:sub_concept
432,마이크로프로세서는 각각 다른 기계어 코드를 가지고 있기 때문에 같은 고급언어라도 다른 기계어 코드를 생성해야 한다.,"{'word': '마이크로프로세서', 'start': 1453, 'end': 1460, 'type': 'COM'}","{'word': '기계어 코드', 'start': 1469, 'end': 1474, 'type': 'COM'}",com:sub_concept
433,그러나 자바는 다양한 마이크로프로세서에서 실행되도록 하는 철학을 가지고 개발되었기 때문에 바이트 코드를 가지고 해석을 해서 실행하는 방식이다.,"{'word': '자바', 'start': 1562, 'end': 1563, 'type': 'COM'}","{'word': '바이트 코드', 'start': 1608, 'end': 1613, 'type': 'COM'}",com:sub_concept
434,"컴파일러(compiler, 해석기, 번역기)는 특정 프로그래밍 언어로 쓰여 있는 문서를 다른 프로그래밍 언어로 옮기는 언어 번역 프로그램을 말한다.","{'word': '컴파일러', 'start': 0, 'end': 3, 'type': 'COM'}","{'word': 'compiler', 'start': 5, 'end': 12, 'type': 'COM'}",com:alter_names
435,"컴파일러(compiler, 해석기, 번역기)는 특정 프로그래밍 언어로 쓰여 있는 문서를 다른 프로그래밍 언어로 옮기는 언어 번역 프로그램을 말한다.","{'word': '컴파일러', 'start': 0, 'end': 3, 'type': 'COM'}","{'word': '해석기', 'start': 15, 'end': 17, 'type': 'COM'}",com:alter_names
436,"원시 코드에서 목적 코드로 옮기는 과정을 컴파일(compile, 옮김, 번역, )이라고 한다.","{'word': '컴파일', 'start': 320, 'end': 322, 'type': 'COM'}","{'word': 'compile', 'start': 324, 'end': 330, 'type': 'COM'}",com:alter_names
437,"원시 코드에서 목적 코드로 옮기는 과정을 컴파일(compile, 옮김, 번역, )이라고 한다.","{'word': '컴파일', 'start': 320, 'end': 322, 'type': 'COM'}","{'word': '옮김', 'start': 333, 'end': 334, 'type': 'COM'}",com:alter_names
438,"원시 코드에서 목적 코드로 옮기는 과정을 컴파일(compile, 옮김, 번역, )이라고 한다.","{'word': '컴파일', 'start': 320, 'end': 322, 'type': 'COM'}","{'word': '번역', 'start': 337, 'end': 338, 'type': 'COM'}",com:alter_names
439,컴파일러가 실행되는 컴퓨터나 운영체제가 컴파일러의 목적코드가 실행될 컴퓨터나 운영체제와 같은 경우 네이티브 컴파일러(native compiler 또는 hosted compiler)라고 한다.,"{'word': '네이티브 컴파일러', 'start': 1961, 'end': 1969, 'type': 'COM'}","{'word': 'native compiler', 'start': 1971, 'end': 1985, 'type': 'COM'}",com:alter_names
440,컴파일러가 실행되는 컴퓨터나 운영체제가 컴파일러의 목적코드가 실행될 컴퓨터나 운영체제와 같은 경우 네이티브 컴파일러(native compiler 또는 hosted compiler)라고 한다.,"{'word': '네이티브 컴파일러', 'start': 1961, 'end': 1969, 'type': 'COM'}","{'word': 'hosted compiler', 'start': 1990, 'end': 2004, 'type': 'COM'}",com:alter_names
441,반면에 크로스 컴파일러(cross compiler)는 다른 컴퓨터나 운영체제에서 실행되도록 제작된다.,"{'word': '크로스 컴파일러', 'start': 2017, 'end': 2024, 'type': 'COM'}","{'word': 'cross compiler', 'start': 2026, 'end': 2039, 'type': 'COM'}",com:alter_names
442,초기 컴퓨터 프로그램들은 어셈블리어로 작성되었다.,"{'word': '초기 컴퓨터 프로그램', 'start': 632, 'end': 642, 'type': 'COM'}","{'word': '어셈블리어', 'start': 646, 'end': 650, 'type': 'COM'}",com:made_of
443,소스를 한 번 읽고 번역하여 바로 출력물을 내놓는 컴파일러도 있지만 여러 가지 목적을 위해 중간 결과를 만들어 그 결과를 다시 최종 결과로 출력하는 컴파일러도 있다.,"{'word': '컴파일러', 'start': 2264, 'end': 2267, 'type': 'COM'}","{'word': '출력물', 'start': 2255, 'end': 2257, 'type': 'COM'}",com:made_of
444,"이런 조건이 없다면 컴파일러를 사용하는 사용자가 컴파일러를 믿고 프로그램을 작성할 수도 없고, 잘못된 옮김을 인정한다면 컴파일러를 올바르게 하기 위한 노력을 들일 필요가 없을 것이다.","{'word': '사용자', 'start': 1149, 'end': 1151, 'type': 'PER'}","{'word': '컴파일러', 'start': 1154, 'end': 1157, 'type': 'COM'}",no_relation
445,따라서 개발자는 해당 마이크로프로세서에 맞는 컴파일러를 사용해야 한다.,"{'word': '개발자', 'start': 1522, 'end': 1524, 'type': 'PER'}","{'word': '마이크로프로세서', 'start': 1530, 'end': 1537, 'type': 'COM'}",no_relation
446,따라서 개발자는 해당 마이크로프로세서에 맞는 컴파일러를 사용해야 한다.,"{'word': '개발자', 'start': 1522, 'end': 1524, 'type': 'PER'}","{'word': '컴파일러', 'start': 1543, 'end': 1546, 'type': 'COM'}",no_relation
447,컴파일러에서 꼭 지켜야 할 두 가지 조건이 있다.,"{'word': '컴파일러', 'start': 1033, 'end': 1036, 'type': 'COM'}","{'word': '조건', 'start': 1053, 'end': 1054, 'type': 'POH'}",no_relation
448,"컴파일러는 를 실행 프로그램을 만들기 위한 (예, 어셈블리 언어, object 코드, machine code)로 바꾸는 데 사용된다.","{'word': '컴파일러', 'start': 83, 'end': 86, 'type': 'COM'}","{'word': '실행 프로그램', 'start': 91, 'end': 97, 'type': 'COM'}",no_relation
449,"원래의 문서를 소스 코드 혹은 원시 코드라고 부르고, 출력된 문서를 목적 코드라고 부른다.","{'word': '소스 코드', 'start': 166, 'end': 170, 'type': 'COM'}","{'word': '목적 코드', 'start': 196, 'end': 200, 'type': 'COM'}",no_relation
450,목적 코드는 주로 다른 프로그램이나 하드웨어가 처리하기에 용이한 형태로 출력되지만 사람이 읽을 수 있는 문서 파일이나 그림 파일 등으로 옮기는 경우도 있다.,"{'word': '목적 코드', 'start': 209, 'end': 213, 'type': 'COM'}","{'word': '하드웨어', 'start': 229, 'end': 232, 'type': 'COM'}",no_relation
451,"원시 코드에서 목적 코드로 옮기는 과정을 컴파일(compile, 옮김, 번역, )이라고 한다.","{'word': '원시 코드', 'start': 297, 'end': 301, 'type': 'COM'}","{'word': '컴파일', 'start': 320, 'end': 322, 'type': 'COM'}",no_relation
452,컴파일러는 소스 프로그램을 읽어서 즉시 결과를 출력하는 인터프리터와는 구분된다.,"{'word': '컴파일러', 'start': 350, 'end': 353, 'type': 'COM'}","{'word': '인터프리터', 'start': 381, 'end': 385, 'type': 'COM'}",no_relation
453,"그러나 현대에 들어 많은 인터프리터가 JIT 컴파일 등의 기술로 실시간 컴파일을 수행하므로, 컴파일러와 인터프리터 사이의 기술적 구분은 사라져 가는 추세이다.","{'word': '컴파일러', 'start': 447, 'end': 450, 'type': 'COM'}","{'word': '인터프리터', 'start': 453, 'end': 457, 'type': 'COM'}",no_relation
454,소스 코드를 컴파일하는 이유는 대부분 사람에게 이해하기 쉬운 형태의 고수준 언어로부터 실행가능한 기계어 프로그램을 만들기 위해서이다.,"{'word': '소스 코드', 'start': 484, 'end': 488, 'type': 'COM'}","{'word': '기계어 프로그램', 'start': 538, 'end': 545, 'type': 'COM'}",no_relation
455,"좁은 의미의 컴파일러는 주로 고수준 언어로 쓰인 소스 코드를 저수준 언어(어셈블리어, 기계어 등)로 번역하는 프로그램을 가리킨다.","{'word': '컴파일러', 'start': 566, 'end': 569, 'type': 'COM'}","{'word': '소스 코드', 'start': 586, 'end': 590, 'type': 'COM'}",no_relation
456,"그러나 서로 다른 CPU 아키텍처가 등장할 때마다 매번 똑같은 프로그램을 서로 다른 어셈블리어로 작성하는 비용이 커지면서, 고급 프로그래밍 언어의 필요성이 대두되었다.","{'word': '어셈블리어', 'start': 707, 'end': 711, 'type': 'COM'}","{'word': '고급 프로그래밍 언어', 'start': 729, 'end': 739, 'type': 'COM'}",no_relation
457,"그러나 초기 컴퓨터 하드웨어의 메모리 크기가 너무 작아, 컴파일러의 등장에 기술적 장애물이 되었다.","{'word': '초기 컴퓨터 하드웨어', 'start': 758, 'end': 768, 'type': 'COM'}","{'word': '컴파일러', 'start': 786, 'end': 789, 'type': 'COM'}",no_relation
458,"1950년대 초부터 기계어에 독립적인 최초의 고급 프로그래밍 언어가 나타났고, 실험적인 컴파일러들이 등장하기 시작했다.","{'word': '고급 프로그래밍 언어', 'start': 835, 'end': 845, 'type': 'COM'}","{'word': '컴파일러', 'start': 859, 'end': 862, 'type': 'COM'}",no_relation
459,"첫째로, 컴파일러는 옮김의 과정에서 프로그램의 뜻을 보존하여야 한다.","{'word': '컴파일러', 'start': 1066, 'end': 1069, 'type': 'COM'}","{'word': '프로그램', 'start': 1081, 'end': 1084, 'type': 'COM'}",no_relation
460,"첫째로, 컴파일러는 옮김의 과정에서 프로그램의 뜻을 보존하여야 한다. 입력받은 프로그램의 의미를 충실히 따라야 한다.","{'word': '컴파일러', 'start': 1066, 'end': 1069, 'type': 'COM'}","{'word': '프로그램', 'start': 1105, 'end': 1108, 'type': 'COM'}",no_relation
461,"두 번째로, 실용적인 면에서, 컴파일러는 입력으로 들어온 프로그램을 어떤 면에서든지 개선해야 한다.","{'word': '컴파일러', 'start': 1247, 'end': 1250, 'type': 'COM'}","{'word': '프로그램', 'start': 1262, 'end': 1265, 'type': 'COM'}",no_relation
462,"예를 들어, 소스 코드를 기계어로 옮긴다면 기계가 이해할 수 없었던 언어를 기계가 이해할 수 있게 개선한 것이 된다.","{'word': '소스 코드', 'start': 1293, 'end': 1297, 'type': 'COM'}","{'word': '기계어', 'start': 1300, 'end': 1302, 'type': 'COM'}",no_relation
463,같은 언어로 옮긴 경우에는 성능이 개선되는 등의 장점이 있어야 한다.,"{'word': '언어', 'start': 1355, 'end': 1356, 'type': 'COM'}","{'word': '성능', 'start': 1367, 'end': 1368, 'type': 'COM'}",no_relation
464,같은 언어로 옮긴 경우에는 성능이 개선되는 등의 장점이 있어야 한다. 그렇지 않다면 컴파일을 수행할 이유가 없어진다.,"{'word': '언어', 'start': 1355, 'end': 1356, 'type': 'COM'}","{'word': '컴파일', 'start': 1399, 'end': 1401, 'type': 'COM'}",no_relation
465,그러나 자바는 다양한 마이크로프로세서에서 실행되도록 하는 철학을 가지고 개발되었기 때문에 바이트 코드를 가지고 해석을 해서 실행하는 방식이다.,"{'word': '자바', 'start': 1562, 'end': 1563, 'type': 'COM'}","{'word': '마이크로프로세서', 'start': 1570, 'end': 1577, 'type': 'COM'}",no_relation
466,장점은 한번 컴파일된 바이트 코드는 다른 플랫폼에서 재컴파일없이 실행할 수 있다.,"{'word': '바이트 코드', 'start': 1650, 'end': 1655, 'type': 'COM'}","{'word': '플랫폼', 'start': 1661, 'end': 1663, 'type': 'COM'}",no_relation
467,"그러나 단점은 바이트 코드를 해석해서 실행할 프로그램 구조가 필요하고, 직접 기계어 코드를 실행하는 것 보다 속도에서 늦다.","{'word': '바이트 코드', 'start': 1692, 'end': 1697, 'type': 'COM'}","{'word': '프로그램 구조', 'start': 1709, 'end': 1715, 'type': 'COM'}",no_relation
468,"그러나 단점은 바이트 코드를 해석해서 실행할 프로그램 구조가 필요하고, 직접 기계어 코드를 실행하는 것 보다 속도에서 늦다.","{'word': '바이트 코드', 'start': 1692, 'end': 1697, 'type': 'COM'}","{'word': '기계어 코드', 'start': 1727, 'end': 1732, 'type': 'COM'}",no_relation
469,많은 수의 컴파일러는 다음과 같은 순서를 거쳐 소스 코드를 번역한다.,"{'word': '컴파일러', 'start': 1760, 'end': 1763, 'type': 'COM'}","{'word': '소스 코드', 'start': 1780, 'end': 1784, 'type': 'COM'}",no_relation
470,컴파일러나 프로그래밍 언어의 특성에 따라 일부 단계는 생략되거나 더 세부적인 단계로 나뉠 수도 있다.,"{'word': '컴파일러', 'start': 1793, 'end': 1796, 'type': 'COM'}","{'word': '프로그래밍 언어', 'start': 1799, 'end': 1806, 'type': 'COM'}",no_relation
471,"컴파일러는 입출력되는 언어의 종류, 내부구조, 목적코드의 동작에 따라 여러 가지로 분류할 수 있다.","{'word': '컴파일러', 'start': 1850, 'end': 1853, 'type': 'COM'}","{'word': '언어의 종류', 'start': 1862, 'end': 1867, 'type': 'COM'}",no_relation
472,"컴파일러는 입출력되는 언어의 종류, 내부구조, 목적코드의 동작에 따라 여러 가지로 분류할 수 있다.","{'word': '컴파일러', 'start': 1850, 'end': 1853, 'type': 'COM'}","{'word': '내부구조', 'start': 1870, 'end': 1873, 'type': 'COM'}",no_relation
473,"컴파일러는 입출력되는 언어의 종류, 내부구조, 목적코드의 동작에 따라 여러 가지로 분류할 수 있다.","{'word': '컴파일러', 'start': 1850, 'end': 1853, 'type': 'COM'}","{'word': '목적코드', 'start': 1876, 'end': 1879, 'type': 'COM'}",no_relation
474,"컴파일러는 입출력되는 언어의 종류, 내부구조, 목적코드의 동작에 따라 여러 가지로 분류할 수 있다.","{'word': '언어의 종류', 'start': 1862, 'end': 1867, 'type': 'COM'}","{'word': '내부구조', 'start': 1870, 'end': 1873, 'type': 'COM'}",no_relation
475,"컴파일러는 입출력되는 언어의 종류, 내부구조, 목적코드의 동작에 따라 여러 가지로 분류할 수 있다.","{'word': '언어의 종류', 'start': 1862, 'end': 1867, 'type': 'COM'}","{'word': '목적코드', 'start': 1876, 'end': 1879, 'type': 'COM'}",no_relation
476,"컴파일러는 입출력되는 언어의 종류, 내부구조, 목적코드의 동작에 따라 여러 가지로 분류할 수 있다.","{'word': '내부구조', 'start': 1870, 'end': 1873, 'type': 'COM'}","{'word': '목적코드', 'start': 1876, 'end': 1879, 'type': 'COM'}",no_relation
477,컴파일러가 실행되는 컴퓨터나 운영체제가 컴파일러의 목적코드가 실행될 컴퓨터나 운영체제와 같은 경우 네이티브 컴파일러(native compiler 또는 hosted compiler)라고 한다.,"{'word': '컴퓨터나 운영체제', 'start': 1917, 'end': 1925, 'type': 'COM'}","{'word': '컴파일러', 'start': 1928, 'end': 1931, 'type': 'COM'}",no_relation
478,임베디드 시스템 등 소프트웨어 개발에 충분한 환경을 갖추지 못한 환경에서 동작할 프로그램을 만들기 위해 사용된다.,"{'word': '임베디드 시스템', 'start': 2070, 'end': 2077, 'type': 'COM'}","{'word': '프로그램', 'start': 2115, 'end': 2118, 'type': 'COM'}",no_relation
479,또한 가상 머신에서 동작할 프로그램을 만드는 컴파일러도 있다.,"{'word': '가상 머신', 'start': 2137, 'end': 2141, 'type': 'COM'}","{'word': '컴파일러', 'start': 2159, 'end': 2162, 'type': 'COM'}",no_relation
480,이 경우 일반적으로 출력물이 가상 머신을 위해 제작된 바이트코드 형태의 기계어가 되므로 바이트코드 컴파일러라고 부른다.,"{'word': '가상 머신', 'start': 2185, 'end': 2189, 'type': 'COM'}","{'word': '바이트코드 컴파일러', 'start': 2218, 'end': 2227, 'type': 'COM'}",no_relation
481,C/C++언어와 같은 고급언어는 직접 기계어 코드로 변환한다.,"{'word': 'C', 'start': 1418, 'end': 1418, 'type': 'COM'}","{'word': 'C++', 'start': 1420, 'end': 1422, 'type': 'COM'}",com:similar_tech
